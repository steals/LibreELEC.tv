diff --git a/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c b/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c
old mode 100644
new mode 100755
index 8c172a20..26b1b01c
--- a/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c
+++ b/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_cec_hw.c
@@ -1,365 +1,494 @@
-#include <linux/irq.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/cdev.h>
-#include <linux/spinlock.h>
-#include <linux/spinlock_types.h>
-#include <asm/delay.h>
-#include <mach/am_regs.h>
-#include <mach/power_gate.h>
-#include <linux/amlogic/tvin/tvin.h>
-
-#include <mach/gpio.h>
-#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
-#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
-#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
-#include <mach/hdmi_tx_reg.h>
-#include <mach/hdmi_parameter.h> 
-
-static DEFINE_MUTEX(cec_mutex);
-
-unsigned int cec_int_disable_flag = 0;
-extern int cec_msg_dbg_en;
-void cec_disable_irq(void)
-{
-    // disable all AO_CEC interrupt sources
-    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x0, 0, 3);
-    cec_int_disable_flag = 1;
-    hdmi_print(INF, CEC "disable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
-}
-void cec_enable_irq(void)
-{
-    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
-    cec_int_disable_flag = 0;
-    hdmi_print(INF, CEC "enable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
-}
-
-void cec_hw_reset(void)
-{
-    //unsigned long data32;
-    // Assert SW reset AO_CEC
-    //data32  = 0;
-    //data32 |= 0 << 1;   // [2:1]    cntl_clk: 0=Disable clk (Power-off mode); 1=Enable gated clock (Normal mode); 2=Enable free-run clk (Debug mode).
-    //data32 |= 1 << 0;   // [0]      sw_reset: 1=Reset
-    aml_write_reg32(P_AO_CEC_GEN_CNTL, 0x1);
-    // Enable gated clock (Normal mode).
-    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 1, 1, 1);
-    // Release SW reset
-    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 0, 0, 1);
-
-    // Enable all AO_CEC interrupt sources
-    if(!cec_int_disable_flag)
-        aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
-
-    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | cec_global_info.my_node_index);
-
-    //Cec arbitration 3/5/7 bit time set.
-    cec_arbit_bit_time_set(3, 0x118, 0);
-    cec_arbit_bit_time_set(5, 0x000, 0);
-    cec_arbit_bit_time_set(7, 0x2aa, 0);
-
-    hdmi_print(INF, CEC "hw reset :logical addr:0x%x\n", aocec_rd_reg(CEC_LOGICAL_ADDR0));
-
-}
-
-int cec_ll_rx( unsigned char *msg, unsigned char *len)
-{
-    unsigned char i;
-    unsigned char rx_status;
-    unsigned char data;
-    unsigned char msg_log_buf[128];
-    int pos;
-    unsigned char n;
-    unsigned char *msg_start = msg;
-    int rx_msg_length;
-
-    if(RX_DONE != aocec_rd_reg(CEC_RX_MSG_STATUS)){
-        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
-        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_NO_OP);
-        return -1;
-    }
-    if(1 != aocec_rd_reg(CEC_RX_NUM_MSG)){
-        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
-        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_NO_OP);
-        return -1;
-    }
-    rx_msg_length = aocec_rd_reg(CEC_RX_MSG_LENGTH) + 1;
-
-    aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
-
-    for (i = 0; i < rx_msg_length && i < MAX_MSG; i++) {
-        data = aocec_rd_reg(CEC_RX_MSG_0_HEADER +i);
-        *msg = data;
-        msg++;
-    }
-    *len = rx_msg_length;
-    rx_status = aocec_rd_reg(CEC_RX_MSG_STATUS);
-
-    aocec_wr_reg(CEC_RX_MSG_CMD, RX_NO_OP);
-    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 2));
-
-    if(cec_msg_dbg_en  == 1){
-        pos = 0;
-        pos += sprintf(msg_log_buf + pos, "CEC: rx msg len: %d   dat: ", rx_msg_length);
-        for(n = 0; n < rx_msg_length; n++) {
-            pos += sprintf(msg_log_buf + pos, "%02x ", msg_start[n]);
-        }
-        pos += sprintf(msg_log_buf + pos, "\n");
-        msg_log_buf[pos] = '\0';
-        hdmi_print(INF, CEC "%s", msg_log_buf);
-    }
-    return rx_status;
-}
-
-
-/*************************** cec arbitration cts code ******************************/
-// using the cec pin as fiq gpi to assist the bus arbitration
-static unsigned char msg_log_buf[128] = { 0 };
-// return value: 1: successful      0: error
-static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
-{
-    int i;
-    unsigned int ret = 0xf;
-    unsigned int n;
-    unsigned int cnt = 30;
-    int pos;
-
-    while(aocec_rd_reg(CEC_TX_MSG_STATUS)){
-        msleep(5);
-        if(TX_ERROR == aocec_rd_reg(CEC_TX_MSG_STATUS)){
-            //aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
-            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-            //cec_hw_reset();
-            break;
-        }
-        if(!(cnt--)){
-            hdmi_print(INF, CEC "tx busy time out.\n");
-            aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
-            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-            break;
-        }
-    }
-    for (i = 0; i < len; i++)
-    {
-        aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
-    }
-    aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
-    aocec_wr_reg(CEC_TX_MSG_CMD, RX_ACK_CURRENT);
-
-    if(cec_msg_dbg_en  == 1) {
-        pos = 0;
-        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
-        for(n = 0; n < len; n++) {
-            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
-        }
-        pos += sprintf(msg_log_buf + pos, "\n");
-
-        msg_log_buf[pos] = '\0';
-        printk("%s", msg_log_buf);
-    }
-    return ret;
-}
-
-int cec_ll_tx_polling(const unsigned char *msg, unsigned char len)
-{
-    int i;
-    unsigned int ret = 0xf;
-    unsigned int n;
-	unsigned int j = 30;
-    int pos;
-
-    while( aocec_rd_reg(CEC_TX_MSG_STATUS)){
-        if(TX_ERROR == aocec_rd_reg(CEC_TX_MSG_STATUS)){
-            //aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
-            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-            //cec_hw_reset();
-            break;
-        }
-        if(!(j--)){
-            hdmi_print(INF, CEC "tx busy time out.\n");
-            aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
-            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-            break;
-        }
-        msleep(5);
-    }
-
-    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x0, 1, 1);
-    for (i = 0; i < len; i++)
-    {
-        aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
-    }
-    aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
-    aocec_wr_reg(CEC_TX_MSG_CMD, RX_ACK_CURRENT);
-
-    j = 30;
-    while((TX_DONE != aocec_rd_reg(CEC_TX_MSG_STATUS)) && (j--)){
-        if(TX_ERROR == aocec_rd_reg(CEC_TX_MSG_STATUS))
-            break;
-		msleep(5);
-	}
-
-    ret = aocec_rd_reg(CEC_TX_MSG_STATUS);
-
-    if(ret == TX_DONE)
-        ret = 1;
-    else
-        ret = 0;
-    aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 1, 1, 1);
-
-    if(cec_msg_dbg_en  == 1) {
-        pos = 0;
-        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
-        for(n = 0; n < len; n++) {
-            pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
-        }
-        pos += sprintf(msg_log_buf + pos, "\nCEC: tx state: %d\n", ret);
-        msg_log_buf[pos] = '\0';
-        printk("%s", msg_log_buf);
-    }
-    return ret;
-}
-
-void tx_irq_handle(void){
-    unsigned tx_status = aocec_rd_reg(CEC_TX_MSG_STATUS);
-    switch(tx_status){
-    case TX_DONE:
-      aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-      break;
-    case TX_BUSY:
-        aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
-        aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-        break;
-    case TX_ERROR:
-        cec_hw_reset();
-        //aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-        break;
-    default:
-        break;
-    }
-    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 1));
-    //aml_write_reg32(P_AO_CEC_INTR_MASKN, aml_read_reg32(P_AO_CEC_INTR_MASKN) | (1 << 2));
-
-}
-
-// Return value: 0: fail    1: success
-int cec_ll_tx(const unsigned char *msg, unsigned char len)
-{
-    int ret = 0;
-    if(cec_int_disable_flag)
-        return 2;
-        
-    mutex_lock(&cec_mutex);
-    //aml_write_reg32(P_AO_CEC_INTR_MASKN, aml_read_reg32(P_AO_CEC_INTR_MASKN) & ~(1 << 2));
-    cec_ll_tx_once(msg, len);
-
-    mutex_unlock(&cec_mutex);
-    
-    return ret;
-}
-
-#ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
-void cec_polling_online_dev(int log_addr, int *bool)
-{
-    unsigned long r;
-    unsigned char msg[1];
-
-    cec_global_info.my_node_index = log_addr;
-    msg[0] = (log_addr<<4) | log_addr;
-
-    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
-    hdmi_print(INF, CEC "CEC_LOGICAL_ADDR0:0x%lx\n",aocec_rd_reg(CEC_LOGICAL_ADDR0));
-    r = cec_ll_tx_polling(msg, 1);
-    cec_hw_reset();
-
-    if (r == 0) {
-        *bool = 0;
-    }else{
-        memset(&(cec_global_info.cec_node_info[log_addr]), 0, sizeof(cec_node_info_t));
-        cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
-    	  *bool = 1;
-    }
-    if(*bool == 0) {
-        aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | log_addr);
-    }
-    hdmi_print(INF, CEC "CEC: poll online logic device: 0x%x BOOL: %d\n", log_addr, *bool);
-
-}
-#endif
-
-
-//--------------------------------------------------------------------------
-// AO CEC0 config
-//--------------------------------------------------------------------------
-void ao_cec_init(void)
-{
-    unsigned long data32;
-    // Assert SW reset AO_CEC
-    data32  = 0;
-    data32 |= 0 << 1;   // [2:1]    cntl_clk: 0=Disable clk (Power-off mode); 1=Enable gated clock (Normal mode); 2=Enable free-run clk (Debug mode).
-    data32 |= 1 << 0;   // [0]      sw_reset: 1=Reset
-    aml_write_reg32(P_AO_CEC_GEN_CNTL, data32);
-    // Enable gated clock (Normal mode).
-    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 1, 1, 1);
-    // Release SW reset
-    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 0, 0, 1);
-
-    // Enable all AO_CEC interrupt sources
-    cec_enable_irq();
-
-    // Device 0 config
-    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0x4);
-}
-
-
-void cec_arbit_bit_time_read(void){//11bit:bit[10:0]
-    //3 bit
-    hdmi_print(INF, CEC "read 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
-    //5 bit
-    hdmi_print(INF, CEC "read 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
-    //7 bit
-    hdmi_print(INF, CEC "read 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
-}
-
-void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag){//11bit:bit[10:0]
-    if(flag)
-        hdmi_print(INF, CEC "bit_set:0x%x;time_set:0x%x \n", bit_set, time_set);
-    switch(bit_set){
-    case 3:
-        //3 bit
-        if(flag)
-            hdmi_print(INF, CEC "read 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
-        aocec_wr_reg(AO_CEC_TXTIME_4BIT_BIT7_0, time_set & 0xff);
-        aocec_wr_reg(AO_CEC_TXTIME_4BIT_BIT10_8, (time_set >> 8) & 0x7);
-        if(flag)
-            hdmi_print(INF, CEC "write 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
-        break;
-        //5 bit
-    case 5:
-        if(flag)
-            hdmi_print(INF, CEC "read 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
-        aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT7_0, time_set & 0xff);
-        aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT10_8, (time_set >> 8) & 0x7);
-        if(flag)
-            hdmi_print(INF, CEC "write 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
-        break;
-        //7 bit
-	case 7:
-        if(flag)
-            hdmi_print(INF, CEC "read 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
-        aocec_wr_reg(AO_CEC_TXTIME_17MS_BIT7_0, time_set & 0xff);
-        aocec_wr_reg(AO_CEC_TXTIME_17MS_BIT10_8, (time_set >> 8) & 0x7);
-        if(flag)
-            hdmi_print(INF, CEC "write 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
-        break;
-    default:
-        break;
-    }
-}
-
-// DELETE LATER, TEST ONLY
-void cec_test_(unsigned int cmd)
-{
-    
-}
+#include <linux/irq.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/cdev.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/power_gate.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#include <mach/gpio.h>
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+#include <mach/hdmi_tx_reg.h>
+#include <mach/hdmi_parameter.h>
+
+static DEFINE_MUTEX(cec_mutex);
+
+void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag);
+unsigned int cec_int_disable_flag = 0;
+static unsigned char msg_log_buf[128] = { 0 };
+extern int cec_msg_dbg_en;
+
+void cec_disable_irq(void)
+{
+    // disable all AO_CEC interrupt sources
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x0, 0, 3);
+    cec_int_disable_flag = 1;
+    hdmi_print(INF, CEC "disable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
+}
+void cec_enable_irq(void)
+{
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
+    cec_int_disable_flag = 0;
+    hdmi_print(INF, CEC "enable:int mask:0x%x\n", aml_read_reg32(P_AO_CEC_INTR_MASKN));
+}
+
+void gpiox_10_pin_mux_mask(void){
+    //GPIOX_10 pin mux masked expect PWM_E
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_3, 0x0, 22, 1); //0x202f bit[22]: XTAL_32K_OUT
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_3, 0x0,  8, 1); //0x202f bit[ 8]: Tsin_D0_B
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_4, 0x0, 23, 1); //0x2030 bit[23]: SPI_MOSI
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_6, 0x0, 17, 1); //0x2032 bit[17]: UART_CTS_B
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_7, 0x0, 31, 1); //0x2033 bit[31]: PWM_VS
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_9, 0x1, 19, 1); //0x2035 bit[19]: PWM_E
+}
+
+void pwm_e_config(void){
+    //PWM E config
+    aml_set_reg32_bits(P_PWM_PWM_E,    0x25ff, 16, 16); //0x21b0 bit[31:16]: PWM_E_HIGH counter
+    aml_set_reg32_bits(P_PWM_PWM_E,    0x25fe,  0, 16); //0x21b0 bit[15: 0]: PWM_E_LOW counter
+    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0x1, 15,  1); //0x21b2 bit[15]   : PWM_E_CLK_EN
+    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0x0,  8,  7); //0x21b2 bit[14: 8]: PWM_E_CLK_DIV
+    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0x2,  4,  2); //0x21b2 bit[5 : 4]: PWM_E_CLK_SEL :0x2 sleect fclk_div4:637.5M
+    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0x1,  0,  1); //0x21b2 bit[0]    : PWM_E_EN
+}
+
+void pwm_out_rtc_32k(void){
+    gpiox_10_pin_mux_mask(); //enable PWM_E pin mux
+    pwm_e_config();  //PWM E config
+    hdmi_print(INF, CEC "Set PWM_E out put RTC 32K!\n");
+}
+
+void cec_hw_reset(void)
+{
+    //unsigned long data32;
+    // Assert SW reset AO_CEC
+    //data32  = 0;
+    //data32 |= 0 << 1;   // [2:1]    cntl_clk: 0=Disable clk (Power-off mode); 1=Enable gated clock (Normal mode); 2=Enable free-run clk (Debug mode).
+    //data32 |= 1 << 0;   // [0]      sw_reset: 1=Reset
+    aml_write_reg32(P_AO_CEC_GEN_CNTL, 0x1);
+    // Enable gated clock (Normal mode).
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 1, 1, 1);
+    // Release SW reset
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 0, 0, 1);
+
+    // Enable all AO_CEC interrupt sources
+    if (!cec_int_disable_flag)
+        aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x6, 0, 3);
+
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | cec_global_info.my_node_index);
+
+    //Cec arbitration 3/5/7 bit time set.
+    cec_arbit_bit_time_set(3, 0x118, 0);
+    cec_arbit_bit_time_set(5, 0x000, 0);
+    cec_arbit_bit_time_set(7, 0x2aa, 0);
+
+    hdmi_print(INF, CEC "hw reset :logical addr:0x%x\n", aocec_rd_reg(CEC_LOGICAL_ADDR0));
+
+}
+
+void cec_rx_buf_clear(void)
+{
+    aocec_wr_reg(CEC_RX_CLEAR_BUF, 0x1);
+    aocec_wr_reg(CEC_RX_CLEAR_BUF, 0x0);
+    hdmi_print(INF, CEC "rx buf clean\n");
+}
+
+int cec_rx_buf_check(void)
+{
+    unsigned long rx_num_msg = aocec_rd_reg(CEC_RX_NUM_MSG);
+
+    if (rx_num_msg)
+        hdmi_print(INF, CEC "rx msg num:0x%02x\n", rx_num_msg);
+
+    return rx_num_msg;
+}
+
+int cec_ll_rx( unsigned char *msg, unsigned char *len)
+{
+    int i;
+    int ret = -1;
+    int pos;
+    int rx_stat;
+
+    rx_stat = aocec_rd_reg(CEC_RX_MSG_STATUS);
+    if ((RX_DONE != rx_stat) || (1 != aocec_rd_reg(CEC_RX_NUM_MSG)))
+    {
+        hdmi_print(INF, CEC, "rx status:%x\n", rx_stat);
+        aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 2));
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_ACK_CURRENT);
+        aocec_wr_reg(CEC_RX_MSG_CMD,  RX_NO_OP);
+        return ret;
+    }
+
+    *len = aocec_rd_reg(CEC_RX_MSG_LENGTH) + 1;
+    for (i = 0; i < (*len) && i < MAX_MSG; i++)
+    {
+        msg[i]= aocec_rd_reg(CEC_RX_MSG_0_HEADER +i);
+    }
+
+    ret = rx_stat;
+
+    if (cec_msg_dbg_en  == 1)
+    {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC[%d]: rx msg len: %d   dat: ",
+                       cec_global_info.my_node_index, *len);
+        for (i = 0; i < (*len); i++)
+        {
+            pos += sprintf(msg_log_buf + pos, "%02x:", msg[i]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\n");
+        msg_log_buf[pos] = '\0';
+        hdmi_print(INF, CEC "%s", msg_log_buf);
+    }
+
+    //cec_rx_buf_check();
+    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 2));
+    aocec_wr_reg(CEC_RX_MSG_CMD, RX_ACK_NEXT);
+    aocec_wr_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+
+    return ret;
+}
+
+
+/*************************** cec arbitration cts code ******************************/
+// using the cec pin as fiq gpi to assist the bus arbitration
+
+// return value: 1: successful      0: error
+static int cec_ll_tx_once(const unsigned char *msg, unsigned char len)
+{
+    int i;
+    unsigned int ret = 0xf;
+    unsigned int n;
+    unsigned int cnt = 30;
+    int pos;
+
+    while (aocec_rd_reg(CEC_TX_MSG_STATUS) || aocec_rd_reg(CEC_RX_MSG_STATUS))
+    {
+        msleep(5);
+        if (TX_ERROR == aocec_rd_reg(CEC_TX_MSG_STATUS))
+        {
+            if (cec_msg_dbg_en  == 1)
+                hdmi_print(INF, CEC "tx once:tx error!\n");
+            //aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            //cec_hw_reset();
+            break;
+        }
+        if (!(cnt--))
+        {
+            if (cec_msg_dbg_en  == 1)
+                hdmi_print(INF, CEC "tx busy time out.\n");
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            break;
+        }
+    }
+    for (i = 0; i < len; i++)
+    {
+        aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
+    }
+    aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
+    aocec_wr_reg(CEC_TX_MSG_CMD, TX_REQ_CURRENT);
+
+    if (cec_msg_dbg_en  == 1)
+    {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
+        for (n = 0; n < len; n++)
+        {
+            pos += sprintf(msg_log_buf + pos, "%02x:", msg[n]);
+        }
+        pos += sprintf(msg_log_buf + pos, "\n");
+
+        msg_log_buf[pos] = '\0';
+        printk("%s", msg_log_buf);
+    }
+    return ret;
+}
+
+int cec_ll_tx_polling(const unsigned char *msg, unsigned char len)
+{
+    int i;
+    unsigned int ret = 0xf;
+    unsigned int n;
+    unsigned int j = 50;
+    int pos;
+    unsigned tx_stat;
+    int flag = 0;
+
+    /*
+     * wait until tx is free
+     */
+    while (1) {
+        tx_stat = aocec_rd_reg(CEC_TX_MSG_STATUS);
+        if (!flag && tx_stat == TX_BUSY) {
+            hdmi_print(INF, CEC "tx_stat is busy, waiting free...\n");
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            flag = 1;
+        }
+        if (tx_stat != TX_BUSY) {
+            break;
+        }
+        if (!(j--))
+        {
+            if (cec_msg_dbg_en  == 1)
+                hdmi_print(INF, CEC "tx busy time out.\n");
+            //aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            break;
+        }
+        msleep(5);
+    }
+
+    hdmi_print(INF, CEC "now tx_stat:%d\n", tx_stat);
+    if (TX_ERROR == tx_stat) {
+        hdmi_print(INF, CEC "tx polling:tx error!.\n");
+        //aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+        aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+        //cec_hw_reset();
+    } else if (TX_BUSY == tx_stat) {
+        return TX_BUSY;
+    }
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 0x0, 1, 1);
+    for (i = 0; i < len; i++)
+    {
+        aocec_wr_reg(CEC_TX_MSG_0_HEADER + i, msg[i]);
+    }
+    aocec_wr_reg(CEC_TX_MSG_LENGTH, len-1);
+    aocec_wr_reg(CEC_TX_MSG_CMD, RX_ACK_CURRENT);
+
+    j = 50;
+    hdmi_print(INF, CEC "start poll\n");
+    while (j--) {
+        ret = aocec_rd_reg(CEC_TX_MSG_STATUS);
+        if (ret != TX_BUSY) {
+            break;
+        }
+        msleep(5);
+    }
+
+    ret = aocec_rd_reg(CEC_TX_MSG_STATUS);
+    hdmi_print(INF, CEC "end poll, tx_stat:%x\n", ret);
+    if (ret == TX_BUSY) {
+        hdmi_print(INF, CEC "tx busy timeout\n");
+        aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+    }
+
+    aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+    aml_set_reg32_bits(P_AO_CEC_INTR_MASKN, 1, 1, 1);
+
+    if (cec_msg_dbg_en  == 1)
+    {
+        pos = 0;
+        pos += sprintf(msg_log_buf + pos, "CEC: tx msg len: %d   dat: ", len);
+        for (n = 0; n < len; n++)
+        {
+            pos += sprintf(msg_log_buf + pos, "%02x:", msg[n]);
+        }
+        msg_log_buf[pos] = '\0';
+        printk("%s\n", msg_log_buf);
+    }
+    return ret;
+}
+
+void tx_irq_handle(void)
+{
+    unsigned tx_status = aocec_rd_reg(CEC_TX_MSG_STATUS);
+    switch (tx_status)
+    {
+        case TX_DONE:
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            break;
+        case TX_BUSY:
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_ABORT);
+            aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            break;
+        case TX_ERROR:
+            if (cec_msg_dbg_en  == 1)
+                hdmi_print(INF, CEC "TX ERROR!!!\n");
+            if (RX_ERROR == aocec_rd_reg(CEC_RX_MSG_STATUS))
+            {
+                cec_hw_reset();
+            }
+            else
+            {
+                aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            }
+            //aocec_wr_reg(CEC_TX_MSG_CMD, TX_NO_OP);
+            break;
+        default:
+        break;
+    }
+    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 1));
+    //aml_write_reg32(P_AO_CEC_INTR_MASKN, aml_read_reg32(P_AO_CEC_INTR_MASKN) | (1 << 2));
+}
+
+// Return value: 0: fail    1: success
+int cec_ll_tx(const unsigned char *msg, unsigned char len)
+{
+    int ret = 0;
+    if (cec_int_disable_flag)
+        return 2;
+
+    mutex_lock(&cec_mutex);
+    //aml_write_reg32(P_AO_CEC_INTR_MASKN, aml_read_reg32(P_AO_CEC_INTR_MASKN) & ~(1 << 2));
+    cec_ll_tx_once(msg, len);
+
+    mutex_unlock(&cec_mutex);
+
+    return ret;
+}
+
+void cec_polling_online_dev(int log_addr, int *bool)
+{
+    unsigned int r;
+    unsigned char msg[1];
+    int retry = 5;
+
+    cec_global_info.my_node_index = log_addr;
+    msg[0] = (log_addr<<4) | log_addr;
+
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+    if (cec_msg_dbg_en  == 1)
+        hdmi_print(INF, CEC "CEC_LOGICAL_ADDR0:0x%lx\n",aocec_rd_reg(CEC_LOGICAL_ADDR0));
+    while (retry) {
+        r = cec_ll_tx_polling(msg, 1);
+        if (r == TX_BUSY) {
+            retry--;
+            hdmi_print(INF, CEC "try log addr %x busy, retry:%d\n", log_addr, retry);
+            /*
+             * try to reset CEC if tx busy is found
+             */
+            cec_hw_reset();
+        } else {
+            break;
+        }
+    }
+//    cec_hw_reset();
+
+    if (r == TX_ERROR) {
+        *bool = 0;
+    } else if (r == TX_DONE) {
+        memset(&(cec_global_info.cec_node_info[log_addr]), 0, sizeof(cec_node_info_t));
+        cec_global_info.cec_node_info[log_addr].dev_type = cec_log_addr_to_dev_type(log_addr);
+        *bool = 1;
+    }
+    if (*bool == 0)
+    {
+        aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | log_addr);
+    }
+    hdmi_print(INF, CEC "CEC: poll online logic device: 0x%x BOOL: %d\n", log_addr, *bool);
+
+}
+
+
+//--------------------------------------------------------------------------
+// AO CEC0 config
+//--------------------------------------------------------------------------
+void ao_cec_init(void)
+{
+    unsigned long data32;
+    pwm_out_rtc_32k();  //enable RTC 32k
+    // Assert SW reset AO_CEC
+    data32  = 0;
+    data32 |= 0 << 1;   // [2:1]    cntl_clk: 0=Disable clk (Power-off mode); 1=Enable gated clock (Normal mode); 2=Enable free-run clk (Debug mode).
+    data32 |= 1 << 0;   // [0]      sw_reset: 1=Reset
+    aml_write_reg32(P_AO_CEC_GEN_CNTL, data32);
+    // Enable gated clock (Normal mode).
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 1, 1, 1);
+    // Release SW reset
+    aml_set_reg32_bits(P_AO_CEC_GEN_CNTL, 0, 0, 1);
+
+    // Enable all AO_CEC interrupt sources
+    cec_enable_irq();
+
+    // Device 0 config
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0x4);
+}
+
+
+void cec_arbit_bit_time_read(void)
+{   //11bit:bit[10:0]
+    //3 bit
+    hdmi_print(INF, CEC "read 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
+    //5 bit
+    hdmi_print(INF, CEC "read 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
+    //7 bit
+    hdmi_print(INF, CEC "read 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
+}
+
+void cec_arbit_bit_time_set(unsigned bit_set, unsigned time_set, unsigned flag)
+{   //11bit:bit[10:0]
+    if (flag)
+        hdmi_print(INF, CEC "bit_set:0x%x;time_set:0x%x \n", bit_set, time_set);
+    switch (bit_set)
+    {
+        case 3:
+            //3 bit
+            if (flag)
+                hdmi_print(INF, CEC "read 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
+            aocec_wr_reg(AO_CEC_TXTIME_4BIT_BIT7_0, time_set & 0xff);
+            aocec_wr_reg(AO_CEC_TXTIME_4BIT_BIT10_8, (time_set >> 8) & 0x7);
+            if (flag)
+                hdmi_print(INF, CEC "write 3 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT10_8),aocec_rd_reg(AO_CEC_TXTIME_4BIT_BIT7_0));
+            break;
+            //5 bit
+        case 5:
+            if (flag)
+                hdmi_print(INF, CEC "read 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
+            aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT7_0, time_set & 0xff);
+            aocec_wr_reg(AO_CEC_TXTIME_2BIT_BIT10_8, (time_set >> 8) & 0x7);
+            if (flag)
+                hdmi_print(INF, CEC "write 5 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_2BIT_BIT7_0));
+            break;
+            //7 bit
+        case 7:
+            if (flag)
+                hdmi_print(INF, CEC "read 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
+            aocec_wr_reg(AO_CEC_TXTIME_17MS_BIT7_0, time_set & 0xff);
+            aocec_wr_reg(AO_CEC_TXTIME_17MS_BIT10_8, (time_set >> 8) & 0x7);
+            if (flag)
+                hdmi_print(INF, CEC "write 7 bit:0x%x%x \n", aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT10_8), aocec_rd_reg(AO_CEC_TXTIME_17MS_BIT7_0));
+            break;
+        default:
+            break;
+    }
+}
+
+void dumpaocecreg(void)
+{
+    int i;
+
+    for (i = 0; i < 0x95; i ++)
+        printk("aocecreg[0x%x]: 0x%x\n", i, (unsigned int)aocec_rd_reg(i));
+    for (i = 0; i < 0x5; i ++)
+        printk("aoreg[0x%x]: 0x%x\n", (0x104 + i*4), aml_read_reg32(P_AO_CEC_GEN_CNTL + i*4));
+}
+
+void raocec(unsigned int addr)
+{
+    printk("aocecreg[0x%x]: 0x%x\n", addr, (unsigned int)aocec_rd_reg(addr));
+}
+
+void waocec(unsigned int addr, unsigned int value)
+{
+    aocec_wr_reg(addr, value);
+    printk("aocecreg[0x%x]: 0x%x\n", addr, (unsigned int)aocec_rd_reg(addr));
+}
+
+// DELETE LATER, TEST ONLY
+void cec_test_(unsigned int cmd)
+{
+    ;
+}
+
+void cec_keep_reset(void)
+{
+    aml_write_reg32(P_AO_CEC_GEN_CNTL, 0x1);
+}
diff --git a/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_hw.c b/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_hw.c
index 2217a4b0..95333ca5 100755
--- a/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_hw.c
+++ b/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_hw.c
@@ -76,7 +76,7 @@ static void hdmi_phy_wakeup(hdmitx_dev_t* hdmitx_device);
 unsigned char hdmi_pll_mode = 0; /* 1, use external clk as hdmi pll source */
 static unsigned char aud_para = 0x49;
 
-#define HSYNC_POLARITY      1                       // HSYNC polarity: active high 
+#define HSYNC_POLARITY      1                       // HSYNC polarity: active high
 #define VSYNC_POLARITY      1                       // VSYNC polarity: active high
 #define TX_INPUT_COLOR_DEPTH    0                   // Pixel bit width: 0=24-bit; 1=30-bit; 2=36-bit; 3=48-bit.
 #define TX_INPUT_COLOR_FORMAT   1                   // Pixel format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
@@ -109,19 +109,6 @@ static unsigned char use_tvenc_conf_flag=1;
 
 static unsigned char cur_vout_index = 1; //CONFIG_AM_TV_OUTPUT2
 
-static bool disableHPD = false;
-
-static  int __init disableHPD_setup(char *s)
-{
-	if(!(strcmp(s, "true")))
-		disableHPD = true;
-	else
-		disableHPD = false;
-
-	return 0;
-}
-__setup("disablehpd=", disableHPD_setup);
-
 static void hdmi_tx_mode_ctrl(HDMI_Video_Codes_t vic)
 {
     switch(vic) {
@@ -202,7 +189,7 @@ static unsigned long modulo(unsigned long a, unsigned long b)
         return(a);
     }
 }
-        
+
 static signed int to_signed(unsigned int a)
 {
     if (a <= 7) {
@@ -225,7 +212,7 @@ static irqreturn_t intr_handler(int irq, void *dev_instance)
 {
     unsigned int data32;
     hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*)dev_instance;
-    data32 = hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT); 
+    data32 = hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT);
     hdmi_print(IMP, SYS "irq %x\n", data32);
     if(hdmitx_device->hpd_lock == 1) {
         hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR, 0xf);
@@ -240,33 +227,22 @@ static irqreturn_t intr_handler(int irq, void *dev_instance)
 
     WRITE_MPEG_REG(HHI_GCLK_MPEG2, READ_MPEG_REG(HHI_GCLK_MPEG2) | (1<<4));     //Enable HDMI PCLK
 
-    if(disableHPD)  {
-        //HPD falling
-        if (data32 & (1 << 1))
-            hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 1); //clear HPD falling interrupt in hdmi module 
-
-        //HPD rising
-        if (data32 & (1 << 0))
-            hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 0); //clear HPD rising interrupt in hdmi module
-    }
-    else    {
-        if (data32 & (1 << 1)) { //HPD falling
-            hdmitx_device->vic_count = 0;
-            hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 1); //clear HPD falling interrupt in hdmi module 
-            hdmitx_device->hpd_event = 2;
-        }
-        if (data32 & (1 << 0)) {  //HPD rising
-            hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 0); //clear HPD rising interrupt in hdmi module
-            // If HPD asserts, then start DDC transaction
-            if (hdmi_rd_reg(TX_HDCP_ST_EDID_STATUS) & (1<<1)) {
-                // Start DDC transaction
-                hdmitx_device->cur_edid_block=0;
-                hdmitx_device->cur_phy_block_ptr=0;
-                hdmitx_device->hpd_event = 1;
-            // Error if HPD deasserts
-            } else {
-                hdmi_print(ERR, HPD "HPD deasserts!\n");
-            }
+    if (data32 & (1 << 1)) { //HPD falling
+        hdmitx_device->vic_count = 0;
+        hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 1); //clear HPD falling interrupt in hdmi module
+        hdmitx_device->hpd_event = 2;
+    }
+    if (data32 & (1 << 0)) {  //HPD rising
+        hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 0); //clear HPD rising interrupt in hdmi module
+        // If HPD asserts, then start DDC transaction
+        if (hdmi_rd_reg(TX_HDCP_ST_EDID_STATUS) & (1<<1)) {
+            // Start DDC transaction
+            hdmitx_device->cur_edid_block=0;
+            hdmitx_device->cur_phy_block_ptr=0;
+            hdmitx_device->hpd_event = 1;
+        // Error if HPD deasserts
+        } else {
+            hdmi_print(ERR, HPD "HPD deasserts!\n");
         }
     }
     if (data32 & (1 << 2)) { //TX EDID interrupt
@@ -281,19 +257,19 @@ static irqreturn_t intr_handler(int irq, void *dev_instance)
                 hdmitx_device->cur_phy_block_ptr++;
                 hdmitx_device->cur_phy_block_ptr=hdmitx_device->cur_phy_block_ptr&0x3;
             }
-        }        
+        }
 //#ifndef AML_A3
 //        /*walkaround: manually clear EDID interrupt*/
-//        hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) | (1<<1)); 
-//        hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) & ~(1<<1)); 
+//        hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) | (1<<1));
+//        hdmi_wr_reg(TX_HDCP_EDID_CONFIG, hdmi_rd_reg(TX_HDCP_EDID_CONFIG) & ~(1<<1));
 //        /**/
-//#endif        
+//#endif
         //tasklet_schedule(&EDID_tasklet);
-        hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 2); //clear EDID rising interrupt in hdmi module 
+        hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  1 << 2); //clear EDID rising interrupt in hdmi module
     }
     if (!((data32 == 1) || (data32 == 2) || (data32 == 4))) {
         hdmi_print(ERR, SYS "Unkown HDMI Interrupt Source\n");
-        hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  data32); //clear unkown interrupt in hdmi module 
+        hdmi_wr_only_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR,  data32); //clear unkown interrupt in hdmi module
     }
 //#ifdef AML_A3
     hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_INTR_STAT_CLR); // A read to allow the interrupt cleared in hdmi_module before next action
@@ -354,38 +330,38 @@ static void hdmi_tvenc1080i_set(Hdmi_tx_video_para_t* param)
     unsigned long vs_adjust;
     unsigned long vs_bline_evn, vs_eline_evn, vs_bline_odd, vs_eline_odd;
     unsigned long vso_begin_evn, vso_begin_odd;
-    
+
     if(param->VIC==HDMI_1080i60){
-         INTERLACE_MODE     = 1;                   
-         PIXEL_REPEAT_VENC  = 1;                   
-         PIXEL_REPEAT_HDMI  = 0;                   
+         INTERLACE_MODE     = 1;
+         PIXEL_REPEAT_VENC  = 1;
+         PIXEL_REPEAT_HDMI  = 0;
          ACTIVE_PIXELS  =     (1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
          ACTIVE_LINES   =     (1080/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0           = 562;                 
-         LINES_F1           = 563;                 
-         FRONT_PORCH        = 88;                  
-         HSYNC_PIXELS       = 44;                  
-         BACK_PORCH         = 148;                  
-         EOF_LINES          = 2;                   
-         VSYNC_LINES        = 5;                   
-         SOF_LINES          = 15;                  
-         TOTAL_FRAMES       = 4;                   
+         LINES_F0           = 562;
+         LINES_F1           = 563;
+         FRONT_PORCH        = 88;
+         HSYNC_PIXELS       = 44;
+         BACK_PORCH         = 148;
+         EOF_LINES          = 2;
+         VSYNC_LINES        = 5;
+         SOF_LINES          = 15;
+         TOTAL_FRAMES       = 4;
     }
     else if(param->VIC==HDMI_1080i50){
-         INTERLACE_MODE     = 1;                   
-         PIXEL_REPEAT_VENC  = 1;                   
-         PIXEL_REPEAT_HDMI  = 0;                   
+         INTERLACE_MODE     = 1;
+         PIXEL_REPEAT_VENC  = 1;
+         PIXEL_REPEAT_HDMI  = 0;
          ACTIVE_PIXELS  =     (1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
          ACTIVE_LINES   =     (1080/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0           = 562;                 
-         LINES_F1           = 563;                 
-         FRONT_PORCH        = 528;                  
-         HSYNC_PIXELS       = 44;                  
-         BACK_PORCH         = 148;                  
-         EOF_LINES          = 2;                   
-         VSYNC_LINES        = 5;                   
-         SOF_LINES          = 15;                  
-         TOTAL_FRAMES       = 4;                   
+         LINES_F0           = 562;
+         LINES_F1           = 563;
+         FRONT_PORCH        = 528;
+         HSYNC_PIXELS       = 44;
+         BACK_PORCH         = 148;
+         EOF_LINES          = 2;
+         VSYNC_LINES        = 5;
+         SOF_LINES          = 15;
+         TOTAL_FRAMES       = 4;
     }
     TOTAL_PIXELS =(FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS); // Number of total pixels per line.
     TOTAL_LINES  =(LINES_F0+(LINES_F1*INTERLACE_MODE));                // Number of total lines per frame.
@@ -433,7 +409,7 @@ static void hdmi_tvenc1080i_set(Hdmi_tx_video_para_t* param)
     hs_end  = modulo(hs_begin + hsync_pixels_venc,   total_pixels_venc); // (2 + 88) % 4400 = 90
     aml_write_reg32(P_ENCP_DVI_HSO_BEGIN,  hs_begin);  // 2
     aml_write_reg32(P_ENCP_DVI_HSO_END,    hs_end);    // 90
-    
+
     // Program Vsync timing for even field
     if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust)) {
         vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust); // 20 - 15 - 5 - 0 = 0
@@ -473,13 +449,13 @@ static void hdmi_tvenc1080i_set(Hdmi_tx_video_para_t* param)
                                                                     //                          6,7=Rsrv.
 #ifdef DOUBLE_CLK_720P_1080I
                          (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
-#else                         
+#else
                          (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
-#endif                         
+#endif
                          (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
     );
     aml_set_reg32_bits(P_VPU_HDMI_SETTING, 1, 1, 1);  // [    1] src_sel_encp: Enable ENCP output to HDMI
-}    
+}
 
 static void hdmi_tvenc480i_set(Hdmi_tx_video_para_t* param)
 {
@@ -501,36 +477,36 @@ static void hdmi_tvenc480i_set(Hdmi_tx_video_para_t* param)
     unsigned long vso_begin_evn, vso_begin_odd;
 
     if((param->VIC==HDMI_480i60)||(param->VIC==HDMI_480i60_16x9)){
-         INTERLACE_MODE     = 1;                   
-         PIXEL_REPEAT_VENC  = 1;                   
-         PIXEL_REPEAT_HDMI  = 1;                   
+         INTERLACE_MODE     = 1;
+         PIXEL_REPEAT_VENC  = 1;
+         PIXEL_REPEAT_HDMI  = 1;
          ACTIVE_PIXELS  =     (720*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
          ACTIVE_LINES   =     (480/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0           = 262;                 
-         LINES_F1           = 263;                 
-         FRONT_PORCH        = 38;                  
-         HSYNC_PIXELS       = 124;                  
-         BACK_PORCH         = 114;                  
-         EOF_LINES          = 4;                   
-         VSYNC_LINES        = 3;                   
-         SOF_LINES          = 15;                  
-         TOTAL_FRAMES       = 4;                   
+         LINES_F0           = 262;
+         LINES_F1           = 263;
+         FRONT_PORCH        = 38;
+         HSYNC_PIXELS       = 124;
+         BACK_PORCH         = 114;
+         EOF_LINES          = 4;
+         VSYNC_LINES        = 3;
+         SOF_LINES          = 15;
+         TOTAL_FRAMES       = 4;
     }
     else if((param->VIC==HDMI_576i50)||(param->VIC==HDMI_576i50_16x9)){
-         INTERLACE_MODE     = 1;                   
-         PIXEL_REPEAT_VENC  = 1;                   
-         PIXEL_REPEAT_HDMI  = 1;                   
+         INTERLACE_MODE     = 1;
+         PIXEL_REPEAT_VENC  = 1;
+         PIXEL_REPEAT_HDMI  = 1;
          ACTIVE_PIXELS  =     (720*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
          ACTIVE_LINES   =     (576/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0           = 312;                 
-         LINES_F1           = 313;                 
-         FRONT_PORCH        = 24;                  
-         HSYNC_PIXELS       = 126;                  
-         BACK_PORCH         = 138;                  
-         EOF_LINES          = 2;                   
-         VSYNC_LINES        = 3;                   
-         SOF_LINES          = 19;                  
-         TOTAL_FRAMES       = 4;                   
+         LINES_F0           = 312;
+         LINES_F1           = 313;
+         FRONT_PORCH        = 24;
+         HSYNC_PIXELS       = 126;
+         BACK_PORCH         = 138;
+         EOF_LINES          = 2;
+         VSYNC_LINES        = 3;
+         SOF_LINES          = 19;
+         TOTAL_FRAMES       = 4;
     }
     TOTAL_PIXELS =(FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS); // Number of total pixels per line.
     TOTAL_LINES  =(LINES_F0+(LINES_F1*INTERLACE_MODE));                // Number of total lines per frame.
@@ -571,7 +547,7 @@ static void hdmi_tvenc480i_set(Hdmi_tx_video_para_t* param)
     hs_end  = modulo(hs_begin + hsync_pixels_venc,   total_pixels_venc); // (1713 + 124) % 1716 = 121
     aml_write_reg32(P_ENCI_DVI_HSO_BEGIN,  hs_begin);  // 1713
     aml_write_reg32(P_ENCI_DVI_HSO_END,    hs_end);    // 121
-    
+
     // Program Vsync timing for even field
     if (de_v_end_odd-1 + EOF_LINES + vs_adjust >= LINES_F1) {
         vs_bline_evn = de_v_end_odd-1 + EOF_LINES + vs_adjust - LINES_F1;
@@ -654,7 +630,7 @@ static void hdmi_tvenc480i_set(Hdmi_tx_video_para_t* param)
                          (1                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
     );
     aml_set_reg32_bits(P_VPU_HDMI_SETTING, 1, 0, 1);  // [    0] src_sel_enci: Enable ENCI output to HDMI
-}    
+}
 
 static void hdmi_tvenc_set(Hdmi_tx_video_para_t *param)
 {
@@ -675,375 +651,117 @@ static void hdmi_tvenc_set(Hdmi_tx_video_para_t *param)
     unsigned long vs_bline_evn, vs_eline_evn, vs_bline_odd, vs_eline_odd;
     unsigned long vso_begin_evn, vso_begin_odd;
 
-
     if((param->VIC==HDMI_480p60)||(param->VIC==HDMI_480p60_16x9)){
-         INTERLACE_MODE     = 0;                   
-         PIXEL_REPEAT_VENC  = 1;                   
-         PIXEL_REPEAT_HDMI  = 0;                   
+         INTERLACE_MODE     = 0;
+         PIXEL_REPEAT_VENC  = 1;
+         PIXEL_REPEAT_HDMI  = 0;
          ACTIVE_PIXELS      = (720*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
          ACTIVE_LINES       = (480/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0           = 525;                 
-         LINES_F1           = 525;                 
-         FRONT_PORCH        = 16;                  
-         HSYNC_PIXELS       = 62;                  
-         BACK_PORCH         = 60;                  
-         EOF_LINES          = 9;                   
-         VSYNC_LINES        = 6;                   
-         SOF_LINES          = 30;                  
-         TOTAL_FRAMES       = 4;                   
-    }
-    else if(param->VIC==HDMI_640x480p60){
-         INTERLACE_MODE     = 0;                   
-         PIXEL_REPEAT_VENC  = 0;                   
-         PIXEL_REPEAT_HDMI  = 0;                   
-         ACTIVE_PIXELS      = (640*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
-         ACTIVE_LINES       = (480/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0           = 525;                 
-         LINES_F1           = 525;                 
-         FRONT_PORCH        = 16;                  
-         HSYNC_PIXELS       = 96;                  
-         BACK_PORCH         = 48;                  
-         EOF_LINES          = 10;                   
-         VSYNC_LINES        = 2;                   
-         SOF_LINES          = 33;                  
-         TOTAL_FRAMES       = 4;                   
+         LINES_F0           = 525;
+         LINES_F1           = 525;
+         FRONT_PORCH        = 16;
+         HSYNC_PIXELS       = 62;
+         BACK_PORCH         = 60;
+         EOF_LINES          = 9;
+         VSYNC_LINES        = 6;
+         SOF_LINES          = 30;
+         TOTAL_FRAMES       = 4;
     }
     else if((param->VIC==HDMI_576p50)||(param->VIC==HDMI_576p50_16x9)){
-         INTERLACE_MODE     = 0;                   
-         PIXEL_REPEAT_VENC  = 1;                   
-         PIXEL_REPEAT_HDMI  = 0;                   
+         INTERLACE_MODE     = 0;
+         PIXEL_REPEAT_VENC  = 1;
+         PIXEL_REPEAT_HDMI  = 0;
          ACTIVE_PIXELS      = (720*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
          ACTIVE_LINES       = (576/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0           = 625;                 
-         LINES_F1           = 625;                 
-         FRONT_PORCH        = 12;                  
-         HSYNC_PIXELS       = 64;                  
-         BACK_PORCH         = 68;                  
-         EOF_LINES          = 5;                   
-         VSYNC_LINES        = 5;                   
-         SOF_LINES          = 39;                  
-         TOTAL_FRAMES       = 4;                   
+         LINES_F0           = 625;
+         LINES_F1           = 625;
+         FRONT_PORCH        = 12;
+         HSYNC_PIXELS       = 64;
+         BACK_PORCH         = 68;
+         EOF_LINES          = 5;
+         VSYNC_LINES        = 5;
+         SOF_LINES          = 39;
+         TOTAL_FRAMES       = 4;
     }
     else if(param->VIC==HDMI_720p60){
-         INTERLACE_MODE     = 0;                   
-         PIXEL_REPEAT_VENC  = 1;                   
-         PIXEL_REPEAT_HDMI  = 0;                   
+         INTERLACE_MODE     = 0;
+         PIXEL_REPEAT_VENC  = 1;
+         PIXEL_REPEAT_HDMI  = 0;
          ACTIVE_PIXELS      = (1280*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
          ACTIVE_LINES       = (720/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0           = 750;                 
-         LINES_F1           = 750;                 
-         FRONT_PORCH        = 110;                  
-         HSYNC_PIXELS       = 40;                  
-         BACK_PORCH         = 220;                  
-         EOF_LINES          = 5;                   
-         VSYNC_LINES        = 5;                   
-         SOF_LINES          = 20;                  
-         TOTAL_FRAMES       = 4;                   
+         LINES_F0           = 750;
+         LINES_F1           = 750;
+         FRONT_PORCH        = 110;
+         HSYNC_PIXELS       = 40;
+         BACK_PORCH         = 220;
+         EOF_LINES          = 5;
+         VSYNC_LINES        = 5;
+         SOF_LINES          = 20;
+         TOTAL_FRAMES       = 4;
     }
     else if(param->VIC==HDMI_720p50){
-         INTERLACE_MODE     = 0;                   
-         PIXEL_REPEAT_VENC  = 1;                   
-         PIXEL_REPEAT_HDMI  = 0;                   
+         INTERLACE_MODE     = 0;
+         PIXEL_REPEAT_VENC  = 1;
+         PIXEL_REPEAT_HDMI  = 0;
          ACTIVE_PIXELS      = (1280*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
          ACTIVE_LINES       = (720/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0           = 750;                 
-         LINES_F1           = 750;                 
-         FRONT_PORCH        = 440;                  
-         HSYNC_PIXELS       = 40;                  
-         BACK_PORCH         = 220;                  
-         EOF_LINES          = 5;                   
-         VSYNC_LINES        = 5;                   
-         SOF_LINES          = 20;                  
-         TOTAL_FRAMES       = 4;                   
-    }
-    else if(param->VIC==HDMI_800p){
-		 INTERLACE_MODE		= 0;
-		 PIXEL_REPEAT_VENC	= 0; //MDRJR
-		 PIXEL_REPEAT_HDMI  = 0;
-		 ACTIVE_PIXELS      = 1280;
-		 ACTIVE_LINES		= 800;
-		 LINES_F0			= 823;
-		 LINES_F1			= 823;
-		 FRONT_PORCH		= 48;
-		 HSYNC_PIXELS		= 32;
-		 BACK_PORCH			= 80;
-		 EOF_LINES			= 3;
-		 VSYNC_LINES		= 6;
-		 SOF_LINES			= 14;
-		 TOTAL_FRAMES		= 4;
-	}
-    else if(param->VIC==HDMI_800x480p60hz){
-        INTERLACE_MODE      = 0;
-        PIXEL_REPEAT_VENC   = 0; //MDRJR
-        PIXEL_REPEAT_HDMI   = 0;
-        ACTIVE_PIXELS       = 800;
-        ACTIVE_LINES        = 480;
-        LINES_F0            = 500;
-        LINES_F1            = 500;
-        FRONT_PORCH         = 24;
-        HSYNC_PIXELS        = 72;
-        BACK_PORCH          = 96;
-        EOF_LINES           = 3;
-        VSYNC_LINES         = 7;
-        SOF_LINES           = 10;
-        TOTAL_FRAMES        = 4;
-	}
-    else if(param->VIC==HDMI_480x320p60hz){
-        INTERLACE_MODE      = 0;
-        PIXEL_REPEAT_VENC   = 0;
-        PIXEL_REPEAT_HDMI   = 0;
-        ACTIVE_PIXELS       = 480;
-        ACTIVE_LINES        = 320;
-        LINES_F0            = 263;
-        LINES_F1            = 263;
-        FRONT_PORCH         = 120;
-        HSYNC_PIXELS        = 100;
-        BACK_PORCH          = 100;
-        EOF_LINES           = 8;
-        VSYNC_LINES         = 4;
-        SOF_LINES           = 95;
-        TOTAL_FRAMES        = 4;
-	}
-    else if(param->VIC==HDMI_480x272p60hz){
-        INTERLACE_MODE      = 0;
-        PIXEL_REPEAT_VENC   = 0;
-        PIXEL_REPEAT_HDMI   = 0;
-        ACTIVE_PIXELS       = 480;
-        ACTIVE_LINES        = 272;
-        LINES_F0            = 263;
-        LINES_F1            = 263;
-        FRONT_PORCH         = 120;
-        HSYNC_PIXELS        = 100;
-        BACK_PORCH          = 100;
-        EOF_LINES           = 8;
-        VSYNC_LINES         = 4;
-        SOF_LINES           = 119;
-        TOTAL_FRAMES        = 4;
-	}
-    else if(param->VIC==HDMI_480x800p60hz){
-        INTERLACE_MODE      = 0;
-        PIXEL_REPEAT_VENC   = 0;
-        PIXEL_REPEAT_HDMI   = 0;
-        ACTIVE_PIXELS       = 480;
-        ACTIVE_LINES        = 800;
-        LINES_F0            = 845;
-        LINES_F1            = 845;
-        FRONT_PORCH         = 40;
-        HSYNC_PIXELS        = 48;
-        BACK_PORCH          = 40;
-        EOF_LINES           = 13;
-        VSYNC_LINES         = 3;
-        SOF_LINES           = 29;
-        TOTAL_FRAMES        = 4;
-	}
-    else if(param->VIC == HDMI_800x600p60hz) {
-        INTERLACE_MODE      = 0;
-        PIXEL_REPEAT_VENC   = 0;
-        PIXEL_REPEAT_HDMI   = 0;
-        ACTIVE_PIXELS       = 800;
-        ACTIVE_LINES        = 600;
-        LINES_F0            = 628;
-        LINES_F1            = 628;
-        FRONT_PORCH         = 40;
-        HSYNC_PIXELS        = 128;
-        BACK_PORCH          = 88;
-        EOF_LINES           = 1;
-        VSYNC_LINES         = 4;
-        SOF_LINES           = 23;
-        TOTAL_FRAMES        = 4;
-    }
-    else if(param->VIC == HDMI_1024x600p60hz) {
-        INTERLACE_MODE      = 0;
-        PIXEL_REPEAT_VENC   = 0;
-        PIXEL_REPEAT_HDMI   = 0;
-        ACTIVE_PIXELS       = 1024;
-        ACTIVE_LINES        = 600;
-        LINES_F0            = 638;
-        LINES_F1            = 638;
-        FRONT_PORCH         = 24;
-        HSYNC_PIXELS        = 136;
-        BACK_PORCH          = 160;
-        EOF_LINES           = 3;
-        VSYNC_LINES         = 6;
-        SOF_LINES           = 29;
-        TOTAL_FRAMES        = 4;
-    }
-    else if(param->VIC == HDMI_1024x768p60hz) {
-        INTERLACE_MODE      = 0;
-        PIXEL_REPEAT_VENC   = 0;
-        PIXEL_REPEAT_HDMI   = 0;
-        ACTIVE_PIXELS       = 1024;
-        ACTIVE_LINES        = 768;
-        LINES_F0            = 806;
-        LINES_F1            = 806;
-        FRONT_PORCH         = 24;
-        HSYNC_PIXELS        = 136;
-        BACK_PORCH          = 160;
-        EOF_LINES           = 3;
-        VSYNC_LINES         = 6;
-        SOF_LINES           = 29;
-        TOTAL_FRAMES        = 4;
-    }
-    else if(param->VIC == HDMI_1360x768p60hz) {
-        INTERLACE_MODE      = 0;
-        PIXEL_REPEAT_VENC   = 0;
-        PIXEL_REPEAT_HDMI   = 0;
-        ACTIVE_PIXELS       = 1360;
-        ACTIVE_LINES        = 768;
-        LINES_F0            = 795;
-        LINES_F1            = 795;
-        FRONT_PORCH         = 64;
-        HSYNC_PIXELS        = 112;
-        BACK_PORCH          = 256;
-        EOF_LINES           = 3;
-        VSYNC_LINES         = 6;
-        SOF_LINES           = 18;
-        TOTAL_FRAMES        = 4;
-    }
-    else if(param->VIC == HDMI_1440x900p60hz) {
-        INTERLACE_MODE      = 0;
-        PIXEL_REPEAT_VENC   = 0;
-        PIXEL_REPEAT_HDMI   = 0;
-        ACTIVE_PIXELS       = 1440;
-        ACTIVE_LINES        = 900;
-        LINES_F0            = 934;
-        LINES_F1            = 934;
-        FRONT_PORCH         = 80;
-        HSYNC_PIXELS        = 152;
-        BACK_PORCH          = 232;
-        EOF_LINES           = 3;
-        VSYNC_LINES         = 6;
-        SOF_LINES           = 25;
-        TOTAL_FRAMES        = 4;
-    }
-    else if(param->VIC == HDMI_1680x1050p60hz) {
-        INTERLACE_MODE      = 0;
-        PIXEL_REPEAT_VENC   = 0;
-        PIXEL_REPEAT_HDMI   = 0;
-        ACTIVE_PIXELS       = 1680;
-        ACTIVE_LINES        = 1050;
-        LINES_F0            = 1089;
-        LINES_F1            = 1089;
-        FRONT_PORCH         = 104;
-        HSYNC_PIXELS        = 176;
-        BACK_PORCH          = 280;
-        EOF_LINES           = 3;
-        VSYNC_LINES         = 6;
-        SOF_LINES           = 30;
-        TOTAL_FRAMES        = 4;
-    }
-    else if(param->VIC==HDMI_1366x768p60hz){
-        INTERLACE_MODE      = 0;
-        PIXEL_REPEAT_VENC   = 0; //MDRJR
-        PIXEL_REPEAT_HDMI   = 0;
-        ACTIVE_PIXELS       = 1366;
-        ACTIVE_LINES        = 768;
-        LINES_F0            = 798;
-        LINES_F1            = 798;
-        FRONT_PORCH         = 70;
-        HSYNC_PIXELS        = 143;
-        BACK_PORCH          = 213;
-        EOF_LINES           = 3;
-        VSYNC_LINES         = 3;
-        SOF_LINES           = 24;
-        TOTAL_FRAMES        = 4;
-	}
-    else if(param->VIC==HDMI_1600x900p60hz){
-        INTERLACE_MODE      = 0;
-        PIXEL_REPEAT_VENC   = 0; //MDRJR
-        PIXEL_REPEAT_HDMI   = 0;
-        ACTIVE_PIXELS       = 1600;
-        ACTIVE_LINES        = 900;
-        LINES_F0            = 1800;
-        LINES_F1            = 1800;
-        FRONT_PORCH         = 24;
-        HSYNC_PIXELS        = 80;
-        BACK_PORCH          = 96;
-        EOF_LINES           = 1;
-        VSYNC_LINES         = 3;
-        SOF_LINES           = 96;
-        TOTAL_FRAMES        = 4;
-	}
-    else if(param->VIC==HDMI_1280x1024){
-         INTERLACE_MODE     = 0;                   
-         PIXEL_REPEAT_VENC  = 0;                   
-         PIXEL_REPEAT_HDMI  = 0;                   
-         ACTIVE_PIXELS      = (1280*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
-         ACTIVE_LINES       = (1024/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0           = 1066;                 
-         LINES_F1           = 1066;                 
-         FRONT_PORCH        = 48;                  
-         HSYNC_PIXELS       = 112;                  
-         BACK_PORCH         = 248;                  
-         EOF_LINES          = 1;                   
-         VSYNC_LINES        = 3;                   
-         SOF_LINES          = 38;                  
-         TOTAL_FRAMES       = 4;                   
-    }
-    else if(param->VIC==HDMI_1920x1200)
-    {
-         INTERLACE_MODE      =0;              
-         PIXEL_REPEAT_VENC   =0;              
-         PIXEL_REPEAT_HDMI   =0;              
-         ACTIVE_PIXELS       =(1920 *(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
-         ACTIVE_LINES        =(1200/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0            =1235;           
-         LINES_F1            =1235;           
-         FRONT_PORCH         =48;             
-         HSYNC_PIXELS        =32;             
-         BACK_PORCH          =80;            
-         EOF_LINES           =3;              
-         VSYNC_LINES         =6;              
-         SOF_LINES           =26;             
-         TOTAL_FRAMES        =4;    
+         LINES_F0           = 750;
+         LINES_F1           = 750;
+         FRONT_PORCH        = 440;
+         HSYNC_PIXELS       = 40;
+         BACK_PORCH         = 220;
+         EOF_LINES          = 5;
+         VSYNC_LINES        = 5;
+         SOF_LINES          = 20;
+         TOTAL_FRAMES       = 4;
     }
     else if(param->VIC==HDMI_1080p50){
-         INTERLACE_MODE      =0;              
-         PIXEL_REPEAT_VENC   =0;              
-         PIXEL_REPEAT_HDMI   =0;              
+         INTERLACE_MODE      =0;
+         PIXEL_REPEAT_VENC   =0;
+         PIXEL_REPEAT_HDMI   =0;
          ACTIVE_PIXELS       =(1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
          ACTIVE_LINES        =(1080/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0            =1125;           
-         LINES_F1            =1125;           
-         FRONT_PORCH         =528;             
-         HSYNC_PIXELS        =44;             
-         BACK_PORCH          =148;            
-         EOF_LINES           =4;              
-         VSYNC_LINES         =5;              
-         SOF_LINES           =36;             
-         TOTAL_FRAMES        =4;              
+         LINES_F0            =1125;
+         LINES_F1            =1125;
+         FRONT_PORCH         =528;
+         HSYNC_PIXELS        =44;
+         BACK_PORCH          =148;
+         EOF_LINES           =4;
+         VSYNC_LINES         =5;
+         SOF_LINES           =36;
+         TOTAL_FRAMES        =4;
     }
     else if(param->VIC==HDMI_1080p24){//1080p24 support
-         INTERLACE_MODE      =0;              
-         PIXEL_REPEAT_VENC   =0;              
-         PIXEL_REPEAT_HDMI   =0;              
+         INTERLACE_MODE      =0;
+         PIXEL_REPEAT_VENC   =0;
+         PIXEL_REPEAT_HDMI   =0;
          ACTIVE_PIXELS       =(1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
          ACTIVE_LINES        =(1080/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0            =1125;           
-         LINES_F1            =1125;           
-         FRONT_PORCH         =638;             
-         HSYNC_PIXELS        =44;             
-         BACK_PORCH          =148;            
-         EOF_LINES           =4;              
-         VSYNC_LINES         =5;              
-         SOF_LINES           =36;             
-         TOTAL_FRAMES        =4;    
+         LINES_F0            =1125;
+         LINES_F1            =1125;
+         FRONT_PORCH         =638;
+         HSYNC_PIXELS        =44;
+         BACK_PORCH          =148;
+         EOF_LINES           =4;
+         VSYNC_LINES         =5;
+         SOF_LINES           =36;
+         TOTAL_FRAMES        =4;
     }
     else{ //HDMI_1080p60, HDMI_1080p30
-         INTERLACE_MODE      =0;              
-         PIXEL_REPEAT_VENC   =0;              
-         PIXEL_REPEAT_HDMI   =0;              
+         INTERLACE_MODE      =0;
+         PIXEL_REPEAT_VENC   =0;
+         PIXEL_REPEAT_HDMI   =0;
          ACTIVE_PIXELS       =(1920*(1+PIXEL_REPEAT_HDMI)); // Number of active pixels per line.
          ACTIVE_LINES        =(1080/(1+INTERLACE_MODE));    // Number of active lines per field.
-         LINES_F0            =1125;           
-         LINES_F1            =1125;           
-         FRONT_PORCH         =88;             
-         HSYNC_PIXELS        =44;             
-         BACK_PORCH          =148;            
-         EOF_LINES           =4;              
-         VSYNC_LINES         =5;              
-         SOF_LINES           =36;             
-         TOTAL_FRAMES        =4;              
+         LINES_F0            =1125;
+         LINES_F1            =1125;
+         FRONT_PORCH         =88;
+         HSYNC_PIXELS        =44;
+         BACK_PORCH          =148;
+         EOF_LINES           =4;
+         VSYNC_LINES         =5;
+         SOF_LINES           =36;
+         TOTAL_FRAMES        =4;
     }
 
     TOTAL_PIXELS       = (FRONT_PORCH+HSYNC_PIXELS+BACK_PORCH+ACTIVE_PIXELS); // Number of total pixels per line.
@@ -1086,7 +804,7 @@ static void hdmi_tvenc_set(Hdmi_tx_video_para_t *param)
     hs_end  = modulo(hs_begin + hsync_pixels_venc,   total_pixels_venc); // (1692 + 124) % 1716 = 100
     aml_write_reg32(P_ENCP_DVI_HSO_BEGIN,  hs_begin);  // 1692
     aml_write_reg32(P_ENCP_DVI_HSO_END,    hs_end);    // 100
-    
+
     // Program Vsync timing for even field
     if (de_v_begin_even >= SOF_LINES + VSYNC_LINES + (1-vs_adjust)) {
         vs_bline_evn = de_v_begin_even - SOF_LINES - VSYNC_LINES - (1-vs_adjust); // 42 - 30 - 6 - 1 = 5
@@ -1138,23 +856,6 @@ static void hdmi_tvenc_set(Hdmi_tx_video_para_t *param)
                                  (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
             );
             break;
-        case HDMI_640x480p60:
-        case HDMI_800x480p60hz:
-        case HDMI_480x800p60hz:
-	case HDMI_480x320p60hz:
-	case HDMI_480x272p60hz:
-            aml_write_reg32(P_VPU_HDMI_SETTING, 2);
-            break;
-        case HDMI_1366x768p60hz:
-        case HDMI_1600x900p60hz:
-        case HDMI_800x600p60hz:
-        case HDMI_1024x600p60hz:
-        case HDMI_1024x768p60hz:
-        case HDMI_1360x768p60hz:
-        case HDMI_1440x900p60hz:
-        case HDMI_1680x1050p60hz:
-            aml_write_reg32(P_VPU_HDMI_SETTING, 0xe);
-            break;
         case HDMI_720p60:
         case HDMI_720p50:
             // Annie 01Sep2011: Register VENC_DVI_SETTING and VENC_DVI_SETTING_MORE are no long valid, use VPU_HDMI_SETTING instead.
@@ -1175,7 +876,7 @@ static void hdmi_tvenc_set(Hdmi_tx_video_para_t *param)
                                  (0                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
 #else
                                  (1                                 << 8) | // [11: 8] wr_rate. 0=A write every clk1; 1=A write every 2 clk1; ...; 15=A write every 16 clk1.
-#endif                             
+#endif
                                  (0                                 <<12)   // [15:12] rd_rate. 0=A read every clk2; 1=A read every 2 clk2; ...; 15=A read every 16 clk2.
             );
             break;
@@ -1209,11 +910,9 @@ hdmi on/off
 static int is_hpd_muxed(void)
 {
     int ret;
-
     ret = !!(aml_read_reg32(P_PERIPHS_PIN_MUX_1)&(1<<26));
-
-    return ret; 
-}    
+    return ret;
+}
 
 static void mux_hpd(void)
 {
@@ -1231,11 +930,7 @@ int read_hpd_gpio(void)
 {
     int level;
 
-    if(disableHPD)
-        level = 1;  // always plug-in
-    else
-        level = !!(aml_read_reg32(P_PREG_PAD_GPIO3_I)&(1<<19)); //read GPIOH_0
-
+    level = !!(aml_read_reg32(P_PREG_PAD_GPIO3_I)&(1<<19)); //read GPIOH_0
     return level;
 }
 EXPORT_SYMBOL(read_hpd_gpio);
@@ -1262,7 +957,7 @@ static void clk81_set(void)
 static void clk81_resume(void)
 {
     struct clk *clk_tmp;
-    
+
     clk_tmp = clk_get_sys("clk81", NULL);
     if (clk_tmp)
     {
@@ -1284,7 +979,7 @@ static void digital_clk_off(unsigned char flag)
 //        hdmi_wr_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL1,  hdmi_rd_reg(OTHER_BASE_ADDR + HDMI_OTHER_CTRL1)&(~(1<<13))); //
 //        hdmi_wr_reg(TX_AUDIO_FORMAT, hdmi_rd_reg(TX_AUDIO_FORMAT)|(1<<7));
 //        hdmi_wr_reg(TX_AUDIO_I2S, hdmi_rd_reg(TX_AUDIO_I2S)|(1<<1));
-//#endif    
+//#endif
     }
 
     if(flag&2){
@@ -1326,7 +1021,7 @@ static void digital_clk_on(unsigned char flag)
         aml_write_reg32(P_HHI_GCLK_OTHER, aml_read_reg32(P_HHI_GCLK_OTHER)|(1<<17)); //enable VCLK1_HDMI GATE, set cbus reg HHI_GCLK_OTHER bit [17] = 1
     }
     if(flag&1){
-    }  
+    }
 }
 
 static void phy_pll_off(void)
@@ -1340,7 +1035,6 @@ void hdmi_hw_set_powermode(hdmitx_dev_t* hdmitx_device)
     int vic = hdmitx_device->cur_VIC;
 
     switch(vic) {
-    case HDMI_1280x1024:
     case HDMI_480i60:
     case HDMI_480i60_16x9:
     case HDMI_576p50:
@@ -1350,7 +1044,6 @@ void hdmi_hw_set_powermode(hdmitx_dev_t* hdmitx_device)
     case HDMI_480p60:
     case HDMI_480p60_16x9:
     case HDMI_720p50:
-    case HDMI_800p:
     case HDMI_720p60:
     case HDMI_1080i50:
     case HDMI_1080i60:
@@ -1368,7 +1061,7 @@ void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
 {
     unsigned int tmp_add_data;
     HDMI_Video_Codes_t vic;
-    
+
     digital_clk_on(7);
     aml_set_reg32_bits(P_HHI_VPU_MEM_PD_REG1, 0x0, 20, 2);
 // Powerup VPU_HDMI
@@ -1410,14 +1103,14 @@ void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
 #endif
     hdmi_print(IMP, SYS "hw init\n");
 
-    hdmi_wr_reg(0x017, 0x1d);   //1d for power-up Band-gap and main-bias ,00 is power down 
+    hdmi_wr_reg(0x017, 0x1d);   //1d for power-up Band-gap and main-bias ,00 is power down
     if(serial_reg_val<0x20){
         hdmi_wr_reg(0x018, 0x24);
     }
     else{
-        hdmi_wr_reg(0x018, serial_reg_val);   //Serializer Internal clock setting ,please fix to vaue 24 ,other setting is only for debug  
+        hdmi_wr_reg(0x018, serial_reg_val);   //Serializer Internal clock setting ,please fix to vaue 24 ,other setting is only for debug
     }
-    hdmi_wr_reg(0x01a, 0xfb);   //bit[2:0]=011 ,CK channel output TMDS CLOCK ,bit[2:0]=101 ,ck channel output PHYCLCK 
+    hdmi_wr_reg(0x01a, 0xfb);   //bit[2:0]=011 ,CK channel output TMDS CLOCK ,bit[2:0]=101 ,ck channel output PHYCLCK
 
     hdmi_hw_set_powermode(hdmitx_device);
 
@@ -1458,10 +1151,10 @@ void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
     hdmi_wr_reg(TX_HDCP_EDID_CONFIG, 0x0c); //// for hdcp, can not use 0x0e
     hdmi_wr_reg(TX_CORE_EDID_CONFIG_MORE, (1 << 0));    // [1]: keep_edid_error
                                                         // [0]: sys_trigger_config_semi_manu
-                                                        
+
     hdmi_wr_reg(TX_PACKET_ALLOC_ACTIVE_1, 0);
     hdmi_wr_reg(TX_PACKET_CONTROL_2, 2);
-    
+
     hdmi_wr_reg(TX_HDCP_CONFIG0,      1<<3);  //set TX rom_encrypt_off=1
     hdmi_wr_reg(TX_HDCP_MEM_CONFIG,   0<<3);  //set TX read_decrypt=0
     hdmi_wr_reg(TX_HDCP_ENCRYPT_BYTE, 0);     //set TX encrypt_byte=0x00
@@ -1495,17 +1188,17 @@ void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
     hdmi_wr_reg(TX_HDCP_CONFIG3, tmp_add_data);
 
     //tmp_add_data[15:8] = 0;
-    //tmp_add_data[7]   = 8'b1 ;  //cp_desired 
-    //tmp_add_data[6]   = 8'b1 ;  //ess_config 
-    //tmp_add_data[5]   = 8'b0 ;  //set_avmute 
-    //tmp_add_data[4]   = 8'b0 ;  //clear_avmute 
-    //tmp_add_data[3]   = 8'b1 ;  //hdcp_1_1 
-    //tmp_add_data[2]   = 8'b0 ;  //forced_polarity 
-    //tmp_add_data[1]   = 8'b0 ;  //forced_vsync_polarity 
+    //tmp_add_data[7]   = 8'b1 ;  //cp_desired
+    //tmp_add_data[6]   = 8'b1 ;  //ess_config
+    //tmp_add_data[5]   = 8'b0 ;  //set_avmute
+    //tmp_add_data[4]   = 8'b0 ;  //clear_avmute
+    //tmp_add_data[3]   = 8'b1 ;  //hdcp_1_1
+    //tmp_add_data[2]   = 8'b0 ;  //forced_polarity
+    //tmp_add_data[1]   = 8'b0 ;  //forced_vsync_polarity
     //tmp_add_data[0]   = 8'b0 ;  //forced_hsync_polarity
     tmp_add_data = 0x40;
     hdmi_wr_reg(TX_HDCP_MODE, tmp_add_data);
-    
+
     hdmi_wr_reg(TX_AUDIO_CONTROL_MORE, 1);
 
     hdmi_hw_set_powermode(hdmitx_device);
@@ -1517,13 +1210,13 @@ void hdmi_hw_init(hdmitx_dev_t* hdmitx_device)
     hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 1<<6); // Release resets all other TX digital clock domain, except tmds_clk
     delay_us(10);
     hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00); // Final release reset on tmds_clk domain
-    delay_us(10);        
+    delay_us(10);
 
-    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x68);        
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x68);
     delay_us(10);
-    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);        
+    hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);
     delay_us(10);
-}    
+}
 
 // When have below format output, we shall manually configure
 // bolow register to get stable Video Timing.
@@ -1555,7 +1248,7 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     unsigned long TX_OUTPUT_COLOR_FORMAT;
 
     hdmi_print(IMP, SYS "hw reset\n");
-    
+
     digital_clk_on(7);
 
     if(param->color==COLOR_SPACE_YUV444){
@@ -1574,15 +1267,15 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
 
     aml_write_reg32(P_HHI_HDMI_AFC_CNTL, aml_read_reg32(P_HHI_HDMI_AFC_CNTL) | 0x3);
 
-    hdmi_wr_reg(0x017, 0x1d);   //1d for power-up Band-gap and main-bias ,00 is power down 
+    hdmi_wr_reg(0x017, 0x1d);   //1d for power-up Band-gap and main-bias ,00 is power down
     if(new_reset_sequence_flag==0){
         if(serial_reg_val==0){
             if((param->VIC==HDMI_1080p30)||(param->VIC==HDMI_720p60)||(param->VIC==HDMI_1080i60)
-                ||(param->VIC==HDMI_1080p24)|| (param->VIC==HDMI_1280x1024) || (param->VIC==HDMI_640x480p60)){
-                hdmi_wr_reg(0x018, 0x22);   
+                ||(param->VIC==HDMI_1080p24)){
+                hdmi_wr_reg(0x018, 0x22);
             }
             else{
-                hdmi_wr_reg(0x018, 0x24);   
+                hdmi_wr_reg(0x018, 0x24);
             }
         }
         else if(serial_reg_val==1){
@@ -1590,10 +1283,10 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
                 ||(param->VIC==HDMI_576p50)||(param->VIC==HDMI_576p50_16x9)
                 ||(param->VIC==HDMI_480i60)||(param->VIC==HDMI_480i60_16x9)
                 ||(param->VIC==HDMI_576i50)||(param->VIC==HDMI_576i50_16x9)){
-                hdmi_wr_reg(0x018, 0x24);   
+                hdmi_wr_reg(0x018, 0x24);
             }
             else{
-                hdmi_wr_reg(0x018, 0x22);   
+                hdmi_wr_reg(0x018, 0x22);
             }
         }
         else{
@@ -1603,7 +1296,7 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
             hdmi_wr_reg(0x018,0x12);
         }
     }
-    hdmi_wr_reg(0x01a, 0xfb);   //bit[2:0]=011 ,CK channel output TMDS CLOCK ,bit[2:0]=101 ,ck channel output PHYCLCK 
+    hdmi_wr_reg(0x01a, 0xfb);   //bit[2:0]=011 ,CK channel output TMDS CLOCK ,bit[2:0]=101 ,ck channel output PHYCLCK
 
     hdmi_hw_set_powermode(hdmitx_device);
 
@@ -1612,8 +1305,8 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     // delay 1000uS, then check HPLL_LOCK
     delay_us(1000);
     //while ( (Rd(HHI_VID_PLL_CNTL3) & (1<<31)) != (1<<31) );
- 
-//////////////////////////////reset    
+
+//////////////////////////////reset
     if(new_reset_sequence_flag){
 
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x90);
@@ -1635,7 +1328,7 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
         tmp_add_data |= 1 << 1; // tx_dig_reset_n_ch1
         tmp_add_data |= 1 << 0; // tx_dig_reset_n_ch0
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, tmp_add_data);
-    
+
         tmp_add_data  = 0;
         tmp_add_data |= 1 << 7; // HDMI_CH3_RST_IN
         tmp_add_data |= 1 << 6; // HDMI_CH2_RST_IN
@@ -1656,9 +1349,9 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     //tmp_add_data[1]   = 1'b1 ;  // sys_trigger_config_semi_manu
     //tmp_add_data[0]   = 1'b0 ;  // Rsrv
 
-    tmp_add_data = 0x0c; // for hdcp, can not use 0x0e 
+    tmp_add_data = 0x0c; // for hdcp, can not use 0x0e
     hdmi_wr_reg(TX_HDCP_EDID_CONFIG, tmp_add_data);
-    
+
     hdmi_wr_reg(TX_HDCP_CONFIG0,      0x3<<3);  //set TX rom_encrypt_off=1
     hdmi_wr_reg(TX_HDCP_MEM_CONFIG,   0<<3);  //set TX read_decrypt=0
     hdmi_wr_reg(TX_HDCP_ENCRYPT_BYTE, 0);     //set TX encrypt_byte=0x00
@@ -1673,13 +1366,13 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     else
         tmp_add_data = (1<<4);
     hdmi_wr_reg(TX_VIDEO_DTV_TIMING, tmp_add_data);
-    
+
     tmp_add_data  = 0;
     tmp_add_data |= 0                       << 7; // [7]   forced_default_phase
     tmp_add_data |= 0                       << 2; // [6:2] Rsrv
     tmp_add_data |= param->color_depth      << 0; // [1:0] Color_depth:0=24-bit pixel; 1=30-bit pixel; 2=36-bit pixel; 3=48-bit pixel
     hdmi_wr_reg(TX_VIDEO_DTV_MODE, tmp_add_data); // 0x00
-    
+
     //tmp_add_data[15:8] = 0;
     //tmp_add_data[7] = 1'b0;       // Force packet timing
     //tmp_add_data[6] = 1'b0;       // PACKET ALLOC MODE
@@ -1690,13 +1383,13 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
 
     // For debug: disable packets of audio_request, acr_request, deep_color_request, and avmute_request
     //hdmi_wr_reg(TX_PACKET_CONTROL_2, hdmi_rd_reg(TX_PACKET_CONTROL_2) | 0x0f);
-    
-    //HDMI CT 7-19 GCP PB1 through PB6 not equal to 0 | 720 3 0 37 72 16367911819.90 31822 General Control Packet (GCP) 
+
+    //HDMI CT 7-19 GCP PB1 through PB6 not equal to 0 | 720 3 0 37 72 16367911819.90 31822 General Control Packet (GCP)
     //PACKET_CONTROL[~deep_color_request_enable]
     //0: horizontal GC packet transport enabled
     //1: horizontal GC packet masked
     hdmi_wr_reg(TX_PACKET_CONTROL_2, hdmi_rd_reg(TX_PACKET_CONTROL_2) | (0x1<<1));
-    
+
     //tmp_add_data[15:8] = 0;
     //tmp_add_data[7:6] = 2'b0;     // audio_source_select[1:0]
     //tmp_add_data[5] = 1'b0;       // external_packet_enable
@@ -1705,7 +1398,7 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     //tmp_add_data[1:0] = 2'b0 ;    // afe_fifo_source_select_lane_0[1:0]
     tmp_add_data = 0x10;
     hdmi_wr_reg(TX_CORE_DATA_CAPTURE_2, tmp_add_data);
-    
+
     //tmp_add_data[15:8] = 0;
     //tmp_add_data[7]   = 1'b0;     // monitor_lane_1
     //tmp_add_data[6:4] = 3'd0;     // monitor_select_lane_1[2:0]
@@ -1713,13 +1406,13 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     //tmp_add_data[2:0] = 3'd7;     // monitor_select_lane_0[2:0]
     tmp_add_data = 0xf;
     hdmi_wr_reg(TX_CORE_DATA_MONITOR_1, tmp_add_data);
-    
+
     //tmp_add_data[15:8] = 0;
     //tmp_add_data[7:3] = 5'b0;     // Rsrv
     //tmp_add_data[2:0] = 3'd2;     // monitor_select[2:0]
     tmp_add_data = 0x2;
     hdmi_wr_reg(TX_CORE_DATA_MONITOR_2, tmp_add_data);
-    
+
     //tmp_add_data[15:8] = 0;
     //tmp_add_data[7] = 1'b1;     // forced_hdmi
     //tmp_add_data[6] = 1'b1;     // hdmi_config
@@ -1728,14 +1421,14 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     //tmp_add_data[2:0] = 3'd0;   // channel_swap[2:0]
     tmp_add_data = 0xc0;
     hdmi_wr_reg(TX_TMDS_MODE, tmp_add_data);
-    
+
     //tmp_add_data[15:8] = 0;
     //tmp_add_data[7] = 1'b0;  // Rsrv
     //tmp_add_data[6] = 1'b0;  // TX_CONNECT_SEL: 0=use lower channel data[29:0]; 1=use upper channel data[59:30]
     //tmp_add_data[5:0] = 'h0;  // Rsrv
     tmp_add_data = 0x0;
     hdmi_wr_reg(TX_SYS4_CONNECT_SEL_1, tmp_add_data);
-    
+
     // Normally it makes sense to synch 3 channel output with clock channel's rising edge,
     // as HDMI's serializer is LSB out first, invert tmds_clk pattern from "1111100000" to
     // "0000011111" actually enable data synch with clock rising edge.
@@ -1745,8 +1438,8 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     //else{
         tmp_add_data = 1 << 4; // Set tmds_clk pattern to be "0000011111" before being sent to AFE clock channel
         hdmi_wr_reg(TX_SYS4_CK_INV_VIDEO, tmp_add_data);
-    //}            
-    
+    //}
+
     //tmp_add_data[15:8] = 0;
     //tmp_add_data[7] = 1'b0;  // Rsrv
     //tmp_add_data[6] = 1'b0;  // TX_AFE_FIFO channel 2 bypass=0
@@ -1758,7 +1451,7 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     //tmp_add_data[0] = 1'b1;  // TX_AFE_FIFO channel 0 enable
     tmp_add_data = 0x0f;
     hdmi_wr_reg(TX_SYS5_FIFO_CONFIG, tmp_add_data);
-    
+
     tmp_add_data  = 0;
     tmp_add_data |= TX_OUTPUT_COLOR_FORMAT  << 6; // [7:6] output_color_format: 0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
     tmp_add_data |= TX_INPUT_COLOR_FORMAT   << 4; // [5:4] input_color_format:  0=RGB444; 1=YCbCr444; 2=Rsrv; 3=YCbCr422.
@@ -1776,7 +1469,7 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
     tmp_add_data |= TX_OUTPUT_COLOR_RANGE   << 2; // [3:2] output_color_range:  0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
     tmp_add_data |= TX_INPUT_COLOR_RANGE    << 0; // [1:0] input_color_range:   0=16-235/240; 1=16-240; 2=1-254; 3=0-255.
     hdmi_wr_reg(TX_VIDEO_DTV_OPTION_H, tmp_add_data); // 0x00
-    
+
     if(!hdmi_audio_off_flag){
 #if 1
         hdmi_audio_init(i2s_to_spdif_flag);
@@ -1800,20 +1493,20 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
 
     //tmp_add_data[15:8] = 0;
     //tmp_add_data[7:0]   = 0xa ; // time_divider[7:0] for DDC I2C bus clock
-    
+
     //tmp_add_data = 0xa; //800k
     //tmp_add_data = 0x3f; //190k
     tmp_add_data = 0x30 - 1; //50k     // hdmi system clock change to XTAL 24MHz
     hdmi_wr_reg(TX_HDCP_CONFIG3, tmp_add_data);
 
     //tmp_add_data[15:8] = 0;
-    //tmp_add_data[7]   = 8'b1 ;  //cp_desired 
-    //tmp_add_data[6]   = 8'b1 ;  //ess_config 
-    //tmp_add_data[5]   = 8'b0 ;  //set_avmute 
-    //tmp_add_data[4]   = 8'b0 ;  //clear_avmute 
-    //tmp_add_data[3]   = 8'b1 ;  //hdcp_1_1 
-    //tmp_add_data[2]   = 8'b0 ;  //forced_polarity 
-    //tmp_add_data[1]   = 8'b0 ;  //forced_vsync_polarity 
+    //tmp_add_data[7]   = 8'b1 ;  //cp_desired
+    //tmp_add_data[6]   = 8'b1 ;  //ess_config
+    //tmp_add_data[5]   = 8'b0 ;  //set_avmute
+    //tmp_add_data[4]   = 8'b0 ;  //clear_avmute
+    //tmp_add_data[3]   = 8'b1 ;  //hdcp_1_1
+    //tmp_add_data[2]   = 8'b0 ;  //forced_polarity
+    //tmp_add_data[1]   = 8'b0 ;  //forced_vsync_polarity
     //tmp_add_data[0]   = 8'b0 ;  //forced_hsync_polarity
     tmp_add_data = 0x40;
     hdmi_wr_reg(TX_HDCP_MODE, tmp_add_data);
@@ -1839,10 +1532,10 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
         hdmi_wr_reg(TX_VIDEO_CSC_COEFF_CB1, 0x58);
         hdmi_wr_reg(TX_VIDEO_CSC_COEFF_CR0, 0xd0);
         hdmi_wr_reg(TX_VIDEO_CSC_COEFF_CR1, 0xb6);
-    }    
+    }
 
     hdmi_hw_set_powermode(hdmitx_device);
-    
+
     // --------------------------------------------------------
     // Release TX out of reset
     // --------------------------------------------------------
@@ -1852,18 +1545,18 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
         delay_us(10);
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00); // Final release reset on tmds_clk domain
         delay_us(10);
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x68);        
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x68);
         delay_us(10);
-        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);        
+        hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x60);
         delay_us(10);
         /* select serial*/
         if(serial_reg_val==0){
             if((param->VIC==HDMI_1080p30)||(param->VIC==HDMI_720p60)||(param->VIC==HDMI_1080i60)
                 ||(param->VIC==HDMI_1080p24)){
-                hdmi_wr_reg(0x018, 0x22);   
+                hdmi_wr_reg(0x018, 0x22);
             }
             else{
-                hdmi_wr_reg(0x018, 0x24);   
+                hdmi_wr_reg(0x018, 0x24);
             }
         }
         else if(serial_reg_val==1){
@@ -1871,10 +1564,10 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
                 ||(param->VIC==HDMI_576p50)||(param->VIC==HDMI_576p50_16x9)
                 ||(param->VIC==HDMI_480i60)||(param->VIC==HDMI_480i60_16x9)
                 ||(param->VIC==HDMI_576i50)||(param->VIC==HDMI_576i50_16x9)){
-                hdmi_wr_reg(0x018, 0x24);   
+                hdmi_wr_reg(0x018, 0x24);
             }
             else{
-                hdmi_wr_reg(0x018, 0x22);   
+                hdmi_wr_reg(0x018, 0x22);
             }
         }
         else{
@@ -1883,7 +1576,7 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
         if((param->VIC==HDMI_1080p60)&&(param->color_depth==COLOR_30BIT)&&(hdmi_rd_reg(0x018)==0x22)){
             hdmi_wr_reg(0x018,0x12);
         }
-        
+
     }
     else{
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x01); // Release serializer resets
@@ -1891,14 +1584,14 @@ static void hdmi_hw_reset(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t *par
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x00); // Release reset on TX digital clock channel
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 1<<6); // Release resets all other TX digital clock domain, except tmds_clk
         delay_us(10);
-    
+
         hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_1, 0x00); // Final release reset on tmds_clk domain
-        
+
         tmp_add_data = hdmi_rd_reg(0x018);
         if((tmp_add_data==0x22)||(tmp_add_data==0x12)){
-            hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x08);        
+            hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x08);
             delay_us(10);
-            hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x00);        
+            hdmi_wr_reg(TX_SYS5_TX_SOFT_RESET_2, 0x00);
         }
     }
     hdmi_reconfig_packet_setting(param->VIC);
@@ -1912,9 +1605,9 @@ static void hdmi_audio_init(unsigned char spdif_flag)
     /* TX_AUDIO_CONTROL[bit 0] should be 1, otherwise no sound??? */
     unsigned char tx_i2s_spdif;
     unsigned char tx_i2s_8_channel;
-    
+
     hdmi_print(IMP, AUD "%s\n", spdif_flag ? "SPDIF" : "I2S");
-    
+
     if(spdif_flag){
         tx_i2s_spdif=0;
     }
@@ -1972,14 +1665,14 @@ static void hdmi_audio_init(unsigned char spdif_flag)
     tmp_add_data |= 0x0 << 0;    // [3:0] N[19:16]
     hdmi_wr_reg(TX_SYS1_ACR_N_2, tmp_add_data); // 0xa0
 
-    hdmi_wr_reg(TX_AUDIO_CONTROL,   hdmi_rd_reg(TX_AUDIO_CONTROL)|0x1); 
+    hdmi_wr_reg(TX_AUDIO_CONTROL,   hdmi_rd_reg(TX_AUDIO_CONTROL)|0x1);
 }
 
 static void enable_audio_spdif(void)
-{    
+{
     hdmi_print(INF, AUD "Enable audio spdif to HDMI\n");
 
-    /* enable audio*/        
+    /* enable audio*/
     hdmi_wr_reg(TX_AUDIO_I2S,   0x0 );  // Address  0x5A=0x0    TX_AUDIO_I2S
 
     hdmi_wr_reg(TX_AUDIO_SPDIF, 1); // TX AUDIO SPDIF Enable
@@ -1990,13 +1683,13 @@ static void enable_audio_i2s(void)
     hdmi_print(INF, AUD "Enable audio i2s to HDMI\n");
     hdmi_wr_reg(TX_AUDIO_I2S,   0x1 );  // Address  0x5A=0x0    TX_AUDIO_I2S
     hdmi_wr_reg(TX_AUDIO_SPDIF, 0); // TX AUDIO SPDIF Enable
-}    
+}
 
 /************************************
 *    hdmitx hardware level interface
 *************************************/
 
-static void hdmitx_dump_tvenc_reg(int cur_VIC, int printk_flag) 
+static void hdmitx_dump_tvenc_reg(int cur_VIC, int printk_flag)
 {
     int i,j;
     for(i=0;hdmi_tvenc_configs[i].vic!=HDMI_Unkown;i++){
@@ -2010,7 +1703,7 @@ static void hdmitx_dump_tvenc_reg(int cur_VIC, int printk_flag)
             break;
         }
     }
-}    
+}
 
 static void hdmitx_config_tvenc_reg(int vic, unsigned reg, unsigned val)
 {
@@ -2020,7 +1713,7 @@ static void hdmitx_config_tvenc_reg(int vic, unsigned reg, unsigned val)
             reg_t* reg_set=hdmi_tvenc_configs[i].reg_set;
             for(j=0;reg_set[j].reg;j++){
                 if(reg_set[j].reg==reg){
-                    reg_set[j].val = val;    
+                    reg_set[j].val = val;
                     hdmi_print(INF, SYS "set [%08x]=%08x\n",reg_set[j].reg, reg_set[j].val);
                     break;
                 }
@@ -2033,12 +1726,76 @@ static void hdmitx_config_tvenc_reg(int vic, unsigned reg, unsigned val)
     }
 }
 
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+//
+// func: hdmitx_set_pll_fr_auto
+// params: none
+// return:
+//		1: current vmode is special and clock setting handled
+//		0: current vmode is not special and clock setting not handled
+//
+// desc:
+//		special vmode has same hdmi vic with normal mode, such as 1080p59hz - 1080p60hz
+//	so pll should not only be set according hdmi vic.
+//
+extern const vinfo_t *get_current_vinfo(void);
+static int hdmitx_set_pll_fr_auto(void)
+{
+	int ret = 0;
+	const vinfo_t *pvinfo = get_current_vinfo();
+
+	if( strncmp(pvinfo->name, "480p59hz", strlen("480p59hz")) == 0 )
+	{
+		set_vmode_clk(VMODE_480P_59HZ);
+		ret = 1;
+	}
+	else if( strncmp(pvinfo->name, "720p59hz", strlen("720p59hz")) == 0 )
+	{
+		set_vmode_clk(VMODE_720P_59HZ);
+		ret = 1;
+	}
+	else if( strncmp(pvinfo->name, "1080i59hz", strlen("1080i59hz")) == 0 )
+	{
+		set_vmode_clk(VMODE_1080I_59HZ);
+		ret = 1;
+	}
+	else if( strncmp(pvinfo->name, "1080p59hz", strlen("1080p59hz")) == 0 )
+	{
+		set_vmode_clk(VMODE_1080P_59HZ);
+		ret = 1;
+	}
+	else if( strncmp(pvinfo->name, "1080p23hz", strlen("1080p23hz")) == 0 )
+	{
+		set_vmode_clk(VMODE_1080P_23HZ);
+		ret = 1;
+	}
+	else if( strncmp(pvinfo->name, "4k2k29hz", strlen("4k2k29hz")) == 0 )
+	{
+		set_vmode_clk(VMODE_4K2K_29HZ);
+		ret = 1;
+	}
+	else if( strncmp(pvinfo->name, "4k2k23hz", strlen("4k2k23hz")) == 0 )
+	{
+		set_vmode_clk(VMODE_4K2K_23HZ);
+		ret = 1;
+	}
+
+	return ret;
+}
+#endif
+
 static void hdmitx_set_pll(Hdmi_tx_video_para_t *param)
 {
     hdmi_print(IMP, SYS "set pll\n");
     hdmi_print(IMP, SYS "param->VIC:%d\n", param->VIC);
-    
+
     cur_vout_index = get_cur_vout_index();
+
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	if( hdmitx_set_pll_fr_auto() )
+		return ;
+#endif
+
     switch(param->VIC)
     {
         case HDMI_480p60:
@@ -2066,45 +1823,6 @@ static void hdmitx_set_pll(Hdmi_tx_video_para_t *param)
         case HDMI_720p50:
             set_vmode_clk(VMODE_720P);
             break;
-        case HDMI_800p:
-			set_vmode_clk(VMODE_800P);
-			break;
-        case HDMI_800x480p60hz:
-            set_vmode_clk(VMODE_800X480P_60HZ);
-            break;
-	case HDMI_480x320p60hz:
-            set_vmode_clk(VMODE_480X320P_60HZ);
-            break;
-	case HDMI_480x272p60hz:
-            set_vmode_clk(VMODE_480X272P_60HZ);
-            break;
-        case HDMI_480x800p60hz:
-            set_vmode_clk(VMODE_480X800P_60HZ);
-            break;
-        case HDMI_1366x768p60hz:
-            set_vmode_clk(VMODE_1366X768P_60HZ);
-            break;
-        case HDMI_800x600p60hz:
-            set_vmode_clk(VMODE_800X600P_60HZ);
-            break;
-        case HDMI_1024x600p60hz:
-            set_vmode_clk(VMODE_1024X600P_60HZ);
-            break;
-        case HDMI_1024x768p60hz:
-            set_vmode_clk(VMODE_1024X768P_60HZ);
-            break;
-        case HDMI_1360x768p60hz:
-            set_vmode_clk(VMODE_1360X768P_60HZ);
-            break;
-        case HDMI_1440x900p60hz:
-            set_vmode_clk(VMODE_1440X900P_60HZ);
-            break;
-        case HDMI_1680x1050p60hz:
-            set_vmode_clk(VMODE_1680X1050P_60HZ);
-            break;
-        case HDMI_1600x900p60hz:
-            set_vmode_clk(VMODE_1600X900P_60HZ);
-            break;
         case HDMI_1080i60:
         case HDMI_1080i50:
             set_vmode_clk(VMODE_1080I);
@@ -2113,15 +1831,6 @@ static void hdmitx_set_pll(Hdmi_tx_video_para_t *param)
         case HDMI_1080p50:
             set_vmode_clk(VMODE_1080P);
             break;
-        case HDMI_640x480p60:
-            set_vmode_clk(VMODE_VGA);
-            break;
-        case HDMI_1280x1024:
-            set_vmode_clk(VMODE_SXGA);
-            break;
-        case HDMI_1920x1200:
-            set_vmode_clk(VMODE_1920x1200);
-            break;
         default:
             break;
     }
@@ -2165,13 +1874,6 @@ static int hdmitx_set_dispmode(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t
         &&(param->VIC!=HDMI_1080p24)
         &&(param->VIC!=HDMI_1080p60)&&(param->VIC!=HDMI_1080p50)
         &&(param->VIC!=HDMI_720p60)&&(param->VIC!=HDMI_720p50)
-       	&&(param->VIC!=HDMI_480x320p60hz)
-       	&&(param->VIC!=HDMI_480x272p60hz)
-	&&(param->VIC!=HDMI_800x480p60hz)&&(param->VIC!=HDMI_480x800p60hz)
-        &&(param->VIC!=HDMI_1366x768p60hz)&&(param->VIC!=HDMI_1600x900p60hz)
-        &&(param->VIC!=HDMI_800x600p60hz)&&(param->VIC!=HDMI_1024x600p60hz)&&(param->VIC!=HDMI_1024x768p60hz)
-        &&(param->VIC!=HDMI_1360x768p60hz)&&(param->VIC!=HDMI_1440x900p60hz)&&(param->VIC!=HDMI_1680x1050p60hz)
-        &&(param->VIC!=HDMI_640x480p60) &&(param->VIC!=HDMI_1280x1024) &&(param->VIC!=HDMI_1920x1200) && (param->VIC!=HDMI_800p)
         &&(param->VIC!=HDMI_4k2k_30)&&(param->VIC!=HDMI_4k2k_25)&&(param->VIC!=HDMI_4k2k_24)&&(param->VIC!=HDMI_4k2k_smpte_24)
         &&(param->VIC!=HDMI_1080i60)&&(param->VIC!=HDMI_1080i50)){
         return -1;
@@ -2197,12 +1899,12 @@ static int hdmitx_set_dispmode(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t
     }
     hdmitx_device->cur_VIC = param->VIC;
     hdmi_tx_gate_pwr_ctrl(VID_EN, hdmitx_device);
-    hdmi_hw_reset(hdmitx_device, param);    
+    hdmi_hw_reset(hdmitx_device, param);
 
     if((param->VIC==HDMI_720p60)||(param->VIC==HDMI_720p50)||
         (param->VIC==HDMI_1080i60)||(param->VIC==HDMI_1080i50)){
-        aml_write_reg32(P_ENCP_VIDEO_HAVON_BEGIN,  aml_read_reg32(P_ENCP_VIDEO_HAVON_BEGIN)-1);     
-        aml_write_reg32(P_ENCP_VIDEO_HAVON_END,  aml_read_reg32(P_ENCP_VIDEO_HAVON_END)-1);     
+        aml_write_reg32(P_ENCP_VIDEO_HAVON_BEGIN,  aml_read_reg32(P_ENCP_VIDEO_HAVON_BEGIN)-1);
+        aml_write_reg32(P_ENCP_VIDEO_HAVON_END,  aml_read_reg32(P_ENCP_VIDEO_HAVON_END)-1);
     }
 
     switch(param->VIC){
@@ -2256,7 +1958,7 @@ static int hdmitx_set_dispmode(hdmitx_dev_t* hdmitx_device, Hdmi_tx_video_para_t
     hdmitx_set_phy(hdmitx_device);
 
     return 0;
-}    
+}
 
 
 static void hdmitx_set_packet(int type, unsigned char* DB, unsigned char* HB)
@@ -2266,11 +1968,11 @@ static void hdmitx_set_packet(int type, unsigned char* DB, unsigned char* HB)
     unsigned char ucData ;
     unsigned int pkt_reg_base=TX_PKT_REG_AVI_INFO_BASE_ADDR;
     int pkt_data_len=0;
-    
+
     switch(type)
     {
         case HDMI_PACKET_AVI:
-            pkt_reg_base=TX_PKT_REG_AVI_INFO_BASE_ADDR; 
+            pkt_reg_base=TX_PKT_REG_AVI_INFO_BASE_ADDR;
             pkt_data_len=13;
             break;
         case HDMI_PACKET_VEND:
@@ -2287,12 +1989,12 @@ static void hdmitx_set_packet(int type, unsigned char* DB, unsigned char* HB)
         default:
             break;
     }
-    
+
     if(DB){
         for(i=0;i<pkt_data_len;i++){
-            hdmi_wr_reg(pkt_reg_base+i+1, DB[i]);  
+            hdmi_wr_reg(pkt_reg_base+i+1, DB[i]);
         }
-    
+
         for(i = 0,ucData = 0; i < pkt_data_len ; i++)
         {
             ucData -= DB[i] ;
@@ -2300,11 +2002,11 @@ static void hdmitx_set_packet(int type, unsigned char* DB, unsigned char* HB)
         for(i=0; i<3; i++){
             ucData -= HB[i];
         }
-        hdmi_wr_reg(pkt_reg_base+0x00, ucData);  
-    
-        hdmi_wr_reg(pkt_reg_base+0x1C, HB[0]);        
-        hdmi_wr_reg(pkt_reg_base+0x1D, HB[1]);        
-        hdmi_wr_reg(pkt_reg_base+0x1E, HB[2]);        
+        hdmi_wr_reg(pkt_reg_base+0x00, ucData);
+
+        hdmi_wr_reg(pkt_reg_base+0x1C, HB[0]);
+        hdmi_wr_reg(pkt_reg_base+0x1D, HB[1]);
+        hdmi_wr_reg(pkt_reg_base+0x1E, HB[2]);
         hdmi_wr_reg(pkt_reg_base+0x1F, 0x00ff);        // Enable packet generation
     }
     else{
@@ -2317,11 +2019,11 @@ static void hdmitx_setaudioinfoframe(unsigned char* AUD_DB, unsigned char* CHAN_
 {
     int i ;
     unsigned char AUD_HB[3]={0x84, 0x1, 0xa};
-    hdmitx_set_packet(HDMI_AUDIO_INFO, AUD_DB, AUD_HB);    
+    hdmitx_set_packet(HDMI_AUDIO_INFO, AUD_DB, AUD_HB);
     //channel status
     if(CHAN_STAT_BUF){
         for(i=0;i<24;i++){
-            hdmi_wr_reg(TX_IEC60958_SUB1_OFFSET+i, CHAN_STAT_BUF[i]);        
+            hdmi_wr_reg(TX_IEC60958_SUB1_OFFSET+i, CHAN_STAT_BUF[i]);
             hdmi_wr_reg(TX_IEC60958_SUB2_OFFSET+i, CHAN_STAT_BUF[24+i]);
         }
     }
@@ -2447,10 +2149,36 @@ static Cts_conf_tab cts_table_192k[] = {
     {24576,  54000,  54000},
     {24576, 108000, 108000},
     {24576,  74250,  74250},
+    {46592,  74250 * 1000 / 1001, 140625},
     {24576, 148500, 148500},
-    {24576, 297000, 247500},
+    {23296, 148500 * 1000 / 1001, 140625},
+    {20480, 297000, 247500},
+    {23296, 297000 * 1000 / 1001, 281250},
 };
 
+static Cts_conf_tab cts_table_48k[] = {
+    {6144,  27000,  27000},
+    {6144,  54000,  54000},
+    {6144,  74250,  74250},
+    {23296,  74250 * 1000 / 1001, 140625},
+    {6144, 148500, 148500},
+    {5824, 148500 * 1000 / 1001, 140625},
+    {5120, 297000, 247500},
+    {5824, 297000 * 1000 / 1001, 281250},
+};
+
+static unsigned int get_n_48k(unsigned int clk)
+{
+    int i;
+
+    for (i = 0; i < ARRAY_SIZE(cts_table_48k); i++) {
+        if (clk == cts_table_48k[i].tmds_clk)
+            return cts_table_48k[i].fixed_n;
+    }
+
+    return 0;
+}
+
 static unsigned int get_cts(unsigned int clk)
 {
     int i;
@@ -2468,19 +2196,6 @@ static Vic_attr_map vic_attr_map_table[] = {
     {HDMI_480p60,           27000 },
     {HDMI_480p60_16x9,      27000 },
     {HDMI_720p60,           74250 },
-    {HDMI_800p,				71000 },
-    {HDMI_800x480p60hz,     29760 },
-    {HDMI_480x320p60hz,     25175 },
-    {HDMI_480x272p60hz,     25175 },
-    {HDMI_480x800p60hz,     32000 },
-    {HDMI_1366x768p60hz,    85500 },
-    {HDMI_1600x900p60hz,    108000},
-    {HDMI_800x600p60hz,     40000},
-    {HDMI_1024x600p60hz,    51450},
-    {HDMI_1024x768p60hz,    65000},
-    {HDMI_1360x768p60hz,    85500},
-    {HDMI_1440x900p60hz,    106500},
-    {HDMI_1680x1050p60hz,   146250},
     {HDMI_1080i60,          74250 },
     {HDMI_480i60,           27000 },
     {HDMI_480i60_16x9,      27000 },
@@ -2491,7 +2206,6 @@ static Vic_attr_map vic_attr_map_table[] = {
     {HDMI_576p50,           27000 },
     {HDMI_576p50_16x9,      27000 },
     {HDMI_720p50,           74250 },
-    {HDMI_1280x1024,        108000},
     {HDMI_1080i50,          74250 },
     {HDMI_576i50,           27000 },
     {HDMI_576i50_16x9,      27000 },
@@ -2508,15 +2222,48 @@ static Vic_attr_map vic_attr_map_table[] = {
     {HDMI_4k2k_smpte_24,    297000},
 };
 
-static unsigned int vic_map_clk(HDMI_Video_Codes_t vic)
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+
+const static char *fr_auto_mode[] = {
+    "480p59hz",
+    "720p59hz",
+    "1080i59hz",
+    "1080p59hz",
+    "1080p23hz",
+    "4k2k29hz",
+    "4k2k23hz",
+};
+
+static int hdmitx_is_framerate_automation(void)
 {
     int i;
+    const vinfo_t *vinfo = get_current_vinfo();
+    for (i = 0; i < ARRAY_SIZE(fr_auto_mode); i ++) {
+        if (strncmp(vinfo->name, fr_auto_mode[i], strlen(fr_auto_mode[i])) == 0) {
+            return 1;
+        }
+    }
+    return 0;
+}
 
-    for(i = 0; i < ARRAY_SIZE(vic_attr_map_table); i++) {
+#endif
+
+static unsigned int vic_map_clk(HDMI_Video_Codes_t vic)
+{
+    int i;
+    for (i = 0; i < ARRAY_SIZE(vic_attr_map_table); i++) {
         if(vic == vic_attr_map_table[i].VIC)
+#ifndef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
             return vic_attr_map_table[i].tmds_clk;
+#else
+        {
+            if (hdmitx_is_framerate_automation())
+                return ((vic_attr_map_table[i].tmds_clk) * 1000 / 1001);
+            else
+                return vic_attr_map_table[i].tmds_clk;
+        }
+#endif
     }
-
     return 0;
 }
 
@@ -2556,12 +2303,52 @@ static void hdmitx_set_aud_cts(audio_type_t type, Hdmi_tx_audio_cts_t cts_mode,
     }
 }
 
+static unsigned int hdmitx_get_aud_n(HDMI_Video_Codes_t vic)
+{
+    unsigned int n_val = 0;
+    unsigned int clk = vic_map_clk(vic);
+    if (clk) {
+        n_val = get_n_48k(clk);
+        printk("get n = %d\n", n_val);
+        if (!n_val) {
+            hdmi_print(ERR, AUD "not find n\n");
+            return 0;
+        }
+    }
+    else {
+        hdmi_print(ERR, AUD "not find tmds clk\n");
+        return 0;
+    }
+    return n_val;
+}
+
+static unsigned int audio_N_1080p24=0;
+static void hdmitx_set_aud_n(void)
+{
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    unsigned int audio_N_para = 6272 ;
+    unsigned int audio_N_tolerance = 3;
+    const vinfo_t *vinfo = get_current_vinfo();
+    if (strncmp(vinfo->name, "1080p23hz", strlen("1080p23hz")) == 0) {
+        audio_N_para = 23296;
+        hdmi_wr_reg(TX_SYS1_ACR_N_0, (audio_N_para&0xff)); // N[7:0]
+        hdmi_wr_reg(TX_SYS1_ACR_N_1, (audio_N_para>>8)&0xff); // N[15:8]
+        hdmi_wr_reg(TX_SYS1_ACR_N_2, (audio_N_tolerance<<4)|((audio_N_para>>16)&0xf)); // N[19:16]
+    }
+    else if (strncmp(vinfo->name, "1080p24hz", strlen("1080p24hz")) == 0) {
+        audio_N_para = audio_N_1080p24;
+        hdmi_wr_reg(TX_SYS1_ACR_N_0, (audio_N_para&0xff)); // N[7:0]
+        hdmi_wr_reg(TX_SYS1_ACR_N_1, (audio_N_para>>8)&0xff); // N[15:8]
+        hdmi_wr_reg(TX_SYS1_ACR_N_2, (audio_N_tolerance<<4)|((audio_N_para>>16)&0xf)); // N[19:16]
+    }
+#endif
+}
 static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio_para_t* audio_param)
 {
     unsigned int audio_N_para = 6272;
     unsigned int audio_N_tolerance = 3;
 //    unsigned int audio_CTS = 30000;
-    
+    const vinfo_t *vinfo = get_current_vinfo();
     hdmi_print(INF, AUD "audio channel num is %d\n", hdmitx_device->cur_audio_param.channel_num);
 
     hdmi_wr_reg(TX_PACKET_CONTROL_2, hdmi_rd_reg(TX_PACKET_CONTROL_2) & (~(1<<3)));
@@ -2588,7 +2375,6 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
         //TMDS Clock:27MHz
         case HDMI_480p60:
         case HDMI_480p60_16x9:
-        case HDMI_640x480p60:
         case HDMI_576p50:
         case HDMI_576p50_16x9:
         case HDMI_480i60:
@@ -2618,22 +2404,13 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
                 case FS_192K:
                     audio_N_para = 24576;
                     break;
-                case FS_352K8:
-                    audio_N_para = 24576;
-                    break;
-                case FS_384K:
-                    audio_N_para = 24576;
-                    break;
                 default:
                     break;
             }
             break;
         //TMDS Clock:74.176MHz
-        case HDMI_800p:
-        case HDMI_800x480p60hz:
         case HDMI_720p60:
         case HDMI_720p50:
-        case HDMI_1280x1024:
         case HDMI_1080i60:
         case HDMI_1080i50:
         case HDMI_1080p30:
@@ -2661,12 +2438,6 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
                 case FS_192K:
                     audio_N_para = 24576;
                     break;
-                case FS_352K8:
-                    audio_N_para = 24576;
-                    break;
-                case FS_384K:
-                    audio_N_para = 24576;
-                    break;
                 default:
                     break;
             }
@@ -2674,7 +2445,6 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
         //TMDS Clock:148.5MHz
         case HDMI_1080p50:
         case HDMI_1080p60:
-        case HDMI_1920x1200:
             switch(audio_param->sample_rate)
             {
                 case FS_32K:
@@ -2698,19 +2468,13 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
                 case FS_192K:
                     audio_N_para = 24576;
                     break;
-                case FS_352K8:
-                    audio_N_para = 24576;
-                    break;
-                case FS_384K:
-                    audio_N_para = 24576;
-                    break;
                 default:
                     break;
             }
             break;
         default:
             break;
-    }    
+    }
 
     hdmi_print(INF, AUD "reset audio N para\n");
     switch(audio_param->sample_rate){
@@ -2730,6 +2494,12 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
         default:
             break;
     }
+    if (audio_param->sample_rate == FS_48K) {
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+        if (strncmp(vinfo->name, "1080p23hz", strlen("1080p23hz")) == 0)
+            audio_N_para=hdmitx_get_aud_n(hdmitx_device->cur_VIC);
+#endif
+    }
 
     hdmitx_set_aud_pkt_type(audio_param->type);
 
@@ -2768,7 +2538,10 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
         default:
             break;
     }
-
+    if (strncmp(vinfo->name, "1080p24hz", strlen("1080p24hz")) == 0)
+    {
+        audio_N_1080p24=audio_N_para;
+    }
     hdmi_wr_reg(TX_SYS1_ACR_N_0, (audio_N_para&0xff)); // N[7:0]
     hdmi_wr_reg(TX_SYS1_ACR_N_1, (audio_N_para>>8)&0xff); // N[15:8]
     hdmi_wr_reg(TX_SYS1_ACR_N_2, (audio_N_tolerance<<4)|((audio_N_para>>16)&0xf)); // N[19:16]
@@ -2777,9 +2550,9 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
     hdmi_wr_reg(TX_SYS0_ACR_CTS_0, 0);      //audio_CTS & 0xff);
     hdmi_wr_reg(TX_SYS0_ACR_CTS_1, 0);      //(audio_CTS>>8) & 0xff);
     hdmi_wr_reg(TX_SYS0_ACR_CTS_2, 1 << 5);      // set bit[5] force_arc_stable to 1
-    
+
     set_hdmi_audio_source(i2s_to_spdif_flag ? 1 : 2);
-    
+
     hdmi_print(INF, AUD "i2s_to_spdif_flag:%d \n", i2s_to_spdif_flag);
     if(i2s_to_spdif_flag)
         enable_audio_spdif();
@@ -2798,15 +2571,15 @@ static int hdmitx_set_audmode(struct hdmi_tx_dev_s* hdmitx_device, Hdmi_tx_audio
 //todo    hdmitx_special_handler_audio(hdmitx_device);
 
     return 0;
-}    
-    
+}
+
 static void hdmitx_setupirq(hdmitx_dev_t* hdmitx_device)
 {
    int r;
    r = request_irq(INT_HDMI_TX, &intr_handler,
                     IRQF_SHARED, "amhdmitx",
                     (void *)hdmitx_device);
-}    
+}
 
 
 #if 1
@@ -2896,7 +2669,7 @@ static void turn_on_prbs_mode(int prbs_mode)
 
     hdmi_print(INF, SYS "PRBS mode %d On\n", prbs_mode);
 }
-    
+
 #endif
 
 static void hdmitx_uninit(hdmitx_dev_t* hdmitx_device)
@@ -2905,11 +2678,11 @@ static void hdmitx_uninit(hdmitx_dev_t* hdmitx_device)
     //aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK)&(~(1 << 25)));
     free_irq(INT_HDMI_TX, (void *)hdmitx_device);
     hdmi_print(1,"power off hdmi, unmux hpd\n");
-    
+
     phy_pll_off();
     digital_clk_off(7); //off sys clk
     unmux_hpd();
-}    
+}
 
 static char hdcp_log_buf[HDMITX_HDCP_MONITOR_BUF_SIZE] = { 0 };
 const static hdcp_sub_t hdcp_monitor_array[] = {
@@ -2966,7 +2739,7 @@ static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
     }
     else if(cmd == HDMITX_EARLY_SUSPEND_RESUME_CNTL) {
         if(argv == HDMITX_EARLY_SUSPEND) {
-            aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0, 30, 1);
+            //aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0, 30, 1);
             hdmi_phy_suspend();
         }
         if(argv == HDMITX_LATE_RESUME) {
@@ -3055,8 +2828,8 @@ static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
     }
     else if(cmd == HDMITX_HWCMD_MUX_HPD){
          mux_hpd();
-    } 
-// For test only. 
+    }
+// For test only.
     else if(cmd == HDMITX_HWCMD_TURNOFF_HDMIHW){
         int unmux_hpd_flag = argv;
 //        WRITE_MPEG_REG(VENC_DVI_SETTING, READ_MPEG_REG(VENC_DVI_SETTING)&(~(1<<13))); //bit 13 is used by HDMI only
@@ -3078,9 +2851,9 @@ static int hdmitx_cntl(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
 #endif
     }
     else if(cmd == HDMITX_HWCMD_TURN_ON_PRBS){
-        turn_on_prbs_mode(argv);    
+        turn_on_prbs_mode(argv);
     }
-    return 0;           
+    return 0;
 }
 
 static void hdmitx_print_info(hdmitx_dev_t* hdmitx_device, int printk_flag)
@@ -3090,7 +2863,7 @@ static void hdmitx_print_info(hdmitx_dev_t* hdmitx_device, int printk_flag)
     hdmi_print(INF, "reset sequence %d\n", new_reset_sequence_flag);
     hdmi_print(INF, "power mode %d\n", power_mode);
     hdmi_print(INF, "%spowerdown when unplug\n",hdmitx_device->unplug_powerdown?"":"do not ");
-    hdmi_print(INF, "use_tvenc_conf_flag=%d\n",use_tvenc_conf_flag); 
+    hdmi_print(INF, "use_tvenc_conf_flag=%d\n",use_tvenc_conf_flag);
     hdmi_print(INF, "vdac %s\n", power_off_vdac_flag?"off":"on");
     hdmi_print(INF, "hdmi audio %s\n", hdmi_audio_off_flag?"off":"on");
     if(!hdmi_audio_off_flag){
@@ -3173,7 +2946,7 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
     unsigned int value=0;
     while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
         tmpbuf[i]=buf[i];
-        i++;    
+        i++;
     }
     tmpbuf[i]=0;
     if((strncmp(tmpbuf, "dumpreg", 7)==0) || (strncmp(tmpbuf, "dumptvencreg", 12)==0)){
@@ -3226,13 +2999,31 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
         //HDMI CEC Regs address range:0xc000~0xc01c;0xc080~0xc094
         for(cec_adr = 0xc000; cec_adr < 0xc01d; cec_adr ++){
             cec_val = hdmi_rd_reg(cec_adr);
-            hdmi_print(INF, "HDMI CEC Regs[0x%x]: 0x%x\n",cec_adr,cec_val);             
+            hdmi_print(INF, "HDMI CEC Regs[0x%x]: 0x%x\n",cec_adr,cec_val);
         }
          for(cec_adr = 0xc080; cec_adr < 0xc095; cec_adr ++){
             cec_val = hdmi_rd_reg(cec_adr);
-            hdmi_print(INF, "HDMI CEC Regs[0x%x]: 0x%x\n",cec_adr,cec_val);             
+            hdmi_print(INF, "HDMI CEC Regs[0x%x]: 0x%x\n",cec_adr,cec_val);
+        }
+        return;
+    }
+    else if (strncmp(tmpbuf, "dumpaocecreg", 12) == 0) {
+        unsigned char cec_val = 0;
+        unsigned int cec_adr =0;
+        for (cec_adr = P_AO_CEC_GEN_CNTL; cec_adr < P_AO_CEC_INTR_STAT; cec_adr += 4) {
+            cec_val = aml_read_reg32(cec_adr);
+            printk("aocec ctrl Regs[0x%x]: 0x%x\n", cec_adr,cec_val);
+        }
+        for (cec_adr = CEC_TX_MSG_0_HEADER; cec_adr < CEC_CLOCK_DIV_L; cec_adr ++) {
+            cec_val = aocec_rd_reg(cec_adr);
+            printk("aocec Regs[0x%x]: 0x%x\n", cec_adr,cec_val);
         }
-        return;      
+        for (cec_adr = CEC_RX_MSG_0_HEADER; cec_adr < CEC_TX_NUM_MSG; cec_adr ++) {
+            cec_val = aocec_rd_reg(cec_adr);
+            printk("aocec Regs[0x%x]: 0x%x\n", cec_adr,cec_val);
+        }
+
+        return;
     }
     else if(strncmp(tmpbuf, "dumpcbusreg", 11)==0){
         unsigned j;
@@ -3241,7 +3032,7 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
         for(j = 0 ; j < value-adr+1 ; j++){
 //            printk("CBUS[0x%x]: 0x%x\n", adr+j, READ_MPEG_REG(adr+j));
             hdmi_print(INF, "CBUS[0x%x]: 0x%x\n", adr+j, aml_read_reg32(CBUS_REG_ADDR(adr+j)));
-            
+
         }
     }
     else if(strncmp(tmpbuf, "log", 3)==0){
@@ -3285,16 +3076,16 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
     else if(strncmp(tmpbuf, "reset", 5)==0){
         if(tmpbuf[5]=='0')
             new_reset_sequence_flag=0;
-        else 
+        else
             new_reset_sequence_flag=1;
         return;
     }
     else if(strncmp(tmpbuf, "delay_flag", 10)==0){
-        delay_flag = tmpbuf[10]-'0';    
+        delay_flag = tmpbuf[10]-'0';
     }
     else if(tmpbuf[0]=='v'){
         hdmitx_print_info(hdmitx_device, 1);
-        return;    
+        return;
     }
     else if(tmpbuf[0]=='s'){
         serial_reg_val=simple_strtoul(tmpbuf+1,NULL,16);
@@ -3320,18 +3111,18 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
     else if(strncmp(tmpbuf,"i2s",2)==0){
         if(strncmp(tmpbuf+3,"off",3)==0)
             i2s_to_spdif_flag=1;
-        else   
+        else
             i2s_to_spdif_flag=0;
     }
     else if(strncmp(tmpbuf, "pattern_on", 10)==0){
         turn_on_shift_pattern();
         hdmi_print(INF, "Shift Pattern On\n");
-        return;        
+        return;
     }
     else if(strncmp(tmpbuf, "pattern_off", 11)==0){
         turn_off_shift_pattern();
         hdmi_print(INF, "Shift Pattern Off\n");
-        return;        
+        return;
     }
     else if(strncmp(tmpbuf, "prbs", 4)==0){
         int prbs_mode =simple_strtoul(tmpbuf+4, NULL, 10);
@@ -3349,7 +3140,7 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
         else if(buf[1]=='c'){
             aml_write_reg32(CBUS_REG_ADDR(adr), value);
             read_back = aml_read_reg32(CBUS_REG_ADDR(adr));
-            
+
         }
         else if(buf[1]=='p'){
             aml_write_reg32(APB_REG_ADDR(adr), value);
@@ -3363,7 +3154,7 @@ static void hdmitx_debug(hdmitx_dev_t* hdmitx_device, const char* buf)
         adr=simple_strtoul(tmpbuf+2, NULL, 16);
         if(buf[1]=='h'){
             value = hdmi_rd_reg(adr);
-            
+
         }
         else if(buf[1]=='c'){
             value = aml_read_reg32(CBUS_REG_ADDR(adr));
@@ -3410,13 +3201,13 @@ static void hdmitx_getediddata(hdmitx_dev_t* hdmitx_device, unsigned int blk_idx
         }
     }
 #endif
-}    
+}
 
 static int hdmitx_cntl_ddc(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned argv)
 {
     int i = 0;
     unsigned char *tmp_char = NULL;
-    
+
     if(!(cmd & CMD_DDC_OFFSET))
         hdmi_print(ERR, "ddc: " "w: invalid cmd 0x%x\n", cmd);
     else
@@ -3517,8 +3308,11 @@ static int hdmitx_cntl_config(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigne
             hdmi_set_reg_bits(TX_TMDS_MODE, 0x3, 6, 2);
         }
         if(argv == DVI_MODE) {
+            hdmi_phy_suspend();
             hdmi_set_reg_bits(TX_VIDEO_DTV_OPTION_L, 0x0, 6, 2);
             hdmi_set_reg_bits(TX_TMDS_MODE, 0x2, 6, 2);
+            msleep(300);
+            hdmi_phy_wakeup(hdmitx_device);
         }
         break;
     case CONF_SYSTEM_ST:
@@ -3597,6 +3391,24 @@ static int hdmitx_cntl_misc(hdmitx_dev_t* hdmitx_device, unsigned cmd, unsigned
     case MISC_VIID_IS_USING:
         return !!(aml_read_reg32(P_HHI_VID2_PLL_CNTL) & (1 << 30));     // bit30: enable
         break;
+    case MISC_COMP_HPLL:
+        if (argv == COMP_HPLL_SET_OPTIMISE_HPLL1)
+            printk("TODO %s[%d]\n", __func__, __LINE__);
+        if (argv == COMP_HPLL_SET_OPTIMISE_HPLL2)
+            printk("TODO %s[%d]\n", __func__, __LINE__);
+        break;
+    case MISC_COMP_AUDIO:
+        if (argv == COMP_AUDIO_SET_N_6144x2) {
+			if(hdmitx_device->cur_audio_param.type == CT_PCM){
+				if( (hdmitx_device->cur_VIC == HDMI_480p60) || (hdmitx_device->cur_VIC == HDMI_480p60_16x9) ||
+					(hdmitx_device->cur_VIC == HDMI_480i60) || (hdmitx_device->cur_VIC == HDMI_480i60_16x9) )
+					hdmi_wr_reg(TX_SYS1_ACR_N_1, 0x30);
+			}
+        }
+        if (argv == COMP_AUDIO_SET_N_6144x3) {
+            hdmi_wr_reg(TX_SYS1_ACR_N_1, 0x48);
+        }
+        break;
     default:
         hdmi_print(ERR, "misc: " "hdmitx: unknown cmd: 0x%x\n", cmd);
     }
@@ -3640,6 +3452,7 @@ void HDMITX_Meson_Init(hdmitx_dev_t* hdmitx_device)
     hdmitx_device->HWOp.SetAudioInfoFrame = hdmitx_setaudioinfoframe;
     hdmitx_device->HWOp.SetDispMode = hdmitx_set_dispmode;
     hdmitx_device->HWOp.SetAudMode = hdmitx_set_audmode;
+    hdmitx_device->HWOp.SetAudN = hdmitx_set_aud_n;
     hdmitx_device->HWOp.SetupIRQ = hdmitx_setupirq;
     hdmitx_device->HWOp.DebugFun = hdmitx_debug;
     hdmitx_device->HWOp.UnInit = hdmitx_uninit;
@@ -3661,9 +3474,9 @@ void HDMITX_Meson_Init(hdmitx_dev_t* hdmitx_device)
     //aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)|(1<<15)); //APB3 err_en
 //    hdmi_wr_reg(0x10, 0xff);
 
-    /**/    
+    /**/
     hdmi_hw_init(hdmitx_device);
-}    
+}
 
 void hdmi_set_audio_para(int para)
 {
@@ -3671,11 +3484,11 @@ void hdmi_set_audio_para(int para)
 
 }
 
-// The following two functions should move to 
+// The following two functions should move to
 // static struct platform_driver amhdmitx_driver.suspend & .wakeup
 // For tempelet use only.
 // Later will change it.
-typedef struct 
+typedef struct
 {
     unsigned long reg;
     unsigned long val_sleep;
@@ -3693,7 +3506,6 @@ static void hdmi_phy_suspend(void)
 
 static void hdmi_phy_wakeup(hdmitx_dev_t* hdmitx_device)
 {
-    if (aml_read_reg32(P_HHI_HDMI_PHY_CNTL0) == 0x08418d00)
-        hdmitx_set_phy(hdmitx_device);
+    hdmitx_set_phy(hdmitx_device);
     //hdmi_print(INF, SYS "phy wakeup\n");
 }
diff --git a/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_reg.c b/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_reg.c
old mode 100644
new mode 100755
index f66e2536..6b9fdd9f
--- a/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_reg.c
+++ b/arch/arm/mach-meson8b/hdmi_tx_hw/hdmi_tx_reg.c
@@ -1,139 +1,137 @@
-/*
- * Amlogic Meson HDMI Transmitter Driver
- * frame buffer driver-----------HDMI_TX
- * Copyright (C) 2010 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- */
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/kernel.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/mm.h>
-#include <linux/major.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/cdev.h>
-#include <asm/uaccess.h>
-#include <mach/am_regs.h>
-
-#include <mach/hdmi_tx_reg.h>
-
-#include "linux/amlogic/hdmi_tx/hdmi_tx_module.h"
-
-static DEFINE_SPINLOCK(reg_lock);
-static DEFINE_SPINLOCK(reg_lock2);
-// if the following bits are 0, then access HDMI IP Port will cause system hungup
-#define GATE_NUM    2
-Hdmi_Gate_s hdmi_gate[GATE_NUM] =   {   {HHI_HDMI_CLK_CNTL, 8},
-                                        {HHI_GCLK_MPEG2   , 4},
-                                    };
-
-// In order to prevent system hangup, add check_cts_hdmi_sys_clk_status() to check 
-static void check_cts_hdmi_sys_clk_status(void)
-{
-    int i;
-
-    for(i = 0; i < GATE_NUM; i++){
-        if(!(aml_read_reg32(CBUS_REG_ADDR(hdmi_gate[i].cbus_addr)) & (1<<hdmi_gate[i].gate_bit))){
-            aml_set_reg32_bits(CBUS_REG_ADDR(hdmi_gate[i].cbus_addr), 1, hdmi_gate[i].gate_bit, 1);
-        }
-    }
-}
-
-unsigned int hdmi_rd_reg(unsigned int addr)
-{
-    unsigned int data;
-
-    unsigned long flags, fiq_flag;
-
-    spin_lock_irqsave(&reg_lock, flags);
-    raw_local_save_flags(fiq_flag);
-    local_fiq_disable();
-
-    check_cts_hdmi_sys_clk_status();
-    aml_write_reg32(P_HDMI_ADDR_PORT, addr);
-    aml_write_reg32(P_HDMI_ADDR_PORT, addr);
-    data = aml_read_reg32(P_HDMI_DATA_PORT);
-
-    raw_local_irq_restore(fiq_flag);
-    spin_unlock_irqrestore(&reg_lock, flags);
-    return (data);
-}
-
-void hdmi_wr_reg(unsigned int addr, unsigned int data)
-{
-    unsigned long flags, fiq_flag;
-    spin_lock_irqsave(&reg_lock, flags);
-    raw_local_save_flags(fiq_flag);
-    local_fiq_disable();
-
-    check_cts_hdmi_sys_clk_status();
-    aml_write_reg32(P_HDMI_ADDR_PORT, addr);
-    aml_write_reg32(P_HDMI_ADDR_PORT, addr);
-    aml_write_reg32(P_HDMI_DATA_PORT, data);
-    raw_local_irq_restore(fiq_flag);
-    spin_unlock_irqrestore(&reg_lock, flags);
-}
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-#define waiting_aocec_free() \
-        do{\
-            unsigned long cnt = 0;\
-            while(aml_read_reg32(P_AO_CEC_RW_REG) & (1<<23))\
-            {\
-                if(5000 == cnt++)\
-                {\
-                    hdmi_print(INF, CEC "waiting aocec free time out.\n");\
-                    break;\
-                }\
-            }\
-        }while(0)
-        
-unsigned long aocec_rd_reg (unsigned long addr)
-{
-    unsigned long data32;
-    unsigned long flags;
-    waiting_aocec_free();
-    spin_lock_irqsave(&reg_lock2, flags);
-    data32  = 0;
-    data32 |= 0     << 16;  // [16]     cec_reg_wr
-    data32 |= 0     << 8;   // [15:8]   cec_reg_wrdata
-    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
-    aml_write_reg32(P_AO_CEC_RW_REG, data32);
-
-    waiting_aocec_free();
-    data32 = ((aml_read_reg32(P_AO_CEC_RW_REG)) >> 24) & 0xff;
-    spin_unlock_irqrestore(&reg_lock2, flags);
-    return (data32);
-} /* aocec_rd_reg */
-
-void aocec_wr_reg (unsigned long addr, unsigned long data)
-{
-    unsigned long data32;
-    unsigned long flags;
-    waiting_aocec_free();
-    spin_lock_irqsave(&reg_lock2, flags);
-    data32  = 0;
-    data32 |= 1     << 16;  // [16]     cec_reg_wr
-    data32 |= data  << 8;   // [15:8]   cec_reg_wrdata
-    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
-    aml_write_reg32(P_AO_CEC_RW_REG, data32);
-    spin_unlock_irqrestore(&reg_lock2, flags);
-    waiting_aocec_free();
-    //waiting_aocec_free();
-} /* aocec_wr_only_reg */
-#endif
+/*
+ * Amlogic Meson HDMI Transmitter Driver
+ * frame buffer driver-----------HDMI_TX
+ * Copyright (C) 2010 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/uaccess.h>
+#include <mach/am_regs.h>
+
+#include <mach/hdmi_tx_reg.h>
+
+#include "linux/amlogic/hdmi_tx/hdmi_tx_module.h"
+
+static DEFINE_SPINLOCK(reg_lock);
+static DEFINE_SPINLOCK(reg_lock2);
+// if the following bits are 0, then access HDMI IP Port will cause system hungup
+#define GATE_NUM    2
+Hdmi_Gate_s hdmi_gate[GATE_NUM] =   {   {HHI_HDMI_CLK_CNTL, 8},
+                                        {HHI_GCLK_MPEG2   , 4},
+                                    };
+
+// In order to prevent system hangup, add check_cts_hdmi_sys_clk_status() to check
+static void check_cts_hdmi_sys_clk_status(void)
+{
+    int i;
+
+    for(i = 0; i < GATE_NUM; i++){
+        if(!(aml_read_reg32(CBUS_REG_ADDR(hdmi_gate[i].cbus_addr)) & (1<<hdmi_gate[i].gate_bit))){
+            aml_set_reg32_bits(CBUS_REG_ADDR(hdmi_gate[i].cbus_addr), 1, hdmi_gate[i].gate_bit, 1);
+        }
+    }
+}
+
+unsigned int hdmi_rd_reg(unsigned int addr)
+{
+    unsigned int data;
+
+    unsigned long flags, fiq_flag;
+
+    spin_lock_irqsave(&reg_lock, flags);
+    raw_local_save_flags(fiq_flag);
+    local_fiq_disable();
+
+    check_cts_hdmi_sys_clk_status();
+    aml_write_reg32(P_HDMI_ADDR_PORT, addr);
+    aml_write_reg32(P_HDMI_ADDR_PORT, addr);
+    data = aml_read_reg32(P_HDMI_DATA_PORT);
+
+    raw_local_irq_restore(fiq_flag);
+    spin_unlock_irqrestore(&reg_lock, flags);
+    return (data);
+}
+
+void hdmi_wr_reg(unsigned int addr, unsigned int data)
+{
+    unsigned long flags, fiq_flag;
+    spin_lock_irqsave(&reg_lock, flags);
+    raw_local_save_flags(fiq_flag);
+    local_fiq_disable();
+
+    check_cts_hdmi_sys_clk_status();
+    aml_write_reg32(P_HDMI_ADDR_PORT, addr);
+    aml_write_reg32(P_HDMI_ADDR_PORT, addr);
+    aml_write_reg32(P_HDMI_DATA_PORT, data);
+    raw_local_irq_restore(fiq_flag);
+    spin_unlock_irqrestore(&reg_lock, flags);
+}
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#define waiting_aocec_free() \
+        do {\
+            unsigned long cnt = 0;\
+            while (aml_read_reg32(P_AO_CEC_RW_REG) & (1<<23))\
+            {\
+                if (3500 == cnt++)\
+                {\
+                    hdmi_print(INF, CEC "waiting aocec free time out.\n");\
+                    break;\
+                }\
+            }\
+        } while (0)
+
+unsigned long aocec_rd_reg (unsigned long addr)
+{
+    unsigned long data32;
+    unsigned long flags;
+    waiting_aocec_free();
+    spin_lock_irqsave(&reg_lock2, flags);
+    data32  = 0;
+    data32 |= 0     << 16;  // [16]     cec_reg_wr
+    data32 |= 0     << 8;   // [15:8]   cec_reg_wrdata
+    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
+    aml_write_reg32(P_AO_CEC_RW_REG, data32);
+
+    waiting_aocec_free();
+    data32 = ((aml_read_reg32(P_AO_CEC_RW_REG)) >> 24) & 0xff;
+    spin_unlock_irqrestore(&reg_lock2, flags);
+    return (data32);
+} /* aocec_rd_reg */
+
+void aocec_wr_reg (unsigned long addr, unsigned long data)
+{
+    unsigned long data32;
+    unsigned long flags;
+    waiting_aocec_free();
+    spin_lock_irqsave(&reg_lock2, flags);
+    data32  = 0;
+    data32 |= 1     << 16;  // [16]     cec_reg_wr
+    data32 |= data  << 8;   // [15:8]   cec_reg_wrdata
+    data32 |= addr  << 0;   // [7:0]    cec_reg_addr
+    aml_write_reg32(P_AO_CEC_RW_REG, data32);
+    spin_unlock_irqrestore(&reg_lock2, flags);
+} /* aocec_wr_only_reg */
+#endif
diff --git a/arch/arm/mach-meson8b/hdmi_tx_hw/tvenc_conf.h b/arch/arm/mach-meson8b/hdmi_tx_hw/tvenc_conf.h
index e8c8cb97..cd5c18b4 100644
--- a/arch/arm/mach-meson8b/hdmi_tx_hw/tvenc_conf.h
+++ b/arch/arm/mach-meson8b/hdmi_tx_hw/tvenc_conf.h
@@ -1,11 +1,3 @@
-typedef struct reg_s {
-    uint reg;
-    uint val;
-} reg_t;
-
-static reg_t hdmi_tvenc_regs_480x320p60[] = {
-	{ 0, 0 }
-};
 
 static  reg_t hdmi_tvenc_regs_480i[] = {
     /*1st col: recommmended, but eof/sof/vs_lines +/- 1 from spec; 2nd col: from simu */
@@ -73,9 +65,9 @@ static  reg_t hdmi_tvenc_regs_1080i[] = {
     {ENCP_DVI_VSO_BEGIN_ODD,             0x00000928},
     {ENCP_DVI_VSO_END_ODD,               0x00000928},
     {VENC_DVI_SETTING,                   0x000080ad},
-    {VENC_DVI_SETTING_MORE,              0x00000000}, 
+    {VENC_DVI_SETTING_MORE,              0x00000000},
     {0,0}
-};    
+};
 
 static  reg_t hdmi_tvenc_regs_1080i50[] = {
     {ENCP_VIDEO_MODE,                    0x00005ffc},
@@ -96,9 +88,9 @@ static  reg_t hdmi_tvenc_regs_1080i50[] = {
     {ENCP_DVI_VSO_BEGIN_ODD,             0x00000ae0},
     {ENCP_DVI_VSO_END_ODD,               0x00000ae0},
     {VENC_DVI_SETTING,                   0x000080ad},
-    {VENC_DVI_SETTING_MORE,              0x00000000}, 
+    {VENC_DVI_SETTING_MORE,              0x00000000},
     {0,0}
-};    
+};
 
 static  reg_t hdmi_tvenc_regs_480p[] = {
     {ENCP_VIDEO_MODE,                   /*0x4000 */ 0x00004000},
@@ -115,7 +107,7 @@ static  reg_t hdmi_tvenc_regs_480p[] = {
     {VENC_DVI_SETTING_MORE,             /*0x0    */ 0x00000000},
     {VENC_DVI_SETTING,                  /*0x80ad */ 0x000080ad},
     {0,0}
-};    
+};
 
 static  reg_t hdmi_tvenc_regs_576p[] = {
     {ENCP_VIDEO_MODE,                    0x00004000},
@@ -132,7 +124,7 @@ static  reg_t hdmi_tvenc_regs_576p[] = {
     {VENC_DVI_SETTING_MORE,              0x00000000},
     {VENC_DVI_SETTING,                   0x000080ad},
     {0,0}
-};    
+};
 
 static  reg_t hdmi_tvenc_regs_720p[] = {
     {ENCP_VIDEO_MODE,                    0x00004040},
@@ -149,7 +141,7 @@ static  reg_t hdmi_tvenc_regs_720p[] = {
     {VENC_DVI_SETTING_MORE,              0x00000000},
     {VENC_DVI_SETTING,                   0x000080ad},
     {0,0}
-};    
+};
 
 static  reg_t hdmi_tvenc_regs_1080p[] = {
     {ENCP_VIDEO_MODE,                    0x00004040},
@@ -166,7 +158,7 @@ static  reg_t hdmi_tvenc_regs_1080p[] = {
     {VENC_DVI_SETTING_MORE,              0x00000000},
     {VENC_DVI_SETTING,                   0x0000809d},
     {0,0}
-};    
+};
 
 static  reg_t hdmi_tvenc_regs_720p50[] = {
     {ENCP_VIDEO_MODE,                    0x00004040},
@@ -183,62 +175,8 @@ static  reg_t hdmi_tvenc_regs_720p50[] = {
     {VENC_DVI_SETTING_MORE,              0x00000000},
     {VENC_DVI_SETTING,                   0x000080ad},
     {0,0}
-};    
-
-static  reg_t hdmi_tvenc_regs_640x480p60[] = {
-    //{ENCP_VIDEO_MODE,                    0x00004040},
-    //{ENCP_DE_H_BEGIN,                    0x00000112},
-    //{ENCP_DE_H_END,                      0x00000612},
-    //{ENCP_DE_V_BEGIN_EVEN,               0x00000029},
-    //{ENCP_DE_V_END_EVEN,                 0x00000429},
-    //{ENCP_DVI_HSO_BEGIN,                 0x00000052},
-    //{ENCP_DVI_HSO_END,                   0x000000c2},
-    //{ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
-    //{ENCP_DVI_VSO_ELINE_EVN,             0x00000003},
-    //{ENCP_DVI_VSO_BEGIN_EVN,             0x00000052},
-    //{ENCP_DVI_VSO_END_EVN,               0x00000052},
-    //{VENC_DVI_SETTING_MORE,              0x00000000},
-    //{VENC_DVI_SETTING,                   0x0000809d},
-    {0,0}
-};   
- 
-static  reg_t hdmi_tvenc_regs_1280x1024x60[] = {
-    //{ENCP_VIDEO_MODE,                    0x00004040},
-    //{ENCP_DE_H_BEGIN,                    0x00000112},
-    //{ENCP_DE_H_END,                      0x00000612},
-    //{ENCP_DE_V_BEGIN_EVEN,               0x00000029},
-    //{ENCP_DE_V_END_EVEN,                 0x00000429},
-    //{ENCP_DVI_HSO_BEGIN,                 0x00000052},
-    //{ENCP_DVI_HSO_END,                   0x000000c2},
-    //{ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
-    //{ENCP_DVI_VSO_ELINE_EVN,             0x00000003},
-    //{ENCP_DVI_VSO_BEGIN_EVN,             0x00000052},
-    //{ENCP_DVI_VSO_END_EVN,               0x00000052},
-    //{VENC_DVI_SETTING_MORE,              0x00000000},
-    //{VENC_DVI_SETTING,                   0x0000809d},
-    {0,0}
-};  
-
-static reg_t hdmi_tvenc_regs_800p[] = {
-	{ 0, 0 }
 };
 
-static  reg_t hdmi_tvenc_regs_1920x1200[] = {//60hz
-    //{ENCP_VIDEO_MODE,                    0x00004040},
-    //{ENCP_DE_H_BEGIN,                    0x00000112},
-    //{ENCP_DE_H_END,                      0x00000612},
-    //{ENCP_DE_V_BEGIN_EVEN,               0x00000029},
-    //{ENCP_DE_V_END_EVEN,                 0x00000429},
-    //{ENCP_DVI_HSO_BEGIN,                 0x00000052},
-    //{ENCP_DVI_HSO_END,                   0x000000c2},
-    //{ENCP_DVI_VSO_BLINE_EVN,             0x00000000},
-    //{ENCP_DVI_VSO_ELINE_EVN,             0x00000003},
-    //{ENCP_DVI_VSO_BEGIN_EVN,             0x00000052},
-    //{ENCP_DVI_VSO_END_EVN,               0x00000052},
-    //{VENC_DVI_SETTING_MORE,              0x00000000},
-    //{VENC_DVI_SETTING,                   0x0000809d},
-    {0,0}
-};  
 static  reg_t hdmi_tvenc_regs_1080p50[] = {
     {ENCP_VIDEO_MODE,                    0x00004040},
     {ENCP_DE_H_BEGIN,                    0x00000112},
@@ -254,7 +192,7 @@ static  reg_t hdmi_tvenc_regs_1080p50[] = {
     {VENC_DVI_SETTING_MORE,              0x00000000},
     {VENC_DVI_SETTING,                   0x0000809d},
     {0,0}
-};    
+};
 
 typedef struct hdmi_tvenc_config_
 {
@@ -263,12 +201,10 @@ typedef struct hdmi_tvenc_config_
 }hdmi_tvenc_config_t;
 
 static const hdmi_tvenc_config_t hdmi_tvenc_configs[] = {
-    {HDMI_480x320p60hz,          hdmi_tvenc_regs_480x320p60},
-    {HDMI_640x480p60  ,          hdmi_tvenc_regs_640x480p60},
+    {HDMI_640x480p60  ,          NULL          },
     {HDMI_480p60,                hdmi_tvenc_regs_480p},
     {HDMI_480p60_16x9,           hdmi_tvenc_regs_480p},
     {HDMI_720p60,                hdmi_tvenc_regs_720p},
-    {HDMI_800p,					 hdmi_tvenc_regs_800p},
     {HDMI_1080i60,               hdmi_tvenc_regs_1080i},
     {HDMI_480i60,                hdmi_tvenc_regs_480i},
     {HDMI_480i60_16x9,           hdmi_tvenc_regs_480i},
@@ -278,8 +214,6 @@ static const hdmi_tvenc_config_t hdmi_tvenc_configs[] = {
     {HDMI_576p50,                hdmi_tvenc_regs_576p},
     {HDMI_576p50_16x9,           hdmi_tvenc_regs_576p},
     {HDMI_720p50,                hdmi_tvenc_regs_720p50},
-    {HDMI_1280x1024,             hdmi_tvenc_regs_1280x1024x60},
-    {HDMI_1920x1200,             hdmi_tvenc_regs_1920x1200},
     {HDMI_1080i50,               hdmi_tvenc_regs_1080i50},
     {HDMI_576i50,                hdmi_tvenc_regs_576i},
     {HDMI_576i50_16x9,           hdmi_tvenc_regs_576i},
@@ -289,5 +223,3 @@ static const hdmi_tvenc_config_t hdmi_tvenc_configs[] = {
     {HDMI_1080p30,               hdmi_tvenc_regs_1080p},
     {HDMI_Unkown,               NULL},
 };
-
-
