diff --git a/drivers/gpu/arm/mali/Kbuild b/drivers/gpu/arm/mali/Kbuild
old mode 100755
new mode 100644
index 96bed4b1..c3d4cc46
--- a/drivers/gpu/arm/mali/Kbuild
+++ b/drivers/gpu/arm/mali/Kbuild
@@ -1,33 +1,87 @@
 #
 # Copyright (C) 2010-2011 ARM Limited. All rights reserved.
-# 
+#
 # This program is free software and is provided to you under the terms of the GNU General Public License version 2
 # as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
-# 
+#
 # A copy of the licence is included with the program, and can also be obtained from Free Software
 # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 #
 
 # This file is called by the Linux build system.
+############## Kasin Added, for platform. ################
+TARGET_PLATFORM:=meson_m450
+ifeq ($(CONFIG_ARCH_MESON1),y)
+TARGET_PLATFORM:= meson_m400
+endif
+ifeq ($(CONFIG_ARCH_MESON3),y)
+TARGET_PLATFORM:= meson_m400
+endif
+ifeq ($(CONFIG_ARCH_MESON6),y)
+TARGET_PLATFORM:= meson_m400
+endif
+ifeq ($(CONFIG_ARCH_MESON6TV),y)
+TARGET_PLATFORM:= meson_m400
+endif
+##################### end Kasin Added. ###################
 
 # set up defaults if not defined by the user
-TARGET_PLATFORM := meson_m450
 TIMESTAMP ?= default
+ifeq ($(CONFIG_UMP), m)
+  USING_UMP ?= 1
+else
+  USING_UMP ?= 0
+endif
+
+ifneq ($(KBUILD_SRC),)
+	ifneq ($(wildcard $(KBUILD_SRC)/$(src)),)
+		TOP_KBUILD_SRC := $(KBUILD_SRC)/
+	endif
+endif
+
 OS_MEMORY_KERNEL_BUFFER_SIZE_IN_MB ?= 16
-USING_GPU_UTILIZATION ?= 1
+
+#USING_GPU_UTILIZATION ?= 0
+#PROFILING_SKIP_PP_JOBS ?= 0
+#PROFILING_SKIP_PP_AND_GP_JOBS ?= 0
+
+USING_GPU_UTILIZATION=1
+USING_DVFS=0
 PROFILING_SKIP_PP_JOBS ?= 0
 PROFILING_SKIP_PP_AND_GP_JOBS ?= 0
+############## Kasin Added, for platform. ################
+ifeq ($(CONFIG_MALI400_DEBUG),y)
+	BUILD ?= debug
+else
+	BUILD ?= release
+	ldflags-y += --strip-debug
+endif
+##################### end Kasin Added. ###################
+
+############## Kasin Added, useless now. ################
+ifeq ($(USING_UMP),1)
+	UMP_SYMVERS_FILE = ../ump/Module.symvers
+	KBUILD_EXTRA_SYMBOLS = $(srctree)/$(src)/$(UMP_SYMVERS_FILE)
+endif
+##################### end Kasin Added. ###################
+
 MALI_PP_SCHEDULER_FORCE_NO_JOB_OVERLAP ?= 0
 MALI_PP_SCHEDULER_KEEP_SUB_JOB_STARTS_ALIGNED ?= 0
 MALI_PP_SCHEDULER_FORCE_NO_JOB_OVERLAP_BETWEEN_APPS ?= 0
 MALI_UPPER_HALF_SCHEDULING ?= 1
+
+############## Kasin Added, useless now. ################
+# Get path to driver source from Linux build system
+DRIVER_DIR=$(src)
+##################### end Kasin Added. ###################
+
 MALI_ENABLE_CPU_CYCLES ?= 0
 
 # For customer releases the Linux Device Drivers will be provided as ARM proprietary and GPL releases:
 # The ARM proprietary product will only include the license/proprietary directory
 # The GPL product will only include the license/gpl directory
-ifeq ($(wildcard $(src)/linux/license/gpl/*),)
-    ccflags-y += -I$(src)/linux/license/proprietary
+ifeq ($(wildcard $(TOP_KBUILD_SRC)$(DRIVER_DIR)/linux/license/gpl/*),)
+    ccflags-y += -I$(TOP_KBUILD_SRC)$(DRIVER_DIR)/linux/license/proprietary
     ifeq ($(CONFIG_MALI400_PROFILING),y)
         $(error Profiling is incompatible with non-GPL license)
     endif
@@ -39,7 +93,7 @@ ifeq ($(wildcard $(src)/linux/license/gpl/*),)
     endif
     $(error Linux Device integration is incompatible with non-GPL license)
 else
-    ccflags-y += -I$(src)/linux/license/gpl
+    ccflags-y += -I$(TOP_KBUILD_SRC)$(DRIVER_DIR)/linux/license/gpl
 endif
 
 ifeq ($(USING_GPU_UTILIZATION), 1)
@@ -48,15 +102,6 @@ ifeq ($(USING_GPU_UTILIZATION), 1)
     endif
 endif
 
-ifeq ($(MALI_PLATFORM_FILES),)
-ifeq ($(CONFIG_ARCH_EXYNOS4),y)
-EXTRA_DEFINES += -DMALI_FAKE_PLATFORM_DEVICE=1
-export MALI_PLATFORM=exynos4
-export MALI_PLATFORM_FILES_BUILDIN = $(notdir $(wildcard $(src)/platform/$(MALI_PLATFORM)/*.c))
-export MALI_PLATFORM_FILES_ADD_PREFIX = $(addprefix platform/$(MALI_PLATFORM)/,$(MALI_PLATFORM_FILES_BUILDIN)) 
-endif
-endif
-
 mali-y += \
 	linux/mali_osk_atomics.o \
 	linux/mali_osk_irq.o \
@@ -70,21 +115,16 @@ mali-y += \
 	linux/mali_osk_mali.o \
 	linux/mali_osk_notification.o \
 	linux/mali_osk_time.o \
-	linux/mali_osk_timers.o \
-	linux/mali_osk_bitmap.o
+	linux/mali_osk_timers.o
 
 mali-y += linux/mali_memory.o linux/mali_memory_os_alloc.o
 mali-y += linux/mali_memory_external.o
 mali-y += linux/mali_memory_block_alloc.o
-mali-y += linux/mali_memory_swap_alloc.o
 
 mali-y += \
 	linux/mali_memory_manager.o \
 	linux/mali_memory_virtual.o \
-	linux/mali_memory_util.o \
-	linux/mali_memory_cow.o \
-	linux/mali_memory_defer_bind.o
-
+	linux/mali_memory_util.o
 mali-y += \
 	linux/mali_ukk_mem.o \
 	linux/mali_ukk_gp.o \
@@ -93,10 +133,6 @@ mali-y += \
 	linux/mali_ukk_soft_job.o \
 	linux/mali_ukk_timeline.o
 
-mali-$(CONFIG_MALI_DEVFREQ) += \
-	linux/mali_devfreq.o \
-	common/mali_pm_metrics.o
-
 # Source files which always are included in a build
 mali-y += \
 	common/mali_kernel_core.o \
@@ -135,28 +171,46 @@ mali-y += \
 	linux/mali_pmu_power_up_down.o \
 	__malidrv_build_info.o
 
+############## Kasin Added, for platform. ################
 mali-y += \
 	platform/meson_main.o \
 	platform/mali_pm_device.o \
 	platform/mali_clock.o \
 	platform/mpgpu.o \
-	platform/meson_m450/scaling.o \
+
+ifeq ($(TARGET_PLATFORM),meson_m400)
+MALI_PLATFORM_FILES:= \
+	platform/meson_m400/mali_fix.o \
+	platform/meson_m400/mali_platform.o \
+	platform/meson_m400/platform_mx.o
+endif
+
+ifeq ($(TARGET_PLATFORM),meson_m450)
+ccflags-y += -DCONFIG_MALI450=y
+mali-y += \
+	platform/meson_m450/scaling.o
+
+mali-$(CONFIG_ARCH_MESON8) += \
+	platform/meson_m450/platform_m8.o
+
+mali-$(CONFIG_ARCH_MESON6TVD) += \
+	platform/meson_m450/platform_m6tvd.o
+
+mali-$(CONFIG_ARCH_MESON8B) += \
 	platform/meson_m450/platform_m8b.o
 
-ccflags-$(CONFIG_SYNC) += -Idrivers/staging/android
+mali-$(CONFIG_ARCH_MESONG9TV) += \
+	platform/meson_m450/platform_m8.o
 
-ifneq ($(wildcard $(src)/linux/mali_slp_global_lock.c),)
-	mali-y += linux/mali_slp_global_lock.o
+mali-$(CONFIG_ARCH_MESONG9BB) += \
+	platform/meson_m450/platform_m8b.o
 endif
+##################### end Kasin Added. ###################
 
 ifneq ($(MALI_PLATFORM_FILES),)
 	mali-y += $(MALI_PLATFORM_FILES:.c=.o)
 endif
 
-ifneq ($(MALI_PLATFORM_FILES_ADD_PREFIX),)
-	mali-y += $(MALI_PLATFORM_FILES_ADD_PREFIX:.c=.o)
-endif
-
 mali-$(CONFIG_MALI400_PROFILING) += linux/mali_ukk_profiling.o
 mali-$(CONFIG_MALI400_PROFILING) += linux/mali_osk_profiling.o
 
@@ -164,9 +218,7 @@ mali-$(CONFIG_MALI400_INTERNAL_PROFILING) += linux/mali_profiling_internal.o tim
 ccflags-$(CONFIG_MALI400_INTERNAL_PROFILING) += -I$(src)/timestamp-$(TIMESTAMP)
 
 mali-$(CONFIG_DMA_SHARED_BUFFER) += linux/mali_memory_dma_buf.o
-mali-$(CONFIG_DMA_SHARED_BUFFER) += linux/mali_memory_secure.o
 mali-$(CONFIG_SYNC) += linux/mali_sync.o
-mali-$(CONFIG_MALI_DMA_BUF_FENCE) += linux/mali_dma_fence.o
 ccflags-$(CONFIG_SYNC) += -Idrivers/staging/android
 
 mali-$(CONFIG_MALI400_UMP) += linux/mali_memory_ump.o
@@ -186,26 +238,22 @@ ccflags-y += -DMALI_STATE_TRACKING=1
 ccflags-y += -DMALI_OS_MEMORY_KERNEL_BUFFER_SIZE_IN_MB=$(OS_MEMORY_KERNEL_BUFFER_SIZE_IN_MB)
 ccflags-y += -DUSING_GPU_UTILIZATION=$(USING_GPU_UTILIZATION)
 ccflags-y += -DMALI_ENABLE_CPU_CYCLES=$(MALI_ENABLE_CPU_CYCLES)
+ccflags-y += -DMALI_FAKE_PLATFORM_DEVICE
 
 ifeq ($(MALI_UPPER_HALF_SCHEDULING),1)
 	ccflags-y += -DMALI_UPPER_HALF_SCHEDULING
 endif
 
-#build-in include path is different
-ifeq ($(MALI_PLATFORM_FILES),)
-ccflags-$(CONFIG_MALI400_UMP) += -I$(src)/../ump/include/
-else
-ccflags-$(CONFIG_MALI400_UMP) += -I$(src)/../../ump/include/ump
-endif
+ccflags-$(CONFIG_MALI400_UMP) += -I$(src)/../ump/include/ump
 ccflags-$(CONFIG_MALI400_DEBUG) += -DDEBUG
 
 # Use our defines when compiling
-ccflags-y += -I$(src) -I$(src)/include -I$(src)/common -I$(src)/linux -I$(src)/platform -Wno-date-time
+ccflags-y += -I$(src) -I$(src)/include -I$(src)/common -I$(src)/linux -I$(src)/platform
 
 # Get subversion revision number, fall back to only ${MALI_RELEASE_NAME} if no svn info is available
-MALI_RELEASE_NAME=$(shell cat $(src)/.version 2> /dev/null)
+MALI_RELEASE_NAME=$(shell cat $(TOP_KBUILD_SRC)$(DRIVER_DIR)/.version 2> /dev/null)
 
-SVN_INFO = (cd $(src); svn info 2>/dev/null)
+SVN_INFO = (cd $(TOP_KBUILD_SRC)$(DRIVER_DIR); svn info 2>/dev/null)
 
 ifneq ($(shell $(SVN_INFO) 2>/dev/null),)
 # SVN detected
@@ -216,13 +264,13 @@ CHANGED_REVISION := $(shell $(SVN_INFO) | grep '^Last Changed Rev: ' | cut -d: -
 REPO_URL := $(shell $(SVN_INFO) | grep '^URL: ' | cut -d: -f2- | cut -b2-)
 
 else # SVN
-GIT_REV := $(shell cd $(src); git describe --always 2>/dev/null)
+GIT_REV := $(shell cd $(TOP_KBUILD_SRC)$(DRIVER_DIR); git describe --always 2>/dev/null)
 ifneq ($(GIT_REV),)
 # Git detected
 DRIVER_REV := $(MALI_RELEASE_NAME)-$(GIT_REV)
-CHANGE_DATE := $(shell cd $(src); git log -1 --format="%ci")
+CHANGE_DATE := $(shell cd $(TOP_KBUILD_SRC)$(DRIVER_DIR); git log -1 --format="%ci")
 CHANGED_REVISION := $(GIT_REV)
-REPO_URL := $(shell cd $(src); git describe --all --always 2>/dev/null)
+REPO_URL := $(shell cd $(TOP_KBUILD_SRC)$(DRIVER_DIR); git describe --all --always 2>/dev/null)
 
 else # Git
 # No Git or SVN detected
@@ -235,7 +283,7 @@ endif
 ccflags-y += -DSVN_REV_STRING=\"$(DRIVER_REV)\"
 
 VERSION_STRINGS :=
-VERSION_STRINGS += API_VERSION=$(shell cd $(src); grep "\#define _MALI_API_VERSION" $(FILES_PREFIX)include/linux/mali/mali_utgard_uk_types.h | cut -d' ' -f 3 )
+VERSION_STRINGS += API_VERSION=$(shell cd $(TOP_KBUILD_SRC)$(DRIVER_DIR);  grep "\#define _MALI_API_VERSION" $(FILES_PREFIX)include/linux/mali/mali_utgard_uk_types.h | cut -d' ' -f 3 )
 VERSION_STRINGS += REPO_URL=$(REPO_URL)
 VERSION_STRINGS += REVISION=$(DRIVER_REV)
 VERSION_STRINGS += CHANGED_REVISION=$(CHANGED_REVISION)
@@ -255,9 +303,8 @@ VERSION_STRINGS += USING_PROFILING=$(CONFIG_MALI400_PROFILING)
 VERSION_STRINGS += USING_INTERNAL_PROFILING=$(CONFIG_MALI400_INTERNAL_PROFILING)
 VERSION_STRINGS += USING_GPU_UTILIZATION=$(USING_GPU_UTILIZATION)
 VERSION_STRINGS += USING_DVFS=$(CONFIG_MALI_DVFS)
-VERSION_STRINGS += USING_DMA_BUF_FENCE = $(CONFIG_MALI_DMA_BUF_FENCE)
 VERSION_STRINGS += MALI_UPPER_HALF_SCHEDULING=$(MALI_UPPER_HALF_SCHEDULING)
 
 # Create file with Mali driver configuration
-$(src)/__malidrv_build_info.c:
-	@echo 'const char *__malidrv_build_info(void) { return "malidrv: $(VERSION_STRINGS)";}' > $(src)/__malidrv_build_info.c
+$(TOP_KBUILD_SRC)$(DRIVER_DIR)/__malidrv_build_info.c:
+	@echo 'const char *__malidrv_build_info(void) { return "malidrv: $(VERSION_STRINGS)";}' > $(TOP_KBUILD_SRC)$(DRIVER_DIR)/__malidrv_build_info.c
diff --git a/drivers/gpu/arm/mali/Kconfig b/drivers/gpu/arm/mali/Kconfig
old mode 100755
new mode 100644
index 7b4e9fb2..09687d5b
--- a/drivers/gpu/arm/mali/Kconfig
+++ b/drivers/gpu/arm/mali/Kconfig
@@ -1,6 +1,8 @@
+menu "Mali GPU OpenGL device driver"
 config MALI400
 	tristate "Mali-300/400/450 support"
 	depends on ARM || ARM64
+	default m
 	select DMA_SHARED_BUFFER
 	---help---
 	  This enables support for the ARM Mali-300, Mali-400, and Mali-450
@@ -9,29 +11,31 @@ config MALI400
 	  To compile this driver as a module, choose M here: the module will be
 	  called mali.
 
-config MALI450
-	bool "Enable Mali-450 support"
-	depends on MALI400
-	---help---
-	  This enables support for Mali-450 specific features.
-
-config MALI470
-	bool "Enable Mali-470 support"
-	depends on MALI400
-	---help---
-	  This enables support for Mali-470 specific features.
-
 config MALI400_DEBUG
 	bool "Enable debug in Mali driver"
 	depends on MALI400
+	default n
 	---help---
 	  This enabled extra debug checks and messages in the Mali driver.
 
+config MALI400_PROFILING_EXTRA_SUPPORT
+	bool "Select other items in kernel to support PROFILING."
+	depends on MALI400_PROFILING
+	select PROFILING
+	select FTRACE
+	select PERF_EVENTS
+	select ENABLE_DEFAULT_TRACERS
+	select DEBUG_MUTEXES
+	select HIGH_RES_TIMERS
+	select HW_PERF_EVENTS
+	select CPU_FREQ
+	select MALI400_DEBUG
+
 config MALI400_PROFILING
 	bool "Enable Mali profiling"
 	depends on MALI400
 	select TRACEPOINTS
-	default y
+	default n
 	---help---
 	  This enables gator profiling of Mali GPU events.
 
@@ -50,8 +54,8 @@ config MALI400_UMP
 
 config MALI_DVFS
 	bool "Enable Mali dynamically frequency change"
-	depends on MALI400 && !MALI_DEVFREQ
-	default y
+	depends on MALI400
+	default n
 	---help---
 	  This enables support for dynamic change frequency of Mali with the goal of lowering power consumption.
 
@@ -76,6 +80,14 @@ config MALI_SHARED_INTERRUPTS
 	  works when the GPU is not using shared interrupts, but might have a slight performance
 	  impact.
 
+if ARCH_MESON6
+config	MESON6_GPU_EXTRA
+	bool "M6 fix"
+	depends on MALI400
+	default y
+	select MALI_SHARED_INTERRUPTS
+endif
+
 config MALI_PMU_PARALLEL_POWER_UP
 	bool "Power up Mali PMU domains in parallel"
 	depends on MALI400
@@ -96,17 +108,6 @@ config MALI_DT
 	  device tree is enabled in kernel and corresponding hardware description is implemented
 	  properly in device DTS file.
 
-config MALI_DEVFREQ
-	bool "Using devfreq to tuning frequency"
-	depends on MALI400 && PM_DEVFREQ
-	default n
-	---help---
-	Support devfreq for Mali.
-
-	Using the devfreq framework and, by default, the simpleondemand
-	governor, the frequency of Mali will be dynamically selected from the
-	available OPPs.
-
 config MALI_QUIET
 	bool "Make Mali driver very quiet"
 	depends on MALI400 && !MALI400_DEBUG
@@ -115,3 +116,4 @@ config MALI_QUIET
 	  This forces the Mali driver to never print any messages.
 
 	  If unsure, say N.
+endmenu
diff --git a/drivers/gpu/arm/mali/Makefile b/drivers/gpu/arm/mali/Makefile
old mode 100755
new mode 100644
index f39ae4da..1edabc97
--- a/drivers/gpu/arm/mali/Makefile
+++ b/drivers/gpu/arm/mali/Makefile
@@ -1,9 +1,9 @@
 #
-# Copyright (C) 2010-2016 ARM Limited. All rights reserved.
-# 
+# Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+#
 # This program is free software and is provided to you under the terms of the GNU General Public License version 2
 # as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
-# 
+#
 # A copy of the licence is included with the program, and can also be obtained from Free Software
 # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 #
@@ -12,13 +12,10 @@ USE_UMPV2=0
 USING_PROFILING ?= 1
 USING_INTERNAL_PROFILING ?= 0
 USING_DVFS ?= 1
-USING_DMA_BUF_FENCE ?= 0
 MALI_HEATMAPS_ENABLED ?= 0
 MALI_DMA_BUF_MAP_ON_ATTACH ?= 1
 MALI_PMU_PARALLEL_POWER_UP ?= 0
 USING_DT ?= 0
-MALI_MEM_SWAP_TRACKING ?= 0
-USING_DEVFREQ ?= 0
 
 # The Makefile sets up "arch" based on the CONFIG, creates the version info
 # string and the __malidrv_build_info.c file, and then call the Linux build
@@ -105,11 +102,9 @@ endif
 # Set up build config
 export CONFIG_MALI400=m
 export CONFIG_MALI450=y
-export CONFIG_MALI470=y
 
 export EXTRA_DEFINES += -DCONFIG_MALI400=1
 export EXTRA_DEFINES += -DCONFIG_MALI450=1
-export EXTRA_DEFINES += -DCONFIG_MALI470=1
 
 ifneq ($(MALI_PLATFORM),)
 export EXTRA_DEFINES += -DMALI_FAKE_PLATFORM_DEVICE=1
@@ -148,11 +143,6 @@ export CONFIG_MALI_DVFS=y
 export EXTRA_DEFINES += -DCONFIG_MALI_DVFS
 endif
 
-ifeq ($(USING_DMA_BUF_FENCE),1)
-export CONFIG_MALI_DMA_BUF_FENCE=y
-export EXTRA_DEFINES += -DCONFIG_MALI_DMA_BUF_FENCE
-endif
-
 ifeq ($(MALI_PMU_PARALLEL_POWER_UP),1)
 export CONFIG_MALI_PMU_PARALLEL_POWER_UP=y
 export EXTRA_DEFINES += -DCONFIG_MALI_PMU_PARALLEL_POWER_UP
@@ -165,15 +155,6 @@ export EXTRA_DEFINES += -DCONFIG_MALI_DT
 endif
 endif
 
-ifeq ($(USING_DEVFREQ), 1)
-ifdef CONFIG_PM_DEVFREQ
-export CONFIG_MALI_DEVFREQ=y
-export EXTRA_DEFINES += -DCONFIG_MALI_DEVFREQ=1
-else
-$(warning "You want to support DEVFREQ but kernel didn't support DEVFREQ.")
-endif
-endif
-
 ifneq ($(BUILD),release)
 # Debug
 export CONFIG_MALI400_DEBUG=y
@@ -189,10 +170,6 @@ ifeq ($(MALI_SKIP_JOBS),1)
 EXTRA_DEFINES += -DPROFILING_SKIP_PP_JOBS=1 -DPROFILING_SKIP_GP_JOBS=1
 endif
 
-ifeq ($(MALI_MEM_SWAP_TRACKING),1)
-EXTRA_DEFINES += -DMALI_MEM_SWAP_TRACKING=1
-endif
-
 all: $(UMP_SYMVERS_FILE)
 	$(MAKE) ARCH=$(ARCH) -C $(KDIR) M=$(CURDIR) modules
 	@rm $(FILES_PREFIX)__malidrv_build_info.c $(FILES_PREFIX)__malidrv_build_info.o
diff --git a/drivers/gpu/arm/mali/common/mali_broadcast.c b/drivers/gpu/arm/mali/common/mali_broadcast.c
old mode 100755
new mode 100644
index 4c4b2bc9..b559512f
--- a/drivers/gpu/arm/mali/common/mali_broadcast.c
+++ b/drivers/gpu/arm/mali/common/mali_broadcast.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_broadcast.h b/drivers/gpu/arm/mali/common/mali_broadcast.h
old mode 100755
new mode 100644
index e12e8a2b..24c3c6f3
--- a/drivers/gpu/arm/mali/common/mali_broadcast.h
+++ b/drivers/gpu/arm/mali/common/mali_broadcast.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_control_timer.c b/drivers/gpu/arm/mali/common/mali_control_timer.c
old mode 100755
new mode 100644
index fc6ceb43..9e69bded
--- a/drivers/gpu/arm/mali/common/mali_control_timer.c
+++ b/drivers/gpu/arm/mali/common/mali_control_timer.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2012, 2014-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2012, 2014-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_control_timer.h b/drivers/gpu/arm/mali/common/mali_control_timer.h
old mode 100755
new mode 100644
index 12653903..d9b16346
--- a/drivers/gpu/arm/mali/common/mali_control_timer.h
+++ b/drivers/gpu/arm/mali/common/mali_control_timer.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2012, 2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2012, 2014-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_dlbu.c b/drivers/gpu/arm/mali/common/mali_dlbu.c
old mode 100755
new mode 100644
index 4f2a121f..8c2e1500
--- a/drivers/gpu/arm/mali/common/mali_dlbu.c
+++ b/drivers/gpu/arm/mali/common/mali_dlbu.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_dlbu.h b/drivers/gpu/arm/mali/common/mali_dlbu.h
old mode 100755
new mode 100644
index c031f115..59df4cd4
--- a/drivers/gpu/arm/mali/common/mali_dlbu.h
+++ b/drivers/gpu/arm/mali/common/mali_dlbu.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_dma.c b/drivers/gpu/arm/mali/common/mali_dma.c
deleted file mode 100644
index a5296264..00000000
--- a/drivers/gpu/arm/mali/common/mali_dma.c
+++ /dev/null
@@ -1,201 +0,0 @@
-/*
- * Copyright (C) 2012-2013 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#include "mali_kernel_common.h"
-#include "mali_osk.h"
-#include "mali_hw_core.h"
-#include "mali_dma.h"
-
-/**
- * Size of the Mali-450 DMA unit registers in bytes.
- */
-#define MALI450_DMA_REG_SIZE 0x08
-
-/**
- * Value that appears in MEMSIZE if an error occurs when reading the command list.
- */
-#define MALI450_DMA_BUS_ERR_VAL 0xffffffff
-
-/**
- * Mali DMA registers
- * Used in the register read/write routines.
- * See the hardware documentation for more information about each register.
- */
-typedef enum mali_dma_register {
-
-	MALI450_DMA_REG_SOURCE_ADDRESS = 0x0000,
-	MALI450_DMA_REG_SOURCE_SIZE = 0x0004,
-} mali_dma_register;
-
-struct mali_dma_core {
-	struct mali_hw_core  hw_core;      /**< Common for all HW cores */
-	_mali_osk_spinlock_t *lock;            /**< Lock protecting access to DMA core */
-	mali_dma_pool pool;                /**< Memory pool for command buffers */
-};
-
-static struct mali_dma_core *mali_global_dma_core = NULL;
-
-struct mali_dma_core *mali_dma_create(_mali_osk_resource_t *resource)
-{
-	struct mali_dma_core* dma;
-	_mali_osk_errcode_t err;
-
-	MALI_DEBUG_ASSERT(NULL == mali_global_dma_core);
-
-	dma = _mali_osk_malloc(sizeof(struct mali_dma_core));
-	if (dma == NULL) goto alloc_failed;
-
-	dma->lock = _mali_osk_spinlock_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_DMA_COMMAND);
-	if (NULL == dma->lock) goto lock_init_failed;
-
-	dma->pool = mali_dma_pool_create(MALI_DMA_CMD_BUF_SIZE, 4, 0);
-	if (NULL == dma->pool) goto dma_pool_failed;
-
-	err = mali_hw_core_create(&dma->hw_core, resource, MALI450_DMA_REG_SIZE);
-	if (_MALI_OSK_ERR_OK != err) goto hw_core_failed;
-
-	mali_global_dma_core = dma;
-	MALI_DEBUG_PRINT(2, ("Mali DMA: Created Mali APB DMA unit\n"));
-	return dma;
-
-	/* Error handling */
-
-hw_core_failed:
-	mali_dma_pool_destroy(dma->pool);
-dma_pool_failed:
-	_mali_osk_spinlock_term(dma->lock);
-lock_init_failed:
-	_mali_osk_free(dma);
-alloc_failed:
-	MALI_DEBUG_PRINT(2, ("Mali DMA: Failed to create APB DMA unit\n"));
-	return NULL;
-}
-
-void mali_dma_delete(struct mali_dma_core *dma)
-{
-	MALI_DEBUG_ASSERT_POINTER(dma);
-
-	MALI_DEBUG_PRINT(2, ("Mali DMA: Deleted Mali APB DMA unit\n"));
-
-	mali_hw_core_delete(&dma->hw_core);
-	_mali_osk_spinlock_term(dma->lock);
-	mali_dma_pool_destroy(dma->pool);
-	_mali_osk_free(dma);
-}
-
-static void mali_dma_bus_error(struct mali_dma_core *dma)
-{
-	u32 addr = mali_hw_core_register_read(&dma->hw_core, MALI450_DMA_REG_SOURCE_ADDRESS);
-
-	MALI_PRINT_ERROR(("Mali DMA: Bus error when reading command list from 0x%lx\n", addr));
-
-	/* Clear the bus error */
-	mali_hw_core_register_write(&dma->hw_core, MALI450_DMA_REG_SOURCE_SIZE, 0);
-}
-
-static mali_bool mali_dma_is_busy(struct mali_dma_core *dma)
-{
-	u32 val;
-	mali_bool dma_busy_flag = MALI_FALSE;
-
-	MALI_DEBUG_ASSERT_POINTER(dma);
-
-	val = mali_hw_core_register_read(&dma->hw_core, MALI450_DMA_REG_SOURCE_SIZE);
-
-	if (MALI450_DMA_BUS_ERR_VAL == val) {
-		/* Bus error reading command list */
-		mali_dma_bus_error(dma);
-		return MALI_FALSE;
-	}
-	if (val > 0) {
-		dma_busy_flag = MALI_TRUE;
-	}
-
-	return dma_busy_flag;
-}
-
-static void mali_dma_start_transfer(struct mali_dma_core* dma, mali_dma_cmd_buf *buf)
-{
-	u32 memsize = buf->size * 4;
-	u32 addr = buf->phys_addr;
-
-	MALI_DEBUG_ASSERT_POINTER(dma);
-	MALI_DEBUG_ASSERT(memsize < (1 << 16));
-	MALI_DEBUG_ASSERT(0 == (memsize & 0x3)); /* 4 byte aligned */
-
-	MALI_DEBUG_ASSERT(!mali_dma_is_busy(dma));
-
-	/* Writes the physical source memory address of chunk containing command headers and data */
-	mali_hw_core_register_write(&dma->hw_core, MALI450_DMA_REG_SOURCE_ADDRESS, addr);
-
-	/* Writes the length of transfer */
-	mali_hw_core_register_write(&dma->hw_core, MALI450_DMA_REG_SOURCE_SIZE, memsize);
-}
-
-_mali_osk_errcode_t mali_dma_get_cmd_buf(mali_dma_cmd_buf *buf)
-{
-	MALI_DEBUG_ASSERT_POINTER(buf);
-
-	buf->virt_addr = (u32*)mali_dma_pool_alloc(mali_global_dma_core->pool, &buf->phys_addr);
-	if (NULL == buf->virt_addr) {
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	/* size contains the number of words in the buffer and is incremented
-	 * as commands are added to the buffer. */
-	buf->size = 0;
-
-	return _MALI_OSK_ERR_OK;
-}
-
-void mali_dma_put_cmd_buf(mali_dma_cmd_buf *buf)
-{
-	MALI_DEBUG_ASSERT_POINTER(buf);
-
-	if (NULL == buf->virt_addr) return;
-
-	mali_dma_pool_free(mali_global_dma_core->pool, buf->virt_addr, buf->phys_addr);
-
-	buf->virt_addr = NULL;
-}
-
-_mali_osk_errcode_t mali_dma_start(struct mali_dma_core* dma, mali_dma_cmd_buf *buf)
-{
-	_mali_osk_errcode_t err = _MALI_OSK_ERR_OK;
-
-	_mali_osk_spinlock_lock(dma->lock);
-
-	if (mali_dma_is_busy(dma)) {
-		err = _MALI_OSK_ERR_BUSY;
-		goto out;
-	}
-
-	mali_dma_start_transfer(dma, buf);
-
-out:
-	_mali_osk_spinlock_unlock(dma->lock);
-	return err;
-}
-
-void mali_dma_debug(struct mali_dma_core *dma)
-{
-	MALI_DEBUG_ASSERT_POINTER(dma);
-	MALI_DEBUG_PRINT(1, ("DMA unit registers:\n\t%08x, %08x\n",
-	                     mali_hw_core_register_read(&dma->hw_core, MALI450_DMA_REG_SOURCE_ADDRESS),
-	                     mali_hw_core_register_read(&dma->hw_core, MALI450_DMA_REG_SOURCE_SIZE)
-	                    ));
-
-}
-
-struct mali_dma_core *mali_dma_get_global_dma_core(void)
-{
-	/* Returns the global dma core object */
-	return mali_global_dma_core;
-}
diff --git a/drivers/gpu/arm/mali/common/mali_dma.h b/drivers/gpu/arm/mali/common/mali_dma.h
deleted file mode 100644
index 93b9ca00..00000000
--- a/drivers/gpu/arm/mali/common/mali_dma.h
+++ /dev/null
@@ -1,190 +0,0 @@
-/*
- * Copyright (C) 2012-2013 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#ifndef __MALI_DMA_H__
-#define __MALI_DMA_H__
-
-#include "mali_osk.h"
-#include "mali_osk_mali.h"
-#include "mali_hw_core.h"
-
-#define MALI_DMA_CMD_BUF_SIZE 1024
-
-typedef struct mali_dma_cmd_buf {
-	u32 *virt_addr;           /**< CPU address of command buffer */
-	u32 phys_addr;            /**< Physical address of command buffer */
-	u32 size;                 /**< Number of prepared words in command buffer */
-} mali_dma_cmd_buf;
-
-/** @brief Create a new DMA unit
- *
- * This is called from entry point of the driver in order to create and
- * intialize the DMA resource
- *
- * @param resource it will be a pointer to a DMA resource
- * @return DMA object on success, NULL on failure
- */
-struct mali_dma_core *mali_dma_create(_mali_osk_resource_t *resource);
-
-/** @brief Delete DMA unit
- *
- * This is called on entry point of driver if the driver initialization fails
- * after initialization of the DMA unit. It is also called on the exit of the
- * driver to delete the DMA resource
- *
- * @param dma Pointer to DMA unit object
- */
-void mali_dma_delete(struct mali_dma_core *dma);
-
-/** @brief Retrieves the MALI DMA core object (if there is)
- *
- * @return The Mali DMA object otherwise NULL
- */
-struct mali_dma_core *mali_dma_get_global_dma_core(void);
-
-/**
- * @brief Run a command buffer on the DMA unit
- *
- * @param dma Pointer to the DMA unit to use
- * @param buf Pointer to the command buffer to use
- * @return _MALI_OSK_ERR_OK if the buffer was started successfully,
- *         _MALI_OSK_ERR_BUSY if the DMA unit is busy.
- */
-_mali_osk_errcode_t mali_dma_start(struct mali_dma_core* dma, mali_dma_cmd_buf *buf);
-
-/**
- * @brief Create a DMA command
- *
- * @param core Mali core
- * @param reg offset to register of core
- * @param n number of registers to write
- */
-MALI_STATIC_INLINE u32 mali_dma_command_write(struct mali_hw_core *core, u32 reg, u32 n)
-{
-	u32 core_offset = core->phys_offset;
-
-	MALI_DEBUG_ASSERT(reg < 0x2000);
-	MALI_DEBUG_ASSERT(n < 0x800);
-	MALI_DEBUG_ASSERT(core_offset < 0x30000);
-	MALI_DEBUG_ASSERT(0 == ((core_offset + reg) & ~0x7FFFF));
-
-	return (n << 20) | (core_offset + reg);
-}
-
-/**
- * @brief Add a array write to DMA command buffer
- *
- * @param buf DMA command buffer to fill in
- * @param core Core to do DMA to
- * @param reg Register on core to start writing to
- * @param data Pointer to data to write
- * @param count Number of 4 byte words to write
- */
-MALI_STATIC_INLINE void mali_dma_write_array(mali_dma_cmd_buf *buf, struct mali_hw_core *core,
-        u32 reg, u32 *data, u32 count)
-{
-	MALI_DEBUG_ASSERT((buf->size + 1 + count ) < MALI_DMA_CMD_BUF_SIZE / 4);
-
-	buf->virt_addr[buf->size++] = mali_dma_command_write(core, reg, count);
-
-	_mali_osk_memcpy(buf->virt_addr + buf->size, data, count * sizeof(*buf->virt_addr));
-
-	buf->size += count;
-}
-
-/**
- * @brief Add a conditional array write to DMA command buffer
- *
- * @param buf DMA command buffer to fill in
- * @param core Core to do DMA to
- * @param reg Register on core to start writing to
- * @param data Pointer to data to write
- * @param count Number of 4 byte words to write
- * @param ref Pointer to referance data that can be skipped if equal
- */
-MALI_STATIC_INLINE void mali_dma_write_array_conditional(mali_dma_cmd_buf *buf, struct mali_hw_core *core,
-        u32 reg, u32 *data, u32 count, const u32 *ref)
-{
-	/* Do conditional array writes are not yet implemented, fallback to a
-	 * normal array write. */
-	mali_dma_write_array(buf, core, reg, data, count);
-}
-
-/**
- * @brief Add a conditional register write to the DMA command buffer
- *
- * If the data matches the reference the command will be skipped.
- *
- * @param buf DMA command buffer to fill in
- * @param core Core to do DMA to
- * @param reg Register on core to start writing to
- * @param data Pointer to data to write
- * @param ref Pointer to referance data that can be skipped if equal
- */
-MALI_STATIC_INLINE void mali_dma_write_conditional(mali_dma_cmd_buf *buf, struct mali_hw_core *core,
-        u32 reg, u32 data, const u32 ref)
-{
-	/* Skip write if reference value is equal to data. */
-	if (data == ref) return;
-
-	buf->virt_addr[buf->size++] = mali_dma_command_write(core, reg, 1);
-
-	buf->virt_addr[buf->size++] = data;
-
-	MALI_DEBUG_ASSERT(buf->size < MALI_DMA_CMD_BUF_SIZE / 4);
-}
-
-/**
- * @brief Add a register write to the DMA command buffer
- *
- * @param buf DMA command buffer to fill in
- * @param core Core to do DMA to
- * @param reg Register on core to start writing to
- * @param data Pointer to data to write
- */
-MALI_STATIC_INLINE void mali_dma_write(mali_dma_cmd_buf *buf, struct mali_hw_core *core,
-                                       u32 reg, u32 data)
-{
-	buf->virt_addr[buf->size++] = mali_dma_command_write(core, reg, 1);
-
-	buf->virt_addr[buf->size++] = data;
-
-	MALI_DEBUG_ASSERT(buf->size < MALI_DMA_CMD_BUF_SIZE / 4);
-}
-
-/**
- * @brief Prepare DMA command buffer for use
- *
- * This function allocates the DMA buffer itself.
- *
- * @param buf The mali_dma_cmd_buf to prepare
- * @return _MALI_OSK_ERR_OK if the \a buf is ready to use
- */
-_mali_osk_errcode_t mali_dma_get_cmd_buf(mali_dma_cmd_buf *buf);
-
-/**
- * @brief Check if a DMA command buffer is ready for use
- *
- * @param buf The mali_dma_cmd_buf to check
- * @return MALI_TRUE if buffer is usable, MALI_FALSE otherwise
- */
-MALI_STATIC_INLINE mali_bool mali_dma_cmd_buf_is_valid(mali_dma_cmd_buf *buf)
-{
-	return NULL != buf->virt_addr;
-}
-
-/**
- * @brief Return a DMA command buffer
- *
- * @param buf Pointer to DMA command buffer to return
- */
-void mali_dma_put_cmd_buf(mali_dma_cmd_buf *buf);
-
-#endif /* __MALI_DMA_H__ */
diff --git a/drivers/gpu/arm/mali/common/mali_dvfs_policy.c b/drivers/gpu/arm/mali/common/mali_dvfs_policy.c
old mode 100755
new mode 100644
index 1094f9df..ec7c760f
--- a/drivers/gpu/arm/mali/common/mali_dvfs_policy.c
+++ b/drivers/gpu/arm/mali/common/mali_dvfs_policy.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2012, 2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2012, 2014-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_dvfs_policy.h b/drivers/gpu/arm/mali/common/mali_dvfs_policy.h
old mode 100755
new mode 100644
index 17704269..ac12c236
--- a/drivers/gpu/arm/mali/common/mali_dvfs_policy.h
+++ b/drivers/gpu/arm/mali/common/mali_dvfs_policy.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2012, 2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2012, 2014-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_executor.c b/drivers/gpu/arm/mali/common/mali_executor.c
old mode 100755
new mode 100644
index bdbb2f2b..346285ec
--- a/drivers/gpu/arm/mali/common/mali_executor.c
+++ b/drivers/gpu/arm/mali/common/mali_executor.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -21,7 +21,6 @@
 #include "mali_timeline.h"
 #include "mali_osk_profiling.h"
 #include "mali_session.h"
-#include "mali_osk_mali.h"
 
 /*
  * If dma_buf with map on demand is used, we defer job deletion and job queue
@@ -102,7 +101,7 @@ static u32 num_physical_pp_cores_total = 0;
 static u32 num_physical_pp_cores_enabled = 0;
 
 /* Enable or disable core scaling */
-static mali_bool core_scaling_enabled = MALI_FALSE;
+static mali_bool core_scaling_enabled = MALI_TRUE;
 
 /* Variables to allow safe pausing of the scheduler */
 static _mali_osk_wait_queue_t *executor_working_wait_queue = NULL;
@@ -119,6 +118,8 @@ static _mali_osk_wait_queue_t *executor_notify_core_change_wait_queue = NULL;
 /*
  * ---------- Forward declaration of static functions ----------
  */
+static void mali_executor_lock(void);
+static void mali_executor_unlock(void);
 static mali_bool mali_executor_is_suspended(void *data);
 static mali_bool mali_executor_is_working(void);
 static void mali_executor_disable_empty_virtual(void);
@@ -130,6 +131,7 @@ static void mali_executor_wq_schedule(void *arg);
 static void mali_executor_send_gp_oom_to_user(struct mali_gp_job *job);
 static void mali_executor_complete_group(struct mali_group *group,
 		mali_bool success,
+		mali_bool release_jobs,
 		struct mali_gp_job **gp_job_done,
 		struct mali_pp_job **pp_job_done);
 static void mali_executor_change_state_pp_physical(struct mali_group *group,
@@ -444,7 +446,8 @@ void mali_executor_zap_all_active(struct mali_session_data *session)
 	if (MALI_FALSE == ret) {
 		struct mali_gp_job *gp_job = NULL;
 
-		mali_executor_complete_group(gp_group, MALI_FALSE, &gp_job, NULL);
+		mali_executor_complete_group(gp_group, MALI_FALSE,
+					     MALI_TRUE, &gp_job, NULL);
 
 		MALI_DEBUG_ASSERT_POINTER(gp_job);
 
@@ -458,7 +461,8 @@ void mali_executor_zap_all_active(struct mali_session_data *session)
 		if (MALI_FALSE == ret) {
 			struct mali_pp_job *pp_job = NULL;
 
-			mali_executor_complete_group(virtual_group, MALI_FALSE, NULL, &pp_job);
+			mali_executor_complete_group(virtual_group, MALI_FALSE,
+						     MALI_TRUE, NULL, &pp_job);
 
 			if (NULL != pp_job) {
 				/* PP job completed, make sure it is freed */
@@ -476,7 +480,8 @@ void mali_executor_zap_all_active(struct mali_session_data *session)
 			if (MALI_FALSE == ret) {
 				struct mali_pp_job *pp_job = NULL;
 
-				mali_executor_complete_group(group, MALI_FALSE, NULL, &pp_job);
+				mali_executor_complete_group(group, MALI_FALSE,
+							     MALI_TRUE, NULL, &pp_job);
 
 				if (NULL != pp_job) {
 					/* PP job completed, free it */
@@ -611,14 +616,11 @@ _mali_osk_errcode_t mali_executor_interrupt_gp(struct mali_group *group,
 		struct mali_gp_job *job;
 		mali_bool success;
 
-		if (MALI_TRUE == time_out) {
-			mali_group_dump_status(group);
-		}
-
 		success = (int_result != MALI_INTERRUPT_RESULT_ERROR) ?
 			  MALI_TRUE : MALI_FALSE;
 
-		mali_executor_complete_group(group, success, &job, NULL);
+		mali_executor_complete_group(group, success,
+					     MALI_TRUE, &job, NULL);
 
 		mali_executor_unlock();
 
@@ -691,6 +693,9 @@ _mali_osk_errcode_t mali_executor_interrupt_pp(struct mali_group *group,
 	}
 #else
 	MALI_DEBUG_ASSERT(MALI_INTERRUPT_RESULT_NONE != int_result);
+	if (!mali_group_has_timed_out(group)) {
+		MALI_DEBUG_ASSERT(!mali_group_pp_is_active(group));
+	}
 #endif
 
 	/* We should now have a real interrupt to handle */
@@ -712,14 +717,11 @@ _mali_osk_errcode_t mali_executor_interrupt_pp(struct mali_group *group,
 		struct mali_pp_job *job = NULL;
 		mali_bool success;
 
-		if (MALI_TRUE == time_out) {
-			mali_group_dump_status(group);
-		}
-
 		success = (int_result == MALI_INTERRUPT_RESULT_SUCCESS) ?
 			  MALI_TRUE : MALI_FALSE;
 
-		mali_executor_complete_group(group, success, NULL, &job);
+		mali_executor_complete_group(group, success,
+					     MALI_TRUE, NULL, &job);
 
 		mali_executor_unlock();
 
@@ -801,10 +803,10 @@ _mali_osk_errcode_t mali_executor_interrupt_mmu(struct mali_group *group,
 				     group->mmu->hw_core.description));
 		MALI_DEBUG_PRINT(3, ("Executor: MMU rawstat = 0x%08X, MMU status = 0x%08X\n",
 				     mali_mmu_get_rawstat(group->mmu), status));
-		mali_mmu_pagedir_diag(mali_session_get_page_directory(group->session), fault_address);
 #endif
 
-		mali_executor_complete_group(group, MALI_FALSE, &gp_job, &pp_job);
+		mali_executor_complete_group(group, MALI_FALSE,
+					     MALI_TRUE, &gp_job, &pp_job);
 
 		mali_executor_unlock();
 
@@ -980,7 +982,8 @@ void mali_executor_abort_session(struct mali_session_data *session)
 		if (EXEC_STATE_WORKING == gp_group_state) {
 			struct mali_gp_job *gp_job = NULL;
 
-			mali_executor_complete_group(gp_group, MALI_FALSE, &gp_job, NULL);
+			mali_executor_complete_group(gp_group, MALI_FALSE,
+						     MALI_TRUE, &gp_job, NULL);
 
 			MALI_DEBUG_ASSERT_POINTER(gp_job);
 
@@ -998,7 +1001,8 @@ void mali_executor_abort_session(struct mali_session_data *session)
 		    && mali_group_get_session(virtual_group) == session) {
 			struct mali_pp_job *pp_job = NULL;
 
-			mali_executor_complete_group(virtual_group, MALI_FALSE, NULL, &pp_job);
+			mali_executor_complete_group(virtual_group, MALI_FALSE,
+						     MALI_FALSE, NULL, &pp_job);
 
 			if (NULL != pp_job) {
 				/* PP job completed, make sure it is freed */
@@ -1013,7 +1017,8 @@ void mali_executor_abort_session(struct mali_session_data *session)
 		if (mali_group_get_session(group) == session) {
 			struct mali_pp_job *pp_job = NULL;
 
-			mali_executor_complete_group(group, MALI_FALSE, NULL, &pp_job);
+			mali_executor_complete_group(group, MALI_FALSE,
+						     MALI_FALSE, NULL, &pp_job);
 
 			if (NULL != pp_job) {
 				/* PP job completed, make sure it is freed */
@@ -1298,7 +1303,7 @@ _mali_osk_errcode_t _mali_ukk_gp_suspend_response(_mali_uk_gp_suspend_response_s
 				mali_executor_unlock();
 				return _MALI_OSK_ERR_OK;
 			} else {
-				MALI_DEBUG_PRINT(2, ("Executor: Unable to resume  gp job becasue gp time out or any other unexpected reason!\n"));
+				MALI_PRINT_ERROR(("Executor: Unable to resume, GP job no longer running.\n"));
 
 				_mali_osk_notification_delete(new_notification);
 
@@ -1322,7 +1327,8 @@ _mali_osk_errcode_t _mali_ukk_gp_suspend_response(_mali_uk_gp_suspend_response_s
 		/* Correct job is still running */
 		struct mali_gp_job *job_done = NULL;
 
-		mali_executor_complete_group(gp_group, MALI_FALSE, &job_done, NULL);
+		mali_executor_complete_group(gp_group, MALI_FALSE,
+					     MALI_TRUE, &job_done, NULL);
 
 		/* The same job should have completed */
 		MALI_DEBUG_ASSERT(job_done == job);
@@ -1341,13 +1347,13 @@ _mali_osk_errcode_t _mali_ukk_gp_suspend_response(_mali_uk_gp_suspend_response_s
  * ---------- Implementation of static functions ----------
  */
 
-void mali_executor_lock(void)
+static void mali_executor_lock(void)
 {
 	_mali_osk_spinlock_irq_lock(mali_executor_lock_obj);
 	MALI_DEBUG_PRINT(5, ("Executor: lock taken\n"));
 }
 
-void mali_executor_unlock(void)
+static void mali_executor_unlock(void)
 {
 	MALI_DEBUG_PRINT(5, ("Executor: Releasing lock\n"));
 	_mali_osk_spinlock_irq_unlock(mali_executor_lock_obj);
@@ -1447,23 +1453,23 @@ static mali_bool mali_executor_physical_rejoin_virtual(struct mali_group *group)
 
 static mali_bool mali_executor_has_virtual_group(void)
 {
-#if (defined(CONFIG_MALI450) || defined(CONFIG_MALI470))
+#if defined(CONFIG_MALI450)
 	return (NULL != virtual_group) ? MALI_TRUE : MALI_FALSE;
 #else
 	return MALI_FALSE;
-#endif /* (defined(CONFIG_MALI450) || defined(CONFIG_MALI470)) */
+#endif /* defined(CONFIG_MALI450) */
 }
 
 static mali_bool mali_executor_virtual_group_is_usable(void)
 {
-#if (defined(CONFIG_MALI450) || defined(CONFIG_MALI470))
+#if defined(CONFIG_MALI450)
 	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-	return ((EXEC_STATE_INACTIVE == virtual_group_state ||
-		 EXEC_STATE_IDLE == virtual_group_state) && (virtual_group->state != MALI_GROUP_STATE_ACTIVATION_PENDING)) ?
+	return (EXEC_STATE_INACTIVE == virtual_group_state ||
+		EXEC_STATE_IDLE == virtual_group_state) ?
 	       MALI_TRUE : MALI_FALSE;
 #else
 	return MALI_FALSE;
-#endif /* (defined(CONFIG_MALI450) || defined(CONFIG_MALI470)) */
+#endif /* defined(CONFIG_MALI450) */
 }
 
 static mali_bool mali_executor_tackle_gp_bound(void)
@@ -1484,75 +1490,6 @@ static mali_bool mali_executor_tackle_gp_bound(void)
 	return MALI_FALSE;
 }
 
-static mali_bool mali_executor_schedule_is_early_out(mali_bool *gpu_secure_mode_is_needed)
-{
-	struct mali_pp_job *next_pp_job_to_start = NULL;
-	struct mali_group *group;
-	struct mali_group *tmp_group;
-	struct mali_pp_job *physical_pp_job_working = NULL;
-	struct mali_pp_job *virtual_pp_job_working = NULL;
-	mali_bool gpu_working_in_protected_mode = MALI_FALSE;
-	mali_bool gpu_working_in_non_protected_mode = MALI_FALSE;
-
-	MALI_DEBUG_ASSERT_LOCK_HELD(mali_scheduler_lock_obj);
-
-	*gpu_secure_mode_is_needed = MALI_FALSE;
-
-	/* Check if the gpu secure mode is supported, exit if not.*/
-	if (MALI_FALSE == _mali_osk_gpu_secure_mode_is_supported()) {
-		return MALI_FALSE;
-	}
-
-	/* Check if need to set gpu secure mode for the next pp job,
-	 * get the next pp job that will be scheduled  if exist.
-	 */
-	next_pp_job_to_start = mali_scheduler_job_pp_next();
-
-	/* Check current pp physical/virtual running job is protected job or not if exist.*/
-	_MALI_OSK_LIST_FOREACHENTRY(group, tmp_group, &group_list_working,
-				    struct mali_group, executor_list) {
-		physical_pp_job_working = group->pp_running_job;
-		break;
-	}
-
-	if (EXEC_STATE_WORKING == virtual_group_state) {
-		virtual_pp_job_working = virtual_group->pp_running_job;
-	}
-
-	if (NULL != physical_pp_job_working) {
-		if (MALI_TRUE == mali_pp_job_is_protected_job(physical_pp_job_working)) {
-			gpu_working_in_protected_mode = MALI_TRUE;
-		} else {
-			gpu_working_in_non_protected_mode = MALI_TRUE;
-		}
-	} else if (NULL != virtual_pp_job_working) {
-		if (MALI_TRUE == mali_pp_job_is_protected_job(virtual_pp_job_working)) {
-			gpu_working_in_protected_mode = MALI_TRUE;
-		} else {
-			gpu_working_in_non_protected_mode = MALI_TRUE;
-		}
-	} else if (EXEC_STATE_WORKING == gp_group_state) {
-		gpu_working_in_non_protected_mode = MALI_TRUE;
-	}
-
-	/* If the next pp job is the protected pp job.*/
-	if ((NULL != next_pp_job_to_start) && MALI_TRUE == mali_pp_job_is_protected_job(next_pp_job_to_start)) {
-		/* if gp is working or any non-protected pp job is working now, unable to schedule protected pp job. */
-		if (MALI_TRUE == gpu_working_in_non_protected_mode)
-			return MALI_TRUE;
-
-		*gpu_secure_mode_is_needed = MALI_TRUE;
-		return MALI_FALSE;
-
-	}
-
-	if (MALI_TRUE == gpu_working_in_protected_mode) {
-		/* Unable to schedule non-protected pp job/gp job if exist protected pp running jobs*/
-		return MALI_TRUE;
-	}
-
-	return MALI_FALSE;
-}
 /*
  * This is where jobs are actually started.
  */
@@ -1563,8 +1500,7 @@ static void mali_executor_schedule(void)
 	u32 num_physical_to_process = 0;
 	mali_bool trigger_pm_update = MALI_FALSE;
 	mali_bool deactivate_idle_group = MALI_TRUE;
-	mali_bool gpu_secure_mode_is_needed = MALI_FALSE;
-	mali_bool is_gpu_secure_mode = MALI_FALSE;
+
 	/* Physical groups + jobs to start in this function */
 	struct mali_group *groups_to_start[MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS];
 	struct mali_pp_job *jobs_to_start[MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS];
@@ -1587,16 +1523,9 @@ static void mali_executor_schedule(void)
 	/* Lock needed in order to safely handle the job queues */
 	mali_scheduler_lock();
 
-	/* 1. Check the schedule if need to early out. */
-	if (MALI_TRUE == mali_executor_schedule_is_early_out(&gpu_secure_mode_is_needed)) {
-		mali_scheduler_unlock();
-		return;
-	}
-
-	/* 2. Activate gp firstly if have gp job queued. */
-	if ((EXEC_STATE_INACTIVE == gp_group_state)
-	    && (0 < mali_scheduler_job_gp_count())
-	    && (gpu_secure_mode_is_needed == MALI_FALSE)) {
+	/* 1. Activate gp firstly if have gp job queued. */
+	if (EXEC_STATE_INACTIVE == gp_group_state &&
+	    0 < mali_scheduler_job_gp_count()) {
 
 		enum mali_group_state state =
 			mali_group_activate(gp_group);
@@ -1608,9 +1537,9 @@ static void mali_executor_schedule(void)
 		}
 	}
 
-	/* 3. Prepare as many physical groups as needed/possible */
+	/* 2. Prepare as many physical groups as needed/possible */
 
-	num_physical_needed = mali_scheduler_job_physical_head_count(gpu_secure_mode_is_needed);
+	num_physical_needed = mali_scheduler_job_physical_head_count();
 
 	/* On mali-450 platform, we don't need to enter in this block frequently. */
 	if (0 < num_physical_needed) {
@@ -1627,7 +1556,7 @@ static void mali_executor_schedule(void)
 
 		if (0 < num_physical_needed) {
 
-			/* 3.1. Activate groups which are inactive */
+			/* 2.1. Activate groups which are inactive */
 
 			struct mali_group *group;
 			struct mali_group *temp;
@@ -1659,7 +1588,7 @@ static void mali_executor_schedule(void)
 		if (mali_executor_virtual_group_is_usable()) {
 
 			/*
-			 * 3.2. And finally, steal and activate groups
+			 * 2.2. And finally, steal and activate groups
 			 * from virtual group if we need even more
 			 */
 			while (0 < num_physical_needed) {
@@ -1702,7 +1631,7 @@ static void mali_executor_schedule(void)
 			}
 		}
 
-		/* 3.3. Assign physical jobs to groups */
+		/* 2.3. Assign physical jobs to groups */
 
 		if (0 < num_physical_to_process) {
 			struct mali_group *group;
@@ -1717,30 +1646,24 @@ static void mali_executor_schedule(void)
 						  MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS);
 
 				MALI_DEBUG_ASSERT(0 <
-						  mali_scheduler_job_physical_head_count(gpu_secure_mode_is_needed));
+						  mali_scheduler_job_physical_head_count());
 
-				/* If the next pp job is non-protected, check if gp bound now. */
-				if ((MALI_FALSE == gpu_secure_mode_is_needed)
-				    && (mali_executor_hint_is_enabled(MALI_EXECUTOR_HINT_GP_BOUND))
-				    && (MALI_TRUE == mali_executor_tackle_gp_bound())) {
-					/*
-					* We're gp bound,
-					* don't start this right now.
-					*/
-					deactivate_idle_group = MALI_FALSE;
-					num_physical_to_process = 0;
-					break;
+				if (mali_executor_hint_is_enabled(
+					    MALI_EXECUTOR_HINT_GP_BOUND)) {
+					if (MALI_TRUE == mali_executor_tackle_gp_bound()) {
+						/*
+						* We're gp bound,
+						* don't start this right now.
+						*/
+						deactivate_idle_group = MALI_FALSE;
+						num_physical_to_process = 0;
+						break;
+					}
 				}
 
 				job = mali_scheduler_job_pp_physical_get(
 					      &sub_job);
 
-				if (MALI_FALSE == gpu_secure_mode_is_needed) {
-					MALI_DEBUG_ASSERT(MALI_FALSE == mali_pp_job_is_protected_job(job));
-				} else {
-					MALI_DEBUG_ASSERT(MALI_TRUE == mali_pp_job_is_protected_job(job));
-				}
-
 				MALI_DEBUG_ASSERT_POINTER(job);
 				MALI_DEBUG_ASSERT(sub_job <= MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS);
 
@@ -1767,7 +1690,8 @@ static void mali_executor_schedule(void)
 		}
 	}
 
-	/* 4. Deactivate idle pp group , must put deactive here before active vitual group
+
+	/* 3. Deactivate idle pp group , must put deactive here before active vitual group
 	 *    for cover case first only has physical job in normal queue but group inactive,
 	 *    so delay the job start go to active group, when group activated,
 	 *    call scheduler again, but now if we get high queue virtual job,
@@ -1779,47 +1703,34 @@ static void mali_executor_schedule(void)
 		trigger_pm_update = MALI_TRUE;
 	}
 
-	/* 5. Activate virtual group, if needed */
+	/* 4. Activate virtual group, if needed */
+
 	if (EXEC_STATE_INACTIVE == virtual_group_state &&
-	    MALI_TRUE ==  mali_scheduler_job_next_is_virtual()) {
-		struct mali_pp_job *virtual_job = mali_scheduler_job_pp_virtual_peek();
-		if ((MALI_FALSE == gpu_secure_mode_is_needed && MALI_FALSE == mali_pp_job_is_protected_job(virtual_job))
-		    || (MALI_TRUE == gpu_secure_mode_is_needed && MALI_TRUE == mali_pp_job_is_protected_job(virtual_job))) {
-			enum mali_group_state state =
-				mali_group_activate(virtual_group);
-			if (MALI_GROUP_STATE_ACTIVE == state) {
-				/* Set virtual group state to idle */
-				virtual_group_state = EXEC_STATE_IDLE;
-			} else {
-				trigger_pm_update = MALI_TRUE;
-			}
+	    0 < mali_scheduler_job_next_is_virtual()) {
+		enum mali_group_state state =
+			mali_group_activate(virtual_group);
+		if (MALI_GROUP_STATE_ACTIVE == state) {
+			/* Set virtual group state to idle */
+			virtual_group_state = EXEC_STATE_IDLE;
+		} else {
+			trigger_pm_update = MALI_TRUE;
 		}
 	}
 
-	/* 6. To power up group asap,  trigger pm update only when no need to swith the gpu mode. */
+	/* 5. To power up group asap, we trigger pm update here. */
 
-	is_gpu_secure_mode = _mali_osk_gpu_secure_mode_is_enabled();
-
-	if ((MALI_FALSE == gpu_secure_mode_is_needed && MALI_FALSE == is_gpu_secure_mode)
-		||(MALI_TRUE == gpu_secure_mode_is_needed && MALI_TRUE == is_gpu_secure_mode))
-	{
-		if (MALI_TRUE == trigger_pm_update) {
-			trigger_pm_update = MALI_FALSE;
-			mali_pm_update_async();
-		}
+	if (MALI_TRUE == trigger_pm_update) {
+		trigger_pm_update = MALI_FALSE;
+		mali_pm_update_async();
 	}
 
-	/* 7. Assign jobs to idle virtual group (or deactivate if no job) */
+	/* 6. Assign jobs to idle virtual group (or deactivate if no job) */
 
 	if (EXEC_STATE_IDLE == virtual_group_state) {
-		if (MALI_TRUE == mali_scheduler_job_next_is_virtual()) {
-			struct mali_pp_job *virtual_job = mali_scheduler_job_pp_virtual_peek();
-			if ((MALI_FALSE == gpu_secure_mode_is_needed && MALI_FALSE == mali_pp_job_is_protected_job(virtual_job))
-			    || (MALI_TRUE == gpu_secure_mode_is_needed && MALI_TRUE == mali_pp_job_is_protected_job(virtual_job))) {
-				virtual_job_to_start =
-					mali_scheduler_job_pp_virtual_get();
-				virtual_group_state = EXEC_STATE_WORKING;
-			}
+		if (0 < mali_scheduler_job_next_is_virtual()) {
+			virtual_job_to_start =
+				mali_scheduler_job_pp_virtual_get();
+			virtual_group_state = EXEC_STATE_WORKING;
 		} else if (!mali_timeline_has_virtual_pp_job()) {
 			virtual_group_state = EXEC_STATE_INACTIVE;
 
@@ -1829,9 +1740,9 @@ static void mali_executor_schedule(void)
 		}
 	}
 
-	/* 8. Assign job to idle GP group (or deactivate if no job) */
+	/* 7. Assign job to idle GP group (or deactivate if no job) */
 
-	if (EXEC_STATE_IDLE == gp_group_state && MALI_FALSE == gpu_secure_mode_is_needed) {
+	if (EXEC_STATE_IDLE == gp_group_state) {
 		if (0 < mali_scheduler_job_gp_count()) {
 			gp_job_to_start = mali_scheduler_job_gp_get();
 			gp_group_state = EXEC_STATE_WORKING;
@@ -1843,15 +1754,16 @@ static void mali_executor_schedule(void)
 		}
 	}
 
-	/* 9. We no longer need the schedule/queue lock */
+	/* 8. We no longer need the schedule/queue lock */
 
 	mali_scheduler_unlock();
 
-	/* 10. start jobs */
+	/* 9. start jobs */
+
 	if (NULL != virtual_job_to_start) {
 		MALI_DEBUG_ASSERT(!mali_group_pp_is_active(virtual_group));
 		mali_group_start_pp_job(virtual_group,
-					virtual_job_to_start, 0, is_gpu_secure_mode);
+					virtual_job_to_start, 0);
 	}
 
 	for (i = 0; i < num_jobs_to_start; i++) {
@@ -1859,17 +1771,17 @@ static void mali_executor_schedule(void)
 					  groups_to_start[i]));
 		mali_group_start_pp_job(groups_to_start[i],
 					jobs_to_start[i],
-					sub_jobs_to_start[i], is_gpu_secure_mode);
+					sub_jobs_to_start[i]);
 	}
 
 	MALI_DEBUG_ASSERT_POINTER(gp_group);
 
 	if (NULL != gp_job_to_start) {
 		MALI_DEBUG_ASSERT(!mali_group_gp_is_active(gp_group));
-		mali_group_start_gp_job(gp_group, gp_job_to_start, is_gpu_secure_mode);
+		mali_group_start_gp_job(gp_group, gp_job_to_start);
 	}
 
-	/* 11. Trigger any pending PM updates */
+	/* 10. Trigger any pending PM updates */
 	if (MALI_TRUE == trigger_pm_update) {
 		mali_pm_update_async();
 	}
@@ -1905,7 +1817,8 @@ static void mali_executor_send_gp_oom_to_user(struct mali_gp_job *job)
 				       notification);
 }
 static struct mali_gp_job *mali_executor_complete_gp(struct mali_group *group,
-		mali_bool success)
+		mali_bool success,
+		mali_bool release_jobs)
 {
 	struct mali_gp_job *job;
 
@@ -1919,17 +1832,20 @@ static struct mali_gp_job *mali_executor_complete_gp(struct mali_group *group,
 	/* Core is now ready to go into idle list */
 	gp_group_state = EXEC_STATE_IDLE;
 
-	/* This will potentially queue more GP and PP jobs */
-	mali_timeline_tracker_release(&job->tracker);
+	if (release_jobs) {
+		/* This will potentially queue more GP and PP jobs */
+		mali_timeline_tracker_release(&job->tracker);
 
-	/* Signal PP job */
-	mali_gp_job_signal_pp_tracker(job, success);
+		/* Signal PP job */
+		mali_gp_job_signal_pp_tracker(job, success);
+	}
 
 	return job;
 }
 
 static struct mali_pp_job *mali_executor_complete_pp(struct mali_group *group,
-		mali_bool success)
+		mali_bool success,
+		mali_bool release_jobs)
 {
 	struct mali_pp_job *job;
 	u32 sub_job;
@@ -1958,7 +1874,7 @@ static struct mali_pp_job *mali_executor_complete_pp(struct mali_group *group,
 	mali_pp_job_mark_sub_job_completed(job, success);
 	job_is_done = mali_pp_job_is_complete(job);
 
-	if (job_is_done) {
+	if (job_is_done && release_jobs) {
 		/* This will potentially queue more GP and PP jobs */
 		mali_timeline_tracker_release(&job->tracker);
 	}
@@ -1968,6 +1884,7 @@ static struct mali_pp_job *mali_executor_complete_pp(struct mali_group *group,
 
 static void mali_executor_complete_group(struct mali_group *group,
 		mali_bool success,
+		mali_bool release_jobs,
 		struct mali_gp_job **gp_job_done,
 		struct mali_pp_job **pp_job_done)
 {
@@ -1978,11 +1895,13 @@ static void mali_executor_complete_group(struct mali_group *group,
 	mali_bool pp_job_is_done = MALI_TRUE;
 
 	if (NULL != gp_core) {
-		gp_job = mali_executor_complete_gp(group, success);
+		gp_job = mali_executor_complete_gp(group,
+						   success, release_jobs);
 	} else {
 		MALI_DEBUG_ASSERT_POINTER(pp_core);
 		MALI_IGNORE(pp_core);
-		pp_job = mali_executor_complete_pp(group, success);
+		pp_job = mali_executor_complete_pp(group,
+						   success, release_jobs);
 
 		pp_job_is_done = mali_pp_job_is_complete(pp_job);
 	}
@@ -2235,7 +2154,7 @@ static void mali_executor_notify_core_change(u32 num_cores)
 {
 	mali_bool done = MALI_FALSE;
 
-	if (mali_is_mali450() || mali_is_mali470()) {
+	if (mali_is_mali450()) {
 		return;
 	}
 
@@ -2337,7 +2256,7 @@ static void mali_executor_wq_notify_core_change(void *arg)
 {
 	MALI_IGNORE(arg);
 
-	if (mali_is_mali450() || mali_is_mali470()) {
+	if (mali_is_mali450()) {
 		return;
 	}
 
@@ -2610,85 +2529,3 @@ static mali_bool mali_executor_deactivate_list_idle(mali_bool deactivate_idle_gr
 
 	return trigger_pm_update;
 }
-
-void mali_executor_running_status_print(void)
-{
-	struct mali_group *group = NULL;
-	struct mali_group *temp = NULL;
-
-	MALI_PRINT(("GP running job: %p\n", gp_group->gp_running_job));
-	if ((gp_group->gp_core) && (gp_group->is_working)) {
-		mali_group_dump_status(gp_group);
-	}
-	MALI_PRINT(("Physical PP groups in WORKING state (count = %u):\n", group_list_working_count));
-	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_working, struct mali_group, executor_list) {
-		MALI_PRINT(("PP running job: %p, subjob %d \n", group->pp_running_job, group->pp_running_sub_job));
-		mali_group_dump_status(group);
-	}
-	MALI_PRINT(("Physical PP groups in INACTIVE state (count = %u):\n", group_list_inactive_count));
-	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_inactive, struct mali_group, executor_list) {
-		MALI_PRINT(("\tPP status %d, SW power: %s\n", group->state, group->power_is_on ? "On" : "Off"));
-		MALI_PRINT(("\tPP #%d: %s\n", group->pp_core->core_id, group->pp_core->hw_core.description));
-	}
-	MALI_PRINT(("Physical PP groups in IDLE state (count = %u):\n", group_list_idle_count));
-	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_idle, struct mali_group, executor_list) {
-		MALI_PRINT(("\tPP status %d, SW power: %s\n", group->state, group->power_is_on ? "On" : "Off"));
-		MALI_PRINT(("\tPP #%d: %s\n", group->pp_core->core_id, group->pp_core->hw_core.description));
-	}
-	MALI_PRINT(("Physical PP groups in DISABLED state (count = %u):\n", group_list_disabled_count));
-	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_disabled, struct mali_group, executor_list) {
-		MALI_PRINT(("\tPP status %d, SW power: %s\n", group->state, group->power_is_on ? "On" : "Off"));
-		MALI_PRINT(("\tPP #%d: %s\n", group->pp_core->core_id, group->pp_core->hw_core.description));
-	}
-
-	if (mali_executor_has_virtual_group()) {
-		MALI_PRINT(("Virtual group running job: %p\n", virtual_group->pp_running_job));
-		MALI_PRINT(("Virtual group status: %d\n", virtual_group_state));
-		MALI_PRINT(("Virtual group->status: %d\n", virtual_group->state));
-		MALI_PRINT(("\tSW power: %s\n", virtual_group->power_is_on ? "On" : "Off"));
-		_MALI_OSK_LIST_FOREACHENTRY(group, temp, &virtual_group->group_list,
-					    struct mali_group, group_list) {
-			int i = 0;
-			MALI_PRINT(("\tchild group(%s) running job: %p\n", group->pp_core->hw_core.description, group->pp_running_job));
-			MALI_PRINT(("\tchild group(%s)->status: %d\n", group->pp_core->hw_core.description, group->state));
-			MALI_PRINT(("\tchild group(%s) SW power: %s\n", group->pp_core->hw_core.description, group->power_is_on ? "On" : "Off"));
-			if (group->pm_domain) {
-				MALI_PRINT(("\tPower domain: id %u\n", mali_pm_domain_get_id(group->pm_domain)));
-				MALI_PRINT(("\tMask:0x%04x \n", mali_pm_domain_get_mask(group->pm_domain)));
-				MALI_PRINT(("\tUse-count:%u \n", mali_pm_domain_get_use_count(group->pm_domain)));
-				MALI_PRINT(("\tCurrent power status:%s \n", (mali_pm_domain_get_mask(group->pm_domain)& mali_pm_get_current_mask()) ? "On" : "Off"));
-				MALI_PRINT(("\tWanted  power status:%s \n", (mali_pm_domain_get_mask(group->pm_domain)& mali_pm_get_wanted_mask()) ? "On" : "Off"));
-			}
-
-			for (i = 0; i < 2; i++) {
-				if (NULL != group->l2_cache_core[i]) {
-					struct mali_pm_domain *domain;
-					domain = mali_l2_cache_get_pm_domain(group->l2_cache_core[i]);
-					MALI_PRINT(("\t L2(index %d) group SW power: %s\n", i, group->l2_cache_core[i]->power_is_on ? "On" : "Off"));
-					if (domain) {
-						MALI_PRINT(("\tL2 Power domain: id %u\n", mali_pm_domain_get_id(domain)));
-						MALI_PRINT(("\tL2 Mask:0x%04x \n", mali_pm_domain_get_mask(domain)));
-						MALI_PRINT(("\tL2 Use-count:%u \n", mali_pm_domain_get_use_count(domain)));
-						MALI_PRINT(("\tL2 Current power status:%s \n", (mali_pm_domain_get_mask(domain) & mali_pm_get_current_mask()) ? "On" : "Off"));
-						MALI_PRINT(("\tL2 Wanted  power status:%s \n", (mali_pm_domain_get_mask(domain) & mali_pm_get_wanted_mask()) ? "On" : "Off"));
-					}
-				}
-			}
-		}
-		if (EXEC_STATE_WORKING == virtual_group_state) {
-			mali_group_dump_status(virtual_group);
-		}
-	}
-}
-
-void mali_executor_status_dump(void)
-{
-	mali_executor_lock();
-	mali_scheduler_lock();
-
-	/* print schedule queue status */
-	mali_scheduler_gp_pp_job_queue_print();
-
-	mali_scheduler_unlock();
-	mali_executor_unlock();
-}
diff --git a/drivers/gpu/arm/mali/common/mali_executor.h b/drivers/gpu/arm/mali/common/mali_executor.h
old mode 100755
new mode 100644
index 1d69dc3a..930c5e48
--- a/drivers/gpu/arm/mali/common/mali_executor.h
+++ b/drivers/gpu/arm/mali/common/mali_executor.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012, 2014-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012, 2014-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -58,6 +58,7 @@ void mali_executor_schedule_from_mask(mali_scheduler_mask mask, mali_bool deferr
 _mali_osk_errcode_t mali_executor_interrupt_gp(struct mali_group *group, mali_bool in_upper_half);
 _mali_osk_errcode_t mali_executor_interrupt_pp(struct mali_group *group, mali_bool in_upper_half);
 _mali_osk_errcode_t mali_executor_interrupt_mmu(struct mali_group *group, mali_bool in_upper_half);
+
 void mali_executor_group_power_up(struct mali_group *groups[], u32 num_groups);
 void mali_executor_group_power_down(struct mali_group *groups[], u32 num_groups);
 
@@ -95,8 +96,4 @@ MALI_STATIC_INLINE mali_bool mali_executor_hint_is_enabled(mali_executor_hint hi
 	return mali_executor_hints[hint];
 }
 
-void mali_executor_running_status_print(void);
-void mali_executor_status_dump(void);
-void mali_executor_lock(void);
-void mali_executor_unlock(void);
 #endif /* __MALI_EXECUTOR_H__ */
diff --git a/drivers/gpu/arm/mali/common/mali_gp.c b/drivers/gpu/arm/mali/common/mali_gp.c
old mode 100755
new mode 100644
index cce3e395..ca4dee4b
--- a/drivers/gpu/arm/mali/common/mali_gp.c
+++ b/drivers/gpu/arm/mali/common/mali_gp.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -19,6 +19,8 @@
 #include "mali_osk_profiling.h"
 #endif
 
+#include <mali_platform.h>
+
 static struct mali_gp_core *mali_global_gp_core = NULL;
 
 /* Interrupt handlers */
@@ -109,6 +111,8 @@ _mali_osk_errcode_t mali_gp_stop_bus_wait(struct mali_gp_core *core)
 
 	if (MALI_REG_POLL_COUNT_SLOW == i) {
 		MALI_PRINT_ERROR(("Mali GP: Failed to stop bus on %s\n", core->hw_core.description));
+		if (mali_gp_reset_fail < 65533)
+			mali_gp_reset_fail++;
 		return _MALI_OSK_ERR_FAULT;
 	}
 	return _MALI_OSK_ERR_OK;
@@ -116,7 +120,7 @@ _mali_osk_errcode_t mali_gp_stop_bus_wait(struct mali_gp_core *core)
 
 void mali_gp_hard_reset(struct mali_gp_core *core)
 {
-	const u32 reset_wait_target_register = MALIGP2_REG_ADDR_MGMT_PERF_CNT_0_LIMIT;
+	const u32 reset_wait_target_register = MALIGP2_REG_ADDR_MGMT_WRITE_BOUND_LOW;
 	const u32 reset_invalid_value = 0xC0FFE000;
 	const u32 reset_check_value = 0xC01A0000;
 	const u32 reset_default_value = 0;
@@ -176,6 +180,8 @@ _mali_osk_errcode_t mali_gp_reset_wait(struct mali_gp_core *core)
 	if (i == MALI_REG_POLL_COUNT_FAST) {
 		MALI_PRINT_ERROR(("Mali GP: Failed to reset core %s, rawstat: 0x%08x\n",
 				  core->hw_core.description, rawstat));
+		if (mali_gp_reset_fail < 65533)
+			mali_gp_reset_fail++;
 		return _MALI_OSK_ERR_FAULT;
 	}
 
@@ -296,7 +302,7 @@ static void mali_gp_irq_probe_trigger(void *data)
 	struct mali_gp_core *core = (struct mali_gp_core *)data;
 
 	mali_hw_core_register_write(&core->hw_core, MALIGP2_REG_ADDR_MGMT_INT_MASK, MALIGP2_REG_VAL_IRQ_MASK_USED);
-	mali_hw_core_register_write(&core->hw_core, MALIGP2_REG_ADDR_MGMT_INT_RAWSTAT, MALIGP2_REG_VAL_IRQ_AXI_BUS_ERROR);
+	mali_hw_core_register_write(&core->hw_core, MALIGP2_REG_ADDR_MGMT_INT_RAWSTAT, MALIGP2_REG_VAL_CMD_FORCE_HANG);
 	_mali_osk_mem_barrier();
 }
 
@@ -306,8 +312,8 @@ static _mali_osk_errcode_t mali_gp_irq_probe_ack(void *data)
 	u32 irq_readout;
 
 	irq_readout = mali_hw_core_register_read(&core->hw_core, MALIGP2_REG_ADDR_MGMT_INT_STAT);
-	if (MALIGP2_REG_VAL_IRQ_AXI_BUS_ERROR & irq_readout) {
-		mali_hw_core_register_write(&core->hw_core, MALIGP2_REG_ADDR_MGMT_INT_CLEAR, MALIGP2_REG_VAL_IRQ_AXI_BUS_ERROR);
+	if (MALIGP2_REG_VAL_IRQ_FORCE_HANG & irq_readout) {
+		mali_hw_core_register_write(&core->hw_core, MALIGP2_REG_ADDR_MGMT_INT_CLEAR, MALIGP2_REG_VAL_IRQ_FORCE_HANG);
 		_mali_osk_mem_barrier();
 		return _MALI_OSK_ERR_OK;
 	}
@@ -340,7 +346,6 @@ void mali_gp_update_performance_counters(struct mali_gp_core *core, struct mali_
 
 #if defined(CONFIG_MALI400_PROFILING)
 		_mali_osk_profiling_report_hw_counter(COUNTER_VP_0_C0, val0);
-		_mali_osk_profiling_record_global_counters(COUNTER_VP_0_C0, val0);
 #endif
 
 	}
@@ -351,7 +356,6 @@ void mali_gp_update_performance_counters(struct mali_gp_core *core, struct mali_
 
 #if defined(CONFIG_MALI400_PROFILING)
 		_mali_osk_profiling_report_hw_counter(COUNTER_VP_0_C1, val1);
-		_mali_osk_profiling_record_global_counters(COUNTER_VP_0_C1, val1);
 #endif
 	}
 }
diff --git a/drivers/gpu/arm/mali/common/mali_gp.h b/drivers/gpu/arm/mali/common/mali_gp.h
old mode 100755
new mode 100644
index ecbe70e9..28c92f18
--- a/drivers/gpu/arm/mali/common/mali_gp.h
+++ b/drivers/gpu/arm/mali/common/mali_gp.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_gp_job.c b/drivers/gpu/arm/mali/common/mali_gp_job.c
old mode 100755
new mode 100644
index 8dd19cb2..e064c86c
--- a/drivers/gpu/arm/mali/common/mali_gp_job.c
+++ b/drivers/gpu/arm/mali/common/mali_gp_job.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -12,87 +12,35 @@
 #include "mali_osk.h"
 #include "mali_osk_list.h"
 #include "mali_uk_types.h"
-#include "mali_memory_virtual.h"
-#include "mali_memory_defer_bind.h"
 
 static u32 gp_counter_src0 = MALI_HW_CORE_NO_COUNTER;      /**< Performance counter 0, MALI_HW_CORE_NO_COUNTER for disabled */
 static u32 gp_counter_src1 = MALI_HW_CORE_NO_COUNTER;           /**< Performance counter 1, MALI_HW_CORE_NO_COUNTER for disabled */
-static void _mali_gp_del_varying_allocations(struct mali_gp_job *job);
-
-
-static int _mali_gp_add_varying_allocations(struct mali_session_data *session,
-		struct mali_gp_job *job,
-		u32 *alloc,
-		u32 num)
-{
-	int i = 0;
-	struct mali_gp_allocation_node *alloc_node;
-	mali_mem_allocation *mali_alloc = NULL;
-	struct mali_vma_node *mali_vma_node = NULL;
-
-	for (i = 0 ; i < num ; i++) {
-		MALI_DEBUG_ASSERT(alloc[i]);
-		alloc_node = _mali_osk_calloc(1, sizeof(struct mali_gp_allocation_node));
-		if (alloc_node) {
-			INIT_LIST_HEAD(&alloc_node->node);
-			/* find mali allocation structure by vaddress*/
-			mali_vma_node = mali_vma_offset_search(&session->allocation_mgr, alloc[i], 0);
-
-			if (likely(mali_vma_node)) {
-				mali_alloc = container_of(mali_vma_node, struct mali_mem_allocation, mali_vma_node);
-				MALI_DEBUG_ASSERT(alloc[i] == mali_vma_node->vm_node.start);
-			} else {
-				MALI_DEBUG_PRINT(1, ("ERROE!_mali_gp_add_varying_allocations,can't find allocation %d by address =0x%x, num=%d\n", i, alloc[i], num));
-				_mali_osk_free(alloc_node);
-				goto fail;
-			}
-			alloc_node->alloc = mali_alloc;
-			/* add to gp job varying alloc list*/
-			list_move(&alloc_node->node, &job->varying_alloc);
-		} else
-			goto fail;
-	}
-
-	return 0;
-fail:
-	MALI_DEBUG_PRINT(1, ("ERROE!_mali_gp_add_varying_allocations,failed to alloc memory!\n"));
-	_mali_gp_del_varying_allocations(job);
-	return -1;
-}
-
-
-static void _mali_gp_del_varying_allocations(struct mali_gp_job *job)
-{
-	struct mali_gp_allocation_node *alloc_node, *tmp_node;
-
-	list_for_each_entry_safe(alloc_node, tmp_node, &job->varying_alloc, node) {
-		list_del(&alloc_node->node);
-		kfree(alloc_node);
-	}
-	INIT_LIST_HEAD(&job->varying_alloc);
-}
 
 struct mali_gp_job *mali_gp_job_create(struct mali_session_data *session, _mali_uk_gp_start_job_s *uargs, u32 id, struct mali_timeline_tracker *pp_tracker)
 {
 	struct mali_gp_job *job;
 	u32 perf_counter_flag;
-	u32 __user *memory_list = NULL;
-	struct mali_gp_allocation_node *alloc_node, *tmp_node;
 
-	job = _mali_osk_calloc(1, sizeof(struct mali_gp_job));
+	job = _mali_osk_malloc(sizeof(struct mali_gp_job));
 	if (NULL != job) {
 		job->finished_notification = _mali_osk_notification_create(_MALI_NOTIFICATION_GP_FINISHED, sizeof(_mali_uk_gp_job_finished_s));
 		if (NULL == job->finished_notification) {
-			goto fail3;
+			_mali_osk_free(job);
+			return NULL;
 		}
 
 		job->oom_notification = _mali_osk_notification_create(_MALI_NOTIFICATION_GP_STALLED, sizeof(_mali_uk_gp_job_suspended_s));
 		if (NULL == job->oom_notification) {
-			goto fail2;
+			_mali_osk_notification_delete(job->finished_notification);
+			_mali_osk_free(job);
+			return NULL;
 		}
 
 		if (0 != _mali_osk_copy_from_user(&job->uargs, uargs, sizeof(_mali_uk_gp_start_job_s))) {
-			goto fail1;
+			_mali_osk_notification_delete(job->finished_notification);
+			_mali_osk_notification_delete(job->oom_notification);
+			_mali_osk_free(job);
+			return NULL;
 		}
 
 		perf_counter_flag = mali_gp_job_get_perf_counter_flag(job);
@@ -114,69 +62,6 @@ struct mali_gp_job *mali_gp_job_create(struct mali_session_data *session, _mali_
 		job->pid = _mali_osk_get_pid();
 		job->tid = _mali_osk_get_tid();
 
-
-		INIT_LIST_HEAD(&job->varying_alloc);
-		INIT_LIST_HEAD(&job->vary_todo);
-		job->dmem = NULL;
-
-		if (job->uargs.deferred_mem_num > session->allocation_mgr.mali_allocation_num) {
-			MALI_PRINT_ERROR(("Mali GP job: The number of  varying buffer to defer bind  is invalid !\n"));
-			goto fail1;
-		}
-
-		/* add varying allocation list*/
-		if (job->uargs.deferred_mem_num > 0) {
-			/* copy varying list from user space*/
-			job->varying_list = _mali_osk_calloc(1, sizeof(u32) * job->uargs.deferred_mem_num);
-			if (!job->varying_list) {
-				MALI_PRINT_ERROR(("Mali GP job: allocate varying_list failed varying_alloc_num = %d !\n", job->uargs.deferred_mem_num));
-				goto fail1;
-			}
-
-			memory_list = (u32 __user *)(uintptr_t)uargs->deferred_mem_list;
-
-			if (0 != _mali_osk_copy_from_user(job->varying_list, memory_list, sizeof(u32) * job->uargs.deferred_mem_num)) {
-				MALI_PRINT_ERROR(("Mali GP job: Failed to copy varying list from user space!\n"));
-				goto fail;
-			}
-
-			if (unlikely(_mali_gp_add_varying_allocations(session, job, job->varying_list,
-					job->uargs.deferred_mem_num))) {
-				MALI_PRINT_ERROR(("Mali GP job: _mali_gp_add_varying_allocations failed!\n"));
-				goto fail;
-			}
-
-			/* do preparetion for each allocation */
-			list_for_each_entry_safe(alloc_node, tmp_node, &job->varying_alloc, node) {
-				if (unlikely(_MALI_OSK_ERR_OK != mali_mem_defer_bind_allocation_prepare(alloc_node->alloc, &job->vary_todo, &job->required_varying_memsize))) {
-					MALI_PRINT_ERROR(("Mali GP job: mali_mem_defer_bind_allocation_prepare failed!\n"));
-					goto fail;
-				}
-			}
-
-			_mali_gp_del_varying_allocations(job);
-
-			/* bind varying here, to avoid memory latency issue. */
-			{
-				struct mali_defer_mem_block dmem_block;
-
-				INIT_LIST_HEAD(&dmem_block.free_pages);
-				atomic_set(&dmem_block.num_free_pages, 0);
-
-				if (mali_mem_prepare_mem_for_job(job, &dmem_block)) {
-					MALI_PRINT_ERROR(("Mali GP job: mali_mem_prepare_mem_for_job failed!\n"));
-					goto fail;
-				}
-				if (_MALI_OSK_ERR_OK != mali_mem_defer_bind(job, &dmem_block)) {
-					MALI_PRINT_ERROR(("gp job create, mali_mem_defer_bind failed! GP %x fail!", job));
-					goto fail;
-				}
-			}
-
-			if (uargs->varying_memsize > MALI_UK_BIG_VARYING_SIZE) {
-				job->big_job = 1;
-			}
-		}
 		job->pp_tracker = pp_tracker;
 		if (NULL != job->pp_tracker) {
 			/* Take a reference on PP job's tracker that will be released when the GP
@@ -188,46 +73,16 @@ struct mali_gp_job *mali_gp_job_create(struct mali_session_data *session, _mali_
 		mali_timeline_fence_copy_uk_fence(&(job->tracker.fence), &(job->uargs.fence));
 
 		return job;
-	} else {
-		MALI_PRINT_ERROR(("Mali GP job: _mali_osk_calloc failed!\n"));
-		return NULL;
 	}
 
-
-fail:
-	_mali_osk_free(job->varying_list);
-	/* Handle allocate fail here, free all varying node */
-	{
-		struct mali_backend_bind_list *bkn, *bkn_tmp;
-		list_for_each_entry_safe(bkn, bkn_tmp , &job->vary_todo, node) {
-			list_del(&bkn->node);
-			_mali_osk_free(bkn);
-		}
-	}
-fail1:
-	_mali_osk_notification_delete(job->oom_notification);
-fail2:
-	_mali_osk_notification_delete(job->finished_notification);
-fail3:
-	_mali_osk_free(job);
 	return NULL;
 }
 
 void mali_gp_job_delete(struct mali_gp_job *job)
 {
-	struct mali_backend_bind_list *bkn, *bkn_tmp;
 	MALI_DEBUG_ASSERT_POINTER(job);
 	MALI_DEBUG_ASSERT(NULL == job->pp_tracker);
 	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->list));
-	_mali_osk_free(job->varying_list);
-
-	/* Handle allocate fail here, free all varying node */
-	list_for_each_entry_safe(bkn, bkn_tmp , &job->vary_todo, node) {
-		list_del(&bkn->node);
-		_mali_osk_free(bkn);
-	}
-
-	mali_mem_defer_dmem_free(job);
 
 	/* de-allocate the pre-allocated oom notifications */
 	if (NULL != job->oom_notification) {
diff --git a/drivers/gpu/arm/mali/common/mali_gp_job.h b/drivers/gpu/arm/mali/common/mali_gp_job.h
old mode 100755
new mode 100644
index 6a675438..fd5f2b80
--- a/drivers/gpu/arm/mali/common/mali_gp_job.h
+++ b/drivers/gpu/arm/mali/common/mali_gp_job.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -21,7 +21,6 @@
 #include "mali_executor.h"
 #include "mali_timeline.h"
 
-struct mali_defer_mem;
 /**
  * This structure represents a GP job
  *
@@ -68,21 +67,6 @@ struct mali_gp_job {
 	u32 heap_current_addr;                             /**< Holds the current HEAP address when the job has completed */
 	u32 perf_counter_value0;                           /**< Value of performance counter 0 (to be returned to user space) */
 	u32 perf_counter_value1;                           /**< Value of performance counter 1 (to be returned to user space) */
-	struct mali_defer_mem *dmem;                                          /** < used for defer bind to store dmem info */
-	struct list_head varying_alloc;                    /**< hold the list of varying allocations */
-	u32 bind_flag;                                     /** < flag for deferbind*/
-	u32 *varying_list;                                 /**< varying memory list need to to defer bind*/
-	struct list_head vary_todo;                        /**< list of backend list need to do defer bind*/
-	u32 required_varying_memsize;                      /** < size of varying memory to reallocate*/
-	u32 big_job;                                       /** < if the gp job have large varying output and may take long time*/
-};
-
-#define MALI_DEFER_BIND_MEMORY_PREPARED (0x1 << 0)
-#define MALI_DEFER_BIND_MEMORY_BINDED (0x1 << 2)
-
-struct mali_gp_allocation_node {
-	struct list_head node;
-	mali_mem_allocation *alloc;
 };
 
 struct mali_gp_job *mali_gp_job_create(struct mali_session_data *session, _mali_uk_gp_start_job_s *uargs, u32 id, struct mali_timeline_tracker *pp_tracker);
diff --git a/drivers/gpu/arm/mali/common/mali_gp_scheduler.c b/drivers/gpu/arm/mali/common/mali_gp_scheduler.c
deleted file mode 100644
index 36a29e31..00000000
--- a/drivers/gpu/arm/mali/common/mali_gp_scheduler.c
+++ /dev/null
@@ -1,701 +0,0 @@
-/*
- * Copyright (C) 2012-2013 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#include "mali_gp_scheduler.h"
-#include "mali_kernel_common.h"
-#include "mali_osk.h"
-#include "mali_osk_list.h"
-#include "mali_scheduler.h"
-#include "mali_gp.h"
-#include "mali_gp_job.h"
-#include "mali_group.h"
-#include "mali_timeline.h"
-#include "mali_osk_profiling.h"
-#include "mali_kernel_utilization.h"
-#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-#include <linux/sched.h>
-#include <trace/events/gpu.h>
-#endif
-
-enum mali_gp_slot_state {
-	MALI_GP_SLOT_STATE_IDLE,
-	MALI_GP_SLOT_STATE_WORKING,
-	MALI_GP_SLOT_STATE_DISABLED,
-};
-
-/* A render slot is an entity which jobs can be scheduled onto */
-struct mali_gp_slot {
-	struct mali_group *group;
-	/*
-	 * We keep track of the state here as well as in the group object
-	 * so we don't need to take the group lock so often (and also avoid clutter with the working lock)
-	 */
-	enum mali_gp_slot_state state;
-	u32 returned_cookie;
-};
-
-static u32 gp_version = 0;
-static _MALI_OSK_LIST_HEAD_STATIC_INIT(job_queue);      /* List of unscheduled jobs. */
-static _MALI_OSK_LIST_HEAD_STATIC_INIT(job_queue_high); /* List of unscheduled high priority jobs. */
-static struct mali_gp_slot slot;
-
-/* Variables to allow safe pausing of the scheduler */
-static _mali_osk_wait_queue_t *gp_scheduler_working_wait_queue = NULL;
-static u32 pause_count = 0;
-
-static mali_bool mali_gp_scheduler_is_suspended(void *data);
-static void mali_gp_scheduler_job_queued(void);
-static void mali_gp_scheduler_job_completed(void);
-
-#if defined(MALI_UPPER_HALF_SCHEDULING)
-static _mali_osk_spinlock_irq_t *gp_scheduler_lock = NULL;
-#else
-static _mali_osk_spinlock_t *gp_scheduler_lock = NULL;
-#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
-
-_mali_osk_errcode_t mali_gp_scheduler_initialize(void)
-{
-	u32 num_groups;
-	u32 i;
-	_mali_osk_errcode_t ret = _MALI_OSK_ERR_OK;
-
-#if defined(MALI_UPPER_HALF_SCHEDULING)
-	gp_scheduler_lock = _mali_osk_spinlock_irq_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_SCHEDULER);
-#else
-	gp_scheduler_lock = _mali_osk_spinlock_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_SCHEDULER);
-#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
-	if (NULL == gp_scheduler_lock) {
-		ret = _MALI_OSK_ERR_NOMEM;
-		goto cleanup;
-	}
-
-	gp_scheduler_working_wait_queue = _mali_osk_wait_queue_init();
-	if (NULL == gp_scheduler_working_wait_queue) {
-		ret = _MALI_OSK_ERR_NOMEM;
-		goto cleanup;
-	}
-
-	/* Find all the available GP cores */
-	num_groups = mali_group_get_glob_num_groups();
-	for (i = 0; i < num_groups; i++) {
-		struct mali_group *group = mali_group_get_glob_group(i);
-		MALI_DEBUG_ASSERT(NULL != group);
-		if (NULL != group) {
-			struct mali_gp_core *gp_core = mali_group_get_gp_core(group);
-			if (NULL != gp_core) {
-				if (0 == gp_version) {
-					/* Retrieve GP version */
-					gp_version = mali_gp_core_get_version(gp_core);
-				}
-				slot.group = group;
-				slot.state = MALI_GP_SLOT_STATE_IDLE;
-				break; /* There is only one GP, no point in looking for more */
-			}
-		} else {
-			ret = _MALI_OSK_ERR_ITEM_NOT_FOUND;
-			goto cleanup;
-		}
-	}
-
-	return _MALI_OSK_ERR_OK;
-
-cleanup:
-	if (NULL != gp_scheduler_working_wait_queue) {
-		_mali_osk_wait_queue_term(gp_scheduler_working_wait_queue);
-		gp_scheduler_working_wait_queue = NULL;
-	}
-
-	if (NULL != gp_scheduler_lock) {
-#if defined(MALI_UPPER_HALF_SCHEDULING)
-		_mali_osk_spinlock_irq_term(gp_scheduler_lock);
-#else
-		_mali_osk_spinlock_term(gp_scheduler_lock);
-#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
-		gp_scheduler_lock = NULL;
-	}
-
-	return ret;
-}
-
-void mali_gp_scheduler_terminate(void)
-{
-	MALI_DEBUG_ASSERT(   MALI_GP_SLOT_STATE_IDLE     == slot.state
-	                     || MALI_GP_SLOT_STATE_DISABLED == slot.state);
-	MALI_DEBUG_ASSERT_POINTER(slot.group);
-	mali_group_delete(slot.group);
-
-	_mali_osk_wait_queue_term(gp_scheduler_working_wait_queue);
-
-#if defined(MALI_UPPER_HALF_SCHEDULING)
-	_mali_osk_spinlock_irq_term(gp_scheduler_lock);
-#else
-	_mali_osk_spinlock_term(gp_scheduler_lock);
-#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
-}
-
-MALI_STATIC_INLINE void mali_gp_scheduler_lock(void)
-{
-#if defined(MALI_UPPER_HALF_SCHEDULING)
-	_mali_osk_spinlock_irq_lock(gp_scheduler_lock);
-#else
-	_mali_osk_spinlock_lock(gp_scheduler_lock);
-#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
-	MALI_DEBUG_PRINT(5, ("Mali GP scheduler: GP scheduler lock taken\n"));
-}
-
-MALI_STATIC_INLINE void mali_gp_scheduler_unlock(void)
-{
-	MALI_DEBUG_PRINT(5, ("Mali GP scheduler: Releasing GP scheduler lock\n"));
-#if defined(MALI_UPPER_HALF_SCHEDULING)
-	_mali_osk_spinlock_irq_unlock(gp_scheduler_lock);
-#else
-	_mali_osk_spinlock_unlock(gp_scheduler_lock);
-#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
-}
-
-#if defined(DEBUG)
-#define MALI_ASSERT_GP_SCHEDULER_LOCKED() MALI_DEBUG_ASSERT_LOCK_HELD(gp_scheduler_lock)
-#else
-#define MALI_ASSERT_GP_SCHEDULER_LOCKED() do {} while (0)
-#endif /* defined(DEBUG) */
-
-/* Group and scheduler must be locked when entering this function.  Both will be unlocked before
- * exiting. */
-static void mali_gp_scheduler_schedule_internal_and_unlock(void)
-{
-	struct mali_gp_job *job = NULL;
-
-	MALI_DEBUG_ASSERT_LOCK_HELD(slot.group->lock);
-	MALI_DEBUG_ASSERT_LOCK_HELD(gp_scheduler_lock);
-
-	if (0 < pause_count || MALI_GP_SLOT_STATE_IDLE != slot.state ||
-	    (_mali_osk_list_empty(&job_queue) && _mali_osk_list_empty(&job_queue_high))) {
-		mali_gp_scheduler_unlock();
-		mali_group_unlock(slot.group);
-		MALI_DEBUG_PRINT(4, ("Mali GP scheduler: Nothing to schedule (paused=%u, idle slots=%u)\n",
-		                     pause_count, MALI_GP_SLOT_STATE_IDLE == slot.state ? 1 : 0));
-#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-		trace_gpu_sched_switch(mali_gp_get_hw_core_desc(group->gp_core), sched_clock(), 0, 0, 0);
-#endif
-		return; /* Nothing to do, so early out */
-	}
-
-	/* Get next job in queue */
-	if (!_mali_osk_list_empty(&job_queue_high)) {
-		job = _MALI_OSK_LIST_ENTRY(job_queue_high.next, struct mali_gp_job, list);
-	} else {
-		MALI_DEBUG_ASSERT(!_mali_osk_list_empty(&job_queue));
-		job = _MALI_OSK_LIST_ENTRY(job_queue.next, struct mali_gp_job, list);
-	}
-
-	MALI_DEBUG_ASSERT_POINTER(job);
-
-	/* Remove the job from queue */
-	_mali_osk_list_del(&job->list);
-
-	/* Mark slot as busy */
-	slot.state = MALI_GP_SLOT_STATE_WORKING;
-
-	mali_gp_scheduler_unlock();
-
-	MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Starting job %u (0x%08X)\n", mali_gp_job_get_id(job), job));
-
-	mali_group_start_gp_job(slot.group, job);
-	mali_group_unlock(slot.group);
-}
-
-void mali_gp_scheduler_schedule(void)
-{
-	mali_group_lock(slot.group);
-	mali_gp_scheduler_lock();
-
-	mali_gp_scheduler_schedule_internal_and_unlock();
-}
-
-static void mali_gp_scheduler_return_job_to_user(struct mali_gp_job *job, mali_bool success)
-{
-	_mali_uk_gp_job_finished_s *jobres = job->finished_notification->result_buffer;
-	_mali_osk_memset(jobres, 0, sizeof(_mali_uk_gp_job_finished_s)); /* @@@@ can be removed once we initialize all members in this struct */
-	jobres->user_job_ptr = mali_gp_job_get_user_id(job);
-	if (MALI_TRUE == success) {
-		jobres->status = _MALI_UK_JOB_STATUS_END_SUCCESS;
-	} else {
-		jobres->status = _MALI_UK_JOB_STATUS_END_UNKNOWN_ERR;
-	}
-
-	jobres->heap_current_addr = mali_gp_job_get_current_heap_addr(job);
-	jobres->perf_counter0 = mali_gp_job_get_perf_counter_value0(job);
-	jobres->perf_counter1 = mali_gp_job_get_perf_counter_value1(job);
-
-	mali_session_send_notification(mali_gp_job_get_session(job), job->finished_notification);
-	job->finished_notification = NULL;
-
-	mali_gp_job_delete(job);
-	mali_gp_scheduler_job_completed();
-}
-
-/* Group must be locked when entering this function.  Will be unlocked before exiting. */
-void mali_gp_scheduler_job_done(struct mali_group *group, struct mali_gp_job *job, mali_bool success)
-{
-	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
-
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_POINTER(job);
-
-	MALI_DEBUG_ASSERT_LOCK_HELD(group->lock);
-	MALI_DEBUG_ASSERT(slot.group == group);
-
-	MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Job %u (0x%08X) completed (%s)\n", mali_gp_job_get_id(job), job, success ? "success" : "failure"));
-
-	/* Release tracker. */
-	schedule_mask |= mali_timeline_tracker_release(&job->tracker);
-
-	/* Signal PP job. */
-	schedule_mask |= mali_gp_job_signal_pp_tracker(job, success);
-
-	mali_gp_scheduler_lock();
-
-	/* Mark slot as idle again */
-	slot.state = MALI_GP_SLOT_STATE_IDLE;
-
-	/* If paused, then this was the last job, so wake up sleeping workers */
-	if (pause_count > 0) {
-		_mali_osk_wait_queue_wake_up(gp_scheduler_working_wait_queue);
-	}
-
-	/* Schedule any queued GP jobs on this group. */
-	mali_gp_scheduler_schedule_internal_and_unlock();
-
-	/* GP is now scheduled, removing it from the mask. */
-	schedule_mask &= ~MALI_SCHEDULER_MASK_GP;
-
-	if (MALI_SCHEDULER_MASK_EMPTY != schedule_mask) {
-		/* Releasing the tracker activated other jobs that need scheduling. */
-		mali_scheduler_schedule_from_mask(schedule_mask, MALI_FALSE);
-	}
-
-	/* Sends the job end message to user space and free the job object */
-	mali_gp_scheduler_return_job_to_user(job, success);
-}
-
-void mali_gp_scheduler_oom(struct mali_group *group, struct mali_gp_job *job)
-{
-	_mali_uk_gp_job_suspended_s * jobres;
-	_mali_osk_notification_t * notification;
-
-	mali_gp_scheduler_lock();
-
-	notification = job->oom_notification;
-	job->oom_notification = NULL;
-	slot.returned_cookie = mali_gp_job_get_id(job);
-
-	jobres = (_mali_uk_gp_job_suspended_s *)notification->result_buffer;
-	jobres->user_job_ptr = mali_gp_job_get_user_id(job);
-	jobres->cookie = mali_gp_job_get_id(job);
-
-	mali_gp_scheduler_unlock();
-
-	mali_session_send_notification(mali_gp_job_get_session(job), notification);
-
-	/*
-	* If this function failed, then we could return the job to user space right away,
-	* but there is a job timer anyway that will do that eventually.
-	* This is not exactly a common case anyway.
-	*/
-}
-
-void mali_gp_scheduler_suspend(void)
-{
-	mali_gp_scheduler_lock();
-	pause_count++; /* Increment the pause_count so that no more jobs will be scheduled */
-	mali_gp_scheduler_unlock();
-
-	_mali_osk_wait_queue_wait_event(gp_scheduler_working_wait_queue, mali_gp_scheduler_is_suspended, NULL);
-}
-
-void mali_gp_scheduler_resume(void)
-{
-	mali_gp_scheduler_lock();
-	pause_count--; /* Decrement pause_count to allow scheduling again (if it reaches 0) */
-	mali_gp_scheduler_unlock();
-	if (0 == pause_count) {
-		mali_gp_scheduler_schedule();
-	}
-}
-
-mali_timeline_point mali_gp_scheduler_submit_job(struct mali_session_data *session, struct mali_gp_job *job)
-{
-	mali_timeline_point point;
-
-	MALI_DEBUG_ASSERT_POINTER(session);
-	MALI_DEBUG_ASSERT_POINTER(job);
-
-	mali_gp_scheduler_job_queued();
-
-	/* Add job to Timeline system. */
-	point = mali_timeline_system_add_tracker(session->timeline_system, &job->tracker, MALI_TIMELINE_GP);
-
-	return point;
-}
-
-_mali_osk_errcode_t _mali_ukk_gp_start_job(void *ctx, _mali_uk_gp_start_job_s *uargs)
-{
-	struct mali_session_data *session;
-	struct mali_gp_job *job;
-	mali_timeline_point point;
-	u32 __user *timeline_point_ptr = NULL;
-
-	MALI_DEBUG_ASSERT_POINTER(uargs);
-	MALI_DEBUG_ASSERT_POINTER(ctx);
-
-	session = (struct mali_session_data*)ctx;
-
-	job = mali_gp_job_create(session, uargs, mali_scheduler_get_new_id(), NULL);
-	if (NULL == job) {
-		MALI_PRINT_ERROR(("Failed to create GP job.\n"));
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	timeline_point_ptr = (u32 __user *) job->uargs.timeline_point_ptr;
-
-	point = mali_gp_scheduler_submit_job(session, job);
-
-	if (0 != _mali_osk_put_user(((u32) point), timeline_point_ptr)) {
-		/* Let user space know that something failed after the job was started. */
-		return _MALI_OSK_ERR_ITEM_NOT_FOUND;
-	}
-
-	return _MALI_OSK_ERR_OK;
-}
-
-_mali_osk_errcode_t _mali_ukk_get_gp_number_of_cores(_mali_uk_get_gp_number_of_cores_s *args)
-{
-	MALI_DEBUG_ASSERT_POINTER(args);
-	MALI_CHECK_NON_NULL(args->ctx, _MALI_OSK_ERR_INVALID_ARGS);
-	args->number_of_cores = 1;
-	return _MALI_OSK_ERR_OK;
-}
-
-_mali_osk_errcode_t _mali_ukk_get_gp_core_version(_mali_uk_get_gp_core_version_s *args)
-{
-	MALI_DEBUG_ASSERT_POINTER(args);
-	MALI_CHECK_NON_NULL(args->ctx, _MALI_OSK_ERR_INVALID_ARGS);
-	args->version = gp_version;
-	return _MALI_OSK_ERR_OK;
-}
-
-_mali_osk_errcode_t _mali_ukk_gp_suspend_response(_mali_uk_gp_suspend_response_s *args)
-{
-	struct mali_session_data *session;
-	struct mali_gp_job *resumed_job;
-	_mali_osk_notification_t *new_notification = 0;
-
-	MALI_DEBUG_ASSERT_POINTER(args);
-
-	if (NULL == args->ctx) {
-		return _MALI_OSK_ERR_INVALID_ARGS;
-	}
-
-	session = (struct mali_session_data*)args->ctx;
-	if (NULL == session) {
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	if (_MALIGP_JOB_RESUME_WITH_NEW_HEAP == args->code) {
-		new_notification = _mali_osk_notification_create(_MALI_NOTIFICATION_GP_STALLED, sizeof(_mali_uk_gp_job_suspended_s));
-
-		if (NULL == new_notification) {
-			MALI_PRINT_ERROR(("Mali GP scheduler: Failed to allocate notification object. Will abort GP job.\n"));
-			mali_group_lock(slot.group);
-			mali_group_abort_gp_job(slot.group, args->cookie);
-			mali_group_unlock(slot.group);
-			return _MALI_OSK_ERR_FAULT;
-		}
-	}
-
-	mali_group_lock(slot.group);
-
-	if (_MALIGP_JOB_RESUME_WITH_NEW_HEAP == args->code) {
-		MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Resuming job %u with new heap; 0x%08X - 0x%08X\n", args->cookie, args->arguments[0], args->arguments[1]));
-
-		resumed_job = mali_group_resume_gp_with_new_heap(slot.group, args->cookie, args->arguments[0], args->arguments[1]);
-		if (NULL != resumed_job) {
-			resumed_job->oom_notification = new_notification;
-			mali_group_unlock(slot.group);
-			return _MALI_OSK_ERR_OK;
-		} else {
-			mali_group_unlock(slot.group);
-			_mali_osk_notification_delete(new_notification);
-			return _MALI_OSK_ERR_FAULT;
-		}
-	}
-
-	MALI_DEBUG_PRINT(2, ("Mali GP scheduler: Aborting job %u, no new heap provided\n", args->cookie));
-	mali_group_abort_gp_job(slot.group, args->cookie);
-	mali_group_unlock(slot.group);
-	return _MALI_OSK_ERR_OK;
-}
-
-void mali_gp_scheduler_abort_session(struct mali_session_data *session)
-{
-	struct mali_gp_job *job, *tmp;
-	_MALI_OSK_LIST_HEAD_STATIC_INIT(removed_jobs);
-
-	MALI_DEBUG_ASSERT_POINTER(session);
-	MALI_DEBUG_ASSERT(session->is_aborting);
-
-	MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Aborting all jobs from session 0x%08X.\n", session));
-
-	mali_gp_scheduler_lock();
-
-	/* Find all jobs from the aborting session. */
-	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &job_queue, struct mali_gp_job, list) {
-		if (job->session == session) {
-			MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Removing job %u (0x%08X) from queue.\n", mali_gp_job_get_id(job), job));
-			_mali_osk_list_move(&job->list, &removed_jobs);
-		}
-	}
-
-	/* Find all high priority jobs from the aborting session. */
-	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &job_queue_high, struct mali_gp_job, list) {
-		if (job->session == session) {
-			MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Removing job %u (0x%08X) from queue.\n", mali_gp_job_get_id(job), job));
-			_mali_osk_list_move(&job->list, &removed_jobs);
-		}
-	}
-
-	mali_gp_scheduler_unlock();
-
-	/* Release and delete all found jobs from the aborting session. */
-	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &removed_jobs, struct mali_gp_job, list) {
-		mali_timeline_tracker_release(&job->tracker);
-		mali_gp_job_signal_pp_tracker(job, MALI_FALSE);
-		mali_gp_job_delete(job);
-		mali_gp_scheduler_job_completed();
-	}
-
-	/* Abort any running jobs from the session. */
-	mali_group_abort_session(slot.group, session);
-}
-
-static mali_bool mali_gp_scheduler_is_suspended(void *data)
-{
-	mali_bool ret;
-
-	/* This callback does not use the data pointer. */
-	MALI_IGNORE(data);
-
-	mali_gp_scheduler_lock();
-	ret = pause_count > 0 && (slot.state == MALI_GP_SLOT_STATE_IDLE || slot.state == MALI_GP_SLOT_STATE_DISABLED);
-	mali_gp_scheduler_unlock();
-
-	return ret;
-}
-
-
-#if MALI_STATE_TRACKING
-u32 mali_gp_scheduler_dump_state(char *buf, u32 size)
-{
-	int n = 0;
-
-	n += _mali_osk_snprintf(buf + n, size - n, "GP\n");
-	n += _mali_osk_snprintf(buf + n, size - n, "\tQueue is %s\n", _mali_osk_list_empty(&job_queue) ? "empty" : "not empty");
-	n += _mali_osk_snprintf(buf + n, size - n, "\tHigh priority queue is %s\n", _mali_osk_list_empty(&job_queue_high) ? "empty" : "not empty");
-
-	n += mali_group_dump_state(slot.group, buf + n, size - n);
-	n += _mali_osk_snprintf(buf + n, size - n, "\n");
-
-	return n;
-}
-#endif
-
-void mali_gp_scheduler_reset_all_groups(void)
-{
-	if (NULL != slot.group) {
-		mali_group_lock(slot.group);
-		mali_group_reset(slot.group);
-		mali_group_unlock(slot.group);
-	}
-}
-
-void mali_gp_scheduler_zap_all_active(struct mali_session_data *session)
-{
-	if (NULL != slot.group) {
-		mali_group_zap_session(slot.group, session);
-	}
-}
-
-void mali_gp_scheduler_enable_group(struct mali_group *group)
-{
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT(slot.group == group);
-	MALI_DEBUG_PRINT(2, ("Mali GP scheduler: enabling gp group %p\n", group));
-
-	mali_group_lock(group);
-
-	if (MALI_GROUP_STATE_DISABLED != group->state) {
-		mali_group_unlock(group);
-		MALI_DEBUG_PRINT(2, ("Mali GP scheduler: gp group %p already enabled\n", group));
-		return;
-	}
-
-	mali_gp_scheduler_lock();
-
-	MALI_DEBUG_ASSERT(MALI_GROUP_STATE_DISABLED == group->state);
-	MALI_DEBUG_ASSERT(MALI_GP_SLOT_STATE_DISABLED == slot.state);
-	slot.state = MALI_GP_SLOT_STATE_IDLE;
-	group->state = MALI_GROUP_STATE_IDLE;
-
-	mali_group_power_on_group(group);
-	mali_group_reset(group);
-
-	/* Pick up any jobs that might have been queued while the GP group was disabled. */
-	mali_gp_scheduler_schedule_internal_and_unlock();
-}
-
-void mali_gp_scheduler_disable_group(struct mali_group *group)
-{
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT(slot.group == group);
-	MALI_DEBUG_PRINT(2, ("Mali GP scheduler: disabling gp group %p\n", group));
-
-	mali_gp_scheduler_suspend();
-	mali_group_lock(group);
-	mali_gp_scheduler_lock();
-
-	MALI_DEBUG_ASSERT(   MALI_GROUP_STATE_IDLE     == group->state
-	                     || MALI_GROUP_STATE_DISABLED == group->state);
-
-	if (MALI_GROUP_STATE_DISABLED == group->state) {
-		MALI_DEBUG_ASSERT(MALI_GP_SLOT_STATE_DISABLED == slot.state);
-		MALI_DEBUG_PRINT(2, ("Mali GP scheduler: gp group %p already disabled\n", group));
-	} else {
-		MALI_DEBUG_ASSERT(MALI_GP_SLOT_STATE_IDLE == slot.state);
-		slot.state = MALI_GP_SLOT_STATE_DISABLED;
-		group->state = MALI_GROUP_STATE_DISABLED;
-
-		mali_group_power_off_group(group, MALI_TRUE);
-	}
-
-	mali_gp_scheduler_unlock();
-	mali_group_unlock(group);
-	mali_gp_scheduler_resume();
-}
-
-static mali_scheduler_mask mali_gp_scheduler_queue_job(struct mali_gp_job *job)
-{
-	_mali_osk_list_t *queue = NULL;
-	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
-	struct mali_gp_job *iter, *tmp;
-
-	MALI_DEBUG_ASSERT_POINTER(job);
-	MALI_DEBUG_ASSERT_POINTER(job->session);
-
-	MALI_DEBUG_ASSERT_LOCK_HELD(gp_scheduler_lock);
-
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE | MALI_PROFILING_EVENT_CHANNEL_SOFTWARE | MALI_PROFILING_EVENT_REASON_SINGLE_SW_GP_ENQUEUE, job->pid, job->tid, job->uargs.frame_builder_id, job->uargs.flush_id, 0);
-
-	job->cache_order = mali_scheduler_get_new_cache_order();
-
-	/* Determine which queue the job should be added to. */
-	if (job->session->use_high_priority_job_queue) {
-		queue = &job_queue_high;
-	} else {
-		queue = &job_queue;
-	}
-
-	/* Find position in queue where job should be added. */
-	_MALI_OSK_LIST_FOREACHENTRY_REVERSE(iter, tmp, queue, struct mali_gp_job, list) {
-		if (mali_gp_job_is_after(job, iter)) {
-			break;
-		}
-	}
-
-	/* Add job to queue. */
-	_mali_osk_list_add(&job->list, &iter->list);
-
-	/* Set schedule bitmask if the GP core is idle. */
-	if (MALI_GP_SLOT_STATE_IDLE == slot.state) {
-		schedule_mask |= MALI_SCHEDULER_MASK_GP;
-	}
-
-#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-	trace_gpu_job_enqueue(mali_gp_job_get_tid(job), mali_gp_job_get_id(job), "GP");
-#endif
-
-	MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Job %u (0x%08X) queued\n", mali_gp_job_get_id(job), job));
-
-	return schedule_mask;
-}
-
-mali_scheduler_mask mali_gp_scheduler_activate_job(struct mali_gp_job *job)
-{
-	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
-
-	MALI_DEBUG_ASSERT_POINTER(job);
-	MALI_DEBUG_ASSERT_POINTER(job->session);
-
-	MALI_DEBUG_PRINT(4, ("Mali GP scheduler: Timeline activation for job %u (0x%08X).\n", mali_gp_job_get_id(job), job));
-
-	mali_gp_scheduler_lock();
-
-	if (unlikely(job->session->is_aborting)) {
-		/* Before checking if the session is aborting, the scheduler must be locked. */
-		MALI_DEBUG_ASSERT_LOCK_HELD(gp_scheduler_lock);
-
-		MALI_DEBUG_PRINT(3, ("Mali GP scheduler: Job %u (0x%08X) activated while session is aborting.\n", mali_gp_job_get_id(job), job));
-
-		/* This job should not be on any list. */
-		MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->list));
-
-		mali_gp_scheduler_unlock();
-
-		/* Release tracker and delete job. */
-		mali_timeline_tracker_release(&job->tracker);
-		mali_gp_job_signal_pp_tracker(job, MALI_FALSE);
-		mali_gp_job_delete(job);
-		mali_gp_scheduler_job_completed();
-
-		/* Since we are aborting we ignore the scheduler mask. */
-		return MALI_SCHEDULER_MASK_EMPTY;
-	}
-
-	/* GP job is ready to run, queue it. */
-	schedule_mask = mali_gp_scheduler_queue_job(job);
-
-	mali_gp_scheduler_unlock();
-
-	return schedule_mask;
-}
-
-static void mali_gp_scheduler_job_queued(void)
-{
-	/* We hold a PM reference for every job we hold queued (and running) */
-	_mali_osk_pm_dev_ref_add();
-
-	if (mali_utilization_enabled()) {
-		/*
-		 * We cheat a little bit by counting the PP as busy from the time a GP job is queued.
-		 * This will be fine because we only loose the tiny idle gap between jobs, but
-		 * we will instead get less utilization work to do (less locks taken)
-		 */
-		mali_utilization_gp_start();
-	}
-}
-
-static void mali_gp_scheduler_job_completed(void)
-{
-	/* Release the PM reference we got in the mali_gp_scheduler_job_queued() function */
-	_mali_osk_pm_dev_ref_dec();
-
-	if (mali_utilization_enabled()) {
-		mali_utilization_gp_end();
-	}
-}
diff --git a/drivers/gpu/arm/mali/common/mali_gp_scheduler.h b/drivers/gpu/arm/mali/common/mali_gp_scheduler.h
deleted file mode 100644
index 8be9c47c..00000000
--- a/drivers/gpu/arm/mali/common/mali_gp_scheduler.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2012-2013 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#ifndef __MALI_GP_SCHEDULER_H__
-#define __MALI_GP_SCHEDULER_H__
-
-#include "mali_osk.h"
-#include "mali_gp_job.h"
-#include "mali_group.h"
-
-_mali_osk_errcode_t mali_gp_scheduler_initialize(void);
-void mali_gp_scheduler_terminate(void);
-
-void mali_gp_scheduler_job_done(struct mali_group *group, struct mali_gp_job *job, mali_bool success);
-void mali_gp_scheduler_oom(struct mali_group *group, struct mali_gp_job *job);
-u32 mali_gp_scheduler_dump_state(char *buf, u32 size);
-
-void mali_gp_scheduler_suspend(void);
-void mali_gp_scheduler_resume(void);
-
-/**
- * @brief Abort all running and queued GP jobs from session.
- *
-* This functions aborts all GP jobs from the specified session. Queued jobs are removed from the
-* queue and jobs currently running on a core will be aborted.
- *
- * @param session Session that is aborting.
- */
-void mali_gp_scheduler_abort_session(struct mali_session_data *session);
-
-/**
- * @brief Reset all groups
- *
- * This function resets all groups known by the GP scheuduler. This must be
- * called after the Mali HW has been powered on in order to reset the HW.
- */
-void mali_gp_scheduler_reset_all_groups(void);
-
-/**
- * @brief Zap TLB on all groups with \a session active
- *
- * The scheculer will zap the session on all groups it owns.
- */
-void mali_gp_scheduler_zap_all_active(struct mali_session_data *session);
-
-/**
- * @brief Re-enable a group that has been disabled with mali_gp_scheduler_disable_group
- *
- * If a Mali PMU is present, the group will be powered back on and added back
- * into the GP scheduler.
- *
- * @param group Pointer to the group to enable
- */
-void mali_gp_scheduler_enable_group(struct mali_group *group);
-
-/**
- * @brief Disable a group
- *
- * The group will be taken out of the GP scheduler and powered off, if a Mali
- * PMU is present.
- *
- * @param group Pointer to the group to disable
- */
-void mali_gp_scheduler_disable_group(struct mali_group *group);
-
-/**
- * @brief Used by the Timeline system to queue a GP job.
- *
- * @note @ref mali_scheduler_schedule_from_mask() should be called if this function returns non-zero.
- *
- * @param job The GP job that is being activated.
- *
- * @return A scheduling bitmask that can be used to decide if scheduling is necessary after this
- * call.
- */
-mali_scheduler_mask mali_gp_scheduler_activate_job(struct mali_gp_job *job);
-
-/**
- * @brief Schedule queued jobs on idle cores.
- */
-void mali_gp_scheduler_schedule(void);
-
-/**
- * @brief Submit a GP job to the GP scheduler.
- *
- * This will add the GP job to the Timeline system.
- *
- * @param session Session this job belongs to.
- * @param job GP job that will be submitted
- * @return Point on GP timeline for job.
- */
-mali_timeline_point mali_gp_scheduler_submit_job(struct mali_session_data *session, struct mali_gp_job *job);
-
-#endif /* __MALI_GP_SCHEDULER_H__ */
diff --git a/drivers/gpu/arm/mali/common/mali_group.c b/drivers/gpu/arm/mali/common/mali_group.c
old mode 100755
new mode 100644
index 9e31802e..bd67d5a9
--- a/drivers/gpu/arm/mali/common/mali_group.c
+++ b/drivers/gpu/arm/mali/common/mali_group.c
@@ -1,12 +1,15 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
+
+#include <linux/types.h>
+#include <mach/cpu.h>
 #include "mali_kernel_common.h"
 #include "mali_group.h"
 #include "mali_osk.h"
@@ -18,10 +21,10 @@
 #include "mali_broadcast.h"
 #include "mali_scheduler.h"
 #include "mali_osk_profiling.h"
-#include "mali_osk_mali.h"
 #include "mali_pm_domain.h"
 #include "mali_pm.h"
 #include "mali_executor.h"
+#include <mali_platform.h>
 
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
 #include <linux/sched.h>
@@ -45,671 +48,606 @@ static void mali_group_bottom_half_mmu(void *data);
 static void mali_group_bottom_half_gp(void *data);
 static void mali_group_bottom_half_pp(void *data);
 static void mali_group_timeout(void *data);
+
 static void mali_group_reset_pp(struct mali_group *group);
 static void mali_group_reset_mmu(struct mali_group *group);
 
-static void mali_group_activate_page_directory(struct mali_group *group, struct mali_session_data *session, mali_bool is_reload);
+static void mali_group_activate_page_directory(struct mali_group *group, struct mali_session_data *session);
 static void mali_group_recovery_reset(struct mali_group *group);
 
 struct mali_group *mali_group_create(struct mali_l2_cache_core *core,
-				     struct mali_dlbu_core *dlbu,
-				     struct mali_bcast_unit *bcast,
-				     u32 domain_index)
+        struct mali_dlbu_core *dlbu,
+        struct mali_bcast_unit *bcast,
+        u32 domain_index)
 {
-	struct mali_group *group = NULL;
-
-	if (mali_global_num_groups >= MALI_MAX_NUMBER_OF_GROUPS) {
-		MALI_PRINT_ERROR(("Mali group: Too many group objects created\n"));
-		return NULL;
-	}
-
-	group = _mali_osk_calloc(1, sizeof(struct mali_group));
-	if (NULL != group) {
-		group->timeout_timer = _mali_osk_timer_init();
-		if (NULL != group->timeout_timer) {
-			_mali_osk_timer_setcallback(group->timeout_timer, mali_group_timeout, (void *)group);
-
-			group->l2_cache_core[0] = core;
-			_mali_osk_list_init(&group->group_list);
-			_mali_osk_list_init(&group->executor_list);
-			_mali_osk_list_init(&group->pm_domain_list);
-			group->bcast_core = bcast;
-			group->dlbu_core = dlbu;
-
-			/* register this object as a part of the correct power domain */
-			if ((NULL != core) || (NULL != dlbu) || (NULL != bcast))
-				group->pm_domain = mali_pm_register_group(domain_index, group);
-
-			mali_global_groups[mali_global_num_groups] = group;
-			mali_global_num_groups++;
-
-			return group;
-		}
-		_mali_osk_free(group);
-	}
-
-	return NULL;
+    struct mali_group *group = NULL;
+
+    if (mali_global_num_groups >= MALI_MAX_NUMBER_OF_GROUPS) {
+        MALI_PRINT_ERROR(("Mali group: Too many group objects created\n"));
+        return NULL;
+    }
+
+    group = _mali_osk_calloc(1, sizeof(struct mali_group));
+    if (NULL != group) {
+        group->timeout_timer = _mali_osk_timer_init();
+        if (NULL != group->timeout_timer) {
+            _mali_osk_timer_setcallback(group->timeout_timer, mali_group_timeout, (void *)group);
+
+            group->l2_cache_core[0] = core;
+            _mali_osk_list_init(&group->group_list);
+            _mali_osk_list_init(&group->executor_list);
+            _mali_osk_list_init(&group->pm_domain_list);
+            group->bcast_core = bcast;
+            group->dlbu_core = dlbu;
+
+            /* register this object as a part of the correct power domain */
+            if ((NULL != core) || (NULL != dlbu) || (NULL != bcast))
+                group->pm_domain = mali_pm_register_group(domain_index, group);
+
+            mali_global_groups[mali_global_num_groups] = group;
+            mali_global_num_groups++;
+
+            return group;
+        }
+        _mali_osk_free(group);
+    }
+
+    return NULL;
 }
 
 void mali_group_delete(struct mali_group *group)
 {
-	u32 i;
-
-	MALI_DEBUG_PRINT(4, ("Deleting group %s\n",
-			     mali_group_core_description(group)));
-
-	MALI_DEBUG_ASSERT(NULL == group->parent_group);
-	MALI_DEBUG_ASSERT((MALI_GROUP_STATE_INACTIVE == group->state) || ((MALI_GROUP_STATE_ACTIVATION_PENDING == group->state)));
-
-	/* Delete the resources that this group owns */
-	if (NULL != group->gp_core) {
-		mali_gp_delete(group->gp_core);
-	}
-
-	if (NULL != group->pp_core) {
-		mali_pp_delete(group->pp_core);
-	}
-
-	if (NULL != group->mmu) {
-		mali_mmu_delete(group->mmu);
-	}
-
-	if (mali_group_is_virtual(group)) {
-		/* Remove all groups from virtual group */
-		struct mali_group *child;
-		struct mali_group *temp;
-
-		_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-			child->parent_group = NULL;
-			mali_group_delete(child);
-		}
-
-		mali_dlbu_delete(group->dlbu_core);
-
-		if (NULL != group->bcast_core) {
-			mali_bcast_unit_delete(group->bcast_core);
-		}
-	}
-
-	for (i = 0; i < mali_global_num_groups; i++) {
-		if (mali_global_groups[i] == group) {
-			mali_global_groups[i] = NULL;
-			mali_global_num_groups--;
-
-			if (i != mali_global_num_groups) {
-				/* We removed a group from the middle of the array -- move the last
-				 * group to the current position to close the gap */
-				mali_global_groups[i] = mali_global_groups[mali_global_num_groups];
-				mali_global_groups[mali_global_num_groups] = NULL;
-			}
-
-			break;
-		}
-	}
-
-	if (NULL != group->timeout_timer) {
-		_mali_osk_timer_del(group->timeout_timer);
-		_mali_osk_timer_term(group->timeout_timer);
-	}
-
-	if (NULL != group->bottom_half_work_mmu) {
-		_mali_osk_wq_delete_work(group->bottom_half_work_mmu);
-	}
-
-	if (NULL != group->bottom_half_work_gp) {
-		_mali_osk_wq_delete_work(group->bottom_half_work_gp);
-	}
-
-	if (NULL != group->bottom_half_work_pp) {
-		_mali_osk_wq_delete_work(group->bottom_half_work_pp);
-	}
-
-	_mali_osk_free(group);
+    u32 i;
+
+    MALI_DEBUG_PRINT(4, ("Deleting group %s\n",
+                mali_group_core_description(group)));
+
+    MALI_DEBUG_ASSERT(NULL == group->parent_group);
+    MALI_DEBUG_ASSERT((MALI_GROUP_STATE_INACTIVE == group->state) || ((MALI_GROUP_STATE_ACTIVATION_PENDING == group->state)));
+
+    /* Delete the resources that this group owns */
+    if (NULL != group->gp_core) {
+        mali_gp_delete(group->gp_core);
+    }
+
+    if (NULL != group->pp_core) {
+        mali_pp_delete(group->pp_core);
+    }
+
+    if (NULL != group->mmu) {
+        mali_mmu_delete(group->mmu);
+    }
+
+    if (mali_group_is_virtual(group)) {
+        /* Remove all groups from virtual group */
+        struct mali_group *child;
+        struct mali_group *temp;
+
+        _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+            child->parent_group = NULL;
+            mali_group_delete(child);
+        }
+
+        mali_dlbu_delete(group->dlbu_core);
+
+        if (NULL != group->bcast_core) {
+            mali_bcast_unit_delete(group->bcast_core);
+        }
+    }
+
+    for (i = 0; i < mali_global_num_groups; i++) {
+        if (mali_global_groups[i] == group) {
+            mali_global_groups[i] = NULL;
+            mali_global_num_groups--;
+
+            if (i != mali_global_num_groups) {
+                /* We removed a group from the middle of the array -- move the last
+                 * group to the current position to close the gap */
+                mali_global_groups[i] = mali_global_groups[mali_global_num_groups];
+                mali_global_groups[mali_global_num_groups] = NULL;
+            }
+
+            break;
+        }
+    }
+
+    if (NULL != group->timeout_timer) {
+        _mali_osk_timer_del(group->timeout_timer);
+        _mali_osk_timer_term(group->timeout_timer);
+    }
+
+    if (NULL != group->bottom_half_work_mmu) {
+        _mali_osk_wq_delete_work(group->bottom_half_work_mmu);
+    }
+
+    if (NULL != group->bottom_half_work_gp) {
+        _mali_osk_wq_delete_work(group->bottom_half_work_gp);
+    }
+
+    if (NULL != group->bottom_half_work_pp) {
+        _mali_osk_wq_delete_work(group->bottom_half_work_pp);
+    }
+
+    _mali_osk_free(group);
 }
 
 _mali_osk_errcode_t mali_group_add_mmu_core(struct mali_group *group, struct mali_mmu_core *mmu_core)
 {
-	/* This group object now owns the MMU core object */
-	group->mmu = mmu_core;
-	group->bottom_half_work_mmu = _mali_osk_wq_create_work(mali_group_bottom_half_mmu, group);
-	if (NULL == group->bottom_half_work_mmu) {
-		return _MALI_OSK_ERR_FAULT;
-	}
-	return _MALI_OSK_ERR_OK;
+    /* This group object now owns the MMU core object */
+    group->mmu = mmu_core;
+    group->bottom_half_work_mmu = _mali_osk_wq_create_work(mali_group_bottom_half_mmu, group);
+    if (NULL == group->bottom_half_work_mmu) {
+        return _MALI_OSK_ERR_FAULT;
+    }
+    return _MALI_OSK_ERR_OK;
 }
 
 void mali_group_remove_mmu_core(struct mali_group *group)
 {
-	/* This group object no longer owns the MMU core object */
-	group->mmu = NULL;
-	if (NULL != group->bottom_half_work_mmu) {
-		_mali_osk_wq_delete_work(group->bottom_half_work_mmu);
-	}
+    /* This group object no longer owns the MMU core object */
+    group->mmu = NULL;
+    if (NULL != group->bottom_half_work_mmu) {
+        _mali_osk_wq_delete_work(group->bottom_half_work_mmu);
+    }
 }
 
 _mali_osk_errcode_t mali_group_add_gp_core(struct mali_group *group, struct mali_gp_core *gp_core)
 {
-	/* This group object now owns the GP core object */
-	group->gp_core = gp_core;
-	group->bottom_half_work_gp = _mali_osk_wq_create_work(mali_group_bottom_half_gp, group);
-	if (NULL == group->bottom_half_work_gp) {
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	return _MALI_OSK_ERR_OK;
+    /* This group object now owns the GP core object */
+    group->gp_core = gp_core;
+    group->bottom_half_work_gp = _mali_osk_wq_create_work(mali_group_bottom_half_gp, group);
+    if (NULL == group->bottom_half_work_gp) {
+        return _MALI_OSK_ERR_FAULT;
+    }
+    return _MALI_OSK_ERR_OK;
 }
 
 void mali_group_remove_gp_core(struct mali_group *group)
 {
-	/* This group object no longer owns the GP core object */
-	group->gp_core = NULL;
-	if (NULL != group->bottom_half_work_gp) {
-		_mali_osk_wq_delete_work(group->bottom_half_work_gp);
-	}
+    /* This group object no longer owns the GP core object */
+    group->gp_core = NULL;
+    if (NULL != group->bottom_half_work_gp) {
+        _mali_osk_wq_delete_work(group->bottom_half_work_gp);
+    }
 }
 
 _mali_osk_errcode_t mali_group_add_pp_core(struct mali_group *group, struct mali_pp_core *pp_core)
 {
-	/* This group object now owns the PP core object */
-	group->pp_core = pp_core;
-	group->bottom_half_work_pp = _mali_osk_wq_create_work(mali_group_bottom_half_pp, group);
-	if (NULL == group->bottom_half_work_pp) {
-		return _MALI_OSK_ERR_FAULT;
-	}
-	return _MALI_OSK_ERR_OK;
+    /* This group object now owns the PP core object */
+    group->pp_core = pp_core;
+    group->bottom_half_work_pp = _mali_osk_wq_create_work(mali_group_bottom_half_pp, group);
+    if (NULL == group->bottom_half_work_pp) {
+        return _MALI_OSK_ERR_FAULT;
+    }
+    return _MALI_OSK_ERR_OK;
 }
 
 void mali_group_remove_pp_core(struct mali_group *group)
 {
-	/* This group object no longer owns the PP core object */
-	group->pp_core = NULL;
-	if (NULL != group->bottom_half_work_pp) {
-		_mali_osk_wq_delete_work(group->bottom_half_work_pp);
-	}
+    /* This group object no longer owns the PP core object */
+    group->pp_core = NULL;
+    if (NULL != group->bottom_half_work_pp) {
+        _mali_osk_wq_delete_work(group->bottom_half_work_pp);
+    }
 }
 
 enum mali_group_state mali_group_activate(struct mali_group *group)
 {
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-	MALI_DEBUG_PRINT(4, ("Group: Activating group %s\n",
-			     mali_group_core_description(group)));
-
-	if (MALI_GROUP_STATE_INACTIVE == group->state) {
-		/* Group is inactive, get PM refs in order to power up */
-
-		/*
-		 * We'll take a maximum of 2 power domain references pr group,
-		 * one for the group itself, and one for it's L2 cache.
-		 */
-		struct mali_pm_domain *domains[MALI_MAX_NUM_DOMAIN_REFS];
-		struct mali_group *groups[MALI_MAX_NUM_DOMAIN_REFS];
-		u32 num_domains = 0;
-		mali_bool all_groups_on;
-
-		/* Deal with child groups first */
-		if (mali_group_is_virtual(group)) {
-			/*
-			 * The virtual group might have 0, 1 or 2 L2s in
-			 * its l2_cache_core array, but we ignore these and
-			 * let the child groups take the needed L2 cache ref
-			 * on behalf of the virtual group.
-			 * In other words; The L2 refs are taken in pair with
-			 * the physical group which the L2 is attached to.
-			 */
-			struct mali_group *child;
-			struct mali_group *temp;
-
-			/*
-			 * Child group is inactive, get PM
-			 * refs in order to power up.
-			 */
-			_MALI_OSK_LIST_FOREACHENTRY(child, temp,
-						    &group->group_list,
-						    struct mali_group, group_list) {
-				MALI_DEBUG_ASSERT(MALI_GROUP_STATE_INACTIVE
-						  == child->state);
-
-				child->state = MALI_GROUP_STATE_ACTIVATION_PENDING;
-
-				MALI_DEBUG_ASSERT_POINTER(
-					child->pm_domain);
-				domains[num_domains] = child->pm_domain;
-				groups[num_domains] = child;
-				num_domains++;
-
-				/*
-				 * Take L2 domain ref for child group.
-				 */
-				MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS
-						  > num_domains);
-				domains[num_domains] = mali_l2_cache_get_pm_domain(
-							       child->l2_cache_core[0]);
-				groups[num_domains] = NULL;
-				MALI_DEBUG_ASSERT(NULL ==
-						  child->l2_cache_core[1]);
-				num_domains++;
-			}
-		} else {
-			/* Take L2 domain ref for physical groups. */
-			MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS >
-					  num_domains);
-
-			domains[num_domains] = mali_l2_cache_get_pm_domain(
-						       group->l2_cache_core[0]);
-			groups[num_domains] = NULL;
-			MALI_DEBUG_ASSERT(NULL == group->l2_cache_core[1]);
-			num_domains++;
-		}
-
-		/* Do the group itself last (it's dependencies first) */
-
-		group->state = MALI_GROUP_STATE_ACTIVATION_PENDING;
-
-		MALI_DEBUG_ASSERT_POINTER(group->pm_domain);
-		domains[num_domains] = group->pm_domain;
-		groups[num_domains] = group;
-		num_domains++;
-
-		all_groups_on = mali_pm_get_domain_refs(domains, groups,
-							num_domains);
-
-		/*
-		 * Complete activation for group, include
-		 * virtual group or physical group.
-		 */
-		if (MALI_TRUE == all_groups_on) {
-
-			mali_group_set_active(group);
-		}
-	} else if (MALI_GROUP_STATE_ACTIVE == group->state) {
-		/* Already active */
-		MALI_DEBUG_ASSERT(MALI_TRUE == group->power_is_on);
-	} else {
-		/*
-		 * Activation already pending, group->power_is_on could
-		 * be both true or false. We need to wait for power up
-		 * notification anyway.
-		 */
-		MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVATION_PENDING
-				  == group->state);
-	}
-
-	MALI_DEBUG_PRINT(4, ("Group: group %s activation result: %s\n",
-			     mali_group_core_description(group),
-			     MALI_GROUP_STATE_ACTIVE == group->state ?
-			     "ACTIVE" : "PENDING"));
-
-	return group->state;
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+    MALI_DEBUG_PRINT(4, ("Group: Activating group %s\n",
+                mali_group_core_description(group)));
+
+    if (MALI_GROUP_STATE_INACTIVE == group->state) {
+        /* Group is inactive, get PM refs in order to power up */
+
+        /*
+         * We'll take a maximum of 2 power domain references pr group,
+         * one for the group itself, and one for it's L2 cache.
+         */
+        struct mali_pm_domain *domains[MALI_MAX_NUM_DOMAIN_REFS];
+        struct mali_group *groups[MALI_MAX_NUM_DOMAIN_REFS];
+        u32 num_domains = 0;
+        mali_bool all_groups_on;
+
+        /* Deal with child groups first */
+        if (mali_group_is_virtual(group)) {
+            /*
+             * The virtual group might have 0, 1 or 2 L2s in
+             * its l2_cache_core array, but we ignore these and
+             * let the child groups take the needed L2 cache ref
+             * on behalf of the virtual group.
+             * In other words; The L2 refs are taken in pair with
+             * the physical group which the L2 is attached to.
+             */
+            struct mali_group *child;
+            struct mali_group *temp;
+
+            /*
+             * Child group is inactive, get PM
+             * refs in order to power up.
+             */
+            _MALI_OSK_LIST_FOREACHENTRY(child, temp,
+                    &group->group_list,
+                    struct mali_group, group_list) {
+                MALI_DEBUG_ASSERT(MALI_GROUP_STATE_INACTIVE
+                        == child->state);
+
+                child->state = MALI_GROUP_STATE_ACTIVATION_PENDING;
+
+                MALI_DEBUG_ASSERT_POINTER(
+                        child->pm_domain);
+                domains[num_domains] = child->pm_domain;
+                groups[num_domains] = child;
+                num_domains++;
+
+                /*
+                 * Take L2 domain ref for child group.
+                 */
+                MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS
+                        > num_domains);
+                domains[num_domains] = mali_l2_cache_get_pm_domain(
+                        child->l2_cache_core[0]);
+                groups[num_domains] = NULL;
+                MALI_DEBUG_ASSERT(NULL ==
+                        child->l2_cache_core[1]);
+                num_domains++;
+            }
+        } else {
+            /* Take L2 domain ref for physical groups. */
+            MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS >
+                    num_domains);
+
+            domains[num_domains] = mali_l2_cache_get_pm_domain(
+                    group->l2_cache_core[0]);
+            groups[num_domains] = NULL;
+            MALI_DEBUG_ASSERT(NULL == group->l2_cache_core[1]);
+            num_domains++;
+        }
+
+        /* Do the group itself last (it's dependencies first) */
+
+        group->state = MALI_GROUP_STATE_ACTIVATION_PENDING;
+
+        MALI_DEBUG_ASSERT_POINTER(group->pm_domain);
+        domains[num_domains] = group->pm_domain;
+        groups[num_domains] = group;
+        num_domains++;
+
+        all_groups_on = mali_pm_get_domain_refs(domains, groups,
+                num_domains);
+
+        /*
+         * Complete activation for group, include
+         * virtual group or physical group.
+         */
+        if (MALI_TRUE == all_groups_on) {
+
+            mali_group_set_active(group);
+        }
+    } else if (MALI_GROUP_STATE_ACTIVE == group->state) {
+        /* Already active */
+        MALI_DEBUG_ASSERT(MALI_TRUE == group->power_is_on);
+    } else {
+        /*
+         * Activation already pending, group->power_is_on could
+         * be both true or false. We need to wait for power up
+         * notification anyway.
+         */
+        MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVATION_PENDING
+                == group->state);
+    }
+
+    MALI_DEBUG_PRINT(4, ("Group: group %s activation result: %s\n",
+                mali_group_core_description(group),
+                MALI_GROUP_STATE_ACTIVE == group->state ?
+                "ACTIVE" : "PENDING"));
+
+    return group->state;
 }
 
 mali_bool mali_group_set_active(struct mali_group *group)
 {
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-	MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVATION_PENDING == group->state);
-	MALI_DEBUG_ASSERT(MALI_TRUE == group->power_is_on);
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+    MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVATION_PENDING == group->state);
+    MALI_DEBUG_ASSERT(MALI_TRUE == group->power_is_on);
 
-	MALI_DEBUG_PRINT(4, ("Group: Activation completed for %s\n",
-			     mali_group_core_description(group)));
+    MALI_DEBUG_PRINT(4, ("Group: Activation completed for %s\n",
+                mali_group_core_description(group)));
 
-	if (mali_group_is_virtual(group)) {
-		struct mali_group *child;
-		struct mali_group *temp;
+    if (mali_group_is_virtual(group)) {
+        struct mali_group *child;
+        struct mali_group *temp;
 
-		_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list,
-					    struct mali_group, group_list) {
-			if (MALI_TRUE != child->power_is_on) {
-				return MALI_FALSE;
-			}
+        _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list,
+                struct mali_group, group_list) {
+            if (MALI_TRUE != child->power_is_on) {
+                return MALI_FALSE;
+            }
 
-			child->state = MALI_GROUP_STATE_ACTIVE;
-		}
+            child->state = MALI_GROUP_STATE_ACTIVE;
+        }
 
-		mali_group_reset(group);
-	}
+        mali_group_reset(group);
+    }
 
-	/* Go to ACTIVE state */
-	group->state = MALI_GROUP_STATE_ACTIVE;
+    /* Go to ACTIVE state */
+    group->state = MALI_GROUP_STATE_ACTIVE;
 
-	return MALI_TRUE;
+    return MALI_TRUE;
 }
 
 mali_bool mali_group_deactivate(struct mali_group *group)
 {
-	struct mali_pm_domain *domains[MALI_MAX_NUM_DOMAIN_REFS];
-	u32 num_domains = 0;
-	mali_bool power_down = MALI_FALSE;
-
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-	MALI_DEBUG_ASSERT(MALI_GROUP_STATE_INACTIVE != group->state);
-
-	MALI_DEBUG_PRINT(3, ("Group: Deactivating group %s\n",
-			     mali_group_core_description(group)));
-
-	group->state = MALI_GROUP_STATE_INACTIVE;
-
-	MALI_DEBUG_ASSERT_POINTER(group->pm_domain);
-	domains[num_domains] = group->pm_domain;
-	num_domains++;
-
-	if (mali_group_is_virtual(group)) {
-		/* Release refs for all child groups */
-		struct mali_group *child;
-		struct mali_group *temp;
-
-		_MALI_OSK_LIST_FOREACHENTRY(child, temp,
-					    &group->group_list,
-					    struct mali_group, group_list) {
-			child->state = MALI_GROUP_STATE_INACTIVE;
-
-			MALI_DEBUG_ASSERT_POINTER(child->pm_domain);
-			domains[num_domains] = child->pm_domain;
-			num_domains++;
-
-			/* Release L2 cache domain for child groups */
-			MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS >
-					  num_domains);
-			domains[num_domains] = mali_l2_cache_get_pm_domain(
-						       child->l2_cache_core[0]);
-			MALI_DEBUG_ASSERT(NULL == child->l2_cache_core[1]);
-			num_domains++;
-		}
-
-		/*
-		 * Must do mali_group_power_down() steps right here for
-		 * virtual group, because virtual group itself is likely to
-		 * stay powered on, however child groups are now very likely
-		 * to be powered off (and thus lose their state).
-		 */
-
-		mali_group_clear_session(group);
-		/*
-		 * Disable the broadcast unit (clear it's mask).
-		 * This is needed in case the GPU isn't actually
-		 * powered down at this point and groups are
-		 * removed from an inactive virtual group.
-		 * If not, then the broadcast unit will intercept
-		 * their interrupts!
-		 */
-		mali_bcast_disable(group->bcast_core);
-	} else {
-		/* Release L2 cache domain for physical groups */
-		MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS >
-				  num_domains);
-		domains[num_domains] = mali_l2_cache_get_pm_domain(
-					       group->l2_cache_core[0]);
-		MALI_DEBUG_ASSERT(NULL == group->l2_cache_core[1]);
-		num_domains++;
-	}
-
-	power_down = mali_pm_put_domain_refs(domains, num_domains);
-
-	return power_down;
+    struct mali_pm_domain *domains[MALI_MAX_NUM_DOMAIN_REFS];
+    u32 num_domains = 0;
+    mali_bool power_down = MALI_FALSE;
+
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+    MALI_DEBUG_ASSERT(MALI_GROUP_STATE_INACTIVE != group->state);
+
+    MALI_DEBUG_PRINT(3, ("Group: Deactivating group %s\n",
+                mali_group_core_description(group)));
+
+    group->state = MALI_GROUP_STATE_INACTIVE;
+
+    MALI_DEBUG_ASSERT_POINTER(group->pm_domain);
+    domains[num_domains] = group->pm_domain;
+    num_domains++;
+
+    if (mali_group_is_virtual(group)) {
+        /* Release refs for all child groups */
+        struct mali_group *child;
+        struct mali_group *temp;
+
+        _MALI_OSK_LIST_FOREACHENTRY(child, temp,
+                &group->group_list,
+                struct mali_group, group_list) {
+            child->state = MALI_GROUP_STATE_INACTIVE;
+
+            MALI_DEBUG_ASSERT_POINTER(child->pm_domain);
+            domains[num_domains] = child->pm_domain;
+            num_domains++;
+
+            /* Release L2 cache domain for child groups */
+            MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS >
+                    num_domains);
+            domains[num_domains] = mali_l2_cache_get_pm_domain(
+                    child->l2_cache_core[0]);
+            MALI_DEBUG_ASSERT(NULL == child->l2_cache_core[1]);
+            num_domains++;
+        }
+
+        /*
+         * Must do mali_group_power_down() steps right here for
+         * virtual group, because virtual group itself is likely to
+         * stay powered on, however child groups are now very likely
+         * to be powered off (and thus lose their state).
+         */
+
+        mali_group_clear_session(group);
+        /*
+         * Disable the broadcast unit (clear it's mask).
+         * This is needed in case the GPU isn't actually
+         * powered down at this point and groups are
+         * removed from an inactive virtual group.
+         * If not, then the broadcast unit will intercept
+         * their interrupts!
+         */
+        mali_bcast_disable(group->bcast_core);
+    } else {
+        /* Release L2 cache domain for physical groups */
+        MALI_DEBUG_ASSERT(MALI_MAX_NUM_DOMAIN_REFS >
+                num_domains);
+        domains[num_domains] = mali_l2_cache_get_pm_domain(
+                group->l2_cache_core[0]);
+        MALI_DEBUG_ASSERT(NULL == group->l2_cache_core[1]);
+        num_domains++;
+    }
+
+    power_down = mali_pm_put_domain_refs(domains, num_domains);
+
+    return power_down;
 }
 
 void mali_group_power_up(struct mali_group *group)
 {
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-	MALI_DEBUG_PRINT(3, ("Group: Power up for %s\n",
-			     mali_group_core_description(group)));
-
-	group->power_is_on = MALI_TRUE;
-
-	if (MALI_FALSE == mali_group_is_virtual(group)
-	    && MALI_FALSE == mali_group_is_in_virtual(group)) {
-		mali_group_reset(group);
-	}
-
-	/*
-	 * When we just acquire only one physical group form virt group,
-	 * we should remove the bcast&dlbu mask from virt group and
-	 * reset bcast and dlbu core, although part of pp cores in virt
-	 * group maybe not be powered on.
-	 */
-	if (MALI_TRUE == mali_group_is_virtual(group)) {
-		mali_bcast_reset(group->bcast_core);
-		mali_dlbu_update_mask(group->dlbu_core);
-	}
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+    MALI_DEBUG_PRINT(3, ("Group: Power up for %s\n",
+                mali_group_core_description(group)));
+
+    group->power_is_on = MALI_TRUE;
+
+    if (MALI_FALSE == mali_group_is_virtual(group)
+            && MALI_FALSE == mali_group_is_in_virtual(group)) {
+        mali_group_reset(group);
+    }
+
+    /*
+     * When we just acquire only one physical group form virt group,
+     * we should remove the bcast&dlbu mask from virt group and
+     * reset bcast and dlbu core, although part of pp cores in virt
+     * group maybe not be powered on.
+     */
+    if (MALI_TRUE == mali_group_is_virtual(group)) {
+        mali_bcast_reset(group->bcast_core);
+        mali_dlbu_update_mask(group->dlbu_core);
+    }
 }
 
 void mali_group_power_down(struct mali_group *group)
 {
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT(MALI_TRUE == group->power_is_on);
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-	MALI_DEBUG_PRINT(3, ("Group: Power down for %s\n",
-			     mali_group_core_description(group)));
-
-	group->power_is_on = MALI_FALSE;
-
-	if (mali_group_is_virtual(group)) {
-		/*
-		 * What we do for physical jobs in this function should
-		 * already have been done in mali_group_deactivate()
-		 * for virtual group.
-		 */
-		MALI_DEBUG_ASSERT(NULL == group->session);
-	} else {
-		mali_group_clear_session(group);
-	}
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT(MALI_TRUE == group->power_is_on);
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+    MALI_DEBUG_PRINT(3, ("Group: Power down for %s\n",
+                mali_group_core_description(group)));
+
+    group->power_is_on = MALI_FALSE;
+
+    if (mali_group_is_virtual(group)) {
+        /*
+         * What we do for physical jobs in this function should
+         * already have been done in mali_group_deactivate()
+         * for virtual group.
+         */
+        MALI_DEBUG_ASSERT(NULL == group->session);
+    } else {
+        mali_group_clear_session(group);
+    }
 }
 
 MALI_DEBUG_CODE(static void mali_group_print_virtual(struct mali_group *vgroup)
-{
-	u32 i;
-	struct mali_group *group;
-	struct mali_group *temp;
-
-	MALI_DEBUG_PRINT(4, ("Virtual group %s (%p)\n",
-			     mali_group_core_description(vgroup),
-			     vgroup));
-	MALI_DEBUG_PRINT(4, ("l2_cache_core[0] = %p, ref = %d\n", vgroup->l2_cache_core[0], vgroup->l2_cache_core_ref_count[0]));
-	MALI_DEBUG_PRINT(4, ("l2_cache_core[1] = %p, ref = %d\n", vgroup->l2_cache_core[1], vgroup->l2_cache_core_ref_count[1]));
-
-	i = 0;
-	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &vgroup->group_list, struct mali_group, group_list) {
-		MALI_DEBUG_PRINT(4, ("[%d] %s (%p), l2_cache_core[0] = %p\n",
-				     i, mali_group_core_description(group),
-				     group, group->l2_cache_core[0]));
-		i++;
-	}
-})
-
-static void mali_group_dump_core_status(struct mali_group *group)
-{
-	u32 i;
-
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT(NULL != group->gp_core || (NULL != group->pp_core && !mali_group_is_virtual(group)));
-
-	if (NULL != group->gp_core) {
-		MALI_PRINT(("Dump Group %s\n", group->gp_core->hw_core.description));
-
-		for (i = 0; i < 0xA8; i += 0x10) {
-			MALI_PRINT(("0x%04x: 0x%08x 0x%08x 0x%08x 0x%08x\n", i, mali_hw_core_register_read(&group->gp_core->hw_core, i),
-				    mali_hw_core_register_read(&group->gp_core->hw_core, i + 4),
-				    mali_hw_core_register_read(&group->gp_core->hw_core, i + 8),
-				    mali_hw_core_register_read(&group->gp_core->hw_core, i + 12)));
-		}
-
-
-	} else {
-		MALI_PRINT(("Dump Group %s\n", group->pp_core->hw_core.description));
-
-		for (i = 0; i < 0x5c; i += 0x10) {
-			MALI_PRINT(("0x%04x: 0x%08x 0x%08x 0x%08x 0x%08x\n", i, mali_hw_core_register_read(&group->pp_core->hw_core, i),
-				    mali_hw_core_register_read(&group->pp_core->hw_core, i + 4),
-				    mali_hw_core_register_read(&group->pp_core->hw_core, i + 8),
-				    mali_hw_core_register_read(&group->pp_core->hw_core, i + 12)));
-		}
-
-		/* Ignore some minor registers */
-		for (i = 0x1000; i < 0x1068; i += 0x10) {
-			MALI_PRINT(("0x%04x: 0x%08x 0x%08x 0x%08x 0x%08x\n", i, mali_hw_core_register_read(&group->pp_core->hw_core, i),
-				    mali_hw_core_register_read(&group->pp_core->hw_core, i + 4),
-				    mali_hw_core_register_read(&group->pp_core->hw_core, i + 8),
-				    mali_hw_core_register_read(&group->pp_core->hw_core, i + 12)));
-		}
-	}
-
-	MALI_PRINT(("Dump Group MMU\n"));
-	for (i = 0; i < 0x24; i += 0x10) {
-		MALI_PRINT(("0x%04x: 0x%08x 0x%08x 0x%08x 0x%08x\n", i, mali_hw_core_register_read(&group->mmu->hw_core, i),
-			    mali_hw_core_register_read(&group->mmu->hw_core, i + 4),
-			    mali_hw_core_register_read(&group->mmu->hw_core, i + 8),
-			    mali_hw_core_register_read(&group->mmu->hw_core, i + 12)));
-	}
-}
-
-
-/**
- * @Dump group status
- */
-void mali_group_dump_status(struct mali_group *group)
-{
-	MALI_DEBUG_ASSERT_POINTER(group);
-
-	if (mali_group_is_virtual(group)) {
-		struct mali_group *group_c;
-		struct mali_group *temp;
-		_MALI_OSK_LIST_FOREACHENTRY(group_c, temp, &group->group_list, struct mali_group, group_list) {
-			mali_group_dump_core_status(group_c);
-		}
-	} else {
-		mali_group_dump_core_status(group);
-	}
-}
+        {
+        u32 i;
+        struct mali_group *group;
+        struct mali_group *temp;
+
+        MALI_DEBUG_PRINT(4, ("Virtual group %s (%p)\n",
+                mali_group_core_description(vgroup),
+                vgroup));
+        MALI_DEBUG_PRINT(4, ("l2_cache_core[0] = %p, ref = %d\n", vgroup->l2_cache_core[0], vgroup->l2_cache_core_ref_count[0]));
+        MALI_DEBUG_PRINT(4, ("l2_cache_core[1] = %p, ref = %d\n", vgroup->l2_cache_core[1], vgroup->l2_cache_core_ref_count[1]));
+
+        i = 0;
+        _MALI_OSK_LIST_FOREACHENTRY(group, temp, &vgroup->group_list, struct mali_group, group_list) {
+        MALI_DEBUG_PRINT(4, ("[%d] %s (%p), l2_cache_core[0] = %p\n",
+                i, mali_group_core_description(group),
+                group, group->l2_cache_core[0]));
+        i++;
+        }
+        })
 
 /**
  * @brief Add child group to virtual group parent
  */
 void mali_group_add_group(struct mali_group *parent, struct mali_group *child)
 {
-	mali_bool found;
-	u32 i;
-
-	MALI_DEBUG_PRINT(3, ("Adding group %s to virtual group %s\n",
-			     mali_group_core_description(child),
-			     mali_group_core_description(parent)));
-
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-	MALI_DEBUG_ASSERT(mali_group_is_virtual(parent));
-	MALI_DEBUG_ASSERT(!mali_group_is_virtual(child));
-	MALI_DEBUG_ASSERT(NULL == child->parent_group);
-
-	_mali_osk_list_addtail(&child->group_list, &parent->group_list);
-
-	child->parent_group = parent;
-
-	MALI_DEBUG_ASSERT_POINTER(child->l2_cache_core[0]);
-
-	MALI_DEBUG_PRINT(4, ("parent->l2_cache_core: [0] = %p, [1] = %p\n", parent->l2_cache_core[0], parent->l2_cache_core[1]));
-	MALI_DEBUG_PRINT(4, ("child->l2_cache_core: [0] = %p, [1] = %p\n", child->l2_cache_core[0], child->l2_cache_core[1]));
-
-	/* Keep track of the L2 cache cores of child groups */
-	found = MALI_FALSE;
-	for (i = 0; i < 2; i++) {
-		if (parent->l2_cache_core[i] == child->l2_cache_core[0]) {
-			MALI_DEBUG_ASSERT(parent->l2_cache_core_ref_count[i] > 0);
-			parent->l2_cache_core_ref_count[i]++;
-			found = MALI_TRUE;
-		}
-	}
-
-	if (!found) {
-		/* First time we see this L2 cache, add it to our list */
-		i = (NULL == parent->l2_cache_core[0]) ? 0 : 1;
-
-		MALI_DEBUG_PRINT(4, ("First time we see l2_cache %p. Adding to [%d] = %p\n", child->l2_cache_core[0], i, parent->l2_cache_core[i]));
-
-		MALI_DEBUG_ASSERT(NULL == parent->l2_cache_core[i]);
-
-		parent->l2_cache_core[i] = child->l2_cache_core[0];
-		parent->l2_cache_core_ref_count[i]++;
-	}
-
-	/* Update Broadcast Unit and DLBU */
-	mali_bcast_add_group(parent->bcast_core, child);
-	mali_dlbu_add_group(parent->dlbu_core, child);
-
-	if (MALI_TRUE == parent->power_is_on) {
-		mali_bcast_reset(parent->bcast_core);
-		mali_dlbu_update_mask(parent->dlbu_core);
-	}
-
-	if (MALI_TRUE == child->power_is_on) {
-		if (NULL == parent->session) {
-			if (NULL != child->session) {
-				/*
-				 * Parent has no session, so clear
-				 * child session as well.
-				 */
-				mali_mmu_activate_empty_page_directory(child->mmu);
-			}
-		} else {
-			if (parent->session == child->session) {
-				/* We already have same session as parent,
-				 * so a simple zap should be enough.
-				 */
-				mali_mmu_zap_tlb(child->mmu);
-			} else {
-				/*
-				 * Parent has a different session, so we must
-				 * switch to that sessions page table
-				 */
-				mali_mmu_activate_page_directory(child->mmu, mali_session_get_page_directory(parent->session));
-			}
-
-			/* It is the parent which keeps the session from now on */
-			child->session = NULL;
-		}
-	} else {
-		/* should have been cleared when child was powered down */
-		MALI_DEBUG_ASSERT(NULL == child->session);
-	}
-
-	/* Start job on child when parent is active */
-	if (NULL != parent->pp_running_job) {
-		struct mali_pp_job *job = parent->pp_running_job;
-
-		MALI_DEBUG_PRINT(3, ("Group %x joining running job %d on virtual group %x\n",
-				     child, mali_pp_job_get_id(job), parent));
-
-		/* Only allowed to add active child to an active parent */
-		MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVE == parent->state);
-		MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVE == child->state);
-
-		mali_pp_job_start(child->pp_core, job, mali_pp_core_get_id(child->pp_core), MALI_TRUE);
-
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-					      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
-					      MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
-					      mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job), 0, 0, 0);
-
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-					      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
-					      MALI_PROFILING_EVENT_REASON_START_STOP_HW_VIRTUAL,
-					      mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
+    mali_bool found;
+    u32 i;
+
+    MALI_DEBUG_PRINT(3, ("Adding group %s to virtual group %s\n",
+                mali_group_core_description(child),
+                mali_group_core_description(parent)));
+
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+    MALI_DEBUG_ASSERT(mali_group_is_virtual(parent));
+    MALI_DEBUG_ASSERT(!mali_group_is_virtual(child));
+    MALI_DEBUG_ASSERT(NULL == child->parent_group);
+
+    _mali_osk_list_addtail(&child->group_list, &parent->group_list);
+
+    child->parent_group = parent;
+
+    MALI_DEBUG_ASSERT_POINTER(child->l2_cache_core[0]);
+
+    MALI_DEBUG_PRINT(4, ("parent->l2_cache_core: [0] = %p, [1] = %p\n", parent->l2_cache_core[0], parent->l2_cache_core[1]));
+    MALI_DEBUG_PRINT(4, ("child->l2_cache_core: [0] = %p, [1] = %p\n", child->l2_cache_core[0], child->l2_cache_core[1]));
+
+    /* Keep track of the L2 cache cores of child groups */
+    found = MALI_FALSE;
+    for (i = 0; i < 2; i++) {
+        if (parent->l2_cache_core[i] == child->l2_cache_core[0]) {
+            MALI_DEBUG_ASSERT(parent->l2_cache_core_ref_count[i] > 0);
+            parent->l2_cache_core_ref_count[i]++;
+            found = MALI_TRUE;
+        }
+    }
+
+    if (!found) {
+        /* First time we see this L2 cache, add it to our list */
+        i = (NULL == parent->l2_cache_core[0]) ? 0 : 1;
+
+        MALI_DEBUG_PRINT(4, ("First time we see l2_cache %p. Adding to [%d] = %p\n", child->l2_cache_core[0], i, parent->l2_cache_core[i]));
+
+        MALI_DEBUG_ASSERT(NULL == parent->l2_cache_core[i]);
+
+        parent->l2_cache_core[i] = child->l2_cache_core[0];
+        parent->l2_cache_core_ref_count[i]++;
+    }
+
+    /* Update Broadcast Unit and DLBU */
+    mali_bcast_add_group(parent->bcast_core, child);
+    mali_dlbu_add_group(parent->dlbu_core, child);
+
+    if (MALI_TRUE == parent->power_is_on) {
+        mali_bcast_reset(parent->bcast_core);
+        mali_dlbu_update_mask(parent->dlbu_core);
+    }
+
+    if (MALI_TRUE == child->power_is_on) {
+        if (NULL == parent->session) {
+            if (NULL != child->session) {
+                /*
+                 * Parent has no session, so clear
+                 * child session as well.
+                 */
+                mali_mmu_activate_empty_page_directory(child->mmu);
+            }
+        } else {
+            if (parent->session == child->session) {
+                /* We already have same session as parent,
+                 * so a simple zap should be enough.
+                 */
+                mali_mmu_zap_tlb(child->mmu);
+            } else {
+                /*
+                 * Parent has a different session, so we must
+                 * switch to that sessions page table
+                 */
+                mali_mmu_activate_page_directory(child->mmu, mali_session_get_page_directory(parent->session));
+            }
+
+            /* It is the parent which keeps the session from now on */
+            child->session = NULL;
+        }
+    } else {
+        /* should have been cleared when child was powered down */
+        MALI_DEBUG_ASSERT(NULL == child->session);
+    }
+
+    /* Start job on child when parent is active */
+    if (NULL != parent->pp_running_job) {
+        struct mali_pp_job *job = parent->pp_running_job;
+
+        MALI_DEBUG_PRINT(3, ("Group %x joining running job %d on virtual group %x\n",
+                    child, mali_pp_job_get_id(job), parent));
+
+        /* Only allowed to add active child to an active parent */
+        MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVE == parent->state);
+        MALI_DEBUG_ASSERT(MALI_GROUP_STATE_ACTIVE == child->state);
+
+        mali_pp_job_start(child->pp_core, job, mali_pp_core_get_id(child->pp_core), MALI_TRUE);
+
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+                MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
+                MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
+                mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job), 0, 0, 0);
+
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+                MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
+                MALI_PROFILING_EVENT_REASON_START_STOP_HW_VIRTUAL,
+                mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-		trace_gpu_sched_switch(
-			mali_pp_core_description(group->pp_core),
-			sched_clock(), mali_pp_job_get_tid(job),
-			0, mali_pp_job_get_id(job));
+        trace_gpu_sched_switch(
+                mali_pp_core_description(group->pp_core),
+                sched_clock(), mali_pp_job_get_tid(job),
+                0, mali_pp_job_get_id(job));
 #endif
 
 #if defined(CONFIG_MALI400_PROFILING)
-		trace_mali_core_active(mali_pp_job_get_pid(job), 1 /* active */, 0 /* PP */, mali_pp_core_get_id(child->pp_core),
-				       mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job));
+        trace_mali_core_active(mali_pp_job_get_pid(job), 1 /* active */, 0 /* PP */, mali_pp_core_get_id(child->pp_core),
+                mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job));
 #endif
-	}
+    }
 
-	MALI_DEBUG_CODE(mali_group_print_virtual(parent);)
+    MALI_DEBUG_CODE(mali_group_print_virtual(parent);)
 }
 
 /**
@@ -717,1149 +655,1081 @@ void mali_group_add_group(struct mali_group *parent, struct mali_group *child)
  */
 void mali_group_remove_group(struct mali_group *parent, struct mali_group *child)
 {
-	u32 i;
+    u32 i;
 
-	MALI_DEBUG_PRINT(3, ("Removing group %s from virtual group %s\n",
-			     mali_group_core_description(child),
-			     mali_group_core_description(parent)));
+    MALI_DEBUG_PRINT(3, ("Removing group %s from virtual group %s\n",
+                mali_group_core_description(child),
+                mali_group_core_description(parent)));
 
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-	MALI_DEBUG_ASSERT(mali_group_is_virtual(parent));
-	MALI_DEBUG_ASSERT(!mali_group_is_virtual(child));
-	MALI_DEBUG_ASSERT(parent == child->parent_group);
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+    MALI_DEBUG_ASSERT(mali_group_is_virtual(parent));
+    MALI_DEBUG_ASSERT(!mali_group_is_virtual(child));
+    MALI_DEBUG_ASSERT(parent == child->parent_group);
 
-	/* Update Broadcast Unit and DLBU */
-	mali_bcast_remove_group(parent->bcast_core, child);
-	mali_dlbu_remove_group(parent->dlbu_core, child);
+    /* Update Broadcast Unit and DLBU */
+    mali_bcast_remove_group(parent->bcast_core, child);
+    mali_dlbu_remove_group(parent->dlbu_core, child);
 
-	if (MALI_TRUE == parent->power_is_on) {
-		mali_bcast_reset(parent->bcast_core);
-		mali_dlbu_update_mask(parent->dlbu_core);
-	}
+    if (MALI_TRUE == parent->power_is_on) {
+        mali_bcast_reset(parent->bcast_core);
+        mali_dlbu_update_mask(parent->dlbu_core);
+    }
 
-	child->session = parent->session;
-	child->parent_group = NULL;
+    child->session = parent->session;
+    child->parent_group = NULL;
 
-	_mali_osk_list_delinit(&child->group_list);
-	if (_mali_osk_list_empty(&parent->group_list)) {
-		parent->session = NULL;
-	}
+    _mali_osk_list_delinit(&child->group_list);
+    if (_mali_osk_list_empty(&parent->group_list)) {
+        parent->session = NULL;
+    }
 
-	/* Keep track of the L2 cache cores of child groups */
-	i = (child->l2_cache_core[0] == parent->l2_cache_core[0]) ? 0 : 1;
+    /* Keep track of the L2 cache cores of child groups */
+    i = (child->l2_cache_core[0] == parent->l2_cache_core[0]) ? 0 : 1;
 
-	MALI_DEBUG_ASSERT(child->l2_cache_core[0] == parent->l2_cache_core[i]);
+    MALI_DEBUG_ASSERT(child->l2_cache_core[0] == parent->l2_cache_core[i]);
 
-	parent->l2_cache_core_ref_count[i]--;
-	if (parent->l2_cache_core_ref_count[i] == 0) {
-		parent->l2_cache_core[i] = NULL;
-	}
+    parent->l2_cache_core_ref_count[i]--;
+    if (parent->l2_cache_core_ref_count[i] == 0) {
+        parent->l2_cache_core[i] = NULL;
+    }
 
-	MALI_DEBUG_CODE(mali_group_print_virtual(parent));
+    MALI_DEBUG_CODE(mali_group_print_virtual(parent));
 }
 
 struct mali_group *mali_group_acquire_group(struct mali_group *parent)
 {
-	struct mali_group *child = NULL;
+    struct mali_group *child = NULL;
 
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-	MALI_DEBUG_ASSERT(mali_group_is_virtual(parent));
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+    MALI_DEBUG_ASSERT(mali_group_is_virtual(parent));
 
-	if (!_mali_osk_list_empty(&parent->group_list)) {
-		child = _MALI_OSK_LIST_ENTRY(parent->group_list.prev, struct mali_group, group_list);
-		mali_group_remove_group(parent, child);
-	}
+    if (!_mali_osk_list_empty(&parent->group_list)) {
+        child = _MALI_OSK_LIST_ENTRY(parent->group_list.prev, struct mali_group, group_list);
+        mali_group_remove_group(parent, child);
+    }
 
-	if (NULL != child) {
-		if (MALI_GROUP_STATE_ACTIVE != parent->state
-		    && MALI_TRUE == child->power_is_on) {
-			mali_group_reset(child);
-		}
-	}
+    if (NULL != child) {
+        if (MALI_GROUP_STATE_ACTIVE != parent->state
+                && MALI_TRUE == child->power_is_on) {
+            mali_group_reset(child);
+        }
+    }
 
-	return child;
+    return child;
 }
 
 void mali_group_reset(struct mali_group *group)
 {
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-	MALI_DEBUG_ASSERT(NULL == group->gp_running_job);
-	MALI_DEBUG_ASSERT(NULL == group->pp_running_job);
-
-	MALI_DEBUG_PRINT(3, ("Group: reset of %s\n",
-			     mali_group_core_description(group)));
-
-	if (NULL != group->dlbu_core) {
-		mali_dlbu_reset(group->dlbu_core);
-	}
-
-	if (NULL != group->bcast_core) {
-		mali_bcast_reset(group->bcast_core);
-	}
-
-	MALI_DEBUG_ASSERT(NULL != group->mmu);
-	mali_group_reset_mmu(group);
-
-	if (NULL != group->gp_core) {
-		MALI_DEBUG_ASSERT(NULL == group->pp_core);
-		mali_gp_reset(group->gp_core);
-	} else {
-		MALI_DEBUG_ASSERT(NULL != group->pp_core);
-		mali_group_reset_pp(group);
-	}
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+    MALI_DEBUG_ASSERT(NULL == group->gp_running_job);
+    MALI_DEBUG_ASSERT(NULL == group->pp_running_job);
+    MALI_DEBUG_ASSERT(NULL == group->session);
+
+    MALI_DEBUG_PRINT(3, ("Group: reset of %s\n",
+                mali_group_core_description(group)));
+
+    if (NULL != group->dlbu_core) {
+        mali_dlbu_reset(group->dlbu_core);
+    }
+
+    if (NULL != group->bcast_core) {
+        mali_bcast_reset(group->bcast_core);
+    }
+
+    MALI_DEBUG_ASSERT(NULL != group->mmu);
+    mali_group_reset_mmu(group);
+
+    if (NULL != group->gp_core) {
+        MALI_DEBUG_ASSERT(NULL == group->pp_core);
+        mali_gp_reset(group->gp_core);
+    } else {
+        MALI_DEBUG_ASSERT(NULL != group->pp_core);
+        mali_group_reset_pp(group);
+    }
 }
 
-void mali_group_start_gp_job(struct mali_group *group, struct mali_gp_job *job, mali_bool gpu_secure_mode_pre_enabled)
+void mali_group_start_gp_job(struct mali_group *group, struct mali_gp_job *job)
 {
-	struct mali_session_data *session;
-
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-	MALI_DEBUG_PRINT(3, ("Group: Starting GP job 0x%08X on group %s\n",
-			     job,
-			     mali_group_core_description(group)));
-
-	session = mali_gp_job_get_session(job);
-
-	MALI_DEBUG_ASSERT_POINTER(group->l2_cache_core[0]);
-	mali_l2_cache_invalidate_conditional(group->l2_cache_core[0], mali_gp_job_get_cache_order(job));
-
-	/* Reset GPU and disable gpu secure mode if needed. */
-	if (MALI_TRUE == _mali_osk_gpu_secure_mode_is_enabled()) {
-		struct mali_pmu_core *pmu = mali_pmu_get_global_pmu_core();
-		_mali_osk_gpu_reset_and_secure_mode_disable();
-		/* Need to disable the pmu interrupt mask register */
-		if (NULL != pmu) {
-			mali_pmu_reset(pmu);
-		}
-	}
-
-	/* Reload mmu page table if needed */
-	if (MALI_TRUE == gpu_secure_mode_pre_enabled) {
-		mali_group_reset(group);
-		mali_group_activate_page_directory(group, session, MALI_TRUE);
-	} else {
-		mali_group_activate_page_directory(group, session, MALI_FALSE);
-	}
-
-	mali_gp_job_start(group->gp_core, job);
-
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-				      MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0) |
-				      MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
-				      mali_gp_job_get_frame_builder_id(job), mali_gp_job_get_flush_id(job), 0, 0, 0);
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-				      MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0),
-				      mali_gp_job_get_pid(job), mali_gp_job_get_tid(job), 0, 0, 0);
+    struct mali_session_data *session;
+
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+    MALI_DEBUG_PRINT(3, ("Group: Starting GP job 0x%08X on group %s\n",
+                job,
+                mali_group_core_description(group)));
+
+    session = mali_gp_job_get_session(job);
+
+    MALI_DEBUG_ASSERT_POINTER(group->l2_cache_core[0]);
+    mali_l2_cache_invalidate_conditional(group->l2_cache_core[0], mali_gp_job_get_cache_order(job));
+
+    mali_group_activate_page_directory(group, session);
+
+    mali_gp_job_start(group->gp_core, job);
+
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+            MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0) |
+            MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
+            mali_gp_job_get_frame_builder_id(job), mali_gp_job_get_flush_id(job), 0, 0, 0);
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+            MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0),
+            mali_gp_job_get_pid(job), mali_gp_job_get_tid(job), 0, 0, 0);
 
 #if defined(CONFIG_MALI400_PROFILING)
-	trace_mali_core_active(mali_gp_job_get_pid(job), 1 /* active */, 1 /* GP */,  0 /* core */,
-			       mali_gp_job_get_frame_builder_id(job), mali_gp_job_get_flush_id(job));
+    trace_mali_core_active(mali_gp_job_get_pid(job), 1 /* active */, 1 /* GP */,  0 /* core */,
+            mali_gp_job_get_frame_builder_id(job), mali_gp_job_get_flush_id(job));
 #endif
 
 #if defined(CONFIG_MALI400_PROFILING)
-	if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
-	    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
-		mali_group_report_l2_cache_counters_per_core(group, 0);
-	}
+    if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
+            (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
+        mali_group_report_l2_cache_counters_per_core(group, 0);
+    }
 #endif /* #if defined(CONFIG_MALI400_PROFILING) */
 
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-	trace_gpu_sched_switch(mali_gp_core_description(group->gp_core),
-			       sched_clock(), mali_gp_job_get_tid(job),
-			       0, mali_gp_job_get_id(job));
+    trace_gpu_sched_switch(mali_gp_core_description(group->gp_core),
+            sched_clock(), mali_gp_job_get_tid(job),
+            0, mali_gp_job_get_id(job));
 #endif
 
-	group->gp_running_job = job;
-	group->is_working = MALI_TRUE;
+    group->gp_running_job = job;
+    group->is_working = MALI_TRUE;
 
-	/* Setup SW timer and record start time */
-	group->start_time = _mali_osk_time_tickcount();
-	_mali_osk_timer_mod(group->timeout_timer, _mali_osk_time_mstoticks(mali_max_job_runtime));
+    /* Setup SW timer and record start time */
+    group->start_time = _mali_osk_time_tickcount();
+    _mali_osk_timer_mod(group->timeout_timer, _mali_osk_time_mstoticks(mali_max_job_runtime));
 
-	MALI_DEBUG_PRINT(4, ("Group: Started GP job 0x%08X on group %s at %u\n",
-			     job,
-			     mali_group_core_description(group),
-			     group->start_time));
+    MALI_DEBUG_PRINT(4, ("Group: Started GP job 0x%08X on group %s at %u\n",
+                job,
+                mali_group_core_description(group),
+                group->start_time));
 }
 
 /* Used to set all the registers except frame renderer list address and fragment shader stack address
  * It means the caller must set these two registers properly before calling this function
  */
-void mali_group_start_pp_job(struct mali_group *group, struct mali_pp_job *job, u32 sub_job, mali_bool gpu_secure_mode_pre_enabled)
+void mali_group_start_pp_job(struct mali_group *group, struct mali_pp_job *job, u32 sub_job)
 {
-	struct mali_session_data *session;
-
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-	MALI_DEBUG_PRINT(3, ("Group: Starting PP job 0x%08X part %u/%u on group %s\n",
-			     job, sub_job + 1,
-			     mali_pp_job_get_sub_job_count(job),
-			     mali_group_core_description(group)));
-
-	session = mali_pp_job_get_session(job);
-
-	if (NULL != group->l2_cache_core[0]) {
-		mali_l2_cache_invalidate_conditional(group->l2_cache_core[0], mali_pp_job_get_cache_order(job));
-	}
-
-	if (NULL != group->l2_cache_core[1]) {
-		mali_l2_cache_invalidate_conditional(group->l2_cache_core[1], mali_pp_job_get_cache_order(job));
-	}
-
-	/* Reset GPU and change gpu secure mode if needed. */
-	if (MALI_TRUE == mali_pp_job_is_protected_job(job) && MALI_FALSE == _mali_osk_gpu_secure_mode_is_enabled()) {
-		struct mali_pmu_core *pmu = mali_pmu_get_global_pmu_core();
-		_mali_osk_gpu_reset_and_secure_mode_enable();
-		/* Need to disable the pmu interrupt mask register */
-		if (NULL != pmu) {
-			mali_pmu_reset(pmu);
-		}
-	} else if (MALI_FALSE == mali_pp_job_is_protected_job(job) && MALI_TRUE == _mali_osk_gpu_secure_mode_is_enabled()) {
-		struct mali_pmu_core *pmu = mali_pmu_get_global_pmu_core();
-		_mali_osk_gpu_reset_and_secure_mode_disable();
-		/* Need to disable the pmu interrupt mask register */
-		if (NULL != pmu) {
-			mali_pmu_reset(pmu);
-		}
-	}
-
-	/* Reload the mmu page table if needed */
-	if ((MALI_TRUE == mali_pp_job_is_protected_job(job) && MALI_FALSE == gpu_secure_mode_pre_enabled)
-		||(MALI_FALSE == mali_pp_job_is_protected_job(job) && MALI_TRUE == gpu_secure_mode_pre_enabled)) {
-		mali_group_reset(group);
-		mali_group_activate_page_directory(group, session, MALI_TRUE);
-	} else {
-		mali_group_activate_page_directory(group, session, MALI_FALSE);
-	}
-
-	if (mali_group_is_virtual(group)) {
-		struct mali_group *child;
-		struct mali_group *temp;
-		u32 core_num = 0;
-
-		MALI_DEBUG_ASSERT(mali_pp_job_is_virtual(job));
-
-		/* Configure DLBU for the job */
-		mali_dlbu_config_job(group->dlbu_core, job);
-
-		/* Write stack address for each child group */
-		_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-			mali_pp_write_addr_stack(child->pp_core, job);
-			core_num++;
-		}
-
-		mali_pp_job_start(group->pp_core, job, sub_job, MALI_FALSE);
-	} else {
-		mali_pp_job_start(group->pp_core, job, sub_job, MALI_FALSE);
-	}
-
-	/* if the group is virtual, loop through physical groups which belong to this group
-	 * and call profiling events for its cores as virtual */
-	if (MALI_TRUE == mali_group_is_virtual(group)) {
-		struct mali_group *child;
-		struct mali_group *temp;
-
-		_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-			_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-						      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
-						      MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
-						      mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job), 0, 0, 0);
-
-			_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-						      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
-						      MALI_PROFILING_EVENT_REASON_START_STOP_HW_VIRTUAL,
-						      mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
+    struct mali_session_data *session;
+
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+    MALI_DEBUG_PRINT(3, ("Group: Starting PP job 0x%08X part %u/%u on group %s\n",
+                job, sub_job + 1,
+                mali_pp_job_get_sub_job_count(job),
+                mali_group_core_description(group)));
+
+    session = mali_pp_job_get_session(job);
+
+    if (NULL != group->l2_cache_core[0]) {
+        mali_l2_cache_invalidate_conditional(group->l2_cache_core[0], mali_pp_job_get_cache_order(job));
+    }
+
+    if (NULL != group->l2_cache_core[1]) {
+        mali_l2_cache_invalidate_conditional(group->l2_cache_core[1], mali_pp_job_get_cache_order(job));
+    }
+
+    mali_group_activate_page_directory(group, session);
+
+    if (mali_group_is_virtual(group)) {
+        struct mali_group *child;
+        struct mali_group *temp;
+        u32 core_num = 0;
+
+        MALI_DEBUG_ASSERT(mali_pp_job_is_virtual(job));
+
+        /* Configure DLBU for the job */
+        mali_dlbu_config_job(group->dlbu_core, job);
+
+        /* Write stack address for each child group */
+        _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+            mali_pp_write_addr_stack(child->pp_core, job);
+            core_num++;
+        }
+
+        mali_pp_job_start(group->pp_core, job, sub_job, MALI_FALSE);
+    } else {
+        mali_pp_job_start(group->pp_core, job, sub_job, MALI_FALSE);
+    }
+
+    /* if the group is virtual, loop through physical groups which belong to this group
+     * and call profiling events for its cores as virtual */
+    if (MALI_TRUE == mali_group_is_virtual(group)) {
+        struct mali_group *child;
+        struct mali_group *temp;
+
+        _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+            _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+                    MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
+                    MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
+                    mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job), 0, 0, 0);
+
+            _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+                    MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
+                    MALI_PROFILING_EVENT_REASON_START_STOP_HW_VIRTUAL,
+                    mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
 
 #if defined(CONFIG_MALI400_PROFILING)
-			trace_mali_core_active(mali_pp_job_get_pid(job), 1 /* active */, 0 /* PP */, mali_pp_core_get_id(child->pp_core),
-					       mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job));
+            trace_mali_core_active(mali_pp_job_get_pid(job), 1 /* active */, 0 /* PP */, mali_pp_core_get_id(child->pp_core),
+                    mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job));
 #endif
-		}
+        }
 
 #if defined(CONFIG_MALI400_PROFILING)
-		if (0 != group->l2_cache_core_ref_count[0]) {
-			if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
-			    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
-				mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
-			}
-		}
-		if (0 != group->l2_cache_core_ref_count[1]) {
-			if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[1])) &&
-			    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[1]))) {
-				mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[1]));
-			}
-		}
+        if (0 != group->l2_cache_core_ref_count[0]) {
+            if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
+                    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
+                mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
+            }
+        }
+        if (0 != group->l2_cache_core_ref_count[1]) {
+            if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[1])) &&
+                    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[1]))) {
+                mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[1]));
+            }
+        }
 #endif /* #if defined(CONFIG_MALI400_PROFILING) */
 
-	} else { /* group is physical - call profiling events for physical cores */
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-					      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(group->pp_core)) |
-					      MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
-					      mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job), 0, 0, 0);
+    } else { /* group is physical - call profiling events for physical cores */
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+                MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(group->pp_core)) |
+                MALI_PROFILING_EVENT_REASON_SINGLE_HW_FLUSH,
+                mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job), 0, 0, 0);
 
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-					      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(group->pp_core)) |
-					      MALI_PROFILING_EVENT_REASON_START_STOP_HW_PHYSICAL,
-					      mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+                MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(group->pp_core)) |
+                MALI_PROFILING_EVENT_REASON_START_STOP_HW_PHYSICAL,
+                mali_pp_job_get_pid(job), mali_pp_job_get_tid(job), 0, 0, 0);
 
 #if defined(CONFIG_MALI400_PROFILING)
-		trace_mali_core_active(mali_pp_job_get_pid(job), 1 /* active */, 0 /* PP */, mali_pp_core_get_id(group->pp_core),
-				       mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job));
+        trace_mali_core_active(mali_pp_job_get_pid(job), 1 /* active */, 0 /* PP */, mali_pp_core_get_id(group->pp_core),
+                mali_pp_job_get_frame_builder_id(job), mali_pp_job_get_flush_id(job));
 #endif
 
 #if defined(CONFIG_MALI400_PROFILING)
-		if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
-		    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
-			mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
-		}
+        if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
+                (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
+            mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
+        }
 #endif /* #if defined(CONFIG_MALI400_PROFILING) */
-	}
+    }
 
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-	trace_gpu_sched_switch(mali_pp_core_description(group->pp_core),
-			       sched_clock(), mali_pp_job_get_tid(job),
-			       0, mali_pp_job_get_id(job));
+    trace_gpu_sched_switch(mali_pp_core_description(group->pp_core),
+            sched_clock(), mali_pp_job_get_tid(job),
+            0, mali_pp_job_get_id(job));
 #endif
 
-	group->pp_running_job = job;
-	group->pp_running_sub_job = sub_job;
-	group->is_working = MALI_TRUE;
+    group->pp_running_job = job;
+    group->pp_running_sub_job = sub_job;
+    group->is_working = MALI_TRUE;
 
-	/* Setup SW timer and record start time */
-	group->start_time = _mali_osk_time_tickcount();
-	_mali_osk_timer_mod(group->timeout_timer, _mali_osk_time_mstoticks(mali_max_job_runtime));
+    /* Setup SW timer and record start time */
+    group->start_time = _mali_osk_time_tickcount();
+    _mali_osk_timer_mod(group->timeout_timer, _mali_osk_time_mstoticks(mali_max_job_runtime));
 
-	MALI_DEBUG_PRINT(4, ("Group: Started PP job 0x%08X part %u/%u on group %s at %u\n",
-			     job, sub_job + 1,
-			     mali_pp_job_get_sub_job_count(job),
-			     mali_group_core_description(group),
-			     group->start_time));
+    MALI_DEBUG_PRINT(4, ("Group: Started PP job 0x%08X part %u/%u on group %s at %u\n",
+                job, sub_job + 1,
+                mali_pp_job_get_sub_job_count(job),
+                mali_group_core_description(group),
+                group->start_time));
 
 }
 
 void mali_group_resume_gp_with_new_heap(struct mali_group *group, u32 job_id, u32 start_addr, u32 end_addr)
 {
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
 
-	MALI_DEBUG_ASSERT_POINTER(group->l2_cache_core[0]);
-	mali_l2_cache_invalidate(group->l2_cache_core[0]);
+    MALI_DEBUG_ASSERT_POINTER(group->l2_cache_core[0]);
+    mali_l2_cache_invalidate(group->l2_cache_core[0]);
 
-	mali_mmu_zap_tlb_without_stall(group->mmu);
+    mali_mmu_zap_tlb_without_stall(group->mmu);
 
-	mali_gp_resume_with_new_heap(group->gp_core, start_addr, end_addr);
+    mali_gp_resume_with_new_heap(group->gp_core, start_addr, end_addr);
 
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_RESUME |
-				      MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0),
-				      0, 0, 0, 0, 0);
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_RESUME |
+            MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0),
+            0, 0, 0, 0, 0);
 
 #if defined(CONFIG_MALI400_PROFILING)
-	trace_mali_core_active(mali_gp_job_get_pid(group->gp_running_job), 1 /* active */, 1 /* GP */,  0 /* core */,
-			       mali_gp_job_get_frame_builder_id(group->gp_running_job), mali_gp_job_get_flush_id(group->gp_running_job));
+    trace_mali_core_active(mali_gp_job_get_pid(group->gp_running_job), 1 /* active */, 1 /* GP */,  0 /* core */,
+            mali_gp_job_get_frame_builder_id(group->gp_running_job), mali_gp_job_get_flush_id(group->gp_running_job));
 #endif
 }
 
 static void mali_group_reset_mmu(struct mali_group *group)
 {
-	struct mali_group *child;
-	struct mali_group *temp;
-	_mali_osk_errcode_t err;
-
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-	if (!mali_group_is_virtual(group)) {
-		/* This is a physical group or an idle virtual group -- simply wait for
-		 * the reset to complete. */
-		err = mali_mmu_reset(group->mmu);
-		MALI_DEBUG_ASSERT(_MALI_OSK_ERR_OK == err);
-	} else { /* virtual group */
-		/* Loop through all members of this virtual group and wait
-		 * until they are done resetting.
-		 */
-		_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-			err = mali_mmu_reset(child->mmu);
-			MALI_DEBUG_ASSERT(_MALI_OSK_ERR_OK == err);
-		}
-	}
+    struct mali_group *child;
+    struct mali_group *temp;
+    _mali_osk_errcode_t err;
+
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+    if (!mali_group_is_virtual(group)) {
+        /* This is a physical group or an idle virtual group -- simply wait for
+         * the reset to complete. */
+        err = mali_mmu_reset(group->mmu);
+        MALI_DEBUG_ASSERT(_MALI_OSK_ERR_OK == err);
+    } else { /* virtual group */
+        /* Loop through all members of this virtual group and wait
+         * until they are done resetting.
+         */
+        _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+            err = mali_mmu_reset(child->mmu);
+            MALI_DEBUG_ASSERT(_MALI_OSK_ERR_OK == err);
+        }
+    }
 }
 
 static void mali_group_reset_pp(struct mali_group *group)
 {
-	struct mali_group *child;
-	struct mali_group *temp;
-
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-	mali_pp_reset_async(group->pp_core);
-
-	if (!mali_group_is_virtual(group) || NULL == group->pp_running_job) {
-		/* This is a physical group or an idle virtual group -- simply wait for
-		 * the reset to complete. */
-		mali_pp_reset_wait(group->pp_core);
-	} else {
-		/* Loop through all members of this virtual group and wait until they
-		 * are done resetting.
-		 */
-		_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-			mali_pp_reset_wait(child->pp_core);
-		}
-	}
+    struct mali_group *child;
+    struct mali_group *temp;
+
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+    mali_pp_reset_async(group->pp_core);
+
+    if (!mali_group_is_virtual(group) || NULL == group->pp_running_job) {
+        /* This is a physical group or an idle virtual group -- simply wait for
+         * the reset to complete. */
+        mali_pp_reset_wait(group->pp_core);
+    } else {
+        /* Loop through all members of this virtual group and wait until they
+         * are done resetting.
+         */
+        _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+            mali_pp_reset_wait(child->pp_core);
+        }
+    }
 }
 
 struct mali_pp_job *mali_group_complete_pp(struct mali_group *group, mali_bool success, u32 *sub_job)
 {
-	struct mali_pp_job *pp_job_to_return;
+    struct mali_pp_job *pp_job_to_return;
 
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_POINTER(group->pp_core);
-	MALI_DEBUG_ASSERT_POINTER(group->pp_running_job);
-	MALI_DEBUG_ASSERT_POINTER(sub_job);
-	MALI_DEBUG_ASSERT(MALI_TRUE == group->is_working);
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_POINTER(group->pp_core);
+    MALI_DEBUG_ASSERT_POINTER(group->pp_running_job);
+    MALI_DEBUG_ASSERT_POINTER(sub_job);
+    MALI_DEBUG_ASSERT(MALI_TRUE == group->is_working);
 
-	/* Stop/clear the timeout timer. */
-	_mali_osk_timer_del_async(group->timeout_timer);
+    /* Stop/clear the timeout timer. */
+    _mali_osk_timer_del_async(group->timeout_timer);
 
-	if (NULL != group->pp_running_job) {
+    if (NULL != group->pp_running_job) {
 
-		/* Deal with HW counters and profiling */
+        /* Deal with HW counters and profiling */
 
-		if (MALI_TRUE == mali_group_is_virtual(group)) {
-			struct mali_group *child;
-			struct mali_group *temp;
+        if (MALI_TRUE == mali_group_is_virtual(group)) {
+            struct mali_group *child;
+            struct mali_group *temp;
 
-			/* update performance counters from each physical pp core within this virtual group */
-			_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-				mali_pp_update_performance_counters(group->pp_core, child->pp_core, group->pp_running_job, mali_pp_core_get_id(child->pp_core));
-			}
+            /* update performance counters from each physical pp core within this virtual group */
+            _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+                mali_pp_update_performance_counters(group->pp_core, child->pp_core, group->pp_running_job, mali_pp_core_get_id(child->pp_core));
+            }
 
 #if defined(CONFIG_MALI400_PROFILING)
-			/* send profiling data per physical core */
-			_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-				_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-							      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
-							      MALI_PROFILING_EVENT_REASON_START_STOP_HW_VIRTUAL,
-							      mali_pp_job_get_perf_counter_value0(group->pp_running_job, mali_pp_core_get_id(child->pp_core)),
-							      mali_pp_job_get_perf_counter_value1(group->pp_running_job, mali_pp_core_get_id(child->pp_core)),
-							      mali_pp_job_get_perf_counter_src0(group->pp_running_job, group->pp_running_sub_job) | (mali_pp_job_get_perf_counter_src1(group->pp_running_job, group->pp_running_sub_job) << 8),
-							      0, 0);
-
-				trace_mali_core_active(mali_pp_job_get_pid(group->pp_running_job),
-						       0 /* active */, 0 /* PP */, mali_pp_core_get_id(child->pp_core),
-						       mali_pp_job_get_frame_builder_id(group->pp_running_job),
-						       mali_pp_job_get_flush_id(group->pp_running_job));
-			}
-			if (0 != group->l2_cache_core_ref_count[0]) {
-				if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
-				    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
-					mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
-				}
-			}
-			if (0 != group->l2_cache_core_ref_count[1]) {
-				if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[1])) &&
-				    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[1]))) {
-					mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[1]));
-				}
-			}
+            /* send profiling data per physical core */
+            _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+                _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+                        MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(child->pp_core)) |
+                        MALI_PROFILING_EVENT_REASON_START_STOP_HW_VIRTUAL,
+                        mali_pp_job_get_perf_counter_value0(group->pp_running_job, mali_pp_core_get_id(child->pp_core)),
+                        mali_pp_job_get_perf_counter_value1(group->pp_running_job, mali_pp_core_get_id(child->pp_core)),
+                        mali_pp_job_get_perf_counter_src0(group->pp_running_job, group->pp_running_sub_job) | (mali_pp_job_get_perf_counter_src1(group->pp_running_job, group->pp_running_sub_job) << 8),
+                        0, 0);
+
+                trace_mali_core_active(mali_pp_job_get_pid(group->pp_running_job),
+                        0 /* active */, 0 /* PP */, mali_pp_core_get_id(child->pp_core),
+                        mali_pp_job_get_frame_builder_id(group->pp_running_job),
+                        mali_pp_job_get_flush_id(group->pp_running_job));
+            }
+            if (0 != group->l2_cache_core_ref_count[0]) {
+                if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
+                        (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
+                    mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
+                }
+            }
+            if (0 != group->l2_cache_core_ref_count[1]) {
+                if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[1])) &&
+                        (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[1]))) {
+                    mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[1]));
+                }
+            }
 
 #endif
-		} else {
-			/* update performance counters for a physical group's pp core */
-			mali_pp_update_performance_counters(group->pp_core, group->pp_core, group->pp_running_job, group->pp_running_sub_job);
+        } else {
+            /* update performance counters for a physical group's pp core */
+            mali_pp_update_performance_counters(group->pp_core, group->pp_core, group->pp_running_job, group->pp_running_sub_job);
 
 #if defined(CONFIG_MALI400_PROFILING)
-			_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-						      MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(group->pp_core)) |
-						      MALI_PROFILING_EVENT_REASON_START_STOP_HW_PHYSICAL,
-						      mali_pp_job_get_perf_counter_value0(group->pp_running_job, group->pp_running_sub_job),
-						      mali_pp_job_get_perf_counter_value1(group->pp_running_job, group->pp_running_sub_job),
-						      mali_pp_job_get_perf_counter_src0(group->pp_running_job, group->pp_running_sub_job) | (mali_pp_job_get_perf_counter_src1(group->pp_running_job, group->pp_running_sub_job) << 8),
-						      0, 0);
-
-			trace_mali_core_active(mali_pp_job_get_pid(group->pp_running_job),
-					       0 /* active */, 0 /* PP */, mali_pp_core_get_id(group->pp_core),
-					       mali_pp_job_get_frame_builder_id(group->pp_running_job),
-					       mali_pp_job_get_flush_id(group->pp_running_job));
-
-			if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
-			    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
-				mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
-			}
+            _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+                    MALI_PROFILING_MAKE_EVENT_CHANNEL_PP(mali_pp_core_get_id(group->pp_core)) |
+                    MALI_PROFILING_EVENT_REASON_START_STOP_HW_PHYSICAL,
+                    mali_pp_job_get_perf_counter_value0(group->pp_running_job, group->pp_running_sub_job),
+                    mali_pp_job_get_perf_counter_value1(group->pp_running_job, group->pp_running_sub_job),
+                    mali_pp_job_get_perf_counter_src0(group->pp_running_job, group->pp_running_sub_job) | (mali_pp_job_get_perf_counter_src1(group->pp_running_job, group->pp_running_sub_job) << 8),
+                    0, 0);
+
+            trace_mali_core_active(mali_pp_job_get_pid(group->pp_running_job),
+                    0 /* active */, 0 /* PP */, mali_pp_core_get_id(group->pp_core),
+                    mali_pp_job_get_frame_builder_id(group->pp_running_job),
+                    mali_pp_job_get_flush_id(group->pp_running_job));
+
+            if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
+                    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0]))) {
+                mali_group_report_l2_cache_counters_per_core(group, mali_l2_cache_get_id(group->l2_cache_core[0]));
+            }
 #endif
-		}
+        }
 
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-		trace_gpu_sched_switch(
-			mali_gp_core_description(group->gp_core),
-			sched_clock(), 0, 0, 0);
+        trace_gpu_sched_switch(
+                mali_gp_core_description(group->gp_core),
+                sched_clock(), 0, 0, 0);
 #endif
 
-	}
+    }
 
-	if (success) {
-		/* Only do soft reset for successful jobs, a full recovery
-		 * reset will be done for failed jobs. */
-		mali_pp_reset_async(group->pp_core);
-	}
+    if (success) {
+        /* Only do soft reset for successful jobs, a full recovery
+         * reset will be done for failed jobs. */
+        mali_pp_reset_async(group->pp_core);
+    }
 
-	pp_job_to_return = group->pp_running_job;
-	group->pp_running_job = NULL;
-	group->is_working = MALI_FALSE;
-	*sub_job = group->pp_running_sub_job;
+    pp_job_to_return = group->pp_running_job;
+    group->pp_running_job = NULL;
+    group->is_working = MALI_FALSE;
+    *sub_job = group->pp_running_sub_job;
 
-	if (!success) {
-		MALI_DEBUG_PRINT(2, ("Mali group: Executing recovery reset due to job failure\n"));
-		mali_group_recovery_reset(group);
-	} else if (_MALI_OSK_ERR_OK != mali_pp_reset_wait(group->pp_core)) {
-		MALI_PRINT_ERROR(("Mali group: Executing recovery reset due to reset failure\n"));
-		mali_group_recovery_reset(group);
-	}
+    if (!success) {
+        MALI_DEBUG_PRINT(2, ("Mali group: Executing recovery reset due to job failure\n"));
+        mali_group_recovery_reset(group);
+    } else if (_MALI_OSK_ERR_OK != mali_pp_reset_wait(group->pp_core)) {
+        MALI_PRINT_ERROR(("Mali group: Executing recovery reset due to reset failure\n"));
+        mali_group_recovery_reset(group);
+    }
 
-	return pp_job_to_return;
+    return pp_job_to_return;
 }
 
 struct mali_gp_job *mali_group_complete_gp(struct mali_group *group, mali_bool success)
 {
-	struct mali_gp_job *gp_job_to_return;
+    struct mali_gp_job *gp_job_to_return;
 
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_POINTER(group->gp_core);
-	MALI_DEBUG_ASSERT_POINTER(group->gp_running_job);
-	MALI_DEBUG_ASSERT(MALI_TRUE == group->is_working);
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_POINTER(group->gp_core);
+    MALI_DEBUG_ASSERT_POINTER(group->gp_running_job);
+    MALI_DEBUG_ASSERT(MALI_TRUE == group->is_working);
 
-	/* Stop/clear the timeout timer. */
-	_mali_osk_timer_del_async(group->timeout_timer);
+    /* Stop/clear the timeout timer. */
+    _mali_osk_timer_del_async(group->timeout_timer);
 
-	if (NULL != group->gp_running_job) {
-		mali_gp_update_performance_counters(group->gp_core, group->gp_running_job);
+    if (NULL != group->gp_running_job) {
+        mali_gp_update_performance_counters(group->gp_core, group->gp_running_job);
 
 #if defined(CONFIG_MALI400_PROFILING)
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP | MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0),
-					      mali_gp_job_get_perf_counter_value0(group->gp_running_job),
-					      mali_gp_job_get_perf_counter_value1(group->gp_running_job),
-					      mali_gp_job_get_perf_counter_src0(group->gp_running_job) | (mali_gp_job_get_perf_counter_src1(group->gp_running_job) << 8),
-					      0, 0);
-
-		if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
-		    (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0])))
-			mali_group_report_l2_cache_counters_per_core(group, 0);
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP | MALI_PROFILING_MAKE_EVENT_CHANNEL_GP(0),
+                mali_gp_job_get_perf_counter_value0(group->gp_running_job),
+                mali_gp_job_get_perf_counter_value1(group->gp_running_job),
+                mali_gp_job_get_perf_counter_src0(group->gp_running_job) | (mali_gp_job_get_perf_counter_src1(group->gp_running_job) << 8),
+                0, 0);
+
+        if ((MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src0(group->l2_cache_core[0])) &&
+                (MALI_HW_CORE_NO_COUNTER != mali_l2_cache_core_get_counter_src1(group->l2_cache_core[0])))
+            mali_group_report_l2_cache_counters_per_core(group, 0);
 #endif
 
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-		trace_gpu_sched_switch(
-			mali_pp_core_description(group->pp_core),
-			sched_clock(), 0, 0, 0);
+        trace_gpu_sched_switch(
+                mali_pp_core_description(group->pp_core),
+                sched_clock(), 0, 0, 0);
 #endif
 
 #if defined(CONFIG_MALI400_PROFILING)
-		trace_mali_core_active(mali_gp_job_get_pid(group->gp_running_job), 0 /* active */, 1 /* GP */,  0 /* core */,
-				       mali_gp_job_get_frame_builder_id(group->gp_running_job), mali_gp_job_get_flush_id(group->gp_running_job));
+        trace_mali_core_active(mali_gp_job_get_pid(group->gp_running_job), 0 /* active */, 1 /* GP */,  0 /* core */,
+                mali_gp_job_get_frame_builder_id(group->gp_running_job), mali_gp_job_get_flush_id(group->gp_running_job));
 #endif
 
-		mali_gp_job_set_current_heap_addr(group->gp_running_job,
-						  mali_gp_read_plbu_alloc_start_addr(group->gp_core));
-	}
-
-	if (success) {
-		/* Only do soft reset for successful jobs, a full recovery
-		 * reset will be done for failed jobs. */
-		mali_gp_reset_async(group->gp_core);
-	}
-
-	gp_job_to_return = group->gp_running_job;
-	group->gp_running_job = NULL;
-	group->is_working = MALI_FALSE;
-
-	if (!success) {
-		MALI_DEBUG_PRINT(2, ("Mali group: Executing recovery reset due to job failure\n"));
-		mali_group_recovery_reset(group);
-	} else if (_MALI_OSK_ERR_OK != mali_gp_reset_wait(group->gp_core)) {
-		MALI_PRINT_ERROR(("Mali group: Executing recovery reset due to reset failure\n"));
-		mali_group_recovery_reset(group);
-	}
-
-	return gp_job_to_return;
+        mali_gp_job_set_current_heap_addr(group->gp_running_job,
+                mali_gp_read_plbu_alloc_start_addr(group->gp_core));
+    }
+
+    if (success) {
+        /* Only do soft reset for successful jobs, a full recovery
+         * reset will be done for failed jobs. */
+        mali_gp_reset_async(group->gp_core);
+    }
+
+    gp_job_to_return = group->gp_running_job;
+    group->gp_running_job = NULL;
+    group->is_working = MALI_FALSE;
+
+    if (!success) {
+        MALI_DEBUG_PRINT(2, ("Mali group: Executing recovery reset due to job failure\n"));
+        mali_group_recovery_reset(group);
+    } else if (_MALI_OSK_ERR_OK != mali_gp_reset_wait(group->gp_core)) {
+        MALI_PRINT_ERROR(("Mali group: Executing recovery reset due to reset failure\n"));
+        mali_group_recovery_reset(group);
+    }
+
+    return gp_job_to_return;
 }
 
 struct mali_group *mali_group_get_glob_group(u32 index)
 {
-	if (mali_global_num_groups > index) {
-		return mali_global_groups[index];
-	}
+    if (mali_global_num_groups > index) {
+        return mali_global_groups[index];
+    }
 
-	return NULL;
+    return NULL;
 }
 
 u32 mali_group_get_glob_num_groups(void)
 {
-	return mali_global_num_groups;
+    return mali_global_num_groups;
 }
 
-static void mali_group_activate_page_directory(struct mali_group *group, struct mali_session_data *session, mali_bool is_reload)
+static void mali_group_activate_page_directory(struct mali_group *group, struct mali_session_data *session)
 {
-	MALI_DEBUG_PRINT(5, ("Mali group: Activating page directory 0x%08X from session 0x%08X on group %s\n",
-			     mali_session_get_page_directory(session), session,
-			     mali_group_core_description(group)));
-
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-	if (group->session != session ||MALI_TRUE == is_reload) {
-		/* Different session than last time, so we need to do some work */
-		MALI_DEBUG_PRINT(5, ("Mali group: Activate session: %08x previous: %08x on group %s\n",
-				     session, group->session,
-				     mali_group_core_description(group)));
-		mali_mmu_activate_page_directory(group->mmu, mali_session_get_page_directory(session));
-		group->session = session;
-	} else {
-		/* Same session as last time, so no work required */
-		MALI_DEBUG_PRINT(4, ("Mali group: Activate existing session 0x%08X on group %s\n",
-				     session->page_directory,
-				     mali_group_core_description(group)));
-		mali_mmu_zap_tlb_without_stall(group->mmu);
-	}
+    MALI_DEBUG_PRINT(5, ("Mali group: Activating page directory 0x%08X from session 0x%08X on group %s\n",
+                mali_session_get_page_directory(session), session,
+                mali_group_core_description(group)));
+
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+    if (group->session != session) {
+        /* Different session than last time, so we need to do some work */
+        MALI_DEBUG_PRINT(5, ("Mali group: Activate session: %08x previous: %08x on group %s\n",
+                    session, group->session,
+                    mali_group_core_description(group)));
+        mali_mmu_activate_page_directory(group->mmu, mali_session_get_page_directory(session));
+        group->session = session;
+    } else {
+        /* Same session as last time, so no work required */
+        MALI_DEBUG_PRINT(4, ("Mali group: Activate existing session 0x%08X on group %s\n",
+                    session->page_directory,
+                    mali_group_core_description(group)));
+        mali_mmu_zap_tlb_without_stall(group->mmu);
+    }
 }
 
 static void mali_group_recovery_reset(struct mali_group *group)
 {
-	_mali_osk_errcode_t err;
-
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-	/* Stop cores, bus stop */
-	if (NULL != group->pp_core) {
-		mali_pp_stop_bus(group->pp_core);
-	} else {
-		mali_gp_stop_bus(group->gp_core);
-	}
-
-	/* Flush MMU and clear page fault (if any) */
-	mali_mmu_activate_fault_flush_page_directory(group->mmu);
-	mali_mmu_page_fault_done(group->mmu);
-
-	/* Wait for cores to stop bus, then do a hard reset on them */
-	if (NULL != group->pp_core) {
-		if (mali_group_is_virtual(group)) {
-			struct mali_group *child, *temp;
-
-			/* Disable the broadcast unit while we do reset directly on the member cores. */
-			mali_bcast_disable(group->bcast_core);
-
-			_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
-				mali_pp_stop_bus_wait(child->pp_core);
-				mali_pp_hard_reset(child->pp_core);
-			}
-
-			mali_bcast_enable(group->bcast_core);
-		} else {
-			mali_pp_stop_bus_wait(group->pp_core);
-			mali_pp_hard_reset(group->pp_core);
-		}
-	} else {
-		mali_gp_stop_bus_wait(group->gp_core);
-		mali_gp_hard_reset(group->gp_core);
-	}
-
-	/* Reset MMU */
-	err = mali_mmu_reset(group->mmu);
-	MALI_DEBUG_ASSERT(_MALI_OSK_ERR_OK == err);
-	MALI_IGNORE(err);
-
-	group->session = NULL;
+    _mali_osk_errcode_t err;
+
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+    /* Stop cores, bus stop */
+    if (NULL != group->pp_core) {
+        mali_pp_stop_bus(group->pp_core);
+    } else {
+        mali_gp_stop_bus(group->gp_core);
+    }
+
+    /* Flush MMU and clear page fault (if any) */
+    mali_mmu_activate_fault_flush_page_directory(group->mmu);
+    mali_mmu_page_fault_done(group->mmu);
+
+    /* Wait for cores to stop bus, then do a hard reset on them */
+    if (NULL != group->pp_core) {
+        if (mali_group_is_virtual(group)) {
+            struct mali_group *child, *temp;
+
+            /* Disable the broadcast unit while we do reset directly on the member cores. */
+            mali_bcast_disable(group->bcast_core);
+
+            _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list, struct mali_group, group_list) {
+                mali_pp_stop_bus_wait(child->pp_core);
+                mali_pp_hard_reset(child->pp_core);
+            }
+
+            mali_bcast_enable(group->bcast_core);
+        } else {
+            mali_pp_stop_bus_wait(group->pp_core);
+            mali_pp_hard_reset(group->pp_core);
+        }
+    } else {
+        mali_gp_stop_bus_wait(group->gp_core);
+        mali_gp_hard_reset(group->gp_core);
+    }
+
+    /* Reset MMU */
+    err = mali_mmu_reset(group->mmu);
+    MALI_DEBUG_ASSERT(_MALI_OSK_ERR_OK == err);
+    MALI_IGNORE(err);
+
+    group->session = NULL;
 }
 
 #if MALI_STATE_TRACKING
 u32 mali_group_dump_state(struct mali_group *group, char *buf, u32 size)
 {
-	int n = 0;
-	int i;
-	struct mali_group *child;
-	struct mali_group *temp;
-
-	if (mali_group_is_virtual(group)) {
-		n += _mali_osk_snprintf(buf + n, size - n,
-					"Virtual PP Group: %p\n", group);
-	} else if (mali_group_is_in_virtual(group)) {
-		n += _mali_osk_snprintf(buf + n, size - n,
-					"Child PP Group: %p\n", group);
-	} else if (NULL != group->pp_core) {
-		n += _mali_osk_snprintf(buf + n, size - n,
-					"Physical PP Group: %p\n", group);
-	} else {
-		MALI_DEBUG_ASSERT_POINTER(group->gp_core);
-		n += _mali_osk_snprintf(buf + n, size - n,
-					"GP Group: %p\n", group);
-	}
-
-	switch (group->state) {
-	case MALI_GROUP_STATE_INACTIVE:
-		n += _mali_osk_snprintf(buf + n, size - n,
-					"\tstate: INACTIVE\n");
-		break;
-	case MALI_GROUP_STATE_ACTIVATION_PENDING:
-		n += _mali_osk_snprintf(buf + n, size - n,
-					"\tstate: ACTIVATION_PENDING\n");
-		break;
-	case MALI_GROUP_STATE_ACTIVE:
-		n += _mali_osk_snprintf(buf + n, size - n,
-					"\tstate: MALI_GROUP_STATE_ACTIVE\n");
-		break;
-	default:
-		n += _mali_osk_snprintf(buf + n, size - n,
-					"\tstate: UNKNOWN (%d)\n", group->state);
-		MALI_DEBUG_ASSERT(0);
-		break;
-	}
-
-	n += _mali_osk_snprintf(buf + n, size - n,
-				"\tSW power: %s\n",
-				group->power_is_on ? "On" : "Off");
-
-	n += mali_pm_dump_state_domain(group->pm_domain, buf + n, size - n);
-
-	for (i = 0; i < 2; i++) {
-		if (NULL != group->l2_cache_core[i]) {
-			struct mali_pm_domain *domain;
-			domain = mali_l2_cache_get_pm_domain(
-					 group->l2_cache_core[i]);
-			n += mali_pm_dump_state_domain(domain,
-						       buf + n, size - n);
-		}
-	}
-
-	if (group->gp_core) {
-		n += mali_gp_dump_state(group->gp_core, buf + n, size - n);
-		n += _mali_osk_snprintf(buf + n, size - n,
-					"\tGP running job: %p\n", group->gp_running_job);
-	}
-
-	if (group->pp_core) {
-		n += mali_pp_dump_state(group->pp_core, buf + n, size - n);
-		n += _mali_osk_snprintf(buf + n, size - n,
-					"\tPP running job: %p, subjob %d \n",
-					group->pp_running_job,
-					group->pp_running_sub_job);
-	}
-
-	_MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list,
-				    struct mali_group, group_list) {
-		n += mali_group_dump_state(child, buf + n, size - n);
-	}
-
-	return n;
+    int n = 0;
+    int i;
+    struct mali_group *child;
+    struct mali_group *temp;
+
+    if (mali_group_is_virtual(group)) {
+        n += _mali_osk_snprintf(buf + n, size - n,
+                "Virtual PP Group: %p\n", group);
+    } else if (mali_group_is_in_virtual(group)) {
+        n += _mali_osk_snprintf(buf + n, size - n,
+                "Child PP Group: %p\n", group);
+    } else if (NULL != group->pp_core) {
+        n += _mali_osk_snprintf(buf + n, size - n,
+                "Physical PP Group: %p\n", group);
+    } else {
+        MALI_DEBUG_ASSERT_POINTER(group->gp_core);
+        n += _mali_osk_snprintf(buf + n, size - n,
+                "GP Group: %p\n", group);
+    }
+
+    switch (group->state) {
+        case MALI_GROUP_STATE_INACTIVE:
+            n += _mali_osk_snprintf(buf + n, size - n,
+                    "\tstate: INACTIVE\n");
+            break;
+        case MALI_GROUP_STATE_ACTIVATION_PENDING:
+            n += _mali_osk_snprintf(buf + n, size - n,
+                    "\tstate: ACTIVATION_PENDING\n");
+            break;
+        case MALI_GROUP_STATE_ACTIVE:
+            n += _mali_osk_snprintf(buf + n, size - n,
+                    "\tstate: MALI_GROUP_STATE_ACTIVE\n");
+            break;
+        default:
+            n += _mali_osk_snprintf(buf + n, size - n,
+                    "\tstate: UNKNOWN (%d)\n", group->state);
+            MALI_DEBUG_ASSERT(0);
+            break;
+    }
+
+    n += _mali_osk_snprintf(buf + n, size - n,
+            "\tSW power: %s\n",
+            group->power_is_on ? "On" : "Off");
+
+    n += mali_pm_dump_state_domain(group->pm_domain, buf + n, size - n);
+
+    for (i = 0; i < 2; i++) {
+        if (NULL != group->l2_cache_core[i]) {
+            struct mali_pm_domain *domain;
+            domain = mali_l2_cache_get_pm_domain(
+                    group->l2_cache_core[i]);
+            n += mali_pm_dump_state_domain(domain,
+                    buf + n, size - n);
+        }
+    }
+
+    if (group->gp_core) {
+        n += mali_gp_dump_state(group->gp_core, buf + n, size - n);
+        n += _mali_osk_snprintf(buf + n, size - n,
+                "\tGP running job: %p\n", group->gp_running_job);
+    }
+
+    if (group->pp_core) {
+        n += mali_pp_dump_state(group->pp_core, buf + n, size - n);
+        n += _mali_osk_snprintf(buf + n, size - n,
+                "\tPP running job: %p, subjob %d \n",
+                group->pp_running_job,
+                group->pp_running_sub_job);
+    }
+
+    _MALI_OSK_LIST_FOREACHENTRY(child, temp, &group->group_list,
+            struct mali_group, group_list) {
+        n += mali_group_dump_state(child, buf + n, size - n);
+    }
+
+    return n;
 }
 #endif
 
-_mali_osk_errcode_t mali_group_upper_half_mmu(void *data)
-{
-	struct mali_group *group = (struct mali_group *)data;
-	_mali_osk_errcode_t ret;
-
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_POINTER(group->mmu);
-
-#if defined(CONFIG_MALI400_PROFILING) && defined (CONFIG_TRACEPOINTS)
-#if defined(CONFIG_MALI_SHARED_INTERRUPTS)
-	mali_executor_lock();
-	if (!mali_group_is_working(group)) {
-		/* Not working, so nothing to do */
-		mali_executor_unlock();
-		return _MALI_OSK_ERR_FAULT;
-	}
-#endif
-	if (NULL != group->gp_core) {
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-					      0, 0, /* No pid and tid for interrupt handler */
-					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
-					      mali_mmu_get_rawstat(group->mmu), 0);
-	} else {
-		MALI_DEBUG_ASSERT_POINTER(group->pp_core);
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-					      0, 0, /* No pid and tid for interrupt handler */
-					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
-						      mali_pp_core_get_id(group->pp_core)),
-					      mali_mmu_get_rawstat(group->mmu), 0);
-	}
-#if defined(CONFIG_MALI_SHARED_INTERRUPTS)
-	mali_executor_unlock();
-#endif
-#endif
-
-	ret = mali_executor_interrupt_mmu(group, MALI_TRUE);
-
-#if defined(CONFIG_MALI400_PROFILING) && defined (CONFIG_TRACEPOINTS)
-#if defined(CONFIG_MALI_SHARED_INTERRUPTS)
-	mali_executor_lock();
-	if (!mali_group_is_working(group) && (!mali_group_power_is_on(group))) {
-		/* group complete and on job shedule on it, it already power off */
-		if (NULL != group->gp_core) {
-			_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-						      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-						      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-						      0, 0, /* No pid and tid for interrupt handler */
-						      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
-						      0xFFFFFFFF, 0);
-		} else {
-			_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-						      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-						      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-						      0, 0, /* No pid and tid for interrupt handler */
-						      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
-							      mali_pp_core_get_id(group->pp_core)),
-						      0xFFFFFFFF, 0);
-		}
-
-		mali_executor_unlock();
-		return ret;
-	}
+/* Kasin added. */
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+#include <platform/meson_m400/mali_fix.h>
+#define INT_MALI_PP2_MMU ( 6+32)
+struct _mali_osk_irq_t_struct;
+u32 get_irqnum(struct _mali_osk_irq_t_struct* irq);
 #endif
 
-	if (NULL != group->gp_core) {
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-					      0, 0, /* No pid and tid for interrupt handler */
-					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
-					      mali_mmu_get_rawstat(group->mmu), 0);
-	} else {
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-					      0, 0, /* No pid and tid for interrupt handler */
-					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
-						      mali_pp_core_get_id(group->pp_core)),
-					      mali_mmu_get_rawstat(group->mmu), 0);
-	}
-#if defined(CONFIG_MALI_SHARED_INTERRUPTS)
-	mali_executor_unlock();
+_mali_osk_errcode_t mali_group_upper_half_mmu(void *data)
+{
+    struct mali_group *group = (struct mali_group *)data;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    struct mali_mmu_core *mmu = group->mmu;
 #endif
+    _mali_osk_errcode_t ret;
+
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_POINTER(group->mmu);
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    if (MALI_FALSE == group->power_is_on)
+        MALI_SUCCESS;
+    if (get_irqnum(mmu->irq) == INT_MALI_PP2_MMU)
+    {
+        if (group == NULL || group->pp_core == NULL)
+            MALI_SUCCESS;
+        if (group->pp_core->core_id == 0) {
+            if (malifix_get_mmu_int_process_state(0) == MMU_INT_HIT)
+                malifix_set_mmu_int_process_state(0, MMU_INT_TOP);
+            else
+                MALI_SUCCESS;
+        }
+        else if (group->pp_core->core_id == 1) {
+            if (malifix_get_mmu_int_process_state(1) == MMU_INT_HIT)
+                malifix_set_mmu_int_process_state(1, MMU_INT_TOP);
+            else
+                MALI_SUCCESS;
+        } else
+            MALI_SUCCESS;
+    }
 #endif
 
-	return ret;
+    if (NULL != group->gp_core) {
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+                MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+                0, 0, /* No pid and tid for interrupt handler */
+                MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
+                mali_mmu_get_rawstat(group->mmu), 0);
+    } else {
+        MALI_DEBUG_ASSERT_POINTER(group->pp_core);
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+                MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+                0, 0, /* No pid and tid for interrupt handler */
+                MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
+                    mali_pp_core_get_id(group->pp_core)),
+                mali_mmu_get_rawstat(group->mmu), 0);
+    }
+
+    ret = mali_executor_interrupt_mmu(group, MALI_TRUE);
+
+    if (NULL != group->gp_core) {
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+                MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+                0, 0, /* No pid and tid for interrupt handler */
+                MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
+                mali_mmu_get_rawstat(group->mmu), 0);
+    } else {
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+                MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+                0, 0, /* No pid and tid for interrupt handler */
+                MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
+                    mali_pp_core_get_id(group->pp_core)),
+                mali_mmu_get_rawstat(group->mmu), 0);
+    }
+
+    return ret;
 }
 
 static void mali_group_bottom_half_mmu(void *data)
 {
-	struct mali_group *group = (struct mali_group *)data;
-
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_POINTER(group->mmu);
-
-	if (NULL != group->gp_core) {
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-					      0, _mali_osk_get_tid(), /* pid and tid */
-					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
-					      mali_mmu_get_rawstat(group->mmu), 0);
-	} else {
-		MALI_DEBUG_ASSERT_POINTER(group->pp_core);
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-					      0, _mali_osk_get_tid(), /* pid and tid */
-					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
-						      mali_pp_core_get_id(group->pp_core)),
-					      mali_mmu_get_rawstat(group->mmu), 0);
-	}
-
-	mali_executor_interrupt_mmu(group, MALI_FALSE);
-
-	if (NULL != group->gp_core) {
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-					      0, _mali_osk_get_tid(), /* pid and tid */
-					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
-					      mali_mmu_get_rawstat(group->mmu), 0);
-	} else {
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-					      0, _mali_osk_get_tid(), /* pid and tid */
-					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
-						      mali_pp_core_get_id(group->pp_core)),
-					      mali_mmu_get_rawstat(group->mmu), 0);
-	}
+    struct mali_group *group = (struct mali_group *)data;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    struct mali_mmu_core *mmu = group->mmu;
+#endif
+
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_POINTER(group->mmu);
+
+    if (NULL != group->gp_core) {
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+                MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+                0, _mali_osk_get_tid(), /* pid and tid */
+                MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
+                mali_mmu_get_rawstat(group->mmu), 0);
+    } else {
+        MALI_DEBUG_ASSERT_POINTER(group->pp_core);
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+                MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+                0, _mali_osk_get_tid(), /* pid and tid */
+                MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
+                    mali_pp_core_get_id(group->pp_core)),
+                mali_mmu_get_rawstat(group->mmu), 0);
+    }
+
+    mali_executor_interrupt_mmu(group, MALI_FALSE);
+
+    if (NULL != group->gp_core) {
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+                MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+                0, _mali_osk_get_tid(), /* pid and tid */
+                MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP_MMU(0),
+                mali_mmu_get_rawstat(group->mmu), 0);
+    } else {
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+                MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+                MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+                0, _mali_osk_get_tid(), /* pid and tid */
+                MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP_MMU(
+                    mali_pp_core_get_id(group->pp_core)),
+                mali_mmu_get_rawstat(group->mmu), 0);
+    }
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    if (get_irqnum(mmu->irq) == INT_MALI_PP2_MMU)
+    {
+        if (group->pp_core->core_id == 0) {
+            if (malifix_get_mmu_int_process_state(0) == MMU_INT_TOP)
+                malifix_set_mmu_int_process_state(0, MMU_INT_NONE);
+        }
+        else if (group->pp_core->core_id == 1) {
+            if (malifix_get_mmu_int_process_state(1) == MMU_INT_TOP)
+                malifix_set_mmu_int_process_state(1, MMU_INT_NONE);
+        }
+    }
+#endif
 }
 
 _mali_osk_errcode_t mali_group_upper_half_gp(void *data)
 {
-	struct mali_group *group = (struct mali_group *)data;
-	_mali_osk_errcode_t ret;
-
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_POINTER(group->gp_core);
-	MALI_DEBUG_ASSERT_POINTER(group->mmu);
-
-#if defined(CONFIG_MALI400_PROFILING) && defined (CONFIG_TRACEPOINTS)
-#if defined(CONFIG_MALI_SHARED_INTERRUPTS)
-	mali_executor_lock();
-	if (!mali_group_is_working(group)) {
-		/* Not working, so nothing to do */
-		mali_executor_unlock();
-		return _MALI_OSK_ERR_FAULT;
-	}
-#endif
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-				      0, 0, /* No pid and tid for interrupt handler */
-				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
-				      mali_gp_get_rawstat(group->gp_core), 0);
-
-	MALI_DEBUG_PRINT(4, ("Group: Interrupt 0x%08X from %s\n",
-			     mali_gp_get_rawstat(group->gp_core),
-			     mali_group_core_description(group)));
-#if defined(CONFIG_MALI_SHARED_INTERRUPTS)
-	mali_executor_unlock();
-#endif
-#endif
-	ret = mali_executor_interrupt_gp(group, MALI_TRUE);
-
-#if defined(CONFIG_MALI400_PROFILING) && defined (CONFIG_TRACEPOINTS)
-#if defined(CONFIG_MALI_SHARED_INTERRUPTS)
-	mali_executor_lock();
-	if (!mali_group_is_working(group) && (!mali_group_power_is_on(group))) {
-		/* group complete and on job shedule on it, it already power off */
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-					      0, 0, /* No pid and tid for interrupt handler */
-					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
-					      0xFFFFFFFF, 0);
-		mali_executor_unlock();
-		return ret;
-	}
-#endif
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-				      0, 0, /* No pid and tid for interrupt handler */
-				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
-				      mali_gp_get_rawstat(group->gp_core), 0);
-#if defined(CONFIG_MALI_SHARED_INTERRUPTS)
-	mali_executor_unlock();
-#endif
-#endif
-	return ret;
+    struct mali_group *group = (struct mali_group *)data;
+    _mali_osk_errcode_t ret;
+
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_POINTER(group->gp_core);
+    MALI_DEBUG_ASSERT_POINTER(group->mmu);
+
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+            MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+            0, 0, /* No pid and tid for interrupt handler */
+            MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
+            mali_gp_get_rawstat(group->gp_core), 0);
+
+    MALI_DEBUG_PRINT(4, ("Group: Interrupt 0x%08X from %s\n",
+                mali_gp_get_rawstat(group->gp_core),
+                mali_group_core_description(group)));
+
+    ret = mali_executor_interrupt_gp(group, MALI_TRUE);
+
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+            MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+            0, 0, /* No pid and tid for interrupt handler */
+            MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
+            mali_gp_get_rawstat(group->gp_core), 0);
+
+    return ret;
 }
 
 static void mali_group_bottom_half_gp(void *data)
 {
-	struct mali_group *group = (struct mali_group *)data;
-
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_POINTER(group->gp_core);
-	MALI_DEBUG_ASSERT_POINTER(group->mmu);
-
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-				      0, _mali_osk_get_tid(), /* pid and tid */
-				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
-				      mali_gp_get_rawstat(group->gp_core), 0);
-
-	mali_executor_interrupt_gp(group, MALI_FALSE);
-
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-				      0, _mali_osk_get_tid(), /* pid and tid */
-				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
-				      mali_gp_get_rawstat(group->gp_core), 0);
+    struct mali_group *group = (struct mali_group *)data;
+
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_POINTER(group->gp_core);
+    MALI_DEBUG_ASSERT_POINTER(group->mmu);
+
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+            MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+            0, _mali_osk_get_tid(), /* pid and tid */
+            MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
+            mali_gp_get_rawstat(group->gp_core), 0);
+
+    mali_executor_interrupt_gp(group, MALI_FALSE);
+
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+            MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+            0, _mali_osk_get_tid(), /* pid and tid */
+            MALI_PROFILING_MAKE_EVENT_DATA_CORE_GP(0),
+            mali_gp_get_rawstat(group->gp_core), 0);
 }
 
-_mali_osk_errcode_t mali_group_upper_half_pp(void *data)
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+int PP0_int_cnt = 0;
+int mali_PP0_int_cnt(void)
 {
-	struct mali_group *group = (struct mali_group *)data;
-	_mali_osk_errcode_t ret;
-
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_POINTER(group->pp_core);
-	MALI_DEBUG_ASSERT_POINTER(group->mmu);
-
-#if defined(CONFIG_MALI400_PROFILING) && defined (CONFIG_TRACEPOINTS)
-#if defined(CONFIG_MALI_SHARED_INTERRUPTS)
-	mali_executor_lock();
-	if (!mali_group_is_working(group)) {
-		/* Not working, so nothing to do */
-		mali_executor_unlock();
-		return _MALI_OSK_ERR_FAULT;
-	}
-#endif
+    return PP0_int_cnt;
+}
+EXPORT_SYMBOL(mali_PP0_int_cnt);
 
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-				      0, 0, /* No pid and tid for interrupt handler */
-				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
-					      mali_pp_core_get_id(group->pp_core)),
-				      mali_pp_get_rawstat(group->pp_core), 0);
-
-	MALI_DEBUG_PRINT(4, ("Group: Interrupt 0x%08X from %s\n",
-			     mali_pp_get_rawstat(group->pp_core),
-			     mali_group_core_description(group)));
-#if defined(CONFIG_MALI_SHARED_INTERRUPTS)
-	mali_executor_unlock();
-#endif
+int PP1_int_cnt = 0;
+int mali_PP1_int_cnt(void)
+{
+    return PP1_int_cnt;
+}
+EXPORT_SYMBOL(mali_PP1_int_cnt);
 #endif
 
-	ret = mali_executor_interrupt_pp(group, MALI_TRUE);
-
-#if defined(CONFIG_MALI400_PROFILING) && defined (CONFIG_TRACEPOINTS)
-#if defined(CONFIG_MALI_SHARED_INTERRUPTS)
-	mali_executor_lock();
-	if (!mali_group_is_working(group) && (!mali_group_power_is_on(group))) {
-		/* group complete and on job shedule on it, it already power off */
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-					      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-					      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-					      0, 0, /* No pid and tid for interrupt handler */
-					      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
-						      mali_pp_core_get_id(group->pp_core)),
-					      0xFFFFFFFF, 0);
-		mali_executor_unlock();
-		return ret;
-	}
-#endif
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
-				      0, 0, /* No pid and tid for interrupt handler */
-				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
-					      mali_pp_core_get_id(group->pp_core)),
-				      mali_pp_get_rawstat(group->pp_core), 0);
-#if defined(CONFIG_MALI_SHARED_INTERRUPTS)
-	mali_executor_unlock();
+_mali_osk_errcode_t mali_group_upper_half_pp(void *data)
+{
+    struct mali_group *group = (struct mali_group *)data;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    struct mali_pp_core *core = group->pp_core;
 #endif
+    _mali_osk_errcode_t ret;
+
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_POINTER(group->pp_core);
+    MALI_DEBUG_ASSERT_POINTER(group->mmu);
+
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+            MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+            0, 0, /* No pid and tid for interrupt handler */
+            MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
+                mali_pp_core_get_id(group->pp_core)),
+            mali_pp_get_rawstat(group->pp_core), 0);
+
+    MALI_DEBUG_PRINT(4, ("Group: Interrupt 0x%08X from %s\n",
+                mali_pp_get_rawstat(group->pp_core),
+                mali_group_core_description(group)));
+
+    ret = mali_executor_interrupt_pp(group, MALI_TRUE);
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    if (core->core_id == 0)
+        PP0_int_cnt++;
+    else if (core->core_id == 1)
+        PP1_int_cnt++;
 #endif
-	return ret;
+
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+            MALI_PROFILING_EVENT_REASON_START_STOP_SW_UPPER_HALF,
+            0, 0, /* No pid and tid for interrupt handler */
+            MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
+                mali_pp_core_get_id(group->pp_core)),
+            mali_pp_get_rawstat(group->pp_core), 0);
+
+    return ret;
 }
 
 static void mali_group_bottom_half_pp(void *data)
 {
-	struct mali_group *group = (struct mali_group *)data;
-
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_POINTER(group->pp_core);
-	MALI_DEBUG_ASSERT_POINTER(group->mmu);
-
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
-				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-				      0, _mali_osk_get_tid(), /* pid and tid */
-				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
-					      mali_pp_core_get_id(group->pp_core)),
-				      mali_pp_get_rawstat(group->pp_core), 0);
-
-	mali_executor_interrupt_pp(group, MALI_FALSE);
-
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
-				      MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
-				      MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
-				      0, _mali_osk_get_tid(), /* pid and tid */
-				      MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
-					      mali_pp_core_get_id(group->pp_core)),
-				      mali_pp_get_rawstat(group->pp_core), 0);
+    struct mali_group *group = (struct mali_group *)data;
+
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_POINTER(group->pp_core);
+    MALI_DEBUG_ASSERT_POINTER(group->mmu);
+
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_START |
+            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+            MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+            0, _mali_osk_get_tid(), /* pid and tid */
+            MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
+                mali_pp_core_get_id(group->pp_core)),
+            mali_pp_get_rawstat(group->pp_core), 0);
+
+    mali_executor_interrupt_pp(group, MALI_FALSE);
+
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_STOP |
+            MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
+            MALI_PROFILING_EVENT_REASON_START_STOP_SW_BOTTOM_HALF,
+            0, _mali_osk_get_tid(), /* pid and tid */
+            MALI_PROFILING_MAKE_EVENT_DATA_CORE_PP(
+                mali_pp_core_get_id(group->pp_core)),
+            mali_pp_get_rawstat(group->pp_core), 0);
 }
 
 static void mali_group_timeout(void *data)
 {
-	struct mali_group *group = (struct mali_group *)data;
-	MALI_DEBUG_ASSERT_POINTER(group);
-
-	MALI_DEBUG_PRINT(2, ("Group: timeout handler for %s at %u\n",
-			     mali_group_core_description(group),
-			     _mali_osk_time_tickcount()));
-
-	if (NULL != group->gp_core) {
-		mali_group_schedule_bottom_half_gp(group);
-	} else {
-		MALI_DEBUG_ASSERT_POINTER(group->pp_core);
-		mali_group_schedule_bottom_half_pp(group);
-	}
+    struct mali_group *group = (struct mali_group *)data;
+    MALI_DEBUG_ASSERT_POINTER(group);
+
+    MALI_DEBUG_PRINT(2, ("Group: timeout handler for %s at %u\n",
+                mali_group_core_description(group),
+                _mali_osk_time_tickcount()));
+
+    if (mali_core_timeout < 65533)
+        mali_core_timeout++;
+    if (NULL != group->gp_core) {
+        mali_group_schedule_bottom_half_gp(group);
+    } else {
+        MALI_DEBUG_ASSERT_POINTER(group->pp_core);
+        mali_group_schedule_bottom_half_pp(group);
+    }
 }
 
 mali_bool mali_group_zap_session(struct mali_group *group,
-				 struct mali_session_data *session)
+        struct mali_session_data *session)
 {
-	MALI_DEBUG_ASSERT_POINTER(group);
-	MALI_DEBUG_ASSERT_POINTER(session);
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-	if (group->session != session) {
-		/* not running from this session */
-		return MALI_TRUE; /* success */
-	}
-
-	if (group->is_working) {
-		/* The Zap also does the stall and disable_stall */
-		mali_bool zap_success = mali_mmu_zap_tlb(group->mmu);
-		return zap_success;
-	} else {
-		/* Just remove the session instead of zapping */
-		mali_group_clear_session(group);
-		return MALI_TRUE; /* success */
-	}
+    MALI_DEBUG_ASSERT_POINTER(group);
+    MALI_DEBUG_ASSERT_POINTER(session);
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+    if (group->session != session) {
+        /* not running from this session */
+        return MALI_TRUE; /* success */
+    }
+
+    if (group->is_working) {
+        /* The Zap also does the stall and disable_stall */
+        mali_bool zap_success = mali_mmu_zap_tlb(group->mmu);
+        return zap_success;
+    } else {
+        /* Just remove the session instead of zapping */
+        mali_group_clear_session(group);
+        return MALI_TRUE; /* success */
+    }
 }
 
 #if defined(CONFIG_MALI400_PROFILING)
 static void mali_group_report_l2_cache_counters_per_core(struct mali_group *group, u32 core_num)
 {
-	u32 source0 = 0;
-	u32 value0 = 0;
-	u32 source1 = 0;
-	u32 value1 = 0;
-	u32 profiling_channel = 0;
-
-	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
-
-	switch (core_num) {
-	case 0:
-		profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
-				    MALI_PROFILING_EVENT_CHANNEL_GPU |
-				    MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L20_COUNTERS;
-		break;
-	case 1:
-		profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
-				    MALI_PROFILING_EVENT_CHANNEL_GPU |
-				    MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L21_COUNTERS;
-		break;
-	case 2:
-		profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
-				    MALI_PROFILING_EVENT_CHANNEL_GPU |
-				    MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L22_COUNTERS;
-		break;
-	default:
-		profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
-				    MALI_PROFILING_EVENT_CHANNEL_GPU |
-				    MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L20_COUNTERS;
-		break;
-	}
-
-	if (0 == core_num) {
-		mali_l2_cache_core_get_counter_values(group->l2_cache_core[0], &source0, &value0, &source1, &value1);
-	}
-	if (1 == core_num) {
-		if (1 == mali_l2_cache_get_id(group->l2_cache_core[0])) {
-			mali_l2_cache_core_get_counter_values(group->l2_cache_core[0], &source0, &value0, &source1, &value1);
-		} else if (1 == mali_l2_cache_get_id(group->l2_cache_core[1])) {
-			mali_l2_cache_core_get_counter_values(group->l2_cache_core[1], &source0, &value0, &source1, &value1);
-		}
-	}
-	if (2 == core_num) {
-		if (2 == mali_l2_cache_get_id(group->l2_cache_core[0])) {
-			mali_l2_cache_core_get_counter_values(group->l2_cache_core[0], &source0, &value0, &source1, &value1);
-		} else if (2 == mali_l2_cache_get_id(group->l2_cache_core[1])) {
-			mali_l2_cache_core_get_counter_values(group->l2_cache_core[1], &source0, &value0, &source1, &value1);
-		}
-	}
-
-	_mali_osk_profiling_add_event(profiling_channel, source1 << 8 | source0, value0, value1, 0, 0);
+    u32 source0 = 0;
+    u32 value0 = 0;
+    u32 source1 = 0;
+    u32 value1 = 0;
+    u32 profiling_channel = 0;
+
+    MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
+
+    switch (core_num) {
+        case 0:
+            profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
+                MALI_PROFILING_EVENT_CHANNEL_GPU |
+                MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L20_COUNTERS;
+            break;
+        case 1:
+            profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
+                MALI_PROFILING_EVENT_CHANNEL_GPU |
+                MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L21_COUNTERS;
+            break;
+        case 2:
+            profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
+                MALI_PROFILING_EVENT_CHANNEL_GPU |
+                MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L22_COUNTERS;
+            break;
+        default:
+            profiling_channel = MALI_PROFILING_EVENT_TYPE_SINGLE |
+                MALI_PROFILING_EVENT_CHANNEL_GPU |
+                MALI_PROFILING_EVENT_REASON_SINGLE_GPU_L20_COUNTERS;
+            break;
+    }
+
+    if (0 == core_num) {
+        mali_l2_cache_core_get_counter_values(group->l2_cache_core[0], &source0, &value0, &source1, &value1);
+    }
+    if (1 == core_num) {
+        if (1 == mali_l2_cache_get_id(group->l2_cache_core[0])) {
+            mali_l2_cache_core_get_counter_values(group->l2_cache_core[0], &source0, &value0, &source1, &value1);
+        } else if (1 == mali_l2_cache_get_id(group->l2_cache_core[1])) {
+            mali_l2_cache_core_get_counter_values(group->l2_cache_core[1], &source0, &value0, &source1, &value1);
+        }
+    }
+    if (2 == core_num) {
+        if (2 == mali_l2_cache_get_id(group->l2_cache_core[0])) {
+            mali_l2_cache_core_get_counter_values(group->l2_cache_core[0], &source0, &value0, &source1, &value1);
+        } else if (2 == mali_l2_cache_get_id(group->l2_cache_core[1])) {
+            mali_l2_cache_core_get_counter_values(group->l2_cache_core[1], &source0, &value0, &source1, &value1);
+        }
+    }
+
+    _mali_osk_profiling_add_event(profiling_channel, source1 << 8 | source0, value0, value1, 0, 0);
 }
 #endif /* #if defined(CONFIG_MALI400_PROFILING) */
diff --git a/drivers/gpu/arm/mali/common/mali_group.h b/drivers/gpu/arm/mali/common/mali_group.h
old mode 100755
new mode 100644
index afe966f9..807be9b9
--- a/drivers/gpu/arm/mali/common/mali_group.h
+++ b/drivers/gpu/arm/mali/common/mali_group.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -96,8 +96,6 @@ struct mali_group *mali_group_create(struct mali_l2_cache_core *core,
 				     struct mali_bcast_unit *bcast,
 				     u32 domain_index);
 
-void mali_group_dump_status(struct mali_group *group);
-
 void mali_group_delete(struct mali_group *group);
 
 _mali_osk_errcode_t mali_group_add_mmu_core(struct mali_group *group,
@@ -128,7 +126,7 @@ MALI_STATIC_INLINE mali_bool mali_group_is_virtual(struct mali_group *group)
 {
 	MALI_DEBUG_ASSERT_POINTER(group);
 
-#if (defined(CONFIG_MALI450) || defined(CONFIG_MALI470))
+#if defined(CONFIG_MALI450)
 	return (NULL != group->dlbu_core);
 #else
 	return MALI_FALSE;
@@ -142,7 +140,7 @@ MALI_STATIC_INLINE mali_bool mali_group_is_in_virtual(struct mali_group *group)
 	MALI_DEBUG_ASSERT_POINTER(group);
 	MALI_DEBUG_ASSERT_EXECUTOR_LOCK_HELD();
 
-#if (defined(CONFIG_MALI450) || defined(CONFIG_MALI470))
+#if defined(CONFIG_MALI450)
 	return (NULL != group->parent_group) ? MALI_TRUE : MALI_FALSE;
 #else
 	return MALI_FALSE;
@@ -285,9 +283,9 @@ MALI_STATIC_INLINE struct mali_pp_core *mali_group_get_pp_core(struct mali_group
 
 /** @brief Start GP job
  */
-void mali_group_start_gp_job(struct mali_group *group, struct mali_gp_job *job, mali_bool gpu_secure_mode_pre_enabled);
+void mali_group_start_gp_job(struct mali_group *group, struct mali_gp_job *job);
 
-void mali_group_start_pp_job(struct mali_group *group, struct mali_pp_job *job, u32 sub_job, mali_bool gpu_secure_mode_pre_enabled);
+void mali_group_start_pp_job(struct mali_group *group, struct mali_pp_job *job, u32 sub_job);
 
 /** @brief Start virtual group Job on a virtual group
 */
@@ -411,7 +409,6 @@ MALI_STATIC_INLINE void mali_group_schedule_bottom_half_gp(struct mali_group *gr
 	_mali_osk_wq_schedule_work(group->bottom_half_work_gp);
 }
 
-
 MALI_STATIC_INLINE void mali_group_schedule_bottom_half_pp(struct mali_group *group)
 {
 	MALI_DEBUG_ASSERT_POINTER(group);
diff --git a/drivers/gpu/arm/mali/common/mali_hw_core.c b/drivers/gpu/arm/mali/common/mali_hw_core.c
old mode 100755
new mode 100644
index dd10cfe8..7b130b8a
--- a/drivers/gpu/arm/mali/common/mali_hw_core.c
+++ b/drivers/gpu/arm/mali/common/mali_hw_core.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_hw_core.h b/drivers/gpu/arm/mali/common/mali_hw_core.h
old mode 100755
new mode 100644
index e4357253..265a130f
--- a/drivers/gpu/arm/mali/common/mali_hw_core.h
+++ b/drivers/gpu/arm/mali/common/mali_hw_core.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -26,7 +26,7 @@ struct mali_hw_core {
 	const char *description;          /**< Name of unit (as specified in device configuration) */
 };
 
-#define MALI_REG_POLL_COUNT_FAST 1000000
+#define MALI_REG_POLL_COUNT_FAST 1000
 #define MALI_REG_POLL_COUNT_SLOW 1000000
 
 /*
diff --git a/drivers/gpu/arm/mali/common/mali_kernel_common.h b/drivers/gpu/arm/mali/common/mali_kernel_common.h
old mode 100755
new mode 100644
index 9bae2657..f5d9f4c3
--- a/drivers/gpu/arm/mali/common/mali_kernel_common.h
+++ b/drivers/gpu/arm/mali/common/mali_kernel_common.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_kernel_core.c b/drivers/gpu/arm/mali/common/mali_kernel_core.c
old mode 100755
new mode 100644
index c16b4448..72ae4f84
--- a/drivers/gpu/arm/mali/common/mali_kernel_core.c
+++ b/drivers/gpu/arm/mali/common/mali_kernel_core.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -41,11 +41,6 @@
 #endif
 #include "mali_control_timer.h"
 #include "mali_dvfs_policy.h"
-#include <linux/sched.h>
-#include <linux/atomic.h>
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-#include <linux/fence.h>
-#endif
 
 #define MALI_SHARED_MEMORY_DEFAULT_SIZE 0xffffffff
 
@@ -79,7 +74,6 @@ static u32 global_gpu_major_version = 0;
 static u32 global_gpu_minor_version = 0;
 
 mali_bool mali_gpu_class_is_mali450 = MALI_FALSE;
-mali_bool mali_gpu_class_is_mali470 = MALI_FALSE;
 
 static _mali_osk_errcode_t mali_set_global_gpu_base_address(void)
 {
@@ -160,10 +154,6 @@ static _mali_osk_errcode_t mali_parse_product_info(void)
 					global_product_id = _MALI_PRODUCT_ID_MALI450;
 					MALI_DEBUG_PRINT(2, ("Found Mali GPU Mali-450 MP r%up%u\n", global_gpu_major_version, global_gpu_minor_version));
 					break;
-				case MALI470_PP_PRODUCT_ID:
-					global_product_id = _MALI_PRODUCT_ID_MALI470;
-					MALI_DEBUG_PRINT(2, ("Found Mali GPU Mali-470 MP r%up%u\n", global_gpu_major_version, global_gpu_minor_version));
-					break;
 				default:
 					MALI_DEBUG_PRINT(2, ("Found unknown Mali GPU (r%up%u)\n", global_gpu_major_version, global_gpu_minor_version));
 					return _MALI_OSK_ERR_FAULT;
@@ -286,20 +276,6 @@ static _mali_osk_errcode_t mali_parse_config_l2_cache(void)
 				return _MALI_OSK_ERR_FAULT;
 			}
 		}
-	} else if (mali_is_mali470()) {
-		_mali_osk_resource_t l2c1_resource;
-
-		/* Make cluster for L2C1 */
-		if (_MALI_OSK_ERR_OK == _mali_osk_resource_find(MALI470_OFFSET_L2_CACHE1, &l2c1_resource)) {
-			MALI_DEBUG_PRINT(3, ("Creating Mali-470 L2 cache 1\n"));
-			l2_cache = mali_create_l2_cache_core(&l2c1_resource, MALI_DOMAIN_INDEX_L21);
-			if (NULL == l2_cache) {
-				return _MALI_OSK_ERR_FAULT;
-			}
-		} else {
-			MALI_DEBUG_PRINT(3, ("Did not find required Mali L2 cache for L2C1\n"));
-			return _MALI_OSK_ERR_FAULT;
-		}
 	}
 
 	return _MALI_OSK_ERR_OK;
@@ -467,7 +443,7 @@ static _mali_osk_errcode_t mali_parse_config_groups(void)
 	_mali_osk_errcode_t resource_dlbu_found;
 	_mali_osk_errcode_t resource_bcast_found;
 
-	if (!(mali_is_mali400() || mali_is_mali450() || mali_is_mali470())) {
+	if (!(mali_is_mali400() || mali_is_mali450())) {
 		/* No known HW core */
 		return _MALI_OSK_ERR_FAULT;
 	}
@@ -510,7 +486,7 @@ static _mali_osk_errcode_t mali_parse_config_groups(void)
 	resource_pp_mmu_found[7] = _mali_osk_resource_find(MALI_OFFSET_PP7_MMU, &(resource_pp_mmu[7]));
 
 
-	if (mali_is_mali450() || mali_is_mali470()) {
+	if (mali_is_mali450()) {
 		resource_bcast_found = _mali_osk_resource_find(MALI_OFFSET_BCAST, &resource_bcast);
 		resource_dlbu_found = _mali_osk_resource_find(MALI_OFFSET_DLBU, &resource_dlbu);
 		resource_pp_mmu_bcast_found = _mali_osk_resource_find(MALI_OFFSET_PP_BCAST_MMU, &resource_pp_mmu_bcast);
@@ -520,7 +496,7 @@ static _mali_osk_errcode_t mali_parse_config_groups(void)
 		    _MALI_OSK_ERR_OK != resource_dlbu_found ||
 		    _MALI_OSK_ERR_OK != resource_pp_mmu_bcast_found ||
 		    _MALI_OSK_ERR_OK != resource_pp_bcast_found) {
-			/* Missing mandatory core(s) for Mali-450 or Mali-470 */
+			/* Missing mandatory core(s) for Mali-450 */
 			MALI_DEBUG_PRINT(2, ("Missing mandatory resources, Mali-450 needs DLBU, Broadcast unit, virtual PP core and virtual MMU\n"));
 			return _MALI_OSK_ERR_FAULT;
 		}
@@ -579,7 +555,7 @@ static _mali_osk_errcode_t mali_parse_config_groups(void)
 		}
 	}
 
-	if (mali_is_mali450() || mali_is_mali470()) {
+	if (mali_is_mali450()) {
 		_mali_osk_errcode_t err = mali_create_virtual_group(&resource_pp_mmu_bcast, &resource_pp_bcast, &resource_dlbu, &resource_bcast);
 		if (_MALI_OSK_ERR_OK != err) {
 			return err;
@@ -708,16 +684,14 @@ static _mali_osk_errcode_t mali_parse_config_memory(void)
 
 static void mali_detect_gpu_class(void)
 {
-	if (_mali_osk_identify_gpu_resource() == 0x450)
+	if (_mali_osk_l2_resource_count() > 1) {
 		mali_gpu_class_is_mali450 = MALI_TRUE;
-
-	if (_mali_osk_identify_gpu_resource() == 0x470)
-		mali_gpu_class_is_mali470 = MALI_TRUE;
+	}
 }
 
 static _mali_osk_errcode_t mali_init_hw_reset(void)
 {
-#if (defined(CONFIG_MALI450) || defined(CONFIG_MALI470))
+#if defined(CONFIG_MALI450)
 	_mali_osk_resource_t resource_bcast;
 
 	/* Ensure broadcast unit is in a good state before we start creating
@@ -733,7 +707,7 @@ static _mali_osk_errcode_t mali_init_hw_reset(void)
 		}
 		mali_bcast_unit_delete(bcast_core);
 	}
-#endif /* (defined(CONFIG_MALI450) || defined(CONFIG_MALI470)) */
+#endif /* CONFIG_MALI450 */
 
 	return _MALI_OSK_ERR_OK;
 }
@@ -760,9 +734,6 @@ _mali_osk_errcode_t mali_initialize_subsystems(void)
 		return err;
 	}
 
-	/*Try to init gpu secure mode */
-	_mali_osk_gpu_secure_mode_init();
-
 #if defined(CONFIG_MALI400_PROFILING)
 	err = _mali_osk_profiling_init(mali_boot_profiling ? MALI_TRUE : MALI_FALSE);
 	if (_MALI_OSK_ERR_OK != err) {
@@ -854,7 +825,7 @@ _mali_osk_errcode_t mali_initialize_subsystems(void)
 		return err;
 	}
 
-	if (mali_is_mali450() || mali_is_mali470()) {
+	if (mali_is_mali450()) {
 		err = mali_dlbu_initialize();
 		if (_MALI_OSK_ERR_OK != err) {
 			mali_pm_init_end();
@@ -932,7 +903,7 @@ void mali_terminate_subsystems(void)
 	mali_delete_l2_cache_cores();
 	mali_mmu_terminate();
 
-	if (mali_is_mali450() || mali_is_mali470()) {
+	if (mali_is_mali450()) {
 		mali_dlbu_terminate();
 	}
 
@@ -946,8 +917,6 @@ void mali_terminate_subsystems(void)
 	_mali_osk_profiling_term();
 #endif
 
-	_mali_osk_gpu_secure_mode_deinit();
-
 	mali_memory_terminate();
 
 	mali_session_terminate();
@@ -1005,7 +974,7 @@ _mali_osk_errcode_t _mali_ukk_get_api_version_v2(_mali_uk_get_api_version_v2_s *
 	args->version = _MALI_UK_API_VERSION; /* report our version */
 
 	/* success regardless of being compatible or not */
-	return _MALI_OSK_ERR_OK;
+	return _MALI_OSK_ERR_OK;;
 }
 
 _mali_osk_errcode_t _mali_ukk_wait_for_notification(_mali_uk_wait_for_notification_s *args)
@@ -1026,7 +995,7 @@ _mali_osk_errcode_t _mali_ukk_wait_for_notification(_mali_uk_wait_for_notificati
 	if (NULL == queue) {
 		MALI_DEBUG_PRINT(1, ("No notification queue registered with the session. Asking userspace to stop querying\n"));
 		args->type = _MALI_NOTIFICATION_CORE_SHUTDOWN_IN_PROGRESS;
-		return _MALI_OSK_ERR_OK;
+		return _MALI_OSK_ERR_OK;;
 	}
 
 	/* receive a notification, might sleep */
@@ -1042,7 +1011,7 @@ _mali_osk_errcode_t _mali_ukk_wait_for_notification(_mali_uk_wait_for_notificati
 	/* finished with the notification */
 	_mali_osk_notification_delete(notification);
 
-	return _MALI_OSK_ERR_OK; /* all ok */
+	return _MALI_OSK_ERR_OK;; /* all ok */
 }
 
 _mali_osk_errcode_t _mali_ukk_post_notification(_mali_uk_post_notification_s *args)
@@ -1061,7 +1030,7 @@ _mali_osk_errcode_t _mali_ukk_post_notification(_mali_uk_post_notification_s *ar
 	/* if the queue does not exist we're currently shutting down */
 	if (NULL == queue) {
 		MALI_DEBUG_PRINT(1, ("No notification queue registered with the session. Asking userspace to stop querying\n"));
-		return _MALI_OSK_ERR_OK;
+		return _MALI_OSK_ERR_OK;;
 	}
 
 	notification = _mali_osk_notification_create(args->type, 0);
@@ -1072,28 +1041,9 @@ _mali_osk_errcode_t _mali_ukk_post_notification(_mali_uk_post_notification_s *ar
 
 	_mali_osk_notification_queue_send(queue, notification);
 
-	return _MALI_OSK_ERR_OK; /* all ok */
-}
-
-_mali_osk_errcode_t _mali_ukk_pending_submit(_mali_uk_pending_submit_s *args)
-{
-	wait_queue_head_t *queue;
-
-	/* check input */
-	MALI_DEBUG_ASSERT_POINTER(args);
-	MALI_DEBUG_ASSERT(NULL != (void *)(uintptr_t)args->ctx);
-
-	queue = mali_session_get_wait_queue();
-
-	/* check pending big job number, might sleep if larger than MAX allowed number */
-	if (wait_event_interruptible(*queue, MALI_MAX_PENDING_BIG_JOB > mali_scheduler_job_gp_big_job_count())) {
-		return _MALI_OSK_ERR_RESTARTSYSCALL;
-	}
-
-	return _MALI_OSK_ERR_OK; /* all ok */
+	return _MALI_OSK_ERR_OK;; /* all ok */
 }
 
-
 _mali_osk_errcode_t _mali_ukk_request_high_priority(_mali_uk_request_high_priority_s *args)
 {
 	struct mali_session_data *session;
@@ -1108,7 +1058,7 @@ _mali_osk_errcode_t _mali_ukk_request_high_priority(_mali_uk_request_high_priori
 		MALI_DEBUG_PRINT(2, ("Session 0x%08X with pid %d was granted higher priority.\n", session, _mali_osk_get_pid()));
 	}
 
-	return _MALI_OSK_ERR_OK;
+	return _MALI_OSK_ERR_OK;;
 }
 
 _mali_osk_errcode_t _mali_ukk_open(void **context)
@@ -1125,17 +1075,22 @@ _mali_osk_errcode_t _mali_ukk_open(void **context)
 	/* create a response queue for this session */
 	session->ioctl_queue = _mali_osk_notification_queue_init();
 	if (NULL == session->ioctl_queue) {
-		goto err;
+		_mali_osk_free(session);
+		MALI_ERROR(_MALI_OSK_ERR_NOMEM);
 	}
 
 	session->page_directory = mali_mmu_pagedir_alloc();
 	if (NULL == session->page_directory) {
-		goto err_mmu;
+		_mali_osk_notification_queue_term(session->ioctl_queue);
+		_mali_osk_free(session);
+		MALI_ERROR(_MALI_OSK_ERR_NOMEM);
 	}
 
 	if (_MALI_OSK_ERR_OK != mali_mmu_pagedir_map(session->page_directory, MALI_DLBU_VIRT_ADDR, _MALI_OSK_MALI_PAGE_SIZE)) {
 		MALI_PRINT_ERROR(("Failed to map DLBU page into session\n"));
-		goto err_mmu;
+		_mali_osk_notification_queue_term(session->ioctl_queue);
+		_mali_osk_free(session);
+		MALI_ERROR(_MALI_OSK_ERR_NOMEM);
 	}
 
 	if (0 != mali_dlbu_phys_addr) {
@@ -1144,30 +1099,31 @@ _mali_osk_errcode_t _mali_ukk_open(void **context)
 	}
 
 	if (_MALI_OSK_ERR_OK != mali_memory_session_begin(session)) {
-		goto err_session;
+		mali_mmu_pagedir_free(session->page_directory);
+		_mali_osk_notification_queue_term(session->ioctl_queue);
+		_mali_osk_free(session);
+		MALI_ERROR(_MALI_OSK_ERR_NOMEM);
 	}
 
 	/* Create soft system. */
 	session->soft_job_system = mali_soft_job_system_create(session);
 	if (NULL == session->soft_job_system) {
-		goto err_soft;
+		mali_memory_session_end(session);
+		mali_mmu_pagedir_free(session->page_directory);
+		_mali_osk_notification_queue_term(session->ioctl_queue);
+		_mali_osk_free(session);
+		MALI_ERROR(_MALI_OSK_ERR_NOMEM);
 	}
 
-	/* Initialize the dma fence context.*/
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
-	session->fence_context = fence_context_alloc(1);
-	_mali_osk_atomic_init(&session->fence_seqno, 0);
-#else
-	MALI_PRINT_ERROR(("The kernel version not support dma fence!\n"));
-	goto err_time_line;
-#endif
-#endif
-
 	/* Create timeline system. */
 	session->timeline_system = mali_timeline_system_create(session);
 	if (NULL == session->timeline_system) {
-		goto err_time_line;
+		mali_soft_job_system_destroy(session->soft_job_system);
+		mali_memory_session_end(session);
+		mali_mmu_pagedir_free(session->page_directory);
+		_mali_osk_notification_queue_term(session->ioctl_queue);
+		_mali_osk_free(session);
+		MALI_ERROR(_MALI_OSK_ERR_NOMEM);
 	}
 
 #if defined(CONFIG_MALI_DVFS)
@@ -1186,31 +1142,15 @@ _mali_osk_errcode_t _mali_ukk_open(void **context)
 
 	session->pid = _mali_osk_get_pid();
 	session->comm = _mali_osk_get_comm();
-	session->max_mali_mem_allocated_size = 0;
-	for (i = 0; i < MALI_MEM_TYPE_MAX; i ++) {
-		atomic_set(&session->mali_mem_array[i], 0);
-	}
-	atomic_set(&session->mali_mem_allocated_pages, 0);
+	session->max_mali_mem_allocated = 0;
+	_mali_osk_memset(session->mali_mem_array, 0, sizeof(size_t) * MALI_MEM_TYPE_MAX);
 	*context = (void *)session;
 
 	/* Add session to the list of all sessions. */
 	mali_session_add(session);
 
 	MALI_DEBUG_PRINT(3, ("Session started\n"));
-	return _MALI_OSK_ERR_OK;
-
-err_time_line:
-	mali_soft_job_system_destroy(session->soft_job_system);
-err_soft:
-	mali_memory_session_end(session);
-err_session:
-	mali_mmu_pagedir_free(session->page_directory);
-err_mmu:
-	_mali_osk_notification_queue_term(session->ioctl_queue);
-err:
-	_mali_osk_free(session);
-	MALI_ERROR(_MALI_OSK_ERR_NOMEM);
-
+	return _MALI_OSK_ERR_OK;;
 }
 
 #if defined(DEBUG)
@@ -1294,12 +1234,7 @@ _mali_osk_errcode_t _mali_ukk_close(void **context)
 	_mali_osk_atomic_term(&session->number_of_window_jobs);
 #endif
 
-#if defined(CONFIG_MALI400_PROFILING)
-	_mali_osk_profiling_stop_sampling(session->pid);
-#endif
-
 	/* Free session data structures */
-	mali_mmu_pagedir_unmap(session->page_directory, MALI_DLBU_VIRT_ADDR, _MALI_OSK_MALI_PAGE_SIZE);
 	mali_mmu_pagedir_free(session->page_directory);
 	_mali_osk_notification_queue_term(session->ioctl_queue);
 	_mali_osk_free(session);
diff --git a/drivers/gpu/arm/mali/common/mali_kernel_core.h b/drivers/gpu/arm/mali/common/mali_kernel_core.h
old mode 100755
new mode 100644
index cf6af326..390b72f9
--- a/drivers/gpu/arm/mali/common/mali_kernel_core.h
+++ b/drivers/gpu/arm/mali/common/mali_kernel_core.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -19,11 +19,9 @@ typedef enum {
 	_MALI_PRODUCT_ID_MALI300,
 	_MALI_PRODUCT_ID_MALI400,
 	_MALI_PRODUCT_ID_MALI450,
-	_MALI_PRODUCT_ID_MALI470,
 } _mali_product_id_t;
 
 extern mali_bool mali_gpu_class_is_mali450;
-extern mali_bool mali_gpu_class_is_mali470;
 
 _mali_osk_errcode_t mali_initialize_subsystems(void);
 
@@ -37,21 +35,22 @@ u32 mali_kernel_core_get_gpu_minor_version(void);
 
 u32 _mali_kernel_core_dump_state(char *buf, u32 size);
 
-MALI_STATIC_INLINE mali_bool mali_is_mali470(void)
-{
-	return mali_gpu_class_is_mali470;
-}
-
 MALI_STATIC_INLINE mali_bool mali_is_mali450(void)
 {
+#if defined(CONFIG_MALI450)
 	return mali_gpu_class_is_mali450;
+#else
+	return MALI_FALSE;
+#endif
 }
 
 MALI_STATIC_INLINE mali_bool mali_is_mali400(void)
 {
-	if (mali_gpu_class_is_mali450 || mali_gpu_class_is_mali470)
-		return MALI_FALSE;
-
+#if !defined(CONFIG_MALI450)
 	return MALI_TRUE;
+#else
+	return !mali_gpu_class_is_mali450;
+#endif
 }
+
 #endif /* __MALI_KERNEL_CORE_H__ */
diff --git a/drivers/gpu/arm/mali/common/mali_kernel_descriptor_mapping.c b/drivers/gpu/arm/mali/common/mali_kernel_descriptor_mapping.c
deleted file mode 100755
index ce33451b..00000000
--- a/drivers/gpu/arm/mali/common/mali_kernel_descriptor_mapping.c
+++ /dev/null
@@ -1,202 +0,0 @@
-/*
- * Copyright (C) 2010, 2012-2014 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#include "mali_kernel_common.h"
-#include "mali_kernel_descriptor_mapping.h"
-#include "mali_osk.h"
-#include "mali_osk_bitops.h"
-#include "mali_memory_types.h"
-#include "mali_session.h"
-
-#define MALI_PAD_INT(x) (((x) + (BITS_PER_LONG - 1)) & ~(BITS_PER_LONG - 1))
-
-/**
- * Allocate a descriptor table capable of holding 'count' mappings
- * @param count Number of mappings in the table
- * @return Pointer to a new table, NULL on error
- */
-static mali_descriptor_table *descriptor_table_alloc(int count);
-
-/**
- * Free a descriptor table
- * @param table The table to free
- */
-static void descriptor_table_free(mali_descriptor_table *table);
-
-mali_descriptor_mapping *mali_descriptor_mapping_create(int init_entries, int max_entries)
-{
-	mali_descriptor_mapping *map = _mali_osk_calloc(1, sizeof(mali_descriptor_mapping));
-
-	init_entries = MALI_PAD_INT(init_entries);
-	max_entries = MALI_PAD_INT(max_entries);
-
-	if (NULL != map) {
-		map->table = descriptor_table_alloc(init_entries);
-		if (NULL != map->table) {
-			map->lock = _mali_osk_mutex_rw_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_DESCRIPTOR_MAP);
-			if (NULL != map->lock) {
-				_mali_osk_set_nonatomic_bit(0, map->table->usage); /* reserve bit 0 to prevent NULL/zero logic to kick in */
-				map->max_nr_mappings_allowed = max_entries;
-				map->current_nr_mappings = init_entries;
-				return map;
-			}
-			descriptor_table_free(map->table);
-		}
-		_mali_osk_free(map);
-	}
-	return NULL;
-}
-
-void mali_descriptor_mapping_destroy(mali_descriptor_mapping *map)
-{
-	descriptor_table_free(map->table);
-	_mali_osk_mutex_rw_term(map->lock);
-	_mali_osk_free(map);
-}
-
-_mali_osk_errcode_t mali_descriptor_mapping_allocate_mapping(mali_descriptor_mapping *map, void *target, int *odescriptor)
-{
-	_mali_osk_errcode_t err = _MALI_OSK_ERR_FAULT;
-	int new_descriptor;
-	mali_mem_allocation *descriptor;
-	struct mali_session_data *session;
-
-	MALI_DEBUG_ASSERT_POINTER(map);
-	MALI_DEBUG_ASSERT_POINTER(odescriptor);
-	MALI_DEBUG_ASSERT_POINTER(target);
-
-	_mali_osk_mutex_rw_wait(map->lock, _MALI_OSK_LOCKMODE_RW);
-	new_descriptor = _mali_osk_find_first_zero_bit(map->table->usage, map->current_nr_mappings);
-	if (new_descriptor == map->current_nr_mappings) {
-		/* no free descriptor, try to expand the table */
-		mali_descriptor_table *new_table, * old_table;
-		if (map->current_nr_mappings >= map->max_nr_mappings_allowed) goto unlock_and_exit;
-
-		map->current_nr_mappings += BITS_PER_LONG;
-		new_table = descriptor_table_alloc(map->current_nr_mappings);
-		if (NULL == new_table) goto unlock_and_exit;
-
-		old_table = map->table;
-		_mali_osk_memcpy(new_table->usage, old_table->usage, (sizeof(unsigned long)*map->current_nr_mappings) / BITS_PER_LONG);
-		_mali_osk_memcpy(new_table->mappings, old_table->mappings, map->current_nr_mappings * sizeof(void *));
-		map->table = new_table;
-		descriptor_table_free(old_table);
-	}
-
-	/* we have found a valid descriptor, set the value and usage bit */
-	_mali_osk_set_nonatomic_bit(new_descriptor, map->table->usage);
-	map->table->mappings[new_descriptor] = target;
-	*odescriptor = new_descriptor;
-
-	/* To calculate the mali mem usage for the session */
-	descriptor = (mali_mem_allocation *)target;
-	session = descriptor->session;
-
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	session->mali_mem_array[descriptor->type] += descriptor->size;
-	if ((MALI_MEM_OS == descriptor->type || MALI_MEM_BLOCK == descriptor->type) &&
-	    (session->mali_mem_array[MALI_MEM_OS] + session->mali_mem_array[MALI_MEM_BLOCK] > session->max_mali_mem_allocated)) {
-		session->max_mali_mem_allocated = session->mali_mem_array[MALI_MEM_OS] + session->mali_mem_array[MALI_MEM_BLOCK];
-	}
-	err = _MALI_OSK_ERR_OK;
-
-unlock_and_exit:
-	_mali_osk_mutex_rw_signal(map->lock, _MALI_OSK_LOCKMODE_RW);
-	MALI_ERROR(err);
-}
-
-void mali_descriptor_mapping_call_for_each(mali_descriptor_mapping *map, void (*callback)(int, void *))
-{
-	int i;
-
-	MALI_DEBUG_ASSERT_POINTER(map);
-	MALI_DEBUG_ASSERT_POINTER(callback);
-
-	_mali_osk_mutex_rw_wait(map->lock, _MALI_OSK_LOCKMODE_RO);
-	/* id 0 is skipped as it's an reserved ID not mapping to anything */
-	for (i = 1; i < map->current_nr_mappings; ++i) {
-		if (_mali_osk_test_bit(i, map->table->usage)) {
-			callback(i, map->table->mappings[i]);
-		}
-	}
-	_mali_osk_mutex_rw_signal(map->lock, _MALI_OSK_LOCKMODE_RO);
-}
-
-_mali_osk_errcode_t mali_descriptor_mapping_get(mali_descriptor_mapping *map, int descriptor, void **target)
-{
-	_mali_osk_errcode_t result = _MALI_OSK_ERR_FAULT;
-	MALI_DEBUG_ASSERT_POINTER(map);
-	_mali_osk_mutex_rw_wait(map->lock, _MALI_OSK_LOCKMODE_RO);
-	if ((descriptor >= 0) && (descriptor < map->current_nr_mappings) && _mali_osk_test_bit(descriptor, map->table->usage)) {
-		*target = map->table->mappings[descriptor];
-		result = _MALI_OSK_ERR_OK;
-	} else *target = NULL;
-	_mali_osk_mutex_rw_signal(map->lock, _MALI_OSK_LOCKMODE_RO);
-	MALI_ERROR(result);
-}
-
-_mali_osk_errcode_t mali_descriptor_mapping_set(mali_descriptor_mapping *map, int descriptor, void *target)
-{
-	_mali_osk_errcode_t result = _MALI_OSK_ERR_FAULT;
-	_mali_osk_mutex_rw_wait(map->lock, _MALI_OSK_LOCKMODE_RO);
-	if ((descriptor >= 0) && (descriptor < map->current_nr_mappings) && _mali_osk_test_bit(descriptor, map->table->usage)) {
-		map->table->mappings[descriptor] = target;
-		result = _MALI_OSK_ERR_OK;
-	}
-	_mali_osk_mutex_rw_signal(map->lock, _MALI_OSK_LOCKMODE_RO);
-	MALI_ERROR(result);
-}
-
-void *mali_descriptor_mapping_free(mali_descriptor_mapping *map, int descriptor)
-{
-	void *old_value = NULL;
-	mali_mem_allocation *tmp_descriptor;
-	struct mali_session_data *session;
-
-	_mali_osk_mutex_rw_wait(map->lock, _MALI_OSK_LOCKMODE_RW);
-	if ((descriptor >= 0) && (descriptor < map->current_nr_mappings) && _mali_osk_test_bit(descriptor, map->table->usage)) {
-		old_value = map->table->mappings[descriptor];
-		map->table->mappings[descriptor] = NULL;
-		_mali_osk_clear_nonatomic_bit(descriptor, map->table->usage);
-	}
-	if (NULL != old_value) {
-		tmp_descriptor = (mali_mem_allocation *)old_value;
-		session = tmp_descriptor->session;
-
-		MALI_DEBUG_ASSERT_POINTER(session);
-
-		MALI_DEBUG_ASSERT(session->mali_mem_array[tmp_descriptor->type] >= tmp_descriptor->size);
-
-		session->mali_mem_array[tmp_descriptor->type] -= tmp_descriptor->size;
-	}
-	_mali_osk_mutex_rw_signal(map->lock, _MALI_OSK_LOCKMODE_RW);
-
-	return old_value;
-}
-
-static mali_descriptor_table *descriptor_table_alloc(int count)
-{
-	mali_descriptor_table *table;
-
-	table = _mali_osk_calloc(1, sizeof(mali_descriptor_table) + ((sizeof(unsigned long) * count) / BITS_PER_LONG) + (sizeof(void *) * count));
-
-	if (NULL != table) {
-		table->usage = (u32 *)((u8 *)table + sizeof(mali_descriptor_table));
-		table->mappings = (void **)((u8 *)table + sizeof(mali_descriptor_table) + ((sizeof(unsigned long) * count) / BITS_PER_LONG));
-	}
-
-	return table;
-}
-
-static void descriptor_table_free(mali_descriptor_table *table)
-{
-	_mali_osk_free(table);
-}
\ No newline at end of file
diff --git a/drivers/gpu/arm/mali/common/mali_kernel_descriptor_mapping.h b/drivers/gpu/arm/mali/common/mali_kernel_descriptor_mapping.h
deleted file mode 100755
index 90ac9bab..00000000
--- a/drivers/gpu/arm/mali/common/mali_kernel_descriptor_mapping.h
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2010, 2012-2014 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-/**
- * @file mali_kernel_descriptor_mapping.h
- */
-
-#ifndef __MALI_KERNEL_DESCRIPTOR_MAPPING_H__
-#define __MALI_KERNEL_DESCRIPTOR_MAPPING_H__
-
-#include "mali_osk.h"
-
-struct mali_session_data;
-
-/**
- * The actual descriptor mapping table, never directly accessed by clients
- */
-typedef struct mali_descriptor_table {
-	u32 *usage;  /**< Pointer to bitpattern indicating if a descriptor is valid/used or not */
-	void **mappings; /**< Array of the pointers the descriptors map to */
-} mali_descriptor_table;
-
-/**
- * The descriptor mapping object
- * Provides a separate namespace where we can map an integer to a pointer
- */
-typedef struct mali_descriptor_mapping {
-	_mali_osk_mutex_rw_t *lock; /**< Lock protecting access to the mapping object */
-	int max_nr_mappings_allowed; /**< Max number of mappings to support in this namespace */
-	int current_nr_mappings; /**< Current number of possible mappings */
-	mali_descriptor_table *table;  /**< Pointer to the current mapping table */
-} mali_descriptor_mapping;
-
-/**
- * Create a descriptor mapping object
- * Create a descriptor mapping capable of holding init_entries growable to max_entries
- * @param init_entries Number of entries to preallocate memory for
- * @param max_entries Number of entries to max support
- * @return Pointer to a descriptor mapping object, NULL on failure
- */
-mali_descriptor_mapping *mali_descriptor_mapping_create(int init_entries, int max_entries);
-
-/**
- * Destroy a descriptor mapping object
- * @param map The map to free
- */
-void mali_descriptor_mapping_destroy(mali_descriptor_mapping *map);
-
-/**
- * Allocate a new mapping entry (descriptor ID)
- * Allocates a new entry in the map.
- * @param map The map to allocate a new entry in
- * @param target The value to map to
- * @return The descriptor allocated, a negative value on error
- */
-_mali_osk_errcode_t mali_descriptor_mapping_allocate_mapping(mali_descriptor_mapping *map, void *target, int *descriptor);
-
-/**
- * Get the value mapped to by a descriptor ID
- * @param map The map to lookup the descriptor id in
- * @param descriptor The descriptor ID to lookup
- * @param target Pointer to a pointer which will receive the stored value
- * @return 0 on successful lookup, negative on error
- */
-_mali_osk_errcode_t mali_descriptor_mapping_get(mali_descriptor_mapping *map, int descriptor, void **target);
-
-/**
- * Set the value mapped to by a descriptor ID
- * @param map The map to lookup the descriptor id in
- * @param descriptor The descriptor ID to lookup
- * @param target Pointer to replace the current value with
- * @return 0 on successful lookup, negative on error
- */
-_mali_osk_errcode_t mali_descriptor_mapping_set(mali_descriptor_mapping *map, int descriptor, void *target);
-
-/**
- * Call the specified callback function for each descriptor in map.
- * Entire function is mutex protected.
- * @param map The map to do callbacks for
- * @param callback A callback function which will be calle for each entry in map
- */
-void mali_descriptor_mapping_call_for_each(mali_descriptor_mapping *map, void (*callback)(int, void *));
-
-/**
- * Free the descriptor ID
- * For the descriptor to be reused it has to be freed
- * @param map The map to free the descriptor from
- * @param descriptor The descriptor ID to free
- *
- * @return old value of descriptor mapping
- */
-void *mali_descriptor_mapping_free(mali_descriptor_mapping *map, int descriptor);
-
-#endif /* __MALI_KERNEL_DESCRIPTOR_MAPPING_H__ */
diff --git a/drivers/gpu/arm/mali/common/mali_kernel_utilization.c b/drivers/gpu/arm/mali/common/mali_kernel_utilization.c
old mode 100755
new mode 100644
index ca7ebea4..b5a3817f
--- a/drivers/gpu/arm/mali/common/mali_kernel_utilization.c
+++ b/drivers/gpu/arm/mali/common/mali_kernel_utilization.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_kernel_utilization.h b/drivers/gpu/arm/mali/common/mali_kernel_utilization.h
old mode 100755
new mode 100644
index 5206225c..e31dae56
--- a/drivers/gpu/arm/mali/common/mali_kernel_utilization.h
+++ b/drivers/gpu/arm/mali/common/mali_kernel_utilization.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_kernel_vsync.c b/drivers/gpu/arm/mali/common/mali_kernel_vsync.c
old mode 100755
new mode 100644
index 3b2b108c..fd2180e7
--- a/drivers/gpu/arm/mali/common/mali_kernel_vsync.c
+++ b/drivers/gpu/arm/mali/common/mali_kernel_vsync.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_l2_cache.c b/drivers/gpu/arm/mali/common/mali_l2_cache.c
old mode 100755
new mode 100644
index 1ed75532..64ffd2fb
--- a/drivers/gpu/arm/mali/common/mali_l2_cache.c
+++ b/drivers/gpu/arm/mali/common/mali_l2_cache.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -203,8 +203,7 @@ void mali_l2_cache_power_up(struct mali_l2_cache_core *cache)
 
 	mali_l2_cache_reset(cache);
 
-	if ((1 << MALI_DOMAIN_INDEX_DUMMY) != cache->pm_domain->pmu_mask)
-		MALI_DEBUG_ASSERT(MALI_FALSE == cache->power_is_on);
+	MALI_DEBUG_ASSERT(MALI_FALSE == cache->power_is_on);
 	cache->power_is_on = MALI_TRUE;
 
 	mali_l2_cache_unlock(cache);
@@ -467,22 +466,24 @@ void mali_l2_cache_invalidate_all_pages(u32 *pages, u32 num_pages)
 
 static void mali_l2_cache_reset(struct mali_l2_cache_core *cache)
 {
+    MALI_DEBUG_ASSERT_POINTER(cache);
+    MALI_DEBUG_ASSERT_LOCK_HELD(cache->lock);
 
-	if (cache && cache->pm_domain && !cache->pm_domain->power_is_on)
-		return;	
+    /* Kasin Added, skip off power domain. */
+    if (cache && cache->pm_domain && cache->pm_domain->power_is_on == MALI_FALSE) {
+        printk("===========%s, %d skip off power domain?\n", __FUNCTION__, __LINE__);
+    }
 
-	MALI_DEBUG_ASSERT_POINTER(cache);
-	MALI_DEBUG_ASSERT_LOCK_HELD(cache->lock);
 
-	/* Invalidate cache (just to keep it in a known state at startup) */
-	mali_l2_cache_send_command(cache, MALI400_L2_CACHE_REGISTER_COMMAND,
-				   MALI400_L2_CACHE_COMMAND_CLEAR_ALL);
+    /* Invalidate cache (just to keep it in a known state at startup) */
+    mali_l2_cache_send_command(cache, MALI400_L2_CACHE_REGISTER_COMMAND,
+            MALI400_L2_CACHE_COMMAND_CLEAR_ALL);
 
-	/* Enable cache */
-	mali_hw_core_register_write(&cache->hw_core,
-				    MALI400_L2_CACHE_REGISTER_ENABLE,
-				    (u32)MALI400_L2_CACHE_ENABLE_ACCESS |
-				    (u32)MALI400_L2_CACHE_ENABLE_READ_ALLOCATE);
+    /* Enable cache */
+    mali_hw_core_register_write(&cache->hw_core,
+            MALI400_L2_CACHE_REGISTER_ENABLE,
+            (u32)MALI400_L2_CACHE_ENABLE_ACCESS |
+            (u32)MALI400_L2_CACHE_ENABLE_READ_ALLOCATE);
 
 	if (MALI400_L2_MAX_READS_NOT_SET != mali_l2_max_reads) {
 		mali_hw_core_register_write(&cache->hw_core,
diff --git a/drivers/gpu/arm/mali/common/mali_l2_cache.h b/drivers/gpu/arm/mali/common/mali_l2_cache.h
old mode 100755
new mode 100644
index de92ad63..8ac75d87
--- a/drivers/gpu/arm/mali/common/mali_l2_cache.h
+++ b/drivers/gpu/arm/mali/common/mali_l2_cache.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_mem_validation.c b/drivers/gpu/arm/mali/common/mali_mem_validation.c
old mode 100755
new mode 100644
index 194fd52b..7ff53f28
--- a/drivers/gpu/arm/mali/common/mali_mem_validation.c
+++ b/drivers/gpu/arm/mali/common/mali_mem_validation.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -46,6 +46,7 @@ _mali_osk_errcode_t mali_mem_validation_add_range(u32 start, u32 size)
 
 _mali_osk_errcode_t mali_mem_validation_check(u32 phys_addr, u32 size)
 {
+#if 0
 	if (phys_addr < (phys_addr + size)) { /* Don't allow overflow (or zero size) */
 		if ((0 == (phys_addr & (~_MALI_OSK_CPU_PAGE_MASK))) &&
 		    (0 == (size & (~_MALI_OSK_CPU_PAGE_MASK)))) {
@@ -62,4 +63,7 @@ _mali_osk_errcode_t mali_mem_validation_check(u32 phys_addr, u32 size)
 	MALI_PRINT_ERROR(("MALI PHYSICAL RANGE VALIDATION ERROR: The range supplied was: phys_base=0x%08X, size=0x%08X\n", phys_addr, size));
 
 	return _MALI_OSK_ERR_FAULT;
+#else
+	return _MALI_OSK_ERR_OK;
+#endif
 }
diff --git a/drivers/gpu/arm/mali/common/mali_mem_validation.h b/drivers/gpu/arm/mali/common/mali_mem_validation.h
old mode 100755
new mode 100644
index f7e6cb10..9ac32ac8
--- a/drivers/gpu/arm/mali/common/mali_mem_validation.h
+++ b/drivers/gpu/arm/mali/common/mali_mem_validation.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_mmu.c b/drivers/gpu/arm/mali/common/mali_mmu.c
old mode 100755
new mode 100644
index fba53405..b12f0195
--- a/drivers/gpu/arm/mali/common/mali_mmu.c
+++ b/drivers/gpu/arm/mali/common/mali_mmu.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_mmu.h b/drivers/gpu/arm/mali/common/mali_mmu.h
old mode 100755
new mode 100644
index ac31c7ac..8080826f
--- a/drivers/gpu/arm/mali/common/mali_mmu.h
+++ b/drivers/gpu/arm/mali/common/mali_mmu.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -91,7 +91,6 @@ MALI_STATIC_INLINE enum mali_interrupt_result mali_mmu_get_interrupt_result(stru
 	if (0 == rawstat_used) {
 		return MALI_INTERRUPT_RESULT_NONE;
 	}
-
 	return MALI_INTERRUPT_RESULT_ERROR;
 }
 
diff --git a/drivers/gpu/arm/mali/common/mali_mmu_page_directory.c b/drivers/gpu/arm/mali/common/mali_mmu_page_directory.c
old mode 100755
new mode 100644
index 74d8cc85..8ff74ee2
--- a/drivers/gpu/arm/mali/common/mali_mmu_page_directory.c
+++ b/drivers/gpu/arm/mali/common/mali_mmu_page_directory.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -120,8 +120,8 @@ _mali_osk_errcode_t mali_mmu_pagedir_map(struct mali_page_directory *pagedir, u3
 	_mali_osk_errcode_t err;
 	mali_io_address pde_mapping;
 	mali_dma_addr pde_phys;
-	int i, page_count;
-	u32 start_address;
+	int i;
+
 	if (last_pde < first_pde)
 		return _MALI_OSK_ERR_INVALID_ARGS;
 
@@ -144,20 +144,9 @@ _mali_osk_errcode_t mali_mmu_pagedir_map(struct mali_page_directory *pagedir, u3
 							pde_phys | MALI_MMU_FLAGS_PRESENT);
 
 			MALI_DEBUG_ASSERT(0 == pagedir->page_entries_usage_count[i]);
-		}
-
-		if (first_pde == last_pde) {
-			pagedir->page_entries_usage_count[i] += size / MALI_MMU_PAGE_SIZE;
-		} else if (i == first_pde) {
-			start_address = i * MALI_MMU_VIRTUAL_PAGE_SIZE;
-			page_count = (start_address + MALI_MMU_VIRTUAL_PAGE_SIZE - mali_address) / MALI_MMU_PAGE_SIZE;
-			pagedir->page_entries_usage_count[i] += page_count;
-		} else if (i == last_pde) {
-			start_address = i * MALI_MMU_VIRTUAL_PAGE_SIZE;
-			page_count = (mali_address + size - start_address) / MALI_MMU_PAGE_SIZE;
-			pagedir->page_entries_usage_count[i] += page_count;
+			pagedir->page_entries_usage_count[i] = 1;
 		} else {
-			pagedir->page_entries_usage_count[i] = 1024;
+			pagedir->page_entries_usage_count[i]++;
 		}
 	}
 	_mali_osk_write_mem_barrier();
@@ -209,7 +198,7 @@ _mali_osk_errcode_t mali_mmu_pagedir_unmap(struct mali_page_directory *pagedir,
 			size_in_pde = MALI_MMU_VIRTUAL_PAGE_SIZE - offset;
 		}
 
-		pagedir->page_entries_usage_count[i] -= size_in_pde / MALI_MMU_PAGE_SIZE;
+		pagedir->page_entries_usage_count[i]--;
 
 		/* If entire page table is unused, free it */
 		if (0 == pagedir->page_entries_usage_count[i]) {
diff --git a/drivers/gpu/arm/mali/common/mali_mmu_page_directory.h b/drivers/gpu/arm/mali/common/mali_mmu_page_directory.h
old mode 100755
new mode 100644
index 4fc1058d..f7bd5304
--- a/drivers/gpu/arm/mali/common/mali_mmu_page_directory.h
+++ b/drivers/gpu/arm/mali/common/mali_mmu_page_directory.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_osk.h b/drivers/gpu/arm/mali/common/mali_osk.h
old mode 100755
new mode 100644
index 5c20fc32..fd89f4ec
--- a/drivers/gpu/arm/mali/common/mali_osk.h
+++ b/drivers/gpu/arm/mali/common/mali_osk.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -16,7 +16,6 @@
 #ifndef __MALI_OSK_H__
 #define __MALI_OSK_H__
 
-#include <linux/seq_file.h>
 #include "mali_osk_types.h"
 #include "mali_osk_specific.h"           /* include any per-os specifics */
 #include "mali_osk_locks.h"
@@ -51,8 +50,6 @@ extern "C" {
 #define MALI_DEBUG_ASSERT_LOCK_HELD(l) do {} while(0)
 #endif
 
-#define _mali_osk_ctxprintf     seq_printf
-
 /** @} */ /* end group _mali_osk_lock */
 
 /** @addtogroup _mali_osk_miscellaneous
@@ -1240,6 +1237,17 @@ void _mali_osk_dbgmsg(const char *fmt, ...);
  */
 u32 _mali_osk_snprintf(char *buf, u32 size, const char *fmt, ...);
 
+/** @brief Print fmt into print_ctx.
+ *
+ * The interpretation of \a fmt is the same as the \c format parameter in
+ * _mali_osu_vsnprintf().
+ *
+ * @param print_ctx a pointer to the result file buffer
+ * @param fmt a _mali_osu_vsnprintf() style format string
+ * @param ... a variable-number of parameters suitable for \a fmt
+ */
+void _mali_osk_ctxprintf(_mali_osk_print_ctx *print_ctx, const char *fmt, ...);
+
 /** @brief Abnormal process abort.
  *
  * Terminates the caller-process if this function is called.
@@ -1315,58 +1323,6 @@ void _mali_osk_pm_dev_barrier(void);
 
 /** @} */ /* end group  _mali_osk_miscellaneous */
 
-/** @defgroup _mali_osk_bitmap OSK Bitmap
- * @{ */
-
-/** @brief Allocate a unique number from the bitmap object.
- *
- * @param bitmap Initialized bitmap object.
- * @return An unique existence in the bitmap object.
- */
-u32 _mali_osk_bitmap_alloc(struct _mali_osk_bitmap *bitmap);
-
-/** @brief Free a interger to the bitmap object.
- *
- * @param bitmap Initialized bitmap object.
- * @param obj An number allocated from bitmap object.
- */
-void _mali_osk_bitmap_free(struct _mali_osk_bitmap *bitmap, u32 obj);
-
-/** @brief Allocate continuous number from the bitmap object.
- *
- * @param bitmap Initialized bitmap object.
- * @return start number of the continuous number block.
- */
-u32 _mali_osk_bitmap_alloc_range(struct _mali_osk_bitmap *bitmap, int cnt);
-
-/** @brief Free a block of continuous number block to the bitmap object.
- *
- * @param bitmap Initialized bitmap object.
- * @param obj Start number.
- * @param cnt The size of the continuous number block.
- */
-void _mali_osk_bitmap_free_range(struct _mali_osk_bitmap *bitmap, u32 obj, int cnt);
-
-/** @brief Available count could be used to allocate in the given bitmap object.
- *
- */
-u32 _mali_osk_bitmap_avail(struct _mali_osk_bitmap *bitmap);
-
-/** @brief Initialize an bitmap object..
- *
- * @param bitmap An poiter of uninitialized bitmap object.
- * @param num Size of thei bitmap object and decide the memory size allocated.
- * @param reserve start number used to allocate.
- */
-int _mali_osk_bitmap_init(struct _mali_osk_bitmap *bitmap, u32 num, u32 reserve);
-
-/** @brief Free the given bitmap object.
- *
- * @param bitmap Initialized bitmap object.
- */
-void _mali_osk_bitmap_term(struct _mali_osk_bitmap *bitmap);
-/** @} */ /* end group  _mali_osk_bitmap */
-
 /** @} */ /* end group osuapi */
 
 /** @} */ /* end group uddapi */
diff --git a/drivers/gpu/arm/mali/common/mali_osk_bitops.h b/drivers/gpu/arm/mali/common/mali_osk_bitops.h
old mode 100755
new mode 100644
index 61e0a911..ac1d8f52
--- a/drivers/gpu/arm/mali/common/mali_osk_bitops.h
+++ b/drivers/gpu/arm/mali/common/mali_osk_bitops.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_osk_list.h b/drivers/gpu/arm/mali/common/mali_osk_list.h
old mode 100755
new mode 100644
index a41f5ab3..2e259cc8
--- a/drivers/gpu/arm/mali/common/mali_osk_list.h
+++ b/drivers/gpu/arm/mali/common/mali_osk_list.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_osk_mali.h b/drivers/gpu/arm/mali/common/mali_osk_mali.h
old mode 100755
new mode 100644
index f242cd4e..08530ff9
--- a/drivers/gpu/arm/mali/common/mali_osk_mali.h
+++ b/drivers/gpu/arm/mali/common/mali_osk_mali.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -23,28 +23,6 @@
 extern "C" {
 #endif
 
-#ifdef CONFIG_MALI_DEVFREQ
-struct mali_device {
-	struct device *dev;
-#ifdef CONFIG_HAVE_CLK
-	struct clk *clock;
-#endif
-#ifdef CONFIG_REGULATOR
-	struct regulator *regulator;
-#endif
-#ifdef CONFIG_PM_DEVFREQ
-	struct devfreq_dev_profile devfreq_profile;
-	struct devfreq *devfreq;
-	unsigned long current_freq;
-	unsigned long current_voltage;
-#ifdef CONFIG_DEVFREQ_THERMAL
-	struct thermal_cooling_device *devfreq_cooling;
-#endif
-#endif
-	struct mali_pm_metrics_data mali_metrics;
-};
-#endif
-
 /** @addtogroup _mali_osk_miscellaneous
  * @{ */
 
@@ -75,15 +53,11 @@ _mali_osk_errcode_t _mali_osk_resource_find(u32 addr, _mali_osk_resource_t *res)
  */
 uintptr_t _mali_osk_resource_base_address(void);
 
-/** @brief Find the specific GPU resource.
- *
- * @return value
- * 0x400 if Mali 400 specific GPU resource identified
- * 0x450 if Mali 450 specific GPU resource identified
- * 0x470 if Mali 470 specific GPU resource identified
+/** @brief Find the number of L2 cache cores.
  *
+ * @return return the number of l2 cache cores we find in device resources.
  */
-u32 _mali_osk_identify_gpu_resource(void);
+u32 _mali_osk_l2_resource_count(void);
 
 /** @brief Retrieve the Mali GPU specific data
  *
@@ -110,38 +84,6 @@ u32 _mali_osk_get_pmu_switch_delay(void);
  */
 mali_bool _mali_osk_shared_interrupts(void);
 
-/** @brief Initialize the gpu secure mode.
- * The gpu secure mode will initially be in a disabled state.
- * @return _MALI_OSK_ERR_OK on success, otherwise failure.
- */
-_mali_osk_errcode_t _mali_osk_gpu_secure_mode_init(void);
-
-/** @brief Deinitialize the gpu secure mode.
- * @return _MALI_OSK_ERR_OK on success, otherwise failure.
- */
-_mali_osk_errcode_t _mali_osk_gpu_secure_mode_deinit(void);
-
-/** @brief Reset GPU and enable the gpu secure mode.
- * @return _MALI_OSK_ERR_OK on success, otherwise failure.
- */
-_mali_osk_errcode_t _mali_osk_gpu_reset_and_secure_mode_enable(void);
-
-/** @brief Reset GPU and disable the gpu secure mode.
- * @return _MALI_OSK_ERR_OK on success, otherwise failure.
- */
-_mali_osk_errcode_t _mali_osk_gpu_reset_and_secure_mode_disable(void);
-
-/** @brief Check if the gpu secure mode has been enabled.
- * @return MALI_TRUE if enabled, otherwise MALI_FALSE.
- */
-mali_bool _mali_osk_gpu_secure_mode_is_enabled(void);
-
-/** @brief Check if the gpu secure mode is supported.
- * @return MALI_TRUE if supported, otherwise MALI_FALSE.
- */
-mali_bool _mali_osk_gpu_secure_mode_is_supported(void);
-
-
 /** @} */ /* end group _mali_osk_miscellaneous */
 
 #ifdef __cplusplus
diff --git a/drivers/gpu/arm/mali/common/mali_osk_profiling.h b/drivers/gpu/arm/mali/common/mali_osk_profiling.h
old mode 100755
new mode 100644
index eca6ad49..662b1671
--- a/drivers/gpu/arm/mali/common/mali_osk_profiling.h
+++ b/drivers/gpu/arm/mali/common/mali_osk_profiling.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -35,11 +35,6 @@ _mali_osk_errcode_t _mali_osk_profiling_init(mali_bool auto_start);
  */
 void _mali_osk_profiling_term(void);
 
-/**
- * Stop the profile sampling operation.
- */
-void _mali_osk_profiling_stop_sampling(u32 pid);
-
 /**
  * Start recording profiling data
  *
@@ -60,8 +55,10 @@ _mali_osk_errcode_t _mali_osk_profiling_start(u32 *limit);
  * @param data2 Third data parameter, depending on event_id specified.
  * @param data3 Fourth data parameter, depending on event_id specified.
  * @param data4 Fifth data parameter, depending on event_id specified.
+ * @return _MALI_OSK_ERR_OK on success, otherwise failure.
  */
-void    _mali_osk_profiling_add_event(u32 event_id, u32 data0, u32 data1, u32 data2, u32 data3, u32 data4);
+/* Call Linux tracepoint directly */
+#define _mali_osk_profiling_add_event(event_id, data0, data1, data2, data3, data4) trace_mali_timeline_event((event_id), (data0), (data1), (data2), (data3), (data4))
 
 /**
  * Report a hardware counter event.
@@ -80,8 +77,6 @@ void    _mali_osk_profiling_add_event(u32 event_id, u32 data0, u32 data1, u32 da
  */
 void _mali_osk_profiling_report_sw_counters(u32 *counters);
 
-void _mali_osk_profiling_record_global_counters(int counter_id, u32 value);
-
 /**
  * Stop recording profiling data
  *
diff --git a/drivers/gpu/arm/mali/common/mali_osk_types.h b/drivers/gpu/arm/mali/common/mali_osk_types.h
old mode 100755
new mode 100644
index 6e9a1336..960137b2
--- a/drivers/gpu/arm/mali/common/mali_osk_types.h
+++ b/drivers/gpu/arm/mali/common/mali_osk_types.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -64,9 +64,6 @@ typedef unsigned long mali_bool;
 
 #define MALI_HW_CORE_NO_COUNTER     ((u32)-1)
 
-
-#define MALI_S32_MAX 0x7fffffff
-
 /**
  * @brief OSK Error codes
  *
@@ -452,18 +449,6 @@ typedef struct _mali_osk_wait_queue_t_struct _mali_osk_wait_queue_t;
   */
 typedef struct seq_file _mali_osk_print_ctx;
 
-#define _MALI_OSK_BITMAP_INVALIDATE_INDEX -1
-
-typedef struct _mali_osk_bitmap {
-	u32         reserve;
-	u32         last;
-	u32         max;
-	u32         avail;
-	_mali_osk_spinlock_t   *lock;
-	unsigned long          *table;
-} _mali_osk_bitmap_t;
-
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/gpu/arm/mali/common/mali_pm.c b/drivers/gpu/arm/mali/common/mali_pm.c
old mode 100755
new mode 100644
index 1ef03a69..fa4b9205
--- a/drivers/gpu/arm/mali/common/mali_pm.c
+++ b/drivers/gpu/arm/mali/common/mali_pm.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -974,8 +974,6 @@ static void mali_pm_set_default_pm_domain_config(void)
 			domain_config[MALI_DOMAIN_INDEX_PP0] = 0x01 << 2;
 		} else if (mali_is_mali450()) {
 			domain_config[MALI_DOMAIN_INDEX_PP0] = 0x01 << 1;
-		} else if (mali_is_mali470()) {
-			domain_config[MALI_DOMAIN_INDEX_PP0] = 0x01 << 0;
 		}
 	}
 
@@ -985,8 +983,6 @@ static void mali_pm_set_default_pm_domain_config(void)
 			domain_config[MALI_DOMAIN_INDEX_PP1] = 0x01 << 3;
 		} else if (mali_is_mali450()) {
 			domain_config[MALI_DOMAIN_INDEX_PP1] = 0x01 << 2;
-		} else if (mali_is_mali470()) {
-			domain_config[MALI_DOMAIN_INDEX_PP1] = 0x01 << 1;
 		}
 	}
 
@@ -996,8 +992,6 @@ static void mali_pm_set_default_pm_domain_config(void)
 			domain_config[MALI_DOMAIN_INDEX_PP2] = 0x01 << 4;
 		} else if (mali_is_mali450()) {
 			domain_config[MALI_DOMAIN_INDEX_PP2] = 0x01 << 2;
-		} else if (mali_is_mali470()) {
-			domain_config[MALI_DOMAIN_INDEX_PP2] = 0x01 << 1;
 		}
 	}
 
@@ -1007,8 +1001,6 @@ static void mali_pm_set_default_pm_domain_config(void)
 			domain_config[MALI_DOMAIN_INDEX_PP3] = 0x01 << 5;
 		} else if (mali_is_mali450()) {
 			domain_config[MALI_DOMAIN_INDEX_PP3] = 0x01 << 2;
-		} else if (mali_is_mali470()) {
-			domain_config[MALI_DOMAIN_INDEX_PP3] = 0x01 << 1;
 		}
 	}
 
@@ -1054,11 +1046,6 @@ static void mali_pm_set_default_pm_domain_config(void)
 			    MALI450_OFFSET_L2_CACHE2, NULL)) {
 			domain_config[MALI_DOMAIN_INDEX_L22] = 0x01 << 3;
 		}
-	} else if (mali_is_mali470()) {
-		if (_MALI_OSK_ERR_OK == _mali_osk_resource_find(
-			    MALI470_OFFSET_L2_CACHE1, NULL)) {
-			domain_config[MALI_DOMAIN_INDEX_L21] = 0x01 << 0;
-		}
 	}
 }
 
@@ -1350,13 +1337,3 @@ void mali_pm_get_best_power_cost_mask(int num_requested, int *dst)
 
 	_mali_osk_memcpy(dst, mali_pm_domain_power_cost_result[num_requested], MALI_MAX_NUMBER_OF_DOMAINS * sizeof(int));
 }
-
-u32 mali_pm_get_current_mask(void)
-{
-	return pd_mask_current;
-}
-
-u32 mali_pm_get_wanted_mask(void)
-{
-	return pd_mask_wanted;
-}
diff --git a/drivers/gpu/arm/mali/common/mali_pm.h b/drivers/gpu/arm/mali/common/mali_pm.h
old mode 100755
new mode 100644
index 3c11977f..b60c54c3
--- a/drivers/gpu/arm/mali/common/mali_pm.h
+++ b/drivers/gpu/arm/mali/common/mali_pm.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -86,6 +86,4 @@ void mali_pm_get_best_power_cost_mask(int num_requested, int *dst);
 const char *mali_pm_mask_to_string(u32 mask);
 #endif
 
-u32 mali_pm_get_current_mask(void);
-u32 mali_pm_get_wanted_mask(void);
 #endif /* __MALI_PM_H__ */
diff --git a/drivers/gpu/arm/mali/common/mali_pm_domain.c b/drivers/gpu/arm/mali/common/mali_pm_domain.c
old mode 100755
new mode 100644
index 9db84886..db38cd77
--- a/drivers/gpu/arm/mali/common/mali_pm_domain.c
+++ b/drivers/gpu/arm/mali/common/mali_pm_domain.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_pm_domain.h b/drivers/gpu/arm/mali/common/mali_pm_domain.h
old mode 100755
new mode 100644
index 2ac8c0d3..fd64c79c
--- a/drivers/gpu/arm/mali/common/mali_pm_domain.h
+++ b/drivers/gpu/arm/mali/common/mali_pm_domain.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_pm_metrics.c b/drivers/gpu/arm/mali/common/mali_pm_metrics.c
deleted file mode 100755
index 981ec815..00000000
--- a/drivers/gpu/arm/mali/common/mali_pm_metrics.c
+++ /dev/null
@@ -1,255 +0,0 @@
-/*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-#include "mali_pm_metrics.h"
-#include "mali_osk_locks.h"
-#include "mali_osk_mali.h"
-#include <linux/ktime.h>
-
-#define MALI_PM_TIME_SHIFT 0
-#define MALI_UTILIZATION_MAX_PERIOD 80000000/* ns = 100ms */
-
-_mali_osk_errcode_t mali_pm_metrics_init(struct mali_device *mdev)
-{
-	int i = 0;
-
-	MALI_DEBUG_ASSERT(mdev != NULL);
-
-	mdev->mali_metrics.time_period_start = ktime_get();
-	mdev->mali_metrics.time_period_start_gp = mdev->mali_metrics.time_period_start;
-	mdev->mali_metrics.time_period_start_pp = mdev->mali_metrics.time_period_start;
-
-	mdev->mali_metrics.time_busy = 0;
-	mdev->mali_metrics.time_idle = 0;
-	mdev->mali_metrics.prev_busy = 0;
-	mdev->mali_metrics.prev_idle = 0;
-	mdev->mali_metrics.num_running_gp_cores = 0;
-	mdev->mali_metrics.num_running_pp_cores = 0;
-	mdev->mali_metrics.time_busy_gp = 0;
-	mdev->mali_metrics.time_idle_gp = 0;
-
-	for (i = 0; i < MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS; i++) {
-		mdev->mali_metrics.time_busy_pp[i] = 0;
-		mdev->mali_metrics.time_idle_pp[i] = 0;
-	}
-	mdev->mali_metrics.gpu_active = MALI_FALSE;
-
-	mdev->mali_metrics.lock = _mali_osk_spinlock_irq_init(_MALI_OSK_LOCKFLAG_UNORDERED, _MALI_OSK_LOCK_ORDER_FIRST);
-	if (NULL == mdev->mali_metrics.lock) {
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	return _MALI_OSK_ERR_OK;
-}
-
-void mali_pm_metrics_term(struct mali_device *mdev)
-{
-	_mali_osk_spinlock_irq_term(mdev->mali_metrics.lock);
-}
-
-/*caller needs to hold mdev->mali_metrics.lock before calling this function*/
-void mali_pm_record_job_status(struct mali_device *mdev)
-{
-	ktime_t now;
-	ktime_t diff;
-	u64 ns_time;
-
-	MALI_DEBUG_ASSERT(mdev != NULL);
-
-	now = ktime_get();
-	diff = ktime_sub(now, mdev->mali_metrics.time_period_start);
-
-	ns_time = (u64)(ktime_to_ns(diff) >> MALI_PM_TIME_SHIFT);
-	mdev->mali_metrics.time_busy += ns_time;
-	mdev->mali_metrics.time_period_start = now;
-}
-
-void mali_pm_record_gpu_idle(mali_bool is_gp)
-{
-	ktime_t now;
-	ktime_t diff;
-	u64 ns_time;
-	struct mali_device *mdev = dev_get_drvdata(&mali_platform_device->dev);
-
-	MALI_DEBUG_ASSERT(mdev != NULL);
-
-	_mali_osk_spinlock_irq_lock(mdev->mali_metrics.lock);
-	now = ktime_get();
-
-	if (MALI_TRUE == is_gp) {
-		--mdev->mali_metrics.num_running_gp_cores;
-		if (0 == mdev->mali_metrics.num_running_gp_cores) {
-			diff = ktime_sub(now, mdev->mali_metrics.time_period_start_gp);
-			ns_time = (u64)(ktime_to_ns(diff) >> MALI_PM_TIME_SHIFT);
-			mdev->mali_metrics.time_busy_gp += ns_time;
-			mdev->mali_metrics.time_period_start_gp = now;
-
-			if (0 == mdev->mali_metrics.num_running_pp_cores) {
-				MALI_DEBUG_ASSERT(mdev->mali_metrics.gpu_active == MALI_TRUE);
-				diff = ktime_sub(now, mdev->mali_metrics.time_period_start);
-				ns_time = (u64)(ktime_to_ns(diff) >> MALI_PM_TIME_SHIFT);
-				mdev->mali_metrics.time_busy += ns_time;
-				mdev->mali_metrics.time_period_start = now;
-				mdev->mali_metrics.gpu_active = MALI_FALSE;
-			}
-		}
-	} else {
-		--mdev->mali_metrics.num_running_pp_cores;
-		if (0 == mdev->mali_metrics.num_running_pp_cores) {
-			diff = ktime_sub(now, mdev->mali_metrics.time_period_start_pp);
-			ns_time = (u64)(ktime_to_ns(diff) >> MALI_PM_TIME_SHIFT);
-			mdev->mali_metrics.time_busy_pp[0] += ns_time;
-			mdev->mali_metrics.time_period_start_pp = now;
-
-			if (0 == mdev->mali_metrics.num_running_gp_cores) {
-				MALI_DEBUG_ASSERT(mdev->mali_metrics.gpu_active == MALI_TRUE);
-				diff = ktime_sub(now, mdev->mali_metrics.time_period_start);
-				ns_time = (u64)(ktime_to_ns(diff) >> MALI_PM_TIME_SHIFT);
-				mdev->mali_metrics.time_busy += ns_time;
-				mdev->mali_metrics.time_period_start = now;
-				mdev->mali_metrics.gpu_active = MALI_FALSE;
-			}
-		}
-	}
-
-	_mali_osk_spinlock_irq_unlock(mdev->mali_metrics.lock);
-}
-
-void mali_pm_record_gpu_active(mali_bool is_gp)
-{
-	ktime_t now;
-	ktime_t diff;
-	struct mali_device *mdev = dev_get_drvdata(&mali_platform_device->dev);
-
-	MALI_DEBUG_ASSERT(mdev != NULL);
-
-	_mali_osk_spinlock_irq_lock(mdev->mali_metrics.lock);
-	now = ktime_get();
-
-	if (MALI_TRUE == is_gp) {
-		mdev->mali_metrics.num_running_gp_cores++;
-		if (1 == mdev->mali_metrics.num_running_gp_cores) {
-			diff = ktime_sub(now, mdev->mali_metrics.time_period_start_gp);
-			mdev->mali_metrics.time_idle_gp += (u64)(ktime_to_ns(diff) >> MALI_PM_TIME_SHIFT);
-			mdev->mali_metrics.time_period_start_gp = now;
-			if (0 == mdev->mali_metrics.num_running_pp_cores) {
-				MALI_DEBUG_ASSERT(mdev->mali_metrics.gpu_active == MALI_FALSE);
-				diff = ktime_sub(now, mdev->mali_metrics.time_period_start);
-				mdev->mali_metrics.time_idle += (u64)(ktime_to_ns(diff) >> MALI_PM_TIME_SHIFT);
-				mdev->mali_metrics.time_period_start = now;
-				mdev->mali_metrics.gpu_active = MALI_TRUE;
-			}
-		} else {
-			MALI_DEBUG_ASSERT(mdev->mali_metrics.gpu_active == MALI_TRUE);
-		}
-	} else {
-		mdev->mali_metrics.num_running_pp_cores++;
-		if (1 == mdev->mali_metrics.num_running_pp_cores) {
-			diff = ktime_sub(now, mdev->mali_metrics.time_period_start_pp);
-			mdev->mali_metrics.time_idle_pp[0] += (u64)(ktime_to_ns(diff) >> MALI_PM_TIME_SHIFT);
-			mdev->mali_metrics.time_period_start_pp = now;
-			if (0 == mdev->mali_metrics.num_running_gp_cores) {
-				MALI_DEBUG_ASSERT(mdev->mali_metrics.gpu_active == MALI_FALSE);
-				diff = ktime_sub(now, mdev->mali_metrics.time_period_start);
-				mdev->mali_metrics.time_idle += (u64)(ktime_to_ns(diff) >> MALI_PM_TIME_SHIFT);
-				mdev->mali_metrics.time_period_start = now;
-				mdev->mali_metrics.gpu_active = MALI_TRUE;
-			}
-		} else {
-			MALI_DEBUG_ASSERT(mdev->mali_metrics.gpu_active == MALI_TRUE);
-		}
-	}
-
-	_mali_osk_spinlock_irq_unlock(mdev->mali_metrics.lock);
-}
-
-
-/*caller needs to hold mdev->mali_metrics.lock before calling this function*/
-static void mali_pm_get_dvfs_utilisation_calc(struct mali_device *mdev, ktime_t now)
-{
-	ktime_t diff;
-
-	MALI_DEBUG_ASSERT(mdev != NULL);
-
-	diff = ktime_sub(now, mdev->mali_metrics.time_period_start);
-
-	if (mdev->mali_metrics.gpu_active) {
-		mdev->mali_metrics.time_busy += (u64)(ktime_to_ns(diff) >> MALI_PM_TIME_SHIFT);
-	} else {
-		mdev->mali_metrics.time_idle += (u64)(ktime_to_ns(diff) >> MALI_PM_TIME_SHIFT);
-	}
-}
-
-/* Caller needs to hold mdev->mali_metrics.lock before calling this function. */
-static void mali_pm_reset_dvfs_utilisation_unlocked(struct mali_device *mdev, ktime_t now)
-{
-	/* Store previous value */
-	mdev->mali_metrics.prev_idle = mdev->mali_metrics.time_idle;
-	mdev->mali_metrics.prev_busy = mdev->mali_metrics.time_busy;
-
-	/* Reset current values */
-	mdev->mali_metrics.time_period_start = now;
-	mdev->mali_metrics.time_period_start_gp = now;
-	mdev->mali_metrics.time_period_start_pp = now;
-	mdev->mali_metrics.time_idle = 0;
-	mdev->mali_metrics.time_busy = 0;
-
-	mdev->mali_metrics.time_busy_gp = 0;
-	mdev->mali_metrics.time_idle_gp = 0;
-	mdev->mali_metrics.time_busy_pp[0] = 0;
-	mdev->mali_metrics.time_idle_pp[0] = 0;
-}
-
-void mali_pm_reset_dvfs_utilisation(struct mali_device *mdev)
-{
-	_mali_osk_spinlock_irq_lock(mdev->mali_metrics.lock);
-	mali_pm_reset_dvfs_utilisation_unlocked(mdev, ktime_get());
-	_mali_osk_spinlock_irq_unlock(mdev->mali_metrics.lock);
-}
-
-void mali_pm_get_dvfs_utilisation(struct mali_device *mdev,
-				  unsigned long *total_out, unsigned long *busy_out)
-{
-	ktime_t now = ktime_get();
-	u64 busy = 0;
-	u64 total = 0;
-
-	_mali_osk_spinlock_irq_lock(mdev->mali_metrics.lock);
-
-	mali_pm_get_dvfs_utilisation_calc(mdev, now);
-
-	busy = mdev->mali_metrics.time_busy;
-	total = busy + mdev->mali_metrics.time_idle;
-
-	/* Reset stats if older than MALI_UTILIZATION_MAX_PERIOD (default
-	 * 100ms) */
-	if (total >= MALI_UTILIZATION_MAX_PERIOD) {
-		mali_pm_reset_dvfs_utilisation_unlocked(mdev, now);
-	} else if (total < (MALI_UTILIZATION_MAX_PERIOD / 2)) {
-		total += mdev->mali_metrics.prev_idle +
-			 mdev->mali_metrics.prev_busy;
-		busy += mdev->mali_metrics.prev_busy;
-	}
-
-	*total_out = (unsigned long)total;
-	*busy_out = (unsigned long)busy;
-	_mali_osk_spinlock_irq_unlock(mdev->mali_metrics.lock);
-}
-
-void mali_pm_metrics_spin_lock(void)
-{
-	struct mali_device *mdev = dev_get_drvdata(&mali_platform_device->dev);
-	_mali_osk_spinlock_irq_lock(mdev->mali_metrics.lock);
-}
-
-void mali_pm_metrics_spin_unlock(void)
-{
-	struct mali_device *mdev = dev_get_drvdata(&mali_platform_device->dev);
-	_mali_osk_spinlock_irq_unlock(mdev->mali_metrics.lock);
-}
diff --git a/drivers/gpu/arm/mali/common/mali_pm_metrics.h b/drivers/gpu/arm/mali/common/mali_pm_metrics.h
deleted file mode 100755
index 256f4484..00000000
--- a/drivers/gpu/arm/mali/common/mali_pm_metrics.h
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#ifndef __MALI_PM_METRICS_H__
-#define __MALI_PM_METRICS_H__
-
-#ifdef CONFIG_MALI_DEVFREQ
-#include "mali_osk_locks.h"
-#include "mali_group.h"
-
-struct mali_device;
-
-/**
- * Metrics data collected for use by the power management framework.
- */
-struct mali_pm_metrics_data {
-	ktime_t time_period_start;
-	u64 time_busy;
-	u64 time_idle;
-	u64 prev_busy;
-	u64 prev_idle;
-	u32 num_running_gp_cores;
-	u32 num_running_pp_cores;
-	ktime_t time_period_start_gp;
-	u64 time_busy_gp;
-	u64 time_idle_gp;
-	ktime_t time_period_start_pp;
-	u64 time_busy_pp[MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS];
-	u64 time_idle_pp[MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS];
-	mali_bool gpu_active;
-	_mali_osk_spinlock_irq_t *lock;
-};
-
-/**
- * Initialize/start the Mali GPU pm_metrics metrics reporting.
- *
- * @return _MALI_OSK_ERR_OK on success, otherwise failure.
- */
-_mali_osk_errcode_t mali_pm_metrics_init(struct mali_device *mdev);
-
-/**
- * Terminate the Mali GPU pm_metrics metrics reporting
- */
-void mali_pm_metrics_term(struct mali_device *mdev);
-
-/**
- * Should be called when a job is about to execute a GPU job
- */
-void mali_pm_record_gpu_active(mali_bool is_gp);
-
-/**
- * Should be called when a job is finished
- */
-void mali_pm_record_gpu_idle(mali_bool is_gp);
-
-void mali_pm_reset_dvfs_utilisation(struct mali_device *mdev);
-
-void mali_pm_get_dvfs_utilisation(struct mali_device *mdev, unsigned long *total_out, unsigned long *busy_out);
-
-void mali_pm_metrics_spin_lock(void);
-
-void mali_pm_metrics_spin_unlock(void);
-#else
-void mali_pm_record_gpu_idle(mali_bool is_gp) {}
-void mali_pm_record_gpu_active(mali_bool is_gp) {}
-#endif
-#endif /* __MALI_PM_METRICS_H__ */
diff --git a/drivers/gpu/arm/mali/common/mali_pmu.c b/drivers/gpu/arm/mali/common/mali_pmu.c
old mode 100755
new mode 100644
index 9f2487ac..94972cbf
--- a/drivers/gpu/arm/mali/common/mali_pmu.c
+++ b/drivers/gpu/arm/mali/common/mali_pmu.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -143,10 +143,7 @@ _mali_osk_errcode_t mali_pmu_power_down(struct mali_pmu_core *pmu, u32 mask)
 	 */
 	MALI_DEBUG_ASSERT(0 == (stat & mask));
 
-	mask  &= ~(0x1 << MALI_DOMAIN_INDEX_DUMMY);
-
 	if (0 == mask || 0 == ((~stat) & mask)) return _MALI_OSK_ERR_OK;
-	if (mask == 8) return _MALI_OSK_ERR_OK;
 
 	mali_hw_core_register_write(&pmu->hw_core,
 				    PMU_REG_ADDR_MGMT_POWER_DOWN, mask);
@@ -156,7 +153,7 @@ _mali_osk_errcode_t mali_pmu_power_down(struct mali_pmu_core *pmu, u32 mask)
 	 * powered off by our power down command, because the HW will simply
 	 * not generate an interrupt in this case.
 	 */
-	if (mali_is_mali450() || mali_is_mali470() || pmu->registered_cores_mask != (mask | stat)) {
+	if (mali_is_mali450() || pmu->registered_cores_mask != (mask | stat)) {
 		err = mali_pmu_wait_for_command_finish(pmu);
 		if (_MALI_OSK_ERR_OK != err) {
 			return err;
@@ -170,7 +167,7 @@ _mali_osk_errcode_t mali_pmu_power_down(struct mali_pmu_core *pmu, u32 mask)
 	/* Verify power status of domains after power down */
 	stat = mali_hw_core_register_read(&pmu->hw_core,
 					  PMU_REG_ADDR_MGMT_STATUS);
-	//MALI_DEBUG_ASSERT(mask == (stat & mask));
+	MALI_DEBUG_ASSERT(mask == (stat & mask));
 #endif
 
 	return _MALI_OSK_ERR_OK;
@@ -198,8 +195,6 @@ _mali_osk_errcode_t mali_pmu_power_up(struct mali_pmu_core *pmu, u32 mask)
 	stat = mali_hw_core_register_read(&pmu->hw_core,
 					  PMU_REG_ADDR_MGMT_STATUS);
 	stat &= pmu->registered_cores_mask;
-
-	mask  &= ~(0x1 << MALI_DOMAIN_INDEX_DUMMY);
 	if (0 == mask || 0 == (stat & mask)) return _MALI_OSK_ERR_OK;
 
 	/*
diff --git a/drivers/gpu/arm/mali/common/mali_pmu.h b/drivers/gpu/arm/mali/common/mali_pmu.h
old mode 100755
new mode 100644
index 36ff58ea..715020dc
--- a/drivers/gpu/arm/mali/common/mali_pmu.h
+++ b/drivers/gpu/arm/mali/common/mali_pmu.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_pp.c b/drivers/gpu/arm/mali/common/mali_pp.c
old mode 100755
new mode 100644
index 81f03848..1d4484b6
--- a/drivers/gpu/arm/mali/common/mali_pp.c
+++ b/drivers/gpu/arm/mali/common/mali_pp.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -15,11 +15,12 @@
 #include "regs/mali_200_regs.h"
 #include "mali_kernel_common.h"
 #include "mali_kernel_core.h"
-
 #if defined(CONFIG_MALI400_PROFILING)
 #include "mali_osk_profiling.h"
 #endif
 
+#include <mali_platform.h>
+
 /* Number of frame registers on Mali-200 */
 #define MALI_PP_MALI200_NUM_FRAME_REGISTERS ((0x04C/4)+1)
 /* Number of frame registers on Mali-300 and later */
@@ -44,7 +45,7 @@ struct mali_pp_core *mali_pp_create(const _mali_osk_resource_t *resource, struct
 		return NULL;
 	}
 
-	core = _mali_osk_calloc(1, sizeof(struct mali_pp_core));
+	core = _mali_osk_malloc(sizeof(struct mali_pp_core));
 	if (NULL != core) {
 		core->core_id = mali_global_num_pp_cores;
 		core->bcast_id = bcast_id;
@@ -148,6 +149,8 @@ _mali_osk_errcode_t mali_pp_stop_bus_wait(struct mali_pp_core *core)
 
 	if (MALI_REG_POLL_COUNT_FAST == i) {
 		MALI_PRINT_ERROR(("Mali PP: Failed to stop bus on %s. Status: 0x%08x\n", core->hw_core.description, mali_hw_core_register_read(&core->hw_core, MALI200_REG_ADDR_MGMT_STATUS)));
+		if (mali_gp_reset_fail < 65533)
+			mali_gp_reset_fail++;
 		return _MALI_OSK_ERR_FAULT;
 	}
 	return _MALI_OSK_ERR_OK;
@@ -203,7 +206,6 @@ static const u32 mali_perf_cnt_enable_reset_value = 0;
 _mali_osk_errcode_t mali_pp_hard_reset(struct mali_pp_core *core)
 {
 	/* Bus must be stopped before calling this function */
-	const u32 reset_wait_target_register = MALI200_REG_ADDR_MGMT_PERF_CNT_0_LIMIT;
 	const u32 reset_invalid_value = 0xC0FFE000;
 	const u32 reset_check_value = 0xC01A0000;
 	int i;
@@ -212,7 +214,7 @@ _mali_osk_errcode_t mali_pp_hard_reset(struct mali_pp_core *core)
 	MALI_DEBUG_PRINT(2, ("Mali PP: Hard reset of core %s\n", core->hw_core.description));
 
 	/* Set register to a bogus value. The register will be used to detect when reset is complete */
-	mali_hw_core_register_write_relaxed(&core->hw_core, reset_wait_target_register, reset_invalid_value);
+	mali_hw_core_register_write_relaxed(&core->hw_core, MALI200_REG_ADDR_MGMT_WRITE_BOUNDARY_LOW, reset_invalid_value);
 	mali_hw_core_register_write_relaxed(&core->hw_core, MALI200_REG_ADDR_MGMT_INT_MASK, MALI200_REG_VAL_IRQ_MASK_NONE);
 
 	/* Force core to reset */
@@ -220,8 +222,8 @@ _mali_osk_errcode_t mali_pp_hard_reset(struct mali_pp_core *core)
 
 	/* Wait for reset to be complete */
 	for (i = 0; i < MALI_REG_POLL_COUNT_FAST; i++) {
-		mali_hw_core_register_write(&core->hw_core, reset_wait_target_register, reset_check_value);
-		if (reset_check_value == mali_hw_core_register_read(&core->hw_core, reset_wait_target_register)) {
+		mali_hw_core_register_write(&core->hw_core, MALI200_REG_ADDR_MGMT_WRITE_BOUNDARY_LOW, reset_check_value);
+		if (reset_check_value == mali_hw_core_register_read(&core->hw_core, MALI200_REG_ADDR_MGMT_WRITE_BOUNDARY_LOW)) {
 			break;
 		}
 	}
@@ -230,7 +232,7 @@ _mali_osk_errcode_t mali_pp_hard_reset(struct mali_pp_core *core)
 		MALI_PRINT_ERROR(("Mali PP: The hard reset loop didn't work, unable to recover\n"));
 	}
 
-	mali_hw_core_register_write(&core->hw_core, reset_wait_target_register, 0x00000000); /* set it back to the default */
+	mali_hw_core_register_write(&core->hw_core, MALI200_REG_ADDR_MGMT_WRITE_BOUNDARY_LOW, 0x00000000); /* set it back to the default */
 	/* Re-enable interrupts */
 	mali_hw_core_register_write(&core->hw_core, MALI200_REG_ADDR_MGMT_INT_CLEAR, MALI200_REG_VAL_IRQ_MASK_ALL);
 	mali_hw_core_register_write(&core->hw_core, MALI200_REG_ADDR_MGMT_INT_MASK, MALI200_REG_VAL_IRQ_MASK_USED);
@@ -413,7 +415,7 @@ static void mali_pp_irq_probe_trigger(void *data)
 {
 	struct mali_pp_core *core = (struct mali_pp_core *)data;
 	mali_hw_core_register_write(&core->hw_core, MALI200_REG_ADDR_MGMT_INT_MASK, MALI200_REG_VAL_IRQ_MASK_USED);
-	mali_hw_core_register_write(&core->hw_core, MALI200_REG_ADDR_MGMT_INT_RAWSTAT, MALI200_REG_VAL_IRQ_BUS_ERROR);
+	mali_hw_core_register_write(&core->hw_core, MALI200_REG_ADDR_MGMT_INT_RAWSTAT, MALI200_REG_VAL_IRQ_FORCE_HANG);
 	_mali_osk_mem_barrier();
 }
 
@@ -423,8 +425,8 @@ static _mali_osk_errcode_t mali_pp_irq_probe_ack(void *data)
 	u32 irq_readout;
 
 	irq_readout = mali_hw_core_register_read(&core->hw_core, MALI200_REG_ADDR_MGMT_INT_STATUS);
-	if (MALI200_REG_VAL_IRQ_BUS_ERROR & irq_readout) {
-		mali_hw_core_register_write(&core->hw_core, MALI200_REG_ADDR_MGMT_INT_CLEAR, MALI200_REG_VAL_IRQ_BUS_ERROR);
+	if (MALI200_REG_VAL_IRQ_FORCE_HANG & irq_readout) {
+		mali_hw_core_register_write(&core->hw_core, MALI200_REG_ADDR_MGMT_INT_CLEAR, MALI200_REG_VAL_IRQ_FORCE_HANG);
 		_mali_osk_mem_barrier();
 		return _MALI_OSK_ERR_OK;
 	}
@@ -475,7 +477,6 @@ void mali_pp_update_performance_counters(struct mali_pp_core *parent, struct mal
 
 #if defined(CONFIG_MALI400_PROFILING)
 		_mali_osk_profiling_report_hw_counter(counter_index, val0);
-		_mali_osk_profiling_record_global_counters(counter_index, val0);
 #endif
 	}
 
@@ -485,7 +486,6 @@ void mali_pp_update_performance_counters(struct mali_pp_core *parent, struct mal
 
 #if defined(CONFIG_MALI400_PROFILING)
 		_mali_osk_profiling_report_hw_counter(counter_index + 1, val1);
-		_mali_osk_profiling_record_global_counters(counter_index + 1, val1);
 #endif
 	}
 }
diff --git a/drivers/gpu/arm/mali/common/mali_pp.h b/drivers/gpu/arm/mali/common/mali_pp.h
old mode 100755
new mode 100644
index 7633ecd3..2ee79d92
--- a/drivers/gpu/arm/mali/common/mali_pp.h
+++ b/drivers/gpu/arm/mali/common/mali_pp.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -93,7 +93,6 @@ MALI_STATIC_INLINE enum mali_interrupt_result mali_pp_get_interrupt_result(struc
 	} else if (MALI200_REG_VAL_IRQ_END_OF_FRAME == rawstat_used) {
 		return MALI_INTERRUPT_RESULT_SUCCESS;
 	}
-
 	return MALI_INTERRUPT_RESULT_ERROR;
 }
 
diff --git a/drivers/gpu/arm/mali/common/mali_pp_job.c b/drivers/gpu/arm/mali/common/mali_pp_job.c
old mode 100755
new mode 100644
index 27349c9c..ea64be6e
--- a/drivers/gpu/arm/mali/common/mali_pp_job.c
+++ b/drivers/gpu/arm/mali/common/mali_pp_job.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -18,8 +18,6 @@
 #if defined(CONFIG_DMA_SHARED_BUFFER) && !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
 #include "linux/mali_memory_dma_buf.h"
 #endif
-#include "mali_memory_swap_alloc.h"
-#include "mali_scheduler.h"
 
 static u32 pp_counter_src0 = MALI_HW_CORE_NO_COUNTER;   /**< Performance counter 0, MALI_HW_CORE_NO_COUNTER for disabled */
 static u32 pp_counter_src1 = MALI_HW_CORE_NO_COUNTER;   /**< Performance counter 1, MALI_HW_CORE_NO_COUNTER for disabled */
@@ -45,10 +43,7 @@ struct mali_pp_job *mali_pp_job_create(struct mali_session_data *session,
 
 	job = _mali_osk_calloc(1, sizeof(struct mali_pp_job));
 	if (NULL != job) {
-
-		_mali_osk_list_init(&job->list);
-		_mali_osk_list_init(&job->session_fb_lookup_list);
-
+		u32 num_memory_cookies = 0;
 		if (0 != _mali_osk_copy_from_user(&job->uargs, uargs, sizeof(_mali_uk_pp_start_job_s))) {
 			goto fail;
 		}
@@ -83,6 +78,7 @@ struct mali_pp_job *mali_pp_job_create(struct mali_session_data *session,
 			}
 		}
 
+		_mali_osk_list_init(&job->list);
 		job->session = session;
 		job->id = id;
 
@@ -92,20 +88,17 @@ struct mali_pp_job *mali_pp_job_create(struct mali_session_data *session,
 
 		_mali_osk_atomic_init(&job->sub_jobs_completed, 0);
 		_mali_osk_atomic_init(&job->sub_job_errors, 0);
-		job->swap_status = MALI_NO_SWAP_IN;
-		job->user_notification = MALI_FALSE;
-		job->num_pp_cores_in_virtual = 0;
-
-		if (job->uargs.num_memory_cookies > session->allocation_mgr.mali_allocation_num) {
-			MALI_PRINT_ERROR(("Mali PP job: The number of memory cookies is invalid !\n"));
-			goto fail;
-		}
-
-		if (job->uargs.num_memory_cookies > 0) {
+		num_memory_cookies = job->uargs.num_memory_cookies;
+		if (num_memory_cookies !=  0) {
 			u32 size;
 			u32 __user *memory_cookies = (u32 __user *)(uintptr_t)job->uargs.memory_cookies;
 
-			size = sizeof(*memory_cookies) * (job->uargs.num_memory_cookies);
+			if (num_memory_cookies > session->allocation_mgr.mali_allocation_nr) {
+				MALI_PRINT_ERROR(("Mali PP job: Too many memory cookies specified in job object\n"));
+				goto fail;
+			}
+
+			size = sizeof(*memory_cookies) * num_memory_cookies;
 
 			job->memory_cookies = _mali_osk_malloc(size);
 			if (NULL == job->memory_cookies) {
@@ -127,8 +120,6 @@ struct mali_pp_job *mali_pp_job_create(struct mali_session_data *session,
 		mali_timeline_tracker_init(&job->tracker, MALI_TIMELINE_TRACKER_PP, NULL, job);
 		mali_timeline_fence_copy_uk_fence(&(job->tracker.fence), &(job->uargs.fence));
 
-		mali_mem_swap_in_pages(job);
-
 		return job;
 	}
 
@@ -146,27 +137,14 @@ void mali_pp_job_delete(struct mali_pp_job *job)
 	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->list));
 	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_fb_lookup_list));
 
-	if (NULL != job->memory_cookies) {
-#if defined(CONFIG_DMA_SHARED_BUFFER) && !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
-		/* Unmap buffers attached to job */
-		mali_dma_buf_unmap_job(job);
-#endif
-		if (MALI_NO_SWAP_IN != job->swap_status) {
-			mali_mem_swap_out_pages(job);
-		}
-
-		_mali_osk_free(job->memory_cookies);
-	}
-
-	if (job->user_notification) {
-		mali_scheduler_return_pp_job_to_user(job,
-						     job->num_pp_cores_in_virtual);
-	}
-
 	if (NULL != job->finished_notification) {
 		_mali_osk_notification_delete(job->finished_notification);
 	}
 
+	if (NULL != job->memory_cookies) {
+		_mali_osk_free(job->memory_cookies);
+	}
+
 	_mali_osk_atomic_term(&job->sub_jobs_completed);
 	_mali_osk_atomic_term(&job->sub_job_errors);
 
diff --git a/drivers/gpu/arm/mali/common/mali_pp_job.h b/drivers/gpu/arm/mali/common/mali_pp_job.h
old mode 100755
new mode 100644
index dbb04f20..7d2a1d06
--- a/drivers/gpu/arm/mali/common/mali_pp_job.h
+++ b/drivers/gpu/arm/mali/common/mali_pp_job.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -25,16 +25,6 @@
 #if defined(CONFIG_DMA_SHARED_BUFFER) && !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
 #include "linux/mali_memory_dma_buf.h"
 #endif
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-#include "linux/mali_dma_fence.h"
-#include <linux/fence.h>
-#endif
-
-typedef enum pp_job_status {
-	MALI_NO_SWAP_IN,
-	MALI_SWAP_IN_FAIL,
-	MALI_SWAP_IN_SUCC,
-} pp_job_status;
 
 /**
  * This structure represents a PP job, including all sub jobs.
@@ -65,10 +55,6 @@ struct mali_pp_job {
 	u32 perf_counter_per_sub_job_src1[_MALI_PP_MAX_SUB_JOBS]; /**< Per sub job counters src1 */
 	u32 sub_jobs_num;                                  /**< Number of subjobs; set to 1 for Mali-450 if DLBU is used, otherwise equals number of PP cores */
 
-	pp_job_status swap_status;                         /**< Used to track each PP job swap status, if fail, we need to drop them in scheduler part */
-	mali_bool user_notification;                       /**< When we deferred delete PP job, we need to judge if we need to send job finish notification to user space */
-	u32 num_pp_cores_in_virtual;                       /**< How many PP cores we have when job finished */
-
 	/*
 	 * These members are used by both scheduler and executor.
 	 * They are "protected" by atomic operations.
@@ -98,11 +84,6 @@ struct mali_pp_job {
 	 */
 	u32 perf_counter_value0[_MALI_PP_MAX_SUB_JOBS];    /**< Value of performance counter 0 (to be returned to user space), one for each sub job */
 	u32 perf_counter_value1[_MALI_PP_MAX_SUB_JOBS];    /**< Value of performance counter 1 (to be returned to user space), one for each sub job */
-
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-	struct mali_dma_fence_context dma_fence_context; /**< The mali dma fence context to record dma fence waiters that this job wait for */
-	struct fence *rendered_dma_fence; /**< the new dma fence link to this job */
-#endif
 };
 
 void mali_pp_job_initialize(void);
@@ -188,7 +169,7 @@ MALI_STATIC_INLINE u32 *mali_pp_job_get_dlbu_registers(struct mali_pp_job *job)
 
 MALI_STATIC_INLINE mali_bool mali_pp_job_is_virtual(struct mali_pp_job *job)
 {
-#if (defined(CONFIG_MALI450) || defined(CONFIG_MALI470))
+#if defined(CONFIG_MALI450)
 	MALI_DEBUG_ASSERT_POINTER(job);
 	return (0 == job->uargs.num_cores) ? MALI_TRUE : MALI_FALSE;
 #else
@@ -504,13 +485,6 @@ MALI_STATIC_INLINE mali_bool mali_pp_job_is_window_surface(
 	       ? MALI_TRUE : MALI_FALSE;
 }
 
-MALI_STATIC_INLINE mali_bool mali_pp_job_is_protected_job(struct mali_pp_job *job)
-{
-	MALI_DEBUG_ASSERT_POINTER(job);
-	return (job->uargs.flags & _MALI_PP_JOB_FLAG_PROTECTED)
-	       ? MALI_TRUE : MALI_FALSE;
-}
-
 MALI_STATIC_INLINE u32 mali_pp_job_get_perf_counter_flag(struct mali_pp_job *job)
 {
 	MALI_DEBUG_ASSERT_POINTER(job);
diff --git a/drivers/gpu/arm/mali/common/mali_pp_scheduler.c b/drivers/gpu/arm/mali/common/mali_pp_scheduler.c
deleted file mode 100644
index 1b0dd678..00000000
--- a/drivers/gpu/arm/mali/common/mali_pp_scheduler.c
+++ /dev/null
@@ -1,2067 +0,0 @@
-/*
- * Copyright (C) 2012-2013 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#include "mali_pp_scheduler.h"
-#include "mali_kernel_common.h"
-#include "mali_kernel_core.h"
-#include "mali_osk.h"
-#include "mali_osk_list.h"
-#include "mali_scheduler.h"
-#include "mali_pp.h"
-#include "mali_pp_job.h"
-#include "mali_group.h"
-#include "mali_pm.h"
-#include "mali_timeline.h"
-#include "mali_osk_profiling.h"
-#include "mali_kernel_utilization.h"
-#include "mali_session.h"
-#include "mali_pm_domain.h"
-#include "linux/mali/mali_utgard.h"
-
-#if defined(CONFIG_DMA_SHARED_BUFFER)
-#include "mali_memory_dma_buf.h"
-#endif
-#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-#include <linux/sched.h>
-#include <trace/events/gpu.h>
-#endif
-
-/* Queue type used for physical and virtual job queues. */
-struct mali_pp_scheduler_job_queue {
-	_MALI_OSK_LIST_HEAD(normal_pri); /* List of jobs with some unscheduled work. */
-	_MALI_OSK_LIST_HEAD(high_pri);   /* List of high priority jobs with some unscheduled work. */
-	u32 depth;                       /* Depth of combined queues. */
-};
-
-/* If dma_buf with map on demand is used, we defer job deletion and job queue if in atomic context,
- * since both might sleep. */
-#if defined(CONFIG_DMA_SHARED_BUFFER) && !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
-#define MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE 1
-#define MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE 1
-#endif /* !defined(CONFIG_DMA_SHARED_BUFFER) && !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH) */
-
-static void mali_pp_scheduler_job_queued(void);
-static void mali_pp_scheduler_job_completed(void);
-
-/* Maximum of 8 PP cores (a group can only have maximum of 1 PP core) */
-#define MALI_MAX_NUMBER_OF_PP_GROUPS 9
-
-static mali_bool mali_pp_scheduler_is_suspended(void *data);
-
-static u32 pp_version = 0;
-
-/* Physical job queue */
-static struct mali_pp_scheduler_job_queue job_queue;
-
-/* Physical groups */
-static _MALI_OSK_LIST_HEAD_STATIC_INIT(group_list_working);     /* List of physical groups with working jobs on the pp core */
-static _MALI_OSK_LIST_HEAD_STATIC_INIT(group_list_idle);        /* List of physical groups with idle jobs on the pp core */
-static _MALI_OSK_LIST_HEAD_STATIC_INIT(group_list_disabled);    /* List of disabled physical groups */
-
-/* Virtual job queue (Mali-450 only) */
-static struct mali_pp_scheduler_job_queue virtual_job_queue;
-
-/**
- * Add job to scheduler queue.
- *
- * @param job Job to queue.
- * @return Schedule mask.
- */
-static mali_scheduler_mask mali_pp_scheduler_queue_job(struct mali_pp_job *job);
-
-/* Virtual group (Mali-450 only) */
-static struct mali_group *virtual_group = NULL;                 /* Virtual group (if any) */
-static enum {
-	VIRTUAL_GROUP_IDLE,
-	VIRTUAL_GROUP_WORKING,
-	VIRTUAL_GROUP_DISABLED,
-}
-virtual_group_state = VIRTUAL_GROUP_IDLE;            /* Flag which indicates whether the virtual group is working or idle */
-
-/* Number of physical cores */
-static u32 num_cores = 0;
-
-/* Number of physical cores which are enabled */
-static u32 enabled_cores = 0;
-
-/* Enable or disable core scaling */
-static mali_bool core_scaling_enabled = MALI_TRUE;
-
-/* Variables to allow safe pausing of the scheduler */
-static _mali_osk_wait_queue_t *pp_scheduler_working_wait_queue = NULL;
-static u32 pause_count = 0;
-
-#if defined(MALI_UPPER_HALF_SCHEDULING)
-static _mali_osk_spinlock_irq_t *pp_scheduler_lock = NULL;
-#else
-static _mali_osk_spinlock_t *pp_scheduler_lock = NULL;
-#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
-
-MALI_STATIC_INLINE void mali_pp_scheduler_lock(void)
-{
-#if defined(MALI_UPPER_HALF_SCHEDULING)
-	_mali_osk_spinlock_irq_lock(pp_scheduler_lock);
-#else
-	_mali_osk_spinlock_lock(pp_scheduler_lock);
-#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
-	MALI_DEBUG_PRINT(5, ("Mali PP scheduler: PP scheduler lock taken.\n"));
-}
-
-MALI_STATIC_INLINE void mali_pp_scheduler_unlock(void)
-{
-	MALI_DEBUG_PRINT(5, ("Mali PP scheduler: Releasing PP scheduler lock.\n"));
-#if defined(MALI_UPPER_HALF_SCHEDULING)
-	_mali_osk_spinlock_irq_unlock(pp_scheduler_lock);
-#else
-	_mali_osk_spinlock_unlock(pp_scheduler_lock);
-#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
-}
-
-#if defined(DEBUG)
-#define MALI_ASSERT_PP_SCHEDULER_LOCKED() MALI_DEBUG_ASSERT_LOCK_HELD(pp_scheduler_lock)
-#else
-#define MALI_ASSERT_PP_SCHEDULER_LOCKED() do {} while (0)
-#endif /* defined(DEBUG) */
-
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
-
-static _mali_osk_wq_work_t *pp_scheduler_wq_job_delete = NULL;
-static _mali_osk_spinlock_irq_t *pp_scheduler_job_delete_lock = NULL;
-static _MALI_OSK_LIST_HEAD_STATIC_INIT(pp_scheduler_job_deletion_queue);
-
-static void mali_pp_scheduler_deferred_job_delete(struct mali_pp_job *job)
-{
-	MALI_DEBUG_ASSERT_POINTER(job);
-
-	_mali_osk_spinlock_irq_lock(pp_scheduler_job_delete_lock);
-
-	/* This job object should not be on any lists. */
-	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->list));
-	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_list));
-	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_fb_lookup_list));
-
-	_mali_osk_list_addtail(&job->list, &pp_scheduler_job_deletion_queue);
-
-	_mali_osk_spinlock_irq_unlock(pp_scheduler_job_delete_lock);
-
-	_mali_osk_wq_schedule_work(pp_scheduler_wq_job_delete);
-}
-
-static void mali_pp_scheduler_do_job_delete(void *arg)
-{
-	_MALI_OSK_LIST_HEAD_STATIC_INIT(list);
-	struct mali_pp_job *job;
-	struct mali_pp_job *tmp;
-
-	MALI_IGNORE(arg);
-
-	_mali_osk_spinlock_irq_lock(pp_scheduler_job_delete_lock);
-
-	/*
-	 * Quickly "unhook" the jobs pending to be deleted, so we can release the lock before
-	 * we start deleting the job objects (without any locks held
-	 */
-	_mali_osk_list_move_list(&pp_scheduler_job_deletion_queue, &list);
-
-	_mali_osk_spinlock_irq_unlock(pp_scheduler_job_delete_lock);
-
-	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &list, struct mali_pp_job, list) {
-		mali_pp_job_delete(job); /* delete the job object itself */
-	}
-}
-
-#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE) */
-
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE)
-
-static _mali_osk_wq_work_t *pp_scheduler_wq_job_queue = NULL;
-static _mali_osk_spinlock_irq_t *pp_scheduler_job_queue_lock = NULL;
-static _MALI_OSK_LIST_HEAD_STATIC_INIT(pp_scheduler_job_queue_list);
-
-static void mali_pp_scheduler_deferred_job_queue(struct mali_pp_job *job)
-{
-	MALI_DEBUG_ASSERT_POINTER(job);
-
-	_mali_osk_spinlock_irq_lock(pp_scheduler_job_queue_lock);
-	_mali_osk_list_addtail(&job->list, &pp_scheduler_job_queue_list);
-	_mali_osk_spinlock_irq_unlock(pp_scheduler_job_queue_lock);
-
-	_mali_osk_wq_schedule_work(pp_scheduler_wq_job_queue);
-}
-
-static void mali_pp_scheduler_do_job_queue(void *arg)
-{
-	_MALI_OSK_LIST_HEAD_STATIC_INIT(list);
-	struct mali_pp_job *job;
-	struct mali_pp_job *tmp;
-	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
-
-	MALI_IGNORE(arg);
-
-	_mali_osk_spinlock_irq_lock(pp_scheduler_job_queue_lock);
-
-	/*
-	 * Quickly "unhook" the jobs pending to be queued, so we can release the lock before
-	 * we start queueing the job objects (without any locks held)
-	 */
-	_mali_osk_list_move_list(&pp_scheduler_job_queue_list, &list);
-
-	_mali_osk_spinlock_irq_unlock(pp_scheduler_job_queue_lock);
-
-	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &list, struct mali_pp_job, list) {
-		_mali_osk_list_delinit(&job->list);
-		schedule_mask |= mali_pp_scheduler_queue_job(job);
-	}
-
-	mali_scheduler_schedule_from_mask(schedule_mask, MALI_FALSE);
-}
-
-#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE) */
-
-MALI_STATIC_INLINE mali_bool mali_pp_scheduler_has_virtual_group(void)
-{
-#if defined(CONFIG_MALI450)
-	return NULL != virtual_group;
-#else
-	return MALI_FALSE;
-#endif /* defined(CONFIG_MALI450) */
-}
-
-_mali_osk_errcode_t mali_pp_scheduler_initialize(void)
-{
-	_MALI_OSK_INIT_LIST_HEAD(&job_queue.normal_pri);
-	_MALI_OSK_INIT_LIST_HEAD(&job_queue.high_pri);
-	job_queue.depth = 0;
-
-	_MALI_OSK_INIT_LIST_HEAD(&virtual_job_queue.normal_pri);
-	_MALI_OSK_INIT_LIST_HEAD(&virtual_job_queue.high_pri);
-	virtual_job_queue.depth = 0;
-
-#if defined(MALI_UPPER_HALF_SCHEDULING)
-	pp_scheduler_lock = _mali_osk_spinlock_irq_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_SCHEDULER);
-#else
-	pp_scheduler_lock = _mali_osk_spinlock_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_SCHEDULER);
-#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
-	if (NULL == pp_scheduler_lock) goto cleanup;
-
-	pp_scheduler_working_wait_queue = _mali_osk_wait_queue_init();
-	if (NULL == pp_scheduler_working_wait_queue) goto cleanup;
-
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
-	pp_scheduler_wq_job_delete = _mali_osk_wq_create_work(mali_pp_scheduler_do_job_delete, NULL);
-	if (NULL == pp_scheduler_wq_job_delete) goto cleanup;
-
-	pp_scheduler_job_delete_lock = _mali_osk_spinlock_irq_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_SCHEDULER_DEFERRED);
-	if (NULL == pp_scheduler_job_delete_lock) goto cleanup;
-#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE) */
-
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE)
-	pp_scheduler_wq_job_queue = _mali_osk_wq_create_work(mali_pp_scheduler_do_job_queue, NULL);
-	if (NULL == pp_scheduler_wq_job_queue) goto cleanup;
-
-	pp_scheduler_job_queue_lock = _mali_osk_spinlock_irq_init(_MALI_OSK_LOCKFLAG_ORDERED, _MALI_OSK_LOCK_ORDER_SCHEDULER_DEFERRED);
-	if (NULL == pp_scheduler_job_queue_lock) goto cleanup;
-#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE) */
-
-	return _MALI_OSK_ERR_OK;
-
-cleanup:
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE)
-	if (NULL != pp_scheduler_job_queue_lock) {
-		_mali_osk_spinlock_irq_term(pp_scheduler_job_queue_lock);
-		pp_scheduler_job_queue_lock = NULL;
-	}
-
-	if (NULL != pp_scheduler_wq_job_queue) {
-		_mali_osk_wq_delete_work(pp_scheduler_wq_job_queue);
-		pp_scheduler_wq_job_queue = NULL;
-	}
-#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE) */
-
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
-	if (NULL != pp_scheduler_job_delete_lock) {
-		_mali_osk_spinlock_irq_term(pp_scheduler_job_delete_lock);
-		pp_scheduler_job_delete_lock = NULL;
-	}
-
-	if (NULL != pp_scheduler_wq_job_delete) {
-		_mali_osk_wq_delete_work(pp_scheduler_wq_job_delete);
-		pp_scheduler_wq_job_delete = NULL;
-	}
-#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE) */
-
-	if (NULL != pp_scheduler_working_wait_queue) {
-		_mali_osk_wait_queue_term(pp_scheduler_working_wait_queue);
-		pp_scheduler_working_wait_queue = NULL;
-	}
-
-	if (NULL != pp_scheduler_lock) {
-#if defined(MALI_UPPER_HALF_SCHEDULING)
-		_mali_osk_spinlock_irq_term(pp_scheduler_lock);
-#else
-		_mali_osk_spinlock_term(pp_scheduler_lock);
-#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
-		pp_scheduler_lock = NULL;
-	}
-
-	return _MALI_OSK_ERR_NOMEM;
-}
-
-void mali_pp_scheduler_terminate(void)
-{
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE)
-	_mali_osk_spinlock_irq_term(pp_scheduler_job_queue_lock);
-	_mali_osk_wq_delete_work(pp_scheduler_wq_job_queue);
-#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE) */
-
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
-	_mali_osk_spinlock_irq_term(pp_scheduler_job_delete_lock);
-	_mali_osk_wq_delete_work(pp_scheduler_wq_job_delete);
-#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE) */
-
-	_mali_osk_wait_queue_term(pp_scheduler_working_wait_queue);
-
-#if defined(MALI_UPPER_HALF_SCHEDULING)
-	_mali_osk_spinlock_irq_term(pp_scheduler_lock);
-#else
-	_mali_osk_spinlock_term(pp_scheduler_lock);
-#endif /* defined(MALI_UPPER_HALF_SCHEDULING) */
-}
-
-void mali_pp_scheduler_populate(void)
-{
-	struct mali_group *group;
-	struct mali_pp_core *pp_core;
-	u32 num_groups;
-	u32 i;
-
-	num_groups = mali_group_get_glob_num_groups();
-
-	/* Do we have a virtual group? */
-	for (i = 0; i < num_groups; i++) {
-		group = mali_group_get_glob_group(i);
-
-		if (mali_group_is_virtual(group)) {
-			MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Found virtual group %p.\n", group));
-
-			virtual_group = group;
-			break;
-		}
-	}
-
-	/* Find all the available PP cores */
-	for (i = 0; i < num_groups; i++) {
-		group = mali_group_get_glob_group(i);
-		pp_core = mali_group_get_pp_core(group);
-
-		if (NULL != pp_core && !mali_group_is_virtual(group)) {
-			if (0 == pp_version) {
-				/* Retrieve PP version from the first available PP core */
-				pp_version = mali_pp_core_get_version(pp_core);
-			}
-
-			if (mali_pp_scheduler_has_virtual_group()) {
-				/* Add all physical PP cores to the virtual group */
-				mali_group_lock(virtual_group);
-				group->state = MALI_GROUP_STATE_JOINING_VIRTUAL;
-				mali_group_add_group(virtual_group, group, MALI_TRUE);
-				mali_group_unlock(virtual_group);
-			} else {
-				_mali_osk_list_add(&group->pp_scheduler_list, &group_list_idle);
-			}
-
-			num_cores++;
-		}
-	}
-
-	enabled_cores = num_cores;
-}
-
-void mali_pp_scheduler_depopulate(void)
-{
-	struct mali_group *group, *temp;
-
-	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&group_list_working));
-	MALI_DEBUG_ASSERT(VIRTUAL_GROUP_WORKING != virtual_group_state);
-
-	/* Delete all groups owned by scheduler */
-	if (mali_pp_scheduler_has_virtual_group()) {
-		mali_group_delete(virtual_group);
-	}
-
-	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_idle, struct mali_group, pp_scheduler_list) {
-		mali_group_delete(group);
-	}
-	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_disabled, struct mali_group, pp_scheduler_list) {
-		mali_group_delete(group);
-	}
-}
-
-MALI_STATIC_INLINE void mali_pp_scheduler_disable_empty_virtual(void)
-{
-	MALI_ASSERT_GROUP_LOCKED(virtual_group);
-
-	if (mali_group_virtual_disable_if_empty(virtual_group)) {
-		MALI_DEBUG_PRINT(4, ("Disabling empty virtual group\n"));
-
-		MALI_DEBUG_ASSERT(VIRTUAL_GROUP_IDLE == virtual_group_state);
-
-		virtual_group_state = VIRTUAL_GROUP_DISABLED;
-	}
-}
-
-MALI_STATIC_INLINE void mali_pp_scheduler_enable_empty_virtual(void)
-{
-	MALI_ASSERT_GROUP_LOCKED(virtual_group);
-
-	if (mali_group_virtual_enable_if_empty(virtual_group)) {
-		MALI_DEBUG_PRINT(4, ("Re-enabling empty virtual group\n"));
-
-		MALI_DEBUG_ASSERT(VIRTUAL_GROUP_DISABLED == virtual_group_state);
-
-		virtual_group_state = VIRTUAL_GROUP_IDLE;
-	}
-}
-
-static struct mali_pp_job *mali_pp_scheduler_get_job(struct mali_pp_scheduler_job_queue *queue)
-{
-	struct mali_pp_job *job = NULL;
-
-	MALI_ASSERT_PP_SCHEDULER_LOCKED();
-	MALI_DEBUG_ASSERT_POINTER(queue);
-
-	/* Check if we have a normal priority job. */
-	if (!_mali_osk_list_empty(&queue->normal_pri)) {
-		MALI_DEBUG_ASSERT(queue->depth > 0);
-		job = _MALI_OSK_LIST_ENTRY(queue->normal_pri.next, struct mali_pp_job, list);
-	}
-
-	/* Prefer normal priority job if it is in progress. */
-	if (NULL != job && 0 < job->sub_jobs_started) {
-		return job;
-	}
-
-	/* Check if we have a high priority job. */
-	if (!_mali_osk_list_empty(&queue->high_pri)) {
-		MALI_DEBUG_ASSERT(queue->depth > 0);
-		job = _MALI_OSK_LIST_ENTRY(queue->high_pri.next, struct mali_pp_job, list);
-	}
-
-	return job;
-}
-
-/**
- * Returns a physical job if a physical job is ready to run
- */
-MALI_STATIC_INLINE struct mali_pp_job *mali_pp_scheduler_get_physical_job(void)
-{
-	MALI_ASSERT_PP_SCHEDULER_LOCKED();
-	return mali_pp_scheduler_get_job(&job_queue);
-}
-
-MALI_STATIC_INLINE void mali_pp_scheduler_dequeue_physical_job(struct mali_pp_job *job)
-{
-	MALI_ASSERT_PP_SCHEDULER_LOCKED();
-	MALI_DEBUG_ASSERT(job_queue.depth > 0);
-
-	/* Remove job from queue */
-	if (!mali_pp_job_has_unstarted_sub_jobs(job)) {
-		/* All sub jobs have been started: remove job from queue */
-		_mali_osk_list_delinit(&job->list);
-		_mali_osk_list_delinit(&job->session_fb_lookup_list);
-	}
-
-	--job_queue.depth;
-}
-
-/**
- * Returns a virtual job if a virtual job is ready to run
- */
-MALI_STATIC_INLINE struct mali_pp_job *mali_pp_scheduler_get_virtual_job(void)
-{
-	MALI_ASSERT_PP_SCHEDULER_LOCKED();
-	MALI_DEBUG_ASSERT_POINTER(virtual_group);
-	return mali_pp_scheduler_get_job(&virtual_job_queue);
-}
-
-MALI_STATIC_INLINE void mali_pp_scheduler_dequeue_virtual_job(struct mali_pp_job *job)
-{
-	MALI_ASSERT_PP_SCHEDULER_LOCKED();
-	MALI_DEBUG_ASSERT(virtual_job_queue.depth > 0);
-
-	/* Remove job from queue */
-	_mali_osk_list_delinit(&job->list);
-	_mali_osk_list_delinit(&job->session_fb_lookup_list);
-	--virtual_job_queue.depth;
-}
-
-/**
- * Checks if the criteria is met for removing a physical core from virtual group
- */
-MALI_STATIC_INLINE mali_bool mali_pp_scheduler_can_move_virtual_to_physical(void)
-{
-	MALI_ASSERT_PP_SCHEDULER_LOCKED();
-	MALI_DEBUG_ASSERT(mali_pp_scheduler_has_virtual_group());
-	MALI_ASSERT_GROUP_LOCKED(virtual_group);
-	/*
-	 * The criteria for taking out a physical group from a virtual group are the following:
-	 * - There virtual group is idle
-	 * - There are currently no physical groups (idle and working)
-	 * - There are physical jobs to be scheduled
-	 */
-	return (VIRTUAL_GROUP_IDLE == virtual_group_state) &&
-	       _mali_osk_list_empty(&group_list_idle) &&
-	       _mali_osk_list_empty(&group_list_working) &&
-	       (NULL != mali_pp_scheduler_get_physical_job());
-}
-
-MALI_STATIC_INLINE struct mali_group *mali_pp_scheduler_acquire_physical_group(void)
-{
-	MALI_ASSERT_PP_SCHEDULER_LOCKED();
-
-	if (!_mali_osk_list_empty(&group_list_idle)) {
-		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Acquiring physical group from idle list.\n"));
-		return _MALI_OSK_LIST_ENTRY(group_list_idle.next, struct mali_group, pp_scheduler_list);
-	} else if (mali_pp_scheduler_has_virtual_group()) {
-		MALI_ASSERT_GROUP_LOCKED(virtual_group);
-		if (mali_pp_scheduler_can_move_virtual_to_physical()) {
-			struct mali_group *group;
-			MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Acquiring physical group from virtual group.\n"));
-			group = mali_group_acquire_group(virtual_group);
-
-			if (mali_pp_scheduler_has_virtual_group()) {
-				mali_pp_scheduler_disable_empty_virtual();
-			}
-
-			return group;
-		}
-	}
-
-	return NULL;
-}
-
-static void mali_pp_scheduler_return_job_to_user(struct mali_pp_job *job, mali_bool deferred)
-{
-	if (MALI_FALSE == mali_pp_job_use_no_notification(job)) {
-		u32 i;
-		u32 num_counters_to_copy;
-		mali_bool success = mali_pp_job_was_success(job);
-
-		_mali_uk_pp_job_finished_s *jobres = job->finished_notification->result_buffer;
-		_mali_osk_memset(jobres, 0, sizeof(_mali_uk_pp_job_finished_s)); /* @@@@ can be removed once we initialize all members in this struct */
-		jobres->user_job_ptr = mali_pp_job_get_user_id(job);
-		if (MALI_TRUE == success) {
-			jobres->status = _MALI_UK_JOB_STATUS_END_SUCCESS;
-		} else {
-			jobres->status = _MALI_UK_JOB_STATUS_END_UNKNOWN_ERR;
-		}
-
-		if (mali_pp_job_is_virtual(job)) {
-			num_counters_to_copy = num_cores; /* Number of physical cores available */
-		} else {
-			num_counters_to_copy = mali_pp_job_get_sub_job_count(job);
-		}
-
-		for (i = 0; i < num_counters_to_copy; i++) {
-			jobres->perf_counter0[i] = mali_pp_job_get_perf_counter_value0(job, i);
-			jobres->perf_counter1[i] = mali_pp_job_get_perf_counter_value1(job, i);
-			jobres->perf_counter_src0 = mali_pp_job_get_pp_counter_global_src0();
-			jobres->perf_counter_src1 = mali_pp_job_get_pp_counter_global_src1();
-		}
-
-		mali_session_send_notification(mali_pp_job_get_session(job), job->finished_notification);
-		job->finished_notification = NULL;
-	}
-
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
-	if (MALI_TRUE == deferred) {
-		/* The deletion of the job object (releasing sync refs etc) must be done in a different context */
-		mali_pp_scheduler_deferred_job_delete(job);
-	} else {
-		mali_pp_job_delete(job);
-	}
-#else
-	MALI_DEBUG_ASSERT(MALI_FALSE == deferred); /* no use cases need this in this configuration */
-	mali_pp_job_delete(job);
-#endif
-}
-
-static void mali_pp_scheduler_finalize_job(struct mali_pp_job * job)
-{
-	/* This job object should not be on any lists. */
-	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->list));
-	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_list));
-	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_fb_lookup_list));
-
-	/* Send notification back to user space */
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
-	mali_pp_scheduler_return_job_to_user(job, MALI_TRUE);
-#else
-	mali_pp_scheduler_return_job_to_user(job, MALI_FALSE);
-#endif
-
-#if defined(CONFIG_MALI400_POWER_PERFORMANCE_POLICY)
-	if (_MALI_PP_JOB_FLAG_IS_WINDOW_SURFACE & job->uargs.flags) {
-		_mali_osk_atomic_inc(&job->session->number_of_window_jobs);
-	}
-#endif
-
-	mali_pp_scheduler_job_completed();
-}
-
-void mali_pp_scheduler_schedule(void)
-{
-	struct mali_group* physical_groups_to_start[MALI_MAX_NUMBER_OF_PP_GROUPS - 1];
-	struct mali_pp_job* physical_jobs_to_start[MALI_MAX_NUMBER_OF_PP_GROUPS - 1];
-	u32 physical_sub_jobs_to_start[MALI_MAX_NUMBER_OF_PP_GROUPS - 1];
-	int num_physical_jobs_to_start = 0;
-	int i;
-
-	if (mali_pp_scheduler_has_virtual_group()) {
-		/* Lock the virtual group since we might have to grab physical groups. */
-		mali_group_lock(virtual_group);
-	}
-
-	mali_pp_scheduler_lock();
-	if (pause_count > 0) {
-		/* Scheduler is suspended, don't schedule any jobs. */
-		mali_pp_scheduler_unlock();
-		if (mali_pp_scheduler_has_virtual_group()) {
-			mali_group_unlock(virtual_group);
-		}
-		return;
-	}
-
-	/* Find physical job(s) to schedule first. */
-	while (1) {
-		struct mali_group *group;
-		struct mali_pp_job *job;
-		u32 sub_job;
-
-		job = mali_pp_scheduler_get_physical_job();
-		if (NULL == job) {
-			break; /* No job, early out. */
-		}
-
-		if (mali_scheduler_hint_is_enabled(MALI_SCHEDULER_HINT_GP_BOUND) &&
-		    mali_pp_job_is_large_and_unstarted(job) && !_mali_osk_list_empty(&group_list_working)) {
-			/* Since not all groups are idle, don't schedule yet. */
-			break;
-		}
-
-		MALI_DEBUG_ASSERT(!mali_pp_job_is_virtual(job));
-		MALI_DEBUG_ASSERT(mali_pp_job_has_unstarted_sub_jobs(job));
-		MALI_DEBUG_ASSERT(1 <= mali_pp_job_get_sub_job_count(job));
-
-		/* Acquire a physical group, either from the idle list or from the virtual group.
-		 * In case the group was acquired from the virtual group, it's state will be
-		 * LEAVING_VIRTUAL and must be set to IDLE before it can be used. */
-		group = mali_pp_scheduler_acquire_physical_group();
-		if (NULL == group) {
-			/* Could not get a group to run the job on, early out. */
-			MALI_DEBUG_PRINT(4, ("Mali PP scheduler: No more physical groups available.\n"));
-			break;
-		}
-
-		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Acquired physical group %p.\n", group));
-
-		/* Mark sub job as started. */
-		sub_job = mali_pp_job_get_first_unstarted_sub_job(job);
-		mali_pp_job_mark_sub_job_started(job, sub_job);
-
-		/* Remove job from queue (if this was the last sub job). */
-		mali_pp_scheduler_dequeue_physical_job(job);
-
-		/* Move group to working list. */
-		_mali_osk_list_move(&(group->pp_scheduler_list), &group_list_working);
-
-		/* Keep track of this group, so that we actually can start the job once we are done with the scheduler lock we are now holding. */
-		physical_groups_to_start[num_physical_jobs_to_start] = group;
-		physical_jobs_to_start[num_physical_jobs_to_start] = job;
-		physical_sub_jobs_to_start[num_physical_jobs_to_start] = sub_job;
-		++num_physical_jobs_to_start;
-
-		MALI_DEBUG_ASSERT(num_physical_jobs_to_start < MALI_MAX_NUMBER_OF_PP_GROUPS);
-	}
-
-	if (mali_pp_scheduler_has_virtual_group()) {
-		if (VIRTUAL_GROUP_IDLE == virtual_group_state) {
-			/* We have a virtual group and it is idle. */
-
-			struct mali_pp_job *job;
-
-			/* Find a virtual job we can start. */
-			job = mali_pp_scheduler_get_virtual_job();
-
-			if (NULL != job) {
-				MALI_DEBUG_ASSERT(mali_pp_job_is_virtual(job));
-				MALI_DEBUG_ASSERT(mali_pp_job_has_unstarted_sub_jobs(job));
-				MALI_DEBUG_ASSERT(1 == mali_pp_job_get_sub_job_count(job));
-
-				/* Mark the one and only sub job as started. */
-				mali_pp_job_mark_sub_job_started(job, 0);
-
-				/* Remove job from queue. */
-				mali_pp_scheduler_dequeue_virtual_job(job);
-
-				/* Virtual group is now working. */
-				virtual_group_state = VIRTUAL_GROUP_WORKING;
-
-				/* We no longer need the scheduler lock, but we still need the virtual lock
-				 * in order to start the virtual job. */
-				mali_pp_scheduler_unlock();
-
-				/* Start job. */
-				mali_group_start_pp_job(virtual_group, job, 0);
-
-				MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Virtual job %u (0x%08X) part %u/%u started (from schedule).\n",
-				                     mali_pp_job_get_id(job), job, 1,
-				                     mali_pp_job_get_sub_job_count(job)));
-
-				mali_group_unlock(virtual_group);
-			} else {
-				/* No virtual job to start. */
-				mali_pp_scheduler_unlock();
-				mali_group_unlock(virtual_group);
-			}
-		} else {
-			/* We have a virtual group, but it is busy or disabled. */
-			MALI_DEBUG_ASSERT(VIRTUAL_GROUP_IDLE != virtual_group_state);
-
-			mali_pp_scheduler_unlock();
-			mali_group_unlock(virtual_group);
-		}
-	} else {
-		/* There is no virtual group. */
-		mali_pp_scheduler_unlock();
-	}
-
-	/* We have now released the scheduler lock, and we are ready to start the physical jobs.
-	 * The reason we want to wait until we have released the scheduler lock is that job start
-	 * may take quite a bit of time (many registers have to be written). This will allow new
-	 * jobs from user space to come in, and post-processing of other PP jobs to happen at the
-	 * same time as we start jobs. */
-	for (i = 0; i < num_physical_jobs_to_start; i++) {
-		struct mali_group *group = physical_groups_to_start[i];
-		struct mali_pp_job *job  = physical_jobs_to_start[i];
-		u32 sub_job              = physical_sub_jobs_to_start[i];
-
-		MALI_DEBUG_ASSERT_POINTER(group);
-		MALI_DEBUG_ASSERT_POINTER(job);
-		MALI_DEBUG_ASSERT(!mali_group_is_virtual(group));
-		MALI_DEBUG_ASSERT(!mali_pp_job_is_virtual(job));
-
-		mali_group_lock(group);
-
-		/* Set state to IDLE if group was acquired from the virtual group. */
-		group->state = MALI_GROUP_STATE_IDLE;
-
-		mali_group_start_pp_job(group, job, sub_job);
-
-		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Physical job %u (0x%08X) part %u/%u started (from schedule).\n",
-		                     mali_pp_job_get_id(job), job, sub_job + 1,
-		                     mali_pp_job_get_sub_job_count(job)));
-
-		mali_group_unlock(group);
-	}
-}
-
-/**
- * Set group idle.
- *
- * If @ref group is the virtual group, nothing is done since the virtual group should be idle
- * already.
- *
- * If @ref group is a physical group we rejoin the virtual group, if it exists.  If not, we move the
- * physical group to the idle list.
- *
- * @note The group and the scheduler must both be locked when entering this function.  Both will be
- * unlocked before exiting.
- *
- * @param group The group to set idle.
- */
-static void mali_pp_scheduler_set_group_idle_and_unlock(struct mali_group *group)
-{
-	MALI_DEBUG_ASSERT_POINTER(group);
-
-	MALI_ASSERT_GROUP_LOCKED(group);
-	MALI_DEBUG_ASSERT_LOCK_HELD(pp_scheduler_lock);
-
-	if (mali_group_is_virtual(group)) {
-		/* The virtual group should have been set to non-working already. */
-		MALI_DEBUG_ASSERT(VIRTUAL_GROUP_IDLE == virtual_group_state);
-
-		mali_pp_scheduler_unlock();
-		mali_group_unlock(group);
-
-		return;
-	} else {
-		if (mali_pp_scheduler_has_virtual_group()) {
-			/* Rejoin virtual group. */
-
-			/* We're no longer needed on the scheduler list. */
-			_mali_osk_list_delinit(&(group->pp_scheduler_list));
-
-			/* Make sure no interrupts are handled for this group during the transition
-			 * from physical to virtual. */
-			group->state = MALI_GROUP_STATE_JOINING_VIRTUAL;
-
-			mali_pp_scheduler_unlock();
-			mali_group_unlock(group);
-
-			mali_group_lock(virtual_group);
-
-			if (mali_pp_scheduler_has_virtual_group()) {
-				mali_pp_scheduler_enable_empty_virtual();
-			}
-
-			/* We need to recheck the group state since it is possible that someone has
-			 * modified the group before we locked the virtual group. */
-			if (MALI_GROUP_STATE_JOINING_VIRTUAL == group->state) {
-				mali_group_add_group(virtual_group, group, MALI_TRUE);
-			}
-
-			mali_group_unlock(virtual_group);
-		} else {
-			/* Move physical group back to idle list. */
-			_mali_osk_list_move(&(group->pp_scheduler_list), &group_list_idle);
-
-#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-			trace_gpu_sched_switch(mali_pp_get_hw_core_desc(group->pp_core), sched_clock(), 0, 0, 0);
-#endif
-
-			mali_pp_scheduler_unlock();
-			mali_group_unlock(group);
-		}
-	}
-}
-
-/**
- * Schedule job on locked group.
- *
- * @note The group and the scheduler must both be locked when entering this function.  Both will be
- * unlocked before exiting.
- *
- * @param group The group to schedule on.
- */
-static void mali_pp_scheduler_schedule_on_group_and_unlock(struct mali_group *group)
-{
-	MALI_DEBUG_ASSERT_POINTER(group);
-
-	MALI_ASSERT_GROUP_LOCKED(group);
-	MALI_DEBUG_ASSERT_LOCK_HELD(pp_scheduler_lock);
-
-	if (mali_group_is_virtual(group)) {
-		/* Now that the virtual group is idle, check if we should reconfigure. */
-
-		struct mali_pp_job *virtual_job = NULL;
-		struct mali_pp_job *physical_job = NULL;
-		struct mali_group *physical_group = NULL;
-		u32 physical_sub_job = 0;
-
-		MALI_DEBUG_ASSERT(VIRTUAL_GROUP_IDLE == virtual_group_state);
-
-		if (mali_pp_scheduler_can_move_virtual_to_physical()) {
-			/* There is a runnable physical job and we can acquire a physical group. */
-			physical_job = mali_pp_scheduler_get_physical_job();
-			MALI_DEBUG_ASSERT_POINTER(physical_job);
-			MALI_DEBUG_ASSERT(mali_pp_job_has_unstarted_sub_jobs(physical_job));
-
-			/* Mark sub job as started. */
-			physical_sub_job = mali_pp_job_get_first_unstarted_sub_job(physical_job);
-			mali_pp_job_mark_sub_job_started(physical_job, physical_sub_job);
-
-			/* Remove job from queue (if this was the last sub job). */
-			mali_pp_scheduler_dequeue_physical_job(physical_job);
-
-			/* Acquire a physical group from the virtual group.  Its state will
-			 * be LEAVING_VIRTUAL and must be set to IDLE before it can be
-			 * used. */
-			physical_group = mali_group_acquire_group(virtual_group);
-
-			/* Move physical group to the working list, as we will soon start a job on it. */
-			_mali_osk_list_move(&(physical_group->pp_scheduler_list), &group_list_working);
-
-			mali_pp_scheduler_disable_empty_virtual();
-		}
-
-		/* Get next virtual job. */
-		virtual_job = mali_pp_scheduler_get_virtual_job();
-		if (NULL != virtual_job && VIRTUAL_GROUP_IDLE == virtual_group_state) {
-			/* There is a runnable virtual job. */
-
-			MALI_DEBUG_ASSERT(mali_pp_job_is_virtual(virtual_job));
-			MALI_DEBUG_ASSERT(mali_pp_job_has_unstarted_sub_jobs(virtual_job));
-			MALI_DEBUG_ASSERT(1 == mali_pp_job_get_sub_job_count(virtual_job));
-
-			mali_pp_job_mark_sub_job_started(virtual_job, 0);
-
-			/* Remove job from queue. */
-			mali_pp_scheduler_dequeue_virtual_job(virtual_job);
-
-			/* Virtual group is now working. */
-			virtual_group_state = VIRTUAL_GROUP_WORKING;
-
-			mali_pp_scheduler_unlock();
-
-			/* Start job. */
-			mali_group_start_pp_job(group, virtual_job, 0);
-
-			MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Virtual job %u (0x%08X) part %u/%u started (from job_done).\n",
-			                     mali_pp_job_get_id(virtual_job), virtual_job, 1,
-			                     mali_pp_job_get_sub_job_count(virtual_job)));
-		} else {
-#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-			trace_gpu_sched_switch("Mali_Virtual_PP", sched_clock(), 0, 0, 0);
-#endif
-
-			mali_pp_scheduler_unlock();
-		}
-
-		/* Releasing the virtual group lock that was held when entering the function. */
-		mali_group_unlock(group);
-
-		/* Start a physical job (if we acquired a physical group earlier). */
-		if (NULL != physical_job && NULL != physical_group) {
-			mali_group_lock(physical_group);
-
-			/* Change the group state from LEAVING_VIRTUAL to IDLE to complete the transition. */
-			physical_group->state = MALI_GROUP_STATE_IDLE;
-
-			/* Start job. */
-			mali_group_start_pp_job(physical_group, physical_job, physical_sub_job);
-
-			MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Physical job %u (0x%08X) part %u/%u started (from job_done).\n",
-			                     mali_pp_job_get_id(physical_job), physical_job, physical_sub_job + 1,
-			                     mali_pp_job_get_sub_job_count(physical_job)));
-
-			mali_group_unlock(physical_group);
-		}
-	} else {
-		/* Physical group. */
-		struct mali_pp_job *job = NULL;
-		u32 sub_job = 0;
-
-		job = mali_pp_scheduler_get_physical_job();
-		if (NULL != job) {
-			/* There is a runnable physical job. */
-			MALI_DEBUG_ASSERT(mali_pp_job_has_unstarted_sub_jobs(job));
-
-			/* Mark sub job as started. */
-			sub_job = mali_pp_job_get_first_unstarted_sub_job(job);
-			mali_pp_job_mark_sub_job_started(job, sub_job);
-
-			/* Remove job from queue (if this was the last sub job). */
-			mali_pp_scheduler_dequeue_physical_job(job);
-
-			mali_pp_scheduler_unlock();
-
-			/* Group is already on the working list, so start the new job. */
-			mali_group_start_pp_job(group, job, sub_job);
-
-			MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Physical job %u (0x%08X) part %u/%u started (from job_done).\n",
-			                     mali_pp_job_get_id(job), job, sub_job + 1, mali_pp_job_get_sub_job_count(job)));
-
-			mali_group_unlock(group);
-		} else {
-			mali_pp_scheduler_set_group_idle_and_unlock(group);
-		}
-	}
-}
-
-void mali_pp_scheduler_job_done(struct mali_group *group, struct mali_pp_job *job, u32 sub_job, mali_bool success, mali_bool in_upper_half)
-{
-	mali_bool job_is_done = MALI_FALSE;
-	mali_bool schedule_on_group = MALI_FALSE;
-	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
-
-	MALI_DEBUG_PRINT(3, ("Mali PP scheduler: %s job %u (0x%08X) part %u/%u completed (%s).\n",
-	                     mali_pp_job_is_virtual(job) ? "Virtual" : "Physical",
-	                     mali_pp_job_get_id(job),
-	                     job, sub_job + 1,
-	                     mali_pp_job_get_sub_job_count(job),
-	                     success ? "success" : "failure"));
-
-	MALI_ASSERT_GROUP_LOCKED(group);
-	mali_pp_scheduler_lock();
-
-	mali_pp_job_mark_sub_job_completed(job, success);
-
-	MALI_DEBUG_ASSERT(mali_pp_job_is_virtual(job) == mali_group_is_virtual(group));
-
-	job_is_done = mali_pp_job_is_complete(job);
-
-	if (job_is_done) {
-		/* Job is removed from these lists when the last sub job is scheduled. */
-		MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->list));
-		MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_fb_lookup_list));
-
-		/* Remove job from session list. */
-		_mali_osk_list_delinit(&job->session_list);
-
-		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: All parts completed for %s job %u (0x%08X).\n",
-		                     mali_pp_job_is_virtual(job) ? "virtual" : "physical",
-		                     mali_pp_job_get_id(job), job));
-
-		mali_pp_scheduler_unlock();
-
-		/* Release tracker.  If other trackers are waiting on this tracker, this could
-		 * trigger activation.  The returned scheduling mask can be used to determine if we
-		 * have to schedule GP, PP or both. */
-		schedule_mask = mali_timeline_tracker_release(&job->tracker);
-
-		mali_pp_scheduler_lock();
-	}
-
-	if (mali_group_is_virtual(group)) {
-		/* Obey the policy. */
-		virtual_group_state = VIRTUAL_GROUP_IDLE;
-	}
-
-	/* If paused, then this was the last job, so wake up sleeping workers and return. */
-	if (pause_count > 0) {
-		/* Wake up sleeping workers. Their wake-up condition is that
-		 * num_slots == num_slots_idle, so unless we are done working, no
-		 * threads will actually be woken up.
-		 */
-		if (!mali_group_is_virtual(group)) {
-			/* Move physical group to idle list. */
-			_mali_osk_list_move(&(group->pp_scheduler_list), &group_list_idle);
-		}
-
-#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-		trace_gpu_sched_switch(mali_pp_get_hw_core_desc(group->pp_core), sched_clock(), 0, 0, 0);
-#endif
-
-		_mali_osk_wait_queue_wake_up(pp_scheduler_working_wait_queue);
-
-		mali_pp_scheduler_unlock();
-		mali_group_unlock(group);
-
-		if (job_is_done) {
-			/* Return job to user and delete it. */
-			mali_pp_scheduler_finalize_job(job);
-		}
-
-		/* A GP job might be queued by tracker release above,
-		 * make sure GP scheduler gets a chance to schedule this (if possible)
-		 */
-		mali_scheduler_schedule_from_mask(schedule_mask & ~MALI_SCHEDULER_MASK_PP, in_upper_half);
-
-		return;
-	}
-
-	/* Since this group just finished running a job, we can reschedule a new job on it
-	 * immediately. */
-
-	/* By default, don't schedule on group. */
-	schedule_on_group = MALI_FALSE;
-
-	if (mali_group_is_virtual(group)) {
-		/* Always schedule immediately on virtual group. */
-		schedule_mask &= ~MALI_SCHEDULER_MASK_PP;
-		schedule_on_group = MALI_TRUE;
-	} else if (0 < job_queue.depth && (!mali_scheduler_mask_is_set(schedule_mask, MALI_SCHEDULER_MASK_PP) || _mali_osk_list_empty(&group_list_idle))) {
-		struct mali_pp_job *next_job = NULL;
-
-		next_job = mali_pp_scheduler_get_physical_job();
-		MALI_DEBUG_ASSERT_POINTER(next_job);
-
-		/* If no new jobs have been queued or if this group is the only idle group, we can
-		 * schedule immediately on this group, unless we are GP bound and the next job would
-		 * benefit from all its sub jobs being started concurrently. */
-
-		if (mali_scheduler_hint_is_enabled(MALI_SCHEDULER_HINT_GP_BOUND) && mali_pp_job_is_large_and_unstarted(next_job)) {
-			/* We are GP bound and the job would benefit from all sub jobs being started
-			 * concurrently.  Postpone scheduling until after group has been unlocked. */
-			schedule_mask |= MALI_SCHEDULER_MASK_PP;
-			schedule_on_group = MALI_FALSE;
-		} else {
-			/* Schedule job immediately since we are not GP bound. */
-			schedule_mask &= ~MALI_SCHEDULER_MASK_PP;
-			schedule_on_group = MALI_TRUE;
-		}
-	}
-
-	if (schedule_on_group) {
-		/* Schedule a new job on this group. */
-		mali_pp_scheduler_schedule_on_group_and_unlock(group);
-	} else {
-		/* Set group idle.  Will rejoin virtual group, under appropriate conditions. */
-		mali_pp_scheduler_set_group_idle_and_unlock(group);
-	}
-
-	if (!schedule_on_group || MALI_SCHEDULER_MASK_EMPTY != schedule_mask) {
-		if (MALI_SCHEDULER_MASK_PP & schedule_mask) {
-			/* Schedule PP directly. */
-			mali_pp_scheduler_schedule();
-			schedule_mask &= ~MALI_SCHEDULER_MASK_PP;
-		}
-
-		/* Schedule other jobs that were activated. */
-		mali_scheduler_schedule_from_mask(schedule_mask, in_upper_half);
-	}
-
-	if (job_is_done) {
-		/* Return job to user and delete it. */
-		mali_pp_scheduler_finalize_job(job);
-	}
-}
-
-void mali_pp_scheduler_suspend(void)
-{
-	mali_pp_scheduler_lock();
-	pause_count++; /* Increment the pause_count so that no more jobs will be scheduled */
-	mali_pp_scheduler_unlock();
-
-	/* Go to sleep. When woken up again (in mali_pp_scheduler_job_done), the
-	 * mali_pp_scheduler_suspended() function will be called. This will return true
-	 * if state is idle and pause_count > 0, so if the core is active this
-	 * will not do anything.
-	 */
-	_mali_osk_wait_queue_wait_event(pp_scheduler_working_wait_queue, mali_pp_scheduler_is_suspended, NULL);
-}
-
-void mali_pp_scheduler_resume(void)
-{
-	mali_pp_scheduler_lock();
-	pause_count--; /* Decrement pause_count to allow scheduling again (if it reaches 0) */
-	mali_pp_scheduler_unlock();
-	if (0 == pause_count) {
-		mali_pp_scheduler_schedule();
-	}
-}
-
-mali_timeline_point mali_pp_scheduler_submit_job(struct mali_session_data *session, struct mali_pp_job *job)
-{
-	mali_timeline_point point;
-	u32 fb_lookup_id = 0;
-
-	MALI_DEBUG_ASSERT_POINTER(session);
-	MALI_DEBUG_ASSERT_POINTER(job);
-
-	mali_pp_scheduler_lock();
-
-	fb_lookup_id = mali_pp_job_get_fb_lookup_id(job);
-	MALI_DEBUG_ASSERT(MALI_PP_JOB_FB_LOOKUP_LIST_SIZE > fb_lookup_id);
-
-	/* Adding job to the lookup list used to quickly discard writeback units of queued jobs. */
-	_mali_osk_list_addtail(&job->session_fb_lookup_list, &session->pp_job_fb_lookup_list[fb_lookup_id]);
-
-	mali_pp_scheduler_unlock();
-
-	mali_pp_scheduler_job_queued();
-
-	/* Add job to Timeline system. */
-	point = mali_timeline_system_add_tracker(session->timeline_system, &job->tracker, MALI_TIMELINE_PP);
-
-	return point;
-}
-
-_mali_osk_errcode_t _mali_ukk_pp_start_job(void *ctx, _mali_uk_pp_start_job_s *uargs)
-{
-	struct mali_session_data *session;
-	struct mali_pp_job *job;
-	mali_timeline_point point;
-	u32 __user *timeline_point_ptr = NULL;
-
-	MALI_DEBUG_ASSERT_POINTER(uargs);
-	MALI_DEBUG_ASSERT_POINTER(ctx);
-
-	session = (struct mali_session_data*)ctx;
-
-	job = mali_pp_job_create(session, uargs, mali_scheduler_get_new_id());
-	if (NULL == job) {
-		MALI_PRINT_ERROR(("Failed to create PP job.\n"));
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	timeline_point_ptr = (u32 __user *) job->uargs.timeline_point_ptr;
-
-	point = mali_pp_scheduler_submit_job(session, job);
-	job = NULL;
-
-	if (0 != _mali_osk_put_user(((u32) point), timeline_point_ptr)) {
-		/* Let user space know that something failed after the job was started. */
-		return _MALI_OSK_ERR_ITEM_NOT_FOUND;
-	}
-
-	return _MALI_OSK_ERR_OK;
-}
-
-_mali_osk_errcode_t _mali_ukk_pp_and_gp_start_job(void *ctx, _mali_uk_pp_and_gp_start_job_s *uargs)
-{
-	struct mali_session_data *session;
-	_mali_uk_pp_and_gp_start_job_s kargs;
-	struct mali_pp_job *pp_job;
-	struct mali_gp_job *gp_job;
-	u32 __user *timeline_point_ptr = NULL;
-	mali_timeline_point point;
-
-	MALI_DEBUG_ASSERT_POINTER(ctx);
-	MALI_DEBUG_ASSERT_POINTER(uargs);
-
-	session = (struct mali_session_data *) ctx;
-
-	if (0 != _mali_osk_copy_from_user(&kargs, uargs, sizeof(_mali_uk_pp_and_gp_start_job_s))) {
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	pp_job = mali_pp_job_create(session, kargs.pp_args, mali_scheduler_get_new_id());
-	if (NULL == pp_job) {
-		MALI_PRINT_ERROR(("Failed to create PP job.\n"));
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	gp_job = mali_gp_job_create(session, kargs.gp_args, mali_scheduler_get_new_id(), mali_pp_job_get_tracker(pp_job));
-	if (NULL == gp_job) {
-		MALI_PRINT_ERROR(("Failed to create GP job.\n"));
-		mali_pp_job_delete(pp_job);
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	timeline_point_ptr = (u32 __user *) pp_job->uargs.timeline_point_ptr;
-
-	/* Submit GP job. */
-	mali_gp_scheduler_submit_job(session, gp_job);
-	gp_job = NULL;
-
-	/* Submit PP job. */
-	point = mali_pp_scheduler_submit_job(session, pp_job);
-	pp_job = NULL;
-
-	if (0 != _mali_osk_put_user(((u32) point), timeline_point_ptr)) {
-		/* Let user space know that something failed after the jobs were started. */
-		return _MALI_OSK_ERR_ITEM_NOT_FOUND;
-	}
-
-	return _MALI_OSK_ERR_OK;
-}
-
-_mali_osk_errcode_t _mali_ukk_get_pp_number_of_cores(_mali_uk_get_pp_number_of_cores_s *args)
-{
-	MALI_DEBUG_ASSERT_POINTER(args);
-	MALI_DEBUG_ASSERT_POINTER(args->ctx);
-	args->number_of_total_cores = num_cores;
-	args->number_of_enabled_cores = enabled_cores;
-	return _MALI_OSK_ERR_OK;
-}
-
-u32 mali_pp_scheduler_get_num_cores_total(void)
-{
-	return num_cores;
-}
-
-u32 mali_pp_scheduler_get_num_cores_enabled(void)
-{
-	return enabled_cores;
-}
-
-_mali_osk_errcode_t _mali_ukk_get_pp_core_version(_mali_uk_get_pp_core_version_s *args)
-{
-	MALI_DEBUG_ASSERT_POINTER(args);
-	MALI_DEBUG_ASSERT_POINTER(args->ctx);
-	args->version = pp_version;
-	return _MALI_OSK_ERR_OK;
-}
-
-void _mali_ukk_pp_job_disable_wb(_mali_uk_pp_disable_wb_s *args)
-{
-	struct mali_session_data *session;
-	struct mali_pp_job *job;
-	struct mali_pp_job *tmp;
-	u32 fb_lookup_id;
-
-	MALI_DEBUG_ASSERT_POINTER(args);
-	MALI_DEBUG_ASSERT_POINTER(args->ctx);
-
-	session = (struct mali_session_data*)args->ctx;
-
-	fb_lookup_id = args->fb_id & MALI_PP_JOB_FB_LOOKUP_LIST_MASK;
-
-	mali_pp_scheduler_lock();
-
-	/* Iterate over all jobs for given frame builder_id. */
-	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &session->pp_job_fb_lookup_list[fb_lookup_id], struct mali_pp_job, session_fb_lookup_list) {
-		MALI_DEBUG_CODE(u32 disable_mask = 0);
-
-		if (mali_pp_job_get_frame_builder_id(job) == (u32) args->fb_id) {
-			MALI_DEBUG_CODE(disable_mask |= 0xD<<(4*3));
-			if (args->wb0_memory == job->uargs.wb0_registers[MALI200_REG_ADDR_WB_SOURCE_ADDR/sizeof(u32)]) {
-				MALI_DEBUG_CODE(disable_mask |= 0x1<<(4*1));
-				mali_pp_job_disable_wb0(job);
-			}
-			if (args->wb1_memory == job->uargs.wb1_registers[MALI200_REG_ADDR_WB_SOURCE_ADDR/sizeof(u32)]) {
-				MALI_DEBUG_CODE(disable_mask |= 0x2<<(4*2));
-				mali_pp_job_disable_wb1(job);
-			}
-			if (args->wb2_memory == job->uargs.wb2_registers[MALI200_REG_ADDR_WB_SOURCE_ADDR/sizeof(u32)]) {
-				MALI_DEBUG_CODE(disable_mask |= 0x3<<(4*3));
-				mali_pp_job_disable_wb2(job);
-			}
-			MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Disable WB: 0x%X.\n", disable_mask));
-		} else {
-			MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Disable WB mismatching FB.\n"));
-		}
-	}
-
-	mali_pp_scheduler_unlock();
-}
-
-void mali_pp_scheduler_abort_session(struct mali_session_data *session)
-{
-	u32 i = 0;
-	struct mali_pp_job *job, *tmp_job;
-	struct mali_group *group, *tmp_group;
-	struct mali_group *groups[MALI_MAX_NUMBER_OF_GROUPS];
-	_MALI_OSK_LIST_HEAD_STATIC_INIT(removed_jobs);
-
-	MALI_DEBUG_ASSERT_POINTER(session);
-	MALI_DEBUG_ASSERT(session->is_aborting);
-
-	MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Aborting all jobs from session 0x%08X.\n", session));
-
-	mali_pp_scheduler_lock();
-
-	/* Find all jobs from the aborting session. */
-	_MALI_OSK_LIST_FOREACHENTRY(job, tmp_job, &session->pp_job_list, struct mali_pp_job, session_list) {
-		/* Remove job from queue. */
-		if (mali_pp_job_is_virtual(job)) {
-			MALI_DEBUG_ASSERT(1 == mali_pp_job_get_sub_job_count(job));
-			if (0 == mali_pp_job_get_first_unstarted_sub_job(job)) {
-				--virtual_job_queue.depth;
-			}
-		} else {
-			job_queue.depth -= mali_pp_job_get_sub_job_count(job) - mali_pp_job_get_first_unstarted_sub_job(job);
-		}
-
-		_mali_osk_list_delinit(&job->list);
-		_mali_osk_list_delinit(&job->session_fb_lookup_list);
-
-		mali_pp_job_mark_unstarted_failed(job);
-
-		if (mali_pp_job_is_complete(job)) {
-			/* Job is complete, remove from session list. */
-			_mali_osk_list_delinit(&job->session_list);
-
-			/* Move job to local list for release and deletion. */
-			_mali_osk_list_add(&job->list, &removed_jobs);
-
-			MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Aborted PP job %u (0x%08X).\n", mali_pp_job_get_id(job), job));
-		} else {
-			MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Keeping partially started PP job %u (0x%08X) in session.\n", mali_pp_job_get_id(job), job));
-		}
-	}
-
-	_MALI_OSK_LIST_FOREACHENTRY(group, tmp_group, &group_list_working, struct mali_group, pp_scheduler_list) {
-		groups[i++] = group;
-	}
-
-	_MALI_OSK_LIST_FOREACHENTRY(group, tmp_group, &group_list_idle, struct mali_group, pp_scheduler_list) {
-		groups[i++] = group;
-	}
-
-	mali_pp_scheduler_unlock();
-
-	/* Release and delete all found jobs from the aborting session. */
-	_MALI_OSK_LIST_FOREACHENTRY(job, tmp_job, &removed_jobs, struct mali_pp_job, list) {
-		mali_timeline_tracker_release(&job->tracker);
-		mali_pp_job_delete(job);
-		mali_pp_scheduler_job_completed();
-	}
-
-	/* Abort any running jobs from the session. */
-	while (i > 0) {
-		mali_group_abort_session(groups[--i], session);
-	}
-
-	if (mali_pp_scheduler_has_virtual_group()) {
-		mali_group_abort_session(virtual_group, session);
-	}
-}
-
-static mali_bool mali_pp_scheduler_is_suspended(void *data)
-{
-	mali_bool ret;
-
-	/* This callback does not use the data pointer. */
-	MALI_IGNORE(data);
-
-	mali_pp_scheduler_lock();
-
-	ret = pause_count > 0
-	      && _mali_osk_list_empty(&group_list_working)
-	      && VIRTUAL_GROUP_WORKING != virtual_group_state;
-
-	mali_pp_scheduler_unlock();
-
-	return ret;
-}
-
-struct mali_pp_core *mali_pp_scheduler_get_virtual_pp(void)
-{
-	if (mali_pp_scheduler_has_virtual_group()) {
-		return mali_group_get_pp_core(virtual_group);
-	} else {
-		return NULL;
-	}
-}
-
-#if MALI_STATE_TRACKING
-u32 mali_pp_scheduler_dump_state(char *buf, u32 size)
-{
-	int n = 0;
-	struct mali_group *group;
-	struct mali_group *temp;
-
-	n += _mali_osk_snprintf(buf + n, size - n, "PP:\n");
-	n += _mali_osk_snprintf(buf + n, size - n, "\tQueue is %s\n", _mali_osk_list_empty(&job_queue.normal_pri) ? "empty" : "not empty");
-	n += _mali_osk_snprintf(buf + n, size - n, "\tHigh priority queue is %s\n", _mali_osk_list_empty(&job_queue.high_pri) ? "empty" : "not empty");
-	n += _mali_osk_snprintf(buf + n, size - n, "\n");
-
-	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_working, struct mali_group, pp_scheduler_list) {
-		n += mali_group_dump_state(group, buf + n, size - n);
-	}
-
-	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_idle, struct mali_group, pp_scheduler_list) {
-		n += mali_group_dump_state(group, buf + n, size - n);
-	}
-
-	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_disabled, struct mali_group, pp_scheduler_list) {
-		n += mali_group_dump_state(group, buf + n, size - n);
-	}
-
-	if (mali_pp_scheduler_has_virtual_group()) {
-		n += mali_group_dump_state(virtual_group, buf + n, size -n);
-	}
-
-	n += _mali_osk_snprintf(buf + n, size - n, "\n");
-	return n;
-}
-#endif
-
-/* This function is intended for power on reset of all cores.
- * No locking is done for the list iteration, which can only be safe if the
- * scheduler is paused and all cores idle. That is always the case on init and
- * power on. */
-void mali_pp_scheduler_reset_all_groups(void)
-{
-	struct mali_group *group, *temp;
-	struct mali_group *groups[MALI_MAX_NUMBER_OF_GROUPS];
-	s32 i = 0;
-
-	if (mali_pp_scheduler_has_virtual_group()) {
-		mali_group_lock(virtual_group);
-		mali_group_reset(virtual_group);
-		mali_group_unlock(virtual_group);
-	}
-
-	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&group_list_working));
-	MALI_DEBUG_ASSERT(VIRTUAL_GROUP_WORKING != virtual_group_state);
-	mali_pp_scheduler_lock();
-	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_idle, struct mali_group, pp_scheduler_list) {
-		groups[i++] = group;
-	}
-	mali_pp_scheduler_unlock();
-
-	while (i > 0) {
-		group = groups[--i];
-
-		mali_group_lock(group);
-		mali_group_reset(group);
-		mali_group_unlock(group);
-	}
-}
-
-void mali_pp_scheduler_zap_all_active(struct mali_session_data *session)
-{
-	struct mali_group *group, *temp;
-	struct mali_group *groups[MALI_MAX_NUMBER_OF_GROUPS];
-	s32 i = 0;
-
-	if (mali_pp_scheduler_has_virtual_group()) {
-		mali_group_zap_session(virtual_group, session);
-	}
-
-	mali_pp_scheduler_lock();
-	_MALI_OSK_LIST_FOREACHENTRY(group, temp, &group_list_working, struct mali_group, pp_scheduler_list) {
-		groups[i++] = group;
-	}
-	mali_pp_scheduler_unlock();
-
-	while (i > 0) {
-		mali_group_zap_session(groups[--i], session);
-	}
-}
-
-/* A pm reference must be taken with _mali_osk_pm_dev_ref_add_no_power_on
- * before calling this function to avoid Mali powering down as HW is accessed.
- */
-static void mali_pp_scheduler_enable_group_internal(struct mali_group *group)
-{
-	MALI_DEBUG_ASSERT_POINTER(group);
-
-	mali_group_lock(group);
-
-	if (MALI_GROUP_STATE_DISABLED != group->state) {
-		mali_group_unlock(group);
-		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: PP group %p already enabled.\n", group));
-		return;
-	}
-
-	MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Enabling PP group %p.\n", group));
-
-	mali_pp_scheduler_lock();
-
-	MALI_DEBUG_ASSERT(MALI_GROUP_STATE_DISABLED == group->state);
-	++enabled_cores;
-
-	if (mali_pp_scheduler_has_virtual_group()) {
-		mali_bool update_hw;
-
-		/* Add group to virtual group. */
-		_mali_osk_list_delinit(&(group->pp_scheduler_list));
-		group->state = MALI_GROUP_STATE_JOINING_VIRTUAL;
-
-		mali_pp_scheduler_unlock();
-		mali_group_unlock(group);
-
-		mali_group_lock(virtual_group);
-
-		update_hw = mali_pm_is_power_on();
-		/* Get ref of group domain */
-		mali_group_get_pm_domain_ref(group);
-
-		MALI_DEBUG_ASSERT(NULL == group->pm_domain ||
-		                  MALI_PM_DOMAIN_ON == mali_pm_domain_state_get(group->pm_domain));
-
-		if (update_hw) {
-			mali_group_lock(group);
-			mali_group_power_on_group(group);
-			mali_group_reset(group);
-			mali_group_unlock(group);
-		}
-
-		mali_pp_scheduler_enable_empty_virtual();
-		mali_group_add_group(virtual_group, group, update_hw);
-		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Done enabling group %p. Added to virtual group.\n", group));
-
-		mali_group_unlock(virtual_group);
-	} else {
-		/* Get ref of group domain */
-		mali_group_get_pm_domain_ref(group);
-
-		MALI_DEBUG_ASSERT(NULL == group->pm_domain ||
-		                  MALI_PM_DOMAIN_ON == mali_pm_domain_state_get(group->pm_domain));
-
-		/* Put group on idle list. */
-		if (mali_pm_is_power_on()) {
-			mali_group_power_on_group(group);
-			mali_group_reset(group);
-		}
-
-		_mali_osk_list_move(&(group->pp_scheduler_list), &group_list_idle);
-		group->state = MALI_GROUP_STATE_IDLE;
-
-		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Done enabling group %p. Now on idle list.\n", group));
-		mali_pp_scheduler_unlock();
-		mali_group_unlock(group);
-	}
-}
-
-void mali_pp_scheduler_enable_group(struct mali_group *group)
-{
-	MALI_DEBUG_ASSERT_POINTER(group);
-
-	_mali_osk_pm_dev_ref_add_no_power_on();
-
-	mali_pp_scheduler_enable_group_internal(group);
-
-	_mali_osk_pm_dev_ref_dec_no_power_on();
-
-	/* Pick up any jobs that might have been queued if all PP groups were disabled. */
-	mali_pp_scheduler_schedule();
-}
-
-static void mali_pp_scheduler_disable_group_internal(struct mali_group *group)
-{
-	if (mali_pp_scheduler_has_virtual_group()) {
-		mali_group_lock(virtual_group);
-
-		MALI_DEBUG_ASSERT(VIRTUAL_GROUP_WORKING != virtual_group_state);
-		if (MALI_GROUP_STATE_JOINING_VIRTUAL == group->state) {
-			/* The group was in the process of being added to the virtual group.  We
-			 * only need to change the state to reverse this. */
-			group->state = MALI_GROUP_STATE_LEAVING_VIRTUAL;
-		} else if (MALI_GROUP_STATE_IN_VIRTUAL == group->state) {
-			/* Remove group from virtual group.  The state of the group will be
-			 * LEAVING_VIRTUAL and the group will not be on any scheduler list. */
-			mali_group_remove_group(virtual_group, group);
-
-			mali_pp_scheduler_disable_empty_virtual();
-		}
-
-		mali_group_unlock(virtual_group);
-	}
-
-	mali_group_lock(group);
-	mali_pp_scheduler_lock();
-
-	MALI_DEBUG_ASSERT(   MALI_GROUP_STATE_IDLE            == group->state
-	                     || MALI_GROUP_STATE_LEAVING_VIRTUAL == group->state
-	                     || MALI_GROUP_STATE_DISABLED        == group->state);
-
-	if (MALI_GROUP_STATE_DISABLED == group->state) {
-		MALI_DEBUG_PRINT(4, ("Mali PP scheduler: PP group %p already disabled.\n", group));
-	} else {
-		MALI_DEBUG_PRINT(3, ("Mali PP scheduler: Disabling PP group %p.\n", group));
-
-		--enabled_cores;
-		_mali_osk_list_move(&(group->pp_scheduler_list), &group_list_disabled);
-		group->state = MALI_GROUP_STATE_DISABLED;
-
-		mali_group_power_off_group(group, MALI_TRUE);
-		mali_group_put_pm_domain_ref(group);
-	}
-
-	mali_pp_scheduler_unlock();
-	mali_group_unlock(group);
-}
-
-void mali_pp_scheduler_disable_group(struct mali_group *group)
-{
-	MALI_DEBUG_ASSERT_POINTER(group);
-
-	mali_pp_scheduler_suspend();
-
-	_mali_osk_pm_dev_ref_add_no_power_on();
-
-	mali_pp_scheduler_disable_group_internal(group);
-
-	_mali_osk_pm_dev_ref_dec_no_power_on();
-
-	mali_pp_scheduler_resume();
-}
-
-static void mali_pp_scheduler_notify_core_change(u32 num_cores)
-{
-	mali_bool done = MALI_FALSE;
-
-	if (mali_is_mali450()) {
-		return;
-	}
-
-	/*
-	 * This function gets a bit complicated because we can't hold the session lock while
-	 * allocating notification objects.
-	 */
-
-	while (!done) {
-		u32 i;
-		u32 num_sessions_alloc;
-		u32 num_sessions_with_lock;
-		u32 used_notification_objects = 0;
-		_mali_osk_notification_t **notobjs;
-
-		/* Pre allocate the number of notifications objects we need right now (might change after lock has been taken) */
-		num_sessions_alloc = mali_session_get_count();
-		if (0 == num_sessions_alloc) {
-			/* No sessions to report to */
-			return;
-		}
-
-		notobjs = (_mali_osk_notification_t **)_mali_osk_malloc(sizeof(_mali_osk_notification_t *) * num_sessions_alloc);
-		if (NULL == notobjs) {
-			MALI_PRINT_ERROR(("Failed to notify user space session about num PP core change (alloc failure)\n"));
-			/* there is probably no point in trying again, system must be really low on memory and probably unusable now anyway */
-			return;
-		}
-
-		for (i = 0; i < num_sessions_alloc; i++) {
-			notobjs[i] = _mali_osk_notification_create(_MALI_NOTIFICATION_PP_NUM_CORE_CHANGE, sizeof(_mali_uk_pp_num_cores_changed_s));
-			if (NULL != notobjs[i]) {
-				_mali_uk_pp_num_cores_changed_s *data = notobjs[i]->result_buffer;
-				data->number_of_enabled_cores = num_cores;
-			} else {
-				MALI_PRINT_ERROR(("Failed to notify user space session about num PP core change (alloc failure %u)\n", i));
-			}
-		}
-
-		mali_session_lock();
-
-		/* number of sessions will not change while we hold the lock */
-		num_sessions_with_lock = mali_session_get_count();
-
-		if (num_sessions_alloc >= num_sessions_with_lock) {
-			/* We have allocated enough notification objects for all the sessions atm */
-			struct mali_session_data *session, *tmp;
-			MALI_SESSION_FOREACH(session, tmp, link) {
-				MALI_DEBUG_ASSERT(used_notification_objects < num_sessions_alloc);
-				if (NULL != notobjs[used_notification_objects]) {
-					mali_session_send_notification(session, notobjs[used_notification_objects]);
-					notobjs[used_notification_objects] = NULL; /* Don't track this notification object any more */
-				}
-				used_notification_objects++;
-			}
-			done = MALI_TRUE;
-		}
-
-		mali_session_unlock();
-
-		/* Delete any remaining/unused notification objects */
-		for (; used_notification_objects < num_sessions_alloc; used_notification_objects++) {
-			if (NULL != notobjs[used_notification_objects]) {
-				_mali_osk_notification_delete(notobjs[used_notification_objects]);
-			}
-		}
-
-		_mali_osk_free(notobjs);
-	}
-}
-
-static void mali_pp_scheduler_core_scale_up(unsigned int target_core_nr)
-{
-	MALI_DEBUG_PRINT(3, ("Requesting %d cores: enabling %d cores\n", target_core_nr, target_core_nr - enabled_cores));
-
-	_mali_osk_pm_dev_ref_add_no_power_on();
-	_mali_osk_pm_dev_barrier();
-
-	while (target_core_nr > enabled_cores) {
-		/*
-		 * If there are any cores which do not belong to any domain,
-		 * then these will always be found at the head of the list and
-		 * we'll thus enabled these first.
-		 */
-
-		mali_pp_scheduler_lock();
-
-		if (!_mali_osk_list_empty(&group_list_disabled)) {
-			struct mali_group *group;
-
-			group = _MALI_OSK_LIST_ENTRY(group_list_disabled.next, struct mali_group, pp_scheduler_list);
-
-			MALI_DEBUG_ASSERT_POINTER(group);
-			MALI_DEBUG_ASSERT(MALI_GROUP_STATE_DISABLED == group->state);
-
-			mali_pp_scheduler_unlock();
-
-			mali_pp_scheduler_enable_group_internal(group);
-		} else {
-			mali_pp_scheduler_unlock();
-			break; /* no more groups on disabled list */
-		}
-	}
-
-	_mali_osk_pm_dev_ref_dec_no_power_on();
-
-	mali_pp_scheduler_schedule();
-}
-
-static void mali_pp_scheduler_core_scale_down(unsigned int target_core_nr)
-{
-	MALI_DEBUG_PRINT(3, ("Requesting %d cores: disabling %d cores\n", target_core_nr, enabled_cores - target_core_nr));
-
-	mali_pp_scheduler_suspend();
-
-	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&group_list_working));
-
-	_mali_osk_pm_dev_ref_add_no_power_on();
-
-	if (NULL != mali_pmu_get_global_pmu_core()) {
-		int i;
-
-		for (i = MALI_MAX_NUMBER_OF_DOMAINS - 1; i >= 0; i--) {
-			if (target_core_nr < enabled_cores) {
-				struct mali_pm_domain *domain;
-
-				domain = mali_pm_domain_get_from_index(i);
-
-				/* Domain is valid and has pp cores */
-				if ((NULL != domain) && (NULL != domain->group_list)) {
-					struct mali_group *group;
-
-					MALI_PM_DOMAIN_FOR_EACH_GROUP(group, domain) {
-						/* If group is pp core */
-						if (NULL != mali_group_get_pp_core(group)) {
-							mali_pp_scheduler_disable_group_internal(group);
-							if (target_core_nr >= enabled_cores) {
-								break;
-							}
-						}
-					}
-				}
-			} else {
-				break;
-			}
-		}
-	}
-
-	/*
-	 * Didn't find enough cores associated with a power domain,
-	 * so we need to disable cores which we can't power off with the PMU.
-	 * Start with physical groups used by the scheduler,
-	 * then remove physical from virtual if even more groups are needed.
-	 */
-
-	while (target_core_nr < enabled_cores) {
-		mali_pp_scheduler_lock();
-		if (!_mali_osk_list_empty(&group_list_idle)) {
-			struct mali_group *group;
-
-			group = _MALI_OSK_LIST_ENTRY(group_list_idle.next, struct mali_group, pp_scheduler_list);
-			MALI_DEBUG_ASSERT_POINTER(group);
-
-			mali_pp_scheduler_unlock();
-
-			mali_pp_scheduler_disable_group_internal(group);
-		} else {
-			mali_pp_scheduler_unlock();
-			break; /* No more physical groups */
-		}
-	}
-
-	if (mali_pp_scheduler_has_virtual_group()) {
-		while (target_core_nr < enabled_cores) {
-			mali_group_lock(virtual_group);
-			if (!_mali_osk_list_empty(&virtual_group->group_list)) {
-				struct mali_group *group;
-
-				group = _MALI_OSK_LIST_ENTRY(virtual_group->group_list.next, struct mali_group, group_list);
-				MALI_DEBUG_ASSERT_POINTER(group);
-
-				mali_group_unlock(virtual_group);
-
-				mali_pp_scheduler_disable_group_internal(group);
-			} else {
-				mali_group_unlock(virtual_group);
-				break; /* No more physical groups in virtual group */
-			}
-		}
-	}
-
-	_mali_osk_pm_dev_ref_dec_no_power_on();
-
-	mali_pp_scheduler_resume();
-}
-
-int mali_pp_scheduler_set_perf_level(unsigned int target_core_nr, mali_bool override)
-{
-	if (target_core_nr == enabled_cores) return 0;
-	if (MALI_FALSE == core_scaling_enabled && MALI_FALSE == override) return -EPERM;
-	if (target_core_nr > num_cores) return -EINVAL;
-	if (0 == target_core_nr) return -EINVAL;
-
-	if (target_core_nr > enabled_cores) {
-		mali_pp_scheduler_core_scale_up(target_core_nr);
-	} else if (target_core_nr < enabled_cores) {
-		mali_pp_scheduler_core_scale_down(target_core_nr);
-	}
-
-	if (target_core_nr != enabled_cores) {
-		MALI_DEBUG_PRINT(2, ("Core scaling failed, target number: %d, actual number: %d\n", target_core_nr, enabled_cores));
-	}
-
-	mali_pp_scheduler_notify_core_change(enabled_cores);
-
-	return 0;
-}
-
-void mali_pp_scheduler_core_scaling_enable(void)
-{
-	/* PS: Core scaling is by default enabled */
-	core_scaling_enabled = MALI_TRUE;
-}
-
-void mali_pp_scheduler_core_scaling_disable(void)
-{
-	core_scaling_enabled = MALI_FALSE;
-}
-
-mali_bool mali_pp_scheduler_core_scaling_is_enabled(void)
-{
-	return core_scaling_enabled;
-}
-
-static void mali_pp_scheduler_job_queued(void)
-{
-	/* We hold a PM reference for every job we hold queued (and running) */
-	_mali_osk_pm_dev_ref_add();
-
-	if (mali_utilization_enabled()) {
-		/*
-		 * We cheat a little bit by counting the PP as busy from the time a PP job is queued.
-		 * This will be fine because we only loose the tiny idle gap between jobs, but
-		 * we will instead get less utilization work to do (less locks taken)
-		 */
-		mali_utilization_pp_start();
-	}
-}
-
-static void mali_pp_scheduler_job_completed(void)
-{
-	/* Release the PM reference we got in the mali_pp_scheduler_job_queued() function */
-	_mali_osk_pm_dev_ref_dec();
-
-	if (mali_utilization_enabled()) {
-		mali_utilization_pp_end();
-	}
-}
-
-static void mali_pp_scheduler_abort_job_and_unlock_scheduler(struct mali_pp_job *job)
-{
-	MALI_DEBUG_ASSERT_POINTER(job);
-	MALI_DEBUG_ASSERT_LOCK_HELD(pp_scheduler_lock);
-
-	/* This job should not be on any lists. */
-	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->list));
-	MALI_DEBUG_ASSERT(_mali_osk_list_empty(&job->session_list));
-
-	_mali_osk_list_delinit(&job->session_fb_lookup_list);
-
-	mali_pp_scheduler_unlock();
-
-	/* Release tracker. */
-	mali_timeline_tracker_release(&job->tracker);
-}
-
-static mali_scheduler_mask mali_pp_scheduler_queue_job(struct mali_pp_job *job)
-{
-	_mali_osk_list_t *queue = NULL;
-	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
-	struct mali_pp_job *iter, *tmp;
-
-	MALI_DEBUG_ASSERT_POINTER(job);
-	MALI_DEBUG_ASSERT_POINTER(job->session);
-
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE)
-	if (mali_pp_job_needs_dma_buf_mapping(job)) {
-		mali_dma_buf_map_job(job);
-	}
-#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE) */
-
-	mali_pp_scheduler_lock();
-
-	if (unlikely(job->session->is_aborting)) {
-		/* Before checking if the session is aborting, the scheduler must be locked. */
-		MALI_DEBUG_ASSERT_LOCK_HELD(pp_scheduler_lock);
-
-		MALI_DEBUG_PRINT(2, ("Mali PP scheduler: Job %u (0x%08X) queued while session is aborting.\n", mali_pp_job_get_id(job), job));
-
-		mali_pp_scheduler_abort_job_and_unlock_scheduler(job);
-
-		/* Delete job. */
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE)
-		mali_pp_scheduler_deferred_job_delete(job);
-#else
-		mali_pp_job_delete(job);
-#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_DELETE) */
-		mali_pp_scheduler_job_completed();
-
-		/* Since we are aborting we ignore the scheduler mask. */
-		return MALI_SCHEDULER_MASK_EMPTY;
-	}
-
-#if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
-	trace_gpu_job_enqueue(mali_pp_job_get_tid(job), mali_pp_job_get_id(job), "PP");
-#endif
-
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE | MALI_PROFILING_EVENT_CHANNEL_SOFTWARE | MALI_PROFILING_EVENT_REASON_SINGLE_SW_PP_ENQUEUE, job->pid, job->tid, job->uargs.frame_builder_id, job->uargs.flush_id, 0);
-
-	job->cache_order = mali_scheduler_get_new_cache_order();
-
-	/* Determine which queue the job should be added to. */
-	if (mali_pp_job_is_virtual(job)) {
-		if (job->session->use_high_priority_job_queue) {
-			queue = &virtual_job_queue.high_pri;
-		} else {
-			queue = &virtual_job_queue.normal_pri;
-		}
-
-		virtual_job_queue.depth += 1;
-
-		/* Set schedule bitmask if the virtual group is idle. */
-		if (VIRTUAL_GROUP_IDLE == virtual_group_state) {
-			schedule_mask |= MALI_SCHEDULER_MASK_PP;
-		}
-	} else {
-		if (job->session->use_high_priority_job_queue) {
-			queue = &job_queue.high_pri;
-		} else {
-			queue = &job_queue.normal_pri;
-		}
-
-		job_queue.depth += mali_pp_job_get_sub_job_count(job);
-
-		/* Set schedule bitmask if there are physical PP cores available, or if there is an
-		 * idle virtual group. */
-		if (!_mali_osk_list_empty(&group_list_idle)
-		    || (mali_pp_scheduler_has_virtual_group()
-		        && (VIRTUAL_GROUP_IDLE == virtual_group_state))) {
-			schedule_mask |= MALI_SCHEDULER_MASK_PP;
-		}
-	}
-
-	/* Find position in queue where job should be added. */
-	_MALI_OSK_LIST_FOREACHENTRY_REVERSE(iter, tmp, queue, struct mali_pp_job, list) {
-		if (mali_pp_job_should_start_after(job, iter)) {
-			break;
-		}
-	}
-
-	/* Add job to queue. */
-	_mali_osk_list_add(&job->list, &iter->list);
-
-	/* Add job to session list. */
-	_mali_osk_list_addtail(&job->session_list, &(job->session->pp_job_list));
-
-	MALI_DEBUG_PRINT(3, ("Mali PP scheduler: %s job %u (0x%08X) with %u parts queued.\n",
-	                     mali_pp_job_is_virtual(job) ? "Virtual" : "Physical",
-	                     mali_pp_job_get_id(job), job, mali_pp_job_get_sub_job_count(job)));
-
-	mali_pp_scheduler_unlock();
-
-	return schedule_mask;
-}
-
-mali_scheduler_mask mali_pp_scheduler_activate_job(struct mali_pp_job *job)
-{
-	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
-
-	MALI_DEBUG_ASSERT_POINTER(job);
-	MALI_DEBUG_ASSERT_POINTER(job->session);
-
-	MALI_DEBUG_PRINT(4, ("Mali PP scheduler: Timeline activation for job %u (0x%08X).\n", mali_pp_job_get_id(job), job));
-
-	if (MALI_TIMELINE_ACTIVATION_ERROR_FATAL_BIT & job->tracker.activation_error) {
-		MALI_DEBUG_PRINT(2, ("Mali PP scheduler: Job %u (0x%08X) activated with error, aborting.\n", mali_pp_job_get_id(job), job));
-
-		mali_pp_scheduler_lock();
-		mali_pp_scheduler_abort_job_and_unlock_scheduler(job);
-
-		mali_pp_job_mark_sub_job_completed(job, MALI_FALSE); /* Flagging the job as failed. */
-		mali_pp_scheduler_finalize_job(job);
-
-		return MALI_SCHEDULER_MASK_EMPTY;
-	}
-
-	/* PP job is ready to run, queue it. */
-
-#if defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE)
-	if (mali_pp_job_needs_dma_buf_mapping(job)) {
-		mali_pp_scheduler_deferred_job_queue(job);
-
-		return MALI_SCHEDULER_MASK_EMPTY;
-	}
-#endif /* defined(MALI_PP_SCHEDULER_USE_DEFERRED_JOB_QUEUE) */
-
-	schedule_mask = mali_pp_scheduler_queue_job(job);
-
-	return schedule_mask;
-}
diff --git a/drivers/gpu/arm/mali/common/mali_pp_scheduler.h b/drivers/gpu/arm/mali/common/mali_pp_scheduler.h
deleted file mode 100644
index e414dff6..00000000
--- a/drivers/gpu/arm/mali/common/mali_pp_scheduler.h
+++ /dev/null
@@ -1,130 +0,0 @@
-/*
- * Copyright (C) 2012-2013 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#ifndef __MALI_PP_SCHEDULER_H__
-#define __MALI_PP_SCHEDULER_H__
-
-#include "mali_osk.h"
-#include "mali_pp_job.h"
-#include "mali_group.h"
-#include "linux/mali/mali_utgard.h"
-
-/** Initalize the HW independent parts of the  PP scheduler
- */
-_mali_osk_errcode_t mali_pp_scheduler_initialize(void);
-void mali_pp_scheduler_terminate(void);
-
-/** Poplulate the PP scheduler with groups
- */
-void mali_pp_scheduler_populate(void);
-void mali_pp_scheduler_depopulate(void);
-
-/**
- * @brief Handle job completion.
- *
- * Will attempt to start a new job on the locked group.
- *
- * If all sub jobs have completed the job's tracker will be released, any other resources associated
- * with the job will be freed.  A notification will also be sent to user space.
- *
- * Releasing the tracker might activate other jobs, so if appropriate we also schedule them.
- *
- * @note Group must be locked when entering this function.  Will be unlocked before exiting.
- *
- * @param group The group that completed the job.
- * @param job The job that is done.
- * @param sub_job Sub job of job.
- * @param success MALI_TRUE if job completed successfully, MALI_FALSE if not.
- * @param in_upper_half MALI_TRUE if called from upper half, MALI_FALSE if not.
- */
-void mali_pp_scheduler_job_done(struct mali_group *group, struct mali_pp_job *job, u32 sub_job, mali_bool success, mali_bool in_upper_half);
-
-void mali_pp_scheduler_suspend(void);
-void mali_pp_scheduler_resume(void);
-
-/**
- * @brief Abort all running and queued PP jobs from session.
- *
- * This functions aborts all PP jobs from the specified session. Queued jobs are removed from the
- * queue and jobs currently running on a core will be aborted.
- *
- * @param session Session that is aborting.
- */
-void mali_pp_scheduler_abort_session(struct mali_session_data *session);
-
-/**
- * @brief Reset all groups
- *
- * This function resets all groups known by the PP scheuduler. This must be
- * called after the Mali HW has been powered on in order to reset the HW.
- *
- * This function is intended for power on reset of all cores.
- * No locking is done, which can only be safe if the scheduler is paused and
- * all cores idle. That is always the case on init and power on.
- */
-void mali_pp_scheduler_reset_all_groups(void);
-
-/**
- * @brief Zap TLB on all groups with \a session active
- *
- * The scheculer will zap the session on all groups it owns.
- */
-void mali_pp_scheduler_zap_all_active(struct mali_session_data *session);
-
-/**
- * @brief Get the virtual PP core
- *
- * The returned PP core may only be used to prepare DMA command buffers for the
- * PP core. Other actions must go through the PP scheduler, or the virtual
- * group.
- *
- * @return Pointer to the virtual PP core, NULL if this doesn't exist
- */
-struct mali_pp_core *mali_pp_scheduler_get_virtual_pp(void);
-
-u32 mali_pp_scheduler_dump_state(char *buf, u32 size);
-
-void mali_pp_scheduler_enable_group(struct mali_group *group);
-void mali_pp_scheduler_disable_group(struct mali_group *group);
-
-/**
- * @brief Used by the Timeline system to queue a PP job.
- *
- * @note @ref mali_scheduler_schedule_from_mask() should be called if this function returns non-zero.
- *
- * @param job The PP job that is being activated.
- *
- * @return A scheduling bitmask that can be used to decide if scheduling is necessary after this
- * call.
- */
-mali_scheduler_mask mali_pp_scheduler_activate_job(struct mali_pp_job *job);
-
-/**
- * @brief Schedule queued jobs on idle cores.
- */
-void mali_pp_scheduler_schedule(void);
-
-int mali_pp_scheduler_set_perf_level(u32 cores, mali_bool override);
-
-void mali_pp_scheduler_core_scaling_enable(void);
-void mali_pp_scheduler_core_scaling_disable(void);
-mali_bool mali_pp_scheduler_core_scaling_is_enabled(void);
-
-u32 mali_pp_scheduler_get_num_cores_total(void);
-u32 mali_pp_scheduler_get_num_cores_enabled(void);
-
-/**
- * @brief Returns the number of Pixel Processors in the system irrespective of the context
- *
- * @return number of physical Pixel Processor cores in the system
- */
-u32 mali_pp_scheduler_get_num_cores_total(void);
-
-#endif /* __MALI_PP_SCHEDULER_H__ */
diff --git a/drivers/gpu/arm/mali/common/mali_scheduler.c b/drivers/gpu/arm/mali/common/mali_scheduler.c
old mode 100755
new mode 100644
index 677d8ee1..55c7bafe
--- a/drivers/gpu/arm/mali/common/mali_scheduler.c
+++ b/drivers/gpu/arm/mali/common/mali_scheduler.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -18,16 +18,9 @@
 #include "mali_pp_job.h"
 #include "mali_executor.h"
 #include "mali_group.h"
-#include <linux/wait.h>
-#include <linux/sched.h>
-#include "mali_pm_metrics.h"
 
 #if defined(CONFIG_DMA_SHARED_BUFFER)
 #include "mali_memory_dma_buf.h"
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-#include "mali_dma_fence.h"
-#include <linux/dma-buf.h>
-#endif
 #endif
 
 #if defined(CONFIG_GPU_TRACEPOINTS) && defined(CONFIG_TRACEPOINTS)
@@ -39,16 +32,16 @@
  */
 
 /*
- * If dma_buf with map on demand is used, we defer job queue
+ * If dma_buf with map on demand is used, we defer job deletion and job queue
  * if in atomic context, since both might sleep.
  */
 #if defined(CONFIG_DMA_SHARED_BUFFER)
 #if !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
+#define MALI_SCHEDULER_USE_DEFERRED_PP_JOB_DELETE 1
 #define MALI_SCHEDULER_USE_DEFERRED_PP_JOB_QUEUE 1
 #endif
 #endif
 
-
 /*
  * ---------- global variables (exported due to inline functions) ----------
  */
@@ -68,9 +61,11 @@ _mali_osk_atomic_t mali_job_cache_order_autonumber;
  * ---------- static variables ----------
  */
 
-_mali_osk_wq_work_t *scheduler_wq_pp_job_delete = NULL;
-_mali_osk_spinlock_irq_t *scheduler_pp_job_delete_lock = NULL;
+#if defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_DELETE)
+static _mali_osk_wq_work_t *scheduler_wq_pp_job_delete = NULL;
+static _mali_osk_spinlock_irq_t *scheduler_pp_job_delete_lock = NULL;
 static _MALI_OSK_LIST_HEAD_STATIC_INIT(scheduler_pp_job_deletion_queue);
+#endif
 
 #if defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_QUEUE)
 static _mali_osk_wq_work_t *scheduler_wq_pp_job_queue = NULL;
@@ -84,17 +79,21 @@ static _MALI_OSK_LIST_HEAD_STATIC_INIT(scheduler_pp_job_queue_list);
 
 static mali_timeline_point mali_scheduler_submit_gp_job(
 	struct mali_session_data *session, struct mali_gp_job *job);
-static _mali_osk_errcode_t mali_scheduler_submit_pp_job(
-	struct mali_session_data *session, struct mali_pp_job *job, mali_timeline_point *point);
+static mali_timeline_point mali_scheduler_submit_pp_job(
+	struct mali_session_data *session, struct mali_pp_job *job);
 
 static mali_bool mali_scheduler_queue_gp_job(struct mali_gp_job *job);
 static mali_bool mali_scheduler_queue_pp_job(struct mali_pp_job *job);
 
 static void mali_scheduler_return_gp_job_to_user(struct mali_gp_job *job,
 		mali_bool success);
+static void mali_scheduler_return_pp_job_to_user(struct mali_pp_job *job,
+		u32 num_cores_in_virtual);
 
+#if defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_DELETE)
 static void mali_scheduler_deferred_pp_job_delete(struct mali_pp_job *job);
-void mali_scheduler_do_pp_job_delete(void *arg);
+static void mali_scheduler_do_pp_job_delete(void *arg);
+#endif /* defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_DELETE) */
 
 #if defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_QUEUE)
 static void mali_scheduler_deferred_pp_job_queue(struct mali_pp_job *job);
@@ -113,12 +112,10 @@ _mali_osk_errcode_t mali_scheduler_initialize(void)
 	_MALI_OSK_INIT_LIST_HEAD(&job_queue_gp.normal_pri);
 	_MALI_OSK_INIT_LIST_HEAD(&job_queue_gp.high_pri);
 	job_queue_gp.depth = 0;
-	job_queue_gp.big_job_num = 0;
 
 	_MALI_OSK_INIT_LIST_HEAD(&job_queue_pp.normal_pri);
 	_MALI_OSK_INIT_LIST_HEAD(&job_queue_pp.high_pri);
 	job_queue_pp.depth = 0;
-	job_queue_pp.big_job_num = 0;
 
 	mali_scheduler_lock_obj = _mali_osk_spinlock_irq_init(
 					  _MALI_OSK_LOCKFLAG_ORDERED,
@@ -127,6 +124,7 @@ _mali_osk_errcode_t mali_scheduler_initialize(void)
 		mali_scheduler_terminate();
 	}
 
+#if defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_DELETE)
 	scheduler_wq_pp_job_delete = _mali_osk_wq_create_work(
 					     mali_scheduler_do_pp_job_delete, NULL);
 	if (NULL == scheduler_wq_pp_job_delete) {
@@ -141,6 +139,7 @@ _mali_osk_errcode_t mali_scheduler_initialize(void)
 		mali_scheduler_terminate();
 		return _MALI_OSK_ERR_FAULT;
 	}
+#endif /* defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_DELETE) */
 
 #if defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_QUEUE)
 	scheduler_wq_pp_job_queue = _mali_osk_wq_create_work(
@@ -176,6 +175,7 @@ void mali_scheduler_terminate(void)
 	}
 #endif /* defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_QUEUE) */
 
+#if defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_DELETE)
 	if (NULL != scheduler_pp_job_delete_lock) {
 		_mali_osk_spinlock_irq_term(scheduler_pp_job_delete_lock);
 		scheduler_pp_job_delete_lock = NULL;
@@ -185,6 +185,7 @@ void mali_scheduler_terminate(void)
 		_mali_osk_wq_delete_work(scheduler_wq_pp_job_delete);
 		scheduler_wq_pp_job_delete = NULL;
 	}
+#endif /* defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_DELETE) */
 
 	if (NULL != mali_scheduler_lock_obj) {
 		_mali_osk_spinlock_irq_term(mali_scheduler_lock_obj);
@@ -195,7 +196,7 @@ void mali_scheduler_terminate(void)
 	_mali_osk_atomic_term(&mali_job_id_autonumber);
 }
 
-u32 mali_scheduler_job_physical_head_count(mali_bool gpu_mode_is_secure)
+u32 mali_scheduler_job_physical_head_count(void)
 {
 	/*
 	 * Count how many physical sub jobs are present from the head of queue
@@ -220,23 +221,16 @@ u32 mali_scheduler_job_physical_head_count(mali_bool gpu_mode_is_secure)
 			 * Remember; virtual jobs can't be queued and started
 			 * at the same time, so this must be a physical job
 			 */
-			if ((MALI_FALSE  == gpu_mode_is_secure && MALI_FALSE == mali_pp_job_is_protected_job(job))
-			    || (MALI_TRUE  == gpu_mode_is_secure && MALI_TRUE == mali_pp_job_is_protected_job(job))) {
-
-				count += mali_pp_job_unstarted_sub_job_count(job);
-				if (MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS <= count) {
-					return MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS;
-				}
+			count += mali_pp_job_unstarted_sub_job_count(job);
+			if (MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS <= count) {
+				return MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS;
 			}
 		}
 	}
 
 	_MALI_OSK_LIST_FOREACHENTRY(job, temp, &job_queue_pp.high_pri,
 				    struct mali_pp_job, list) {
-		if ((MALI_FALSE == mali_pp_job_is_virtual(job))
-		    && ((MALI_FALSE  == gpu_mode_is_secure && MALI_FALSE == mali_pp_job_is_protected_job(job))
-			|| (MALI_TRUE  == gpu_mode_is_secure && MALI_TRUE == mali_pp_job_is_protected_job(job)))) {
-
+		if (MALI_FALSE == mali_pp_job_is_virtual(job)) {
 			count += mali_pp_job_unstarted_sub_job_count(job);
 			if (MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS <= count) {
 				return MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS;
@@ -249,55 +243,22 @@ u32 mali_scheduler_job_physical_head_count(mali_bool gpu_mode_is_secure)
 
 	_MALI_OSK_LIST_FOREACHENTRY(job, temp, &job_queue_pp.normal_pri,
 				    struct mali_pp_job, list) {
-		if ((MALI_FALSE == mali_pp_job_is_virtual(job))
-		    && (MALI_FALSE == mali_pp_job_has_started_sub_jobs(job))
-		    && ((MALI_FALSE  == gpu_mode_is_secure && MALI_FALSE == mali_pp_job_is_protected_job(job))
-			|| (MALI_TRUE  == gpu_mode_is_secure && MALI_TRUE == mali_pp_job_is_protected_job(job)))) {
-
-			count += mali_pp_job_unstarted_sub_job_count(job);
-			if (MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS <= count) {
-				return MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS;
+		if (MALI_FALSE == mali_pp_job_is_virtual(job)) {
+			/* any partially started is already counted */
+			if (MALI_FALSE == mali_pp_job_has_started_sub_jobs(job)) {
+				count += mali_pp_job_unstarted_sub_job_count(job);
+				if (MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS <=
+				    count) {
+					return MALI_MAX_NUMBER_OF_PHYSICAL_PP_GROUPS;
+				}
 			}
 		} else {
 			/* Came across a virtual job, so stop counting */
 			return count;
 		}
 	}
-	return count;
-}
-
-struct mali_pp_job *mali_scheduler_job_pp_next(void)
-{
-	struct mali_pp_job *job;
-	struct mali_pp_job *temp;
-
-	MALI_DEBUG_ASSERT_LOCK_HELD(mali_scheduler_lock_obj);
-
-	/* Check for partially started normal pri jobs */
-	if (!_mali_osk_list_empty(&job_queue_pp.normal_pri)) {
-		MALI_DEBUG_ASSERT(0 < job_queue_pp.depth);
-
-		job = _MALI_OSK_LIST_ENTRY(job_queue_pp.normal_pri.next,
-					   struct mali_pp_job, list);
-
-		MALI_DEBUG_ASSERT_POINTER(job);
-
-		if (MALI_TRUE == mali_pp_job_has_started_sub_jobs(job)) {
-			return job;
-		}
-	}
 
-	_MALI_OSK_LIST_FOREACHENTRY(job, temp, &job_queue_pp.high_pri,
-				    struct mali_pp_job, list) {
-		return job;
-	}
-
-	_MALI_OSK_LIST_FOREACHENTRY(job, temp, &job_queue_pp.normal_pri,
-				    struct mali_pp_job, list) {
-		return job;
-	}
-
-	return NULL;
+	return count;
 }
 
 mali_bool mali_scheduler_job_next_is_virtual(void)
@@ -321,7 +282,6 @@ struct mali_gp_job *mali_scheduler_job_gp_get(void)
 
 	MALI_DEBUG_ASSERT_LOCK_HELD(mali_scheduler_lock_obj);
 	MALI_DEBUG_ASSERT(0 < job_queue_gp.depth);
-	MALI_DEBUG_ASSERT(job_queue_gp.big_job_num <= job_queue_gp.depth);
 
 	if (!_mali_osk_list_empty(&job_queue_gp.high_pri)) {
 		queue = &job_queue_gp.high_pri;
@@ -336,14 +296,7 @@ struct mali_gp_job *mali_scheduler_job_gp_get(void)
 
 	mali_gp_job_list_remove(job);
 	job_queue_gp.depth--;
-	if (job->big_job) {
-		job_queue_gp.big_job_num --;
-		if (job_queue_gp.big_job_num < MALI_MAX_PENDING_BIG_JOB) {
-			/* wake up process */
-			wait_queue_head_t *queue = mali_session_get_wait_queue();
-			wake_up(queue);
-		}
-	}
+
 	return job;
 }
 
@@ -578,7 +531,6 @@ void mali_scheduler_complete_gp_job(struct mali_gp_job *job,
 		if (mali_utilization_enabled()) {
 			mali_utilization_gp_end();
 		}
-		mali_pm_record_gpu_idle(MALI_TRUE);
 	}
 
 	mali_gp_job_delete(job);
@@ -589,13 +541,10 @@ void mali_scheduler_complete_pp_job(struct mali_pp_job *job,
 				    mali_bool user_notification,
 				    mali_bool dequeued)
 {
-	job->user_notification = user_notification;
-	job->num_pp_cores_in_virtual = num_cores_in_virtual;
-
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-	if (NULL != job->rendered_dma_fence)
-		mali_dma_fence_signal_and_put(&job->rendered_dma_fence);
-#endif
+	if (user_notification) {
+		mali_scheduler_return_pp_job_to_user(job,
+						     num_cores_in_virtual);
+	}
 
 	if (dequeued) {
 #if defined(CONFIG_MALI_DVFS)
@@ -605,16 +554,24 @@ void mali_scheduler_complete_pp_job(struct mali_pp_job *job,
 			mali_session_inc_num_window_jobs(session);
 		}
 #endif
+
 		_mali_osk_pm_dev_ref_put();
 
 		if (mali_utilization_enabled()) {
 			mali_utilization_pp_end();
 		}
-		mali_pm_record_gpu_idle(MALI_FALSE);
 	}
 
-	/* With ZRAM feature enabled, all pp jobs will be force to use deferred delete. */
+#if defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_DELETE)
+	/*
+	 * The deletion of the job object (releasing sync refs etc)
+	 * must be done in a different context
+	 */
 	mali_scheduler_deferred_pp_job_delete(job);
+#else
+	/* no use cases need this in this configuration */
+	mali_pp_job_delete(job);
+#endif
 }
 
 void mali_scheduler_abort_session(struct mali_session_data *session)
@@ -640,7 +597,6 @@ void mali_scheduler_abort_session(struct mali_session_data *session)
 		if (mali_gp_job_get_session(gp_job) == session) {
 			mali_gp_job_list_move(gp_job, &removed_jobs_gp);
 			job_queue_gp.depth--;
-			job_queue_gp.big_job_num -= gp_job->big_job ? 1 : 0;
 		}
 	}
 
@@ -650,7 +606,6 @@ void mali_scheduler_abort_session(struct mali_session_data *session)
 		if (mali_gp_job_get_session(gp_job) == session) {
 			mali_gp_job_list_move(gp_job, &removed_jobs_gp);
 			job_queue_gp.depth--;
-			job_queue_gp.big_job_num -= gp_job->big_job ? 1 : 0;
 		}
 	}
 
@@ -666,13 +621,9 @@ void mali_scheduler_abort_session(struct mali_session_data *session)
 					pp_job);
 			mali_pp_job_mark_unstarted_failed(pp_job);
 
-			if (MALI_FALSE == mali_pp_job_has_unstarted_sub_jobs(pp_job)) {
-				if (mali_pp_job_is_complete(pp_job)) {
-					mali_pp_job_list_move(pp_job,
-							      &removed_jobs_pp);
-				} else {
-					mali_pp_job_list_remove(pp_job);
-				}
+			if (mali_pp_job_is_complete(pp_job)) {
+				mali_pp_job_list_move(pp_job,
+						      &removed_jobs_pp);
 			}
 		}
 	}
@@ -689,13 +640,9 @@ void mali_scheduler_abort_session(struct mali_session_data *session)
 					pp_job);
 			mali_pp_job_mark_unstarted_failed(pp_job);
 
-			if (MALI_FALSE == mali_pp_job_has_unstarted_sub_jobs(pp_job)) {
-				if (mali_pp_job_is_complete(pp_job)) {
-					mali_pp_job_list_move(pp_job,
-							      &removed_jobs_pp);
-				} else {
-					mali_pp_job_list_remove(pp_job);
-				}
+			if (mali_pp_job_is_complete(pp_job)) {
+				mali_pp_job_list_move(pp_job,
+						      &removed_jobs_pp);
 			}
 		}
 	}
@@ -764,7 +711,6 @@ _mali_osk_errcode_t _mali_ukk_gp_start_job(void *ctx,
 _mali_osk_errcode_t _mali_ukk_pp_start_job(void *ctx,
 		_mali_uk_pp_start_job_s *uargs)
 {
-	_mali_osk_errcode_t ret;
 	struct mali_session_data *session;
 	struct mali_pp_job *job;
 	mali_timeline_point point;
@@ -783,27 +729,23 @@ _mali_osk_errcode_t _mali_ukk_pp_start_job(void *ctx,
 
 	point_ptr = (u32 __user *)(uintptr_t)mali_pp_job_get_timeline_point_ptr(job);
 
-	/* Submit PP job. */
-	ret = mali_scheduler_submit_pp_job(session, job, &point);
+	point = mali_scheduler_submit_pp_job(session, job);
 	job = NULL;
 
-	if (_MALI_OSK_ERR_OK == ret) {
-		if (0 != _mali_osk_put_user(((u32) point), point_ptr)) {
-			/*
-			* Let user space know that something failed
-			* after the jobs were started.
-			*/
-			return _MALI_OSK_ERR_ITEM_NOT_FOUND;
-		}
+	if (0 != _mali_osk_put_user(((u32) point), point_ptr)) {
+		/*
+		 * Let user space know that something failed
+		 * after the job was started.
+		 */
+		return _MALI_OSK_ERR_ITEM_NOT_FOUND;
 	}
 
-	return ret;
+	return _MALI_OSK_ERR_OK;
 }
 
 _mali_osk_errcode_t _mali_ukk_pp_and_gp_start_job(void *ctx,
 		_mali_uk_pp_and_gp_start_job_s *uargs)
 {
-	_mali_osk_errcode_t ret;
 	struct mali_session_data *session;
 	_mali_uk_pp_and_gp_start_job_s kargs;
 	struct mali_pp_job *pp_job;
@@ -849,20 +791,18 @@ _mali_osk_errcode_t _mali_ukk_pp_and_gp_start_job(void *ctx,
 	gp_job = NULL;
 
 	/* Submit PP job. */
-	ret = mali_scheduler_submit_pp_job(session, pp_job, &point);
+	point = mali_scheduler_submit_pp_job(session, pp_job);
 	pp_job = NULL;
 
-	if (_MALI_OSK_ERR_OK == ret) {
-		if (0 != _mali_osk_put_user(((u32) point), point_ptr)) {
-			/*
-			* Let user space know that something failed
-			* after the jobs were started.
-			*/
-			return _MALI_OSK_ERR_ITEM_NOT_FOUND;
-		}
+	if (0 != _mali_osk_put_user(((u32) point), point_ptr)) {
+		/*
+		 * Let user space know that something failed
+		 * after the jobs were started.
+		 */
+		return _MALI_OSK_ERR_ITEM_NOT_FOUND;
 	}
 
-	return ret;
+	return _MALI_OSK_ERR_OK;
 }
 
 void _mali_ukk_pp_job_disable_wb(_mali_uk_pp_disable_wb_s *args)
@@ -971,19 +911,10 @@ static mali_timeline_point mali_scheduler_submit_gp_job(
 	return point;
 }
 
-static _mali_osk_errcode_t mali_scheduler_submit_pp_job(
-	struct mali_session_data *session, struct mali_pp_job *job, mali_timeline_point *point)
-
+static mali_timeline_point mali_scheduler_submit_pp_job(
+	struct mali_session_data *session, struct mali_pp_job *job)
 {
-	_mali_osk_errcode_t ret = _MALI_OSK_ERR_OK;
-
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-	struct ww_acquire_ctx ww_actx;
-	u32 i;
-	u32 num_memory_cookies = 0;
-	struct reservation_object **reservation_object_list = NULL;
-	unsigned int num_reservation_object = 0;
-#endif
+	mali_timeline_point point;
 
 	MALI_DEBUG_ASSERT_POINTER(session);
 	MALI_DEBUG_ASSERT_POINTER(job);
@@ -996,132 +927,11 @@ static _mali_osk_errcode_t mali_scheduler_submit_pp_job(
 	mali_pp_job_fb_lookup_add(job);
 	mali_scheduler_unlock();
 
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-
-	/* Allocate the reservation_object_list to list the dma reservation object of dependent dma buffer */
-	num_memory_cookies = mali_pp_job_num_memory_cookies(job);
-	if (0 < num_memory_cookies) {
-		reservation_object_list = kzalloc(sizeof(struct reservation_object *) * num_memory_cookies, GFP_KERNEL);
-		if (NULL == reservation_object_list) {
-			MALI_PRINT_ERROR(("Failed to alloc the reservation object list.\n"));
-			ret = _MALI_OSK_ERR_NOMEM;
-			goto failed_to_alloc_reservation_object_list;
-		}
-	}
-
-	/* Add the dma reservation object into reservation_object_list*/
-	for (i = 0; i < num_memory_cookies; i++) {
-		mali_mem_backend *mem_backend = NULL;
-		struct reservation_object *tmp_reservation_object = NULL;
-		u32 mali_addr  = mali_pp_job_get_memory_cookie(job, i);
-
-		mem_backend = mali_mem_backend_struct_search(session, mali_addr);
-
-		MALI_DEBUG_ASSERT_POINTER(mem_backend);
-
-		if (NULL == mem_backend) {
-			MALI_PRINT_ERROR(("Failed to find the memory backend for memory cookie[%d].\n", i));
-			goto failed_to_find_mem_backend;
-		}
-
-		if (MALI_MEM_DMA_BUF != mem_backend->type)
-			continue;
-
-		tmp_reservation_object = mem_backend->dma_buf.attachment->buf->resv;
-
-		if (NULL != tmp_reservation_object) {
-			mali_dma_fence_add_reservation_object_list(tmp_reservation_object,
-					reservation_object_list, &num_reservation_object);
-		}
-	}
-
-	/*
-	 * Add the mali dma fence callback to wait for all dependent dma buf,
-	 * and extend the timeline system to support dma fence,
-	 * then create the new internal dma fence to replace all last dma fence for dependent dma buf.
-	 */
-	if (0 < num_reservation_object) {
-		int error;
-		int num_dma_fence_waiter = 0;
-		/* Create one new dma fence.*/
-		job->rendered_dma_fence = mali_dma_fence_new(job->session->fence_context,
-					  _mali_osk_atomic_inc_return(&job->session->fence_seqno));
-
-		if (NULL == job->rendered_dma_fence) {
-			MALI_PRINT_ERROR(("Failed to creat one new dma fence.\n"));
-			ret = _MALI_OSK_ERR_FAULT;
-			goto failed_to_create_dma_fence;
-		}
-
-		/* In order to avoid deadlock, wait/wound mutex lock to lock all dma buffers*/
-
-		error = mali_dma_fence_lock_reservation_object_list(reservation_object_list,
-				num_reservation_object, &ww_actx);
-
-		if (0 != error) {
-			MALI_PRINT_ERROR(("Failed to lock all reservation objects.\n"));
-			ret = _MALI_OSK_ERR_FAULT;
-			goto failed_to_lock_reservation_object_list;
-		}
-
-		mali_dma_fence_context_init(&job->dma_fence_context,
-					    mali_timeline_dma_fence_callback, (void *)job);
-
-		/* Add dma fence waiters and dma fence callback. */
-		for (i = 0; i < num_reservation_object; i++) {
-			ret = mali_dma_fence_context_add_waiters(&job->dma_fence_context, reservation_object_list[i]);
-			if (_MALI_OSK_ERR_OK != ret) {
-				MALI_PRINT_ERROR(("Failed to add waiter into mali dma fence context.\n"));
-				goto failed_to_add_dma_fence_waiter;
-			}
-		}
-
-		for (i = 0; i < num_reservation_object; i++) {
-			reservation_object_add_excl_fence(reservation_object_list[i], job->rendered_dma_fence);
-		}
-
-		num_dma_fence_waiter = job->dma_fence_context.num_dma_fence_waiter;
-
-		/* Add job to Timeline system. */
-		(*point) = mali_timeline_system_add_tracker(session->timeline_system,
-				mali_pp_job_get_tracker(job), MALI_TIMELINE_PP);
-
-		if (0 != num_dma_fence_waiter) {
-			mali_dma_fence_context_dec_count(&job->dma_fence_context);
-		}
-
-		/* Unlock all wait/wound mutex lock. */
-		mali_dma_fence_unlock_reservation_object_list(reservation_object_list,
-				num_reservation_object, &ww_actx);
-	} else {
-		/* Add job to Timeline system. */
-		(*point) = mali_timeline_system_add_tracker(session->timeline_system,
-				mali_pp_job_get_tracker(job), MALI_TIMELINE_PP);
-	}
-
-	kfree(reservation_object_list);
-	return ret;
-#else
 	/* Add job to Timeline system. */
-	(*point) = mali_timeline_system_add_tracker(session->timeline_system,
+	point = mali_timeline_system_add_tracker(session->timeline_system,
 			mali_pp_job_get_tracker(job), MALI_TIMELINE_PP);
-#endif
 
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-failed_to_add_dma_fence_waiter:
-	mali_dma_fence_context_term(&job->dma_fence_context);
-	mali_dma_fence_unlock_reservation_object_list(reservation_object_list,
-			num_reservation_object, &ww_actx);
-failed_to_lock_reservation_object_list:
-	mali_dma_fence_signal_and_put(&job->rendered_dma_fence);
-failed_to_create_dma_fence:
-failed_to_find_mem_backend:
-	if (NULL != reservation_object_list)
-		kfree(reservation_object_list);
-failed_to_alloc_reservation_object_list:
-	mali_pp_job_fb_lookup_remove(job);
-#endif
-	return ret;
+	return point;
 }
 
 static mali_bool mali_scheduler_queue_gp_job(struct mali_gp_job *job)
@@ -1151,7 +961,6 @@ static mali_bool mali_scheduler_queue_gp_job(struct mali_gp_job *job)
 	}
 
 	job_queue_gp.depth += 1;
-	job_queue_gp.big_job_num += (job->big_job) ? 1 : 0;
 
 	/* Add job to queue (mali_gp_job_queue_add find correct place). */
 	mali_gp_job_list_add(job, queue);
@@ -1174,8 +983,6 @@ static mali_bool mali_scheduler_queue_gp_job(struct mali_gp_job *job)
 		mali_utilization_gp_start();
 	}
 
-	mali_pm_record_gpu_active(MALI_TRUE);
-
 	/* Add profiling events for job enqueued */
 	_mali_osk_profiling_add_event(
 		MALI_PROFILING_EVENT_TYPE_SINGLE |
@@ -1213,10 +1020,6 @@ static mali_bool mali_scheduler_queue_pp_job(struct mali_pp_job *job)
 		MALI_DEBUG_PRINT(2, ("Mali PP scheduler: Job %u (0x%08X) queued while session is aborting.\n",
 				     mali_pp_job_get_id(job), job));
 		return MALI_FALSE; /* job not queued */
-	} else if (unlikely(MALI_SWAP_IN_FAIL == job->swap_status)) {
-		MALI_DEBUG_PRINT(2, ("Mali PP scheduler: Job %u (0x%08X) queued while swap in failed.\n",
-				     mali_pp_job_get_id(job), job));
-		return MALI_FALSE;
 	}
 
 	mali_pp_job_set_cache_order(job, mali_scheduler_get_new_cache_order());
@@ -1251,9 +1054,8 @@ static mali_bool mali_scheduler_queue_pp_job(struct mali_pp_job *job)
 		mali_utilization_pp_start();
 	}
 
-	mali_pm_record_gpu_active(MALI_FALSE);
-
 	/* Add profiling events for job enqueued */
+
 	_mali_osk_profiling_add_event(
 		MALI_PROFILING_EVENT_TYPE_SINGLE |
 		MALI_PROFILING_EVENT_CHANNEL_SOFTWARE |
@@ -1296,8 +1098,6 @@ static void mali_scheduler_return_gp_job_to_user(struct mali_gp_job *job,
 	jobres = notification->result_buffer;
 	MALI_DEBUG_ASSERT_POINTER(jobres);
 
-	jobres->pending_big_job_num = mali_scheduler_job_gp_big_job_count();
-
 	jobres->user_job_ptr = mali_gp_job_get_user_id(job);
 	if (MALI_TRUE == success) {
 		jobres->status = _MALI_UK_JOB_STATUS_END_SUCCESS;
@@ -1311,7 +1111,7 @@ static void mali_scheduler_return_gp_job_to_user(struct mali_gp_job *job,
 	mali_session_send_notification(session, notification);
 }
 
-void mali_scheduler_return_pp_job_to_user(struct mali_pp_job *job,
+static void mali_scheduler_return_pp_job_to_user(struct mali_pp_job *job,
 		u32 num_cores_in_virtual)
 {
 	u32 i;
@@ -1362,6 +1162,8 @@ void mali_scheduler_return_pp_job_to_user(struct mali_pp_job *job,
 	mali_session_send_notification(session, notification);
 }
 
+#if defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_DELETE)
+
 static void mali_scheduler_deferred_pp_job_delete(struct mali_pp_job *job)
 {
 	MALI_DEBUG_ASSERT_POINTER(job);
@@ -1373,7 +1175,7 @@ static void mali_scheduler_deferred_pp_job_delete(struct mali_pp_job *job)
 	_mali_osk_wq_schedule_work(scheduler_wq_pp_job_delete);
 }
 
-void mali_scheduler_do_pp_job_delete(void *arg)
+static void mali_scheduler_do_pp_job_delete(void *arg)
 {
 	_MALI_OSK_LIST_HEAD_STATIC_INIT(list);
 	struct mali_pp_job *job;
@@ -1392,16 +1194,14 @@ void mali_scheduler_do_pp_job_delete(void *arg)
 
 	_MALI_OSK_LIST_FOREACHENTRY(job, tmp, &list,
 				    struct mali_pp_job, list) {
-		_mali_osk_list_delinit(&job->list);
-
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-		mali_dma_fence_context_term(&job->dma_fence_context);
-#endif
 
+		_mali_osk_list_delinit(&job->list);
 		mali_pp_job_delete(job); /* delete the job object itself */
 	}
 }
 
+#endif /* defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_DELETE) */
+
 #if defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_QUEUE)
 
 static void mali_scheduler_deferred_pp_job_queue(struct mali_pp_job *job)
@@ -1484,65 +1284,3 @@ static void mali_scheduler_do_pp_job_queue(void *arg)
 }
 
 #endif /* defined(MALI_SCHEDULER_USE_DEFERRED_PP_JOB_QUEUE) */
-
-void mali_scheduler_gp_pp_job_queue_print(void)
-{
-	struct mali_gp_job *gp_job = NULL;
-	struct mali_gp_job *tmp_gp_job = NULL;
-	struct mali_pp_job *pp_job = NULL;
-	struct mali_pp_job *tmp_pp_job = NULL;
-
-	MALI_DEBUG_ASSERT_LOCK_HELD(mali_scheduler_lock_obj);
-	MALI_DEBUG_ASSERT_LOCK_HELD(mali_executor_lock_obj);
-
-	/* dump job queup status */
-	if ((0 == job_queue_gp.depth) && (0 == job_queue_pp.depth)) {
-		MALI_PRINT(("No GP&PP job in the job queue.\n"));
-		return;
-	}
-
-	MALI_PRINT(("Total (%d) GP job in the job queue.\n", job_queue_gp.depth));
-	if (job_queue_gp.depth > 0) {
-		if (!_mali_osk_list_empty(&job_queue_gp.high_pri)) {
-			_MALI_OSK_LIST_FOREACHENTRY(gp_job, tmp_gp_job, &job_queue_gp.high_pri,
-						    struct mali_gp_job, list) {
-				MALI_PRINT(("GP job(%p) id = %d tid = %d pid = %d in the gp job high_pri queue\n", gp_job, gp_job->id, gp_job->tid, gp_job->pid));
-			}
-		}
-
-		if (!_mali_osk_list_empty(&job_queue_gp.normal_pri)) {
-			_MALI_OSK_LIST_FOREACHENTRY(gp_job, tmp_gp_job, &job_queue_gp.normal_pri,
-						    struct mali_gp_job, list) {
-				MALI_PRINT(("GP job(%p) id = %d tid = %d pid = %d in the gp job normal_pri queue\n", gp_job, gp_job->id, gp_job->tid, gp_job->pid));
-			}
-		}
-	}
-
-	MALI_PRINT(("Total (%d) PP job in the job queue.\n", job_queue_pp.depth));
-	if (job_queue_pp.depth > 0) {
-		if (!_mali_osk_list_empty(&job_queue_pp.high_pri)) {
-			_MALI_OSK_LIST_FOREACHENTRY(pp_job, tmp_pp_job, &job_queue_pp.high_pri,
-						    struct mali_pp_job, list) {
-				if (mali_pp_job_is_virtual(pp_job)) {
-					MALI_PRINT(("PP Virtual job(%p) id = %d tid = %d pid = %d in the pp job high_pri queue\n", pp_job, pp_job->id, pp_job->tid, pp_job->pid));
-				} else {
-					MALI_PRINT(("PP Physical job(%p) id = %d tid = %d pid = %d in the pp job high_pri queue\n", pp_job, pp_job->id, pp_job->tid, pp_job->pid));
-				}
-			}
-		}
-
-		if (!_mali_osk_list_empty(&job_queue_pp.normal_pri)) {
-			_MALI_OSK_LIST_FOREACHENTRY(pp_job, tmp_pp_job, &job_queue_pp.normal_pri,
-						    struct mali_pp_job, list) {
-				if (mali_pp_job_is_virtual(pp_job)) {
-					MALI_PRINT(("PP Virtual job(%p) id = %d tid = %d pid = %d in the pp job normal_pri queue\n", pp_job, pp_job->id, pp_job->tid, pp_job->pid));
-				} else {
-					MALI_PRINT(("PP Physical job(%p) id = %d tid = %d pid = %d in the pp job normal_pri queue\n", pp_job, pp_job->id, pp_job->tid, pp_job->pid));
-				}
-			}
-		}
-	}
-
-	/* dump group running job status */
-	mali_executor_running_status_print();
-}
diff --git a/drivers/gpu/arm/mali/common/mali_scheduler.h b/drivers/gpu/arm/mali/common/mali_scheduler.h
old mode 100755
new mode 100644
index 8a7ebc9f..181ba763
--- a/drivers/gpu/arm/mali/common/mali_scheduler.h
+++ b/drivers/gpu/arm/mali/common/mali_scheduler.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -20,7 +20,6 @@ struct mali_scheduler_job_queue {
 	_MALI_OSK_LIST_HEAD(normal_pri); /* Queued jobs with normal priority */
 	_MALI_OSK_LIST_HEAD(high_pri);   /* Queued jobs with high priority */
 	u32 depth;                       /* Depth of combined queues. */
-	u32 big_job_num;
 };
 
 extern _mali_osk_spinlock_irq_t *mali_scheduler_lock_obj;
@@ -55,15 +54,10 @@ MALI_STATIC_INLINE u32 mali_scheduler_job_gp_count(void)
 {
 	return job_queue_gp.depth;
 }
-MALI_STATIC_INLINE u32 mali_scheduler_job_gp_big_job_count(void)
-{
-	return job_queue_gp.big_job_num;
-}
 
-u32 mali_scheduler_job_physical_head_count(mali_bool gpu_mode_is_secure);
+u32 mali_scheduler_job_physical_head_count(void);
 
 mali_bool mali_scheduler_job_next_is_virtual(void);
-struct mali_pp_job *mali_scheduler_job_pp_next(void);
 
 struct mali_gp_job *mali_scheduler_job_gp_get(void);
 struct mali_pp_job *mali_scheduler_job_pp_physical_peek(void);
@@ -119,13 +113,8 @@ void mali_scheduler_complete_pp_job(struct mali_pp_job *job,
 
 void mali_scheduler_abort_session(struct mali_session_data *session);
 
-void mali_scheduler_return_pp_job_to_user(struct mali_pp_job *job,
-		u32 num_cores_in_virtual);
-
 #if MALI_STATE_TRACKING
 u32 mali_scheduler_dump_state(char *buf, u32 size);
 #endif
 
-void mali_scheduler_gp_pp_job_queue_print(void);
-
 #endif /* __MALI_SCHEDULER_H__ */
diff --git a/drivers/gpu/arm/mali/common/mali_scheduler_types.h b/drivers/gpu/arm/mali/common/mali_scheduler_types.h
old mode 100755
new mode 100644
index 0819c590..adb716f0
--- a/drivers/gpu/arm/mali/common/mali_scheduler_types.h
+++ b/drivers/gpu/arm/mali/common/mali_scheduler_types.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_session.c b/drivers/gpu/arm/mali/common/mali_session.c
old mode 100755
new mode 100644
index 1b409619..d9b81af5
--- a/drivers/gpu/arm/mali/common/mali_session.c
+++ b/drivers/gpu/arm/mali/common/mali_session.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -12,21 +12,15 @@
 #include "mali_osk_list.h"
 #include "mali_session.h"
 #include "mali_ukk.h"
-#ifdef MALI_MEM_SWAP_TRACKING
-#include "mali_memory_swap_alloc.h"
-#endif
 
 _MALI_OSK_LIST_HEAD(mali_sessions);
 static u32 mali_session_count = 0;
 
 _mali_osk_spinlock_irq_t *mali_sessions_lock = NULL;
-wait_queue_head_t pending_queue;
 
 _mali_osk_errcode_t mali_session_initialize(void)
 {
 	_MALI_OSK_INIT_LIST_HEAD(&mali_sessions);
-	/* init wait queue for big varying job */
-	init_waitqueue_head(&pending_queue);
 
 	mali_sessions_lock = _mali_osk_spinlock_irq_init(
 				     _MALI_OSK_LOCKFLAG_ORDERED,
@@ -67,11 +61,6 @@ u32 mali_session_get_count(void)
 	return mali_session_count;
 }
 
-wait_queue_head_t *mali_session_get_wait_queue(void)
-{
-	return &pending_queue;
-}
-
 /*
  * Get the max completed window jobs from all active session,
  * which will be used in window render frame per sec calculate
@@ -104,41 +93,18 @@ void mali_session_memory_tracking(_mali_osk_print_ctx *print_ctx)
 	struct mali_session_data *session, *tmp;
 	u32 mali_mem_usage;
 	u32 total_mali_mem_size;
-#ifdef MALI_MEM_SWAP_TRACKING
-	u32 swap_pool_size;
-	u32 swap_unlock_size;
-#endif
 
 	MALI_DEBUG_ASSERT_POINTER(print_ctx);
 	mali_session_lock();
 	MALI_SESSION_FOREACH(session, tmp, link) {
-#ifdef MALI_MEM_SWAP_TRACKING
-		_mali_osk_ctxprintf(print_ctx, "  %-25s  %-10u  %-10u  %-15u  %-15u  %-10u  %-10u  %-10u\n",
-				    session->comm, session->pid,
-				    (atomic_read(&session->mali_mem_allocated_pages)) * _MALI_OSK_MALI_PAGE_SIZE,
-				    (unsigned int)session->max_mali_mem_allocated_size,
-				    (unsigned int)((atomic_read(&session->mali_mem_array[MALI_MEM_EXTERNAL])) * _MALI_OSK_MALI_PAGE_SIZE),
-				    (unsigned int)((atomic_read(&session->mali_mem_array[MALI_MEM_UMP])) * _MALI_OSK_MALI_PAGE_SIZE),
-				    (unsigned int)((atomic_read(&session->mali_mem_array[MALI_MEM_DMA_BUF])) * _MALI_OSK_MALI_PAGE_SIZE),
-				    (unsigned int)((atomic_read(&session->mali_mem_array[MALI_MEM_SWAP])) * _MALI_OSK_MALI_PAGE_SIZE)
-				   );
-#else
-		_mali_osk_ctxprintf(print_ctx, "  %-25s  %-10u  %-10u  %-15u  %-15u  %-10u  %-10u  \n",
+		_mali_osk_ctxprintf(print_ctx, "  %-25s  %-10u  %-10u  %-15u  %-15u  %-10u  %-10u\n",
 				    session->comm, session->pid,
-				    (unsigned int)((atomic_read(&session->mali_mem_allocated_pages)) * _MALI_OSK_MALI_PAGE_SIZE),
-				    (unsigned int)session->max_mali_mem_allocated_size,
-				    (unsigned int)((atomic_read(&session->mali_mem_array[MALI_MEM_EXTERNAL])) * _MALI_OSK_MALI_PAGE_SIZE),
-				    (unsigned int)((atomic_read(&session->mali_mem_array[MALI_MEM_UMP])) * _MALI_OSK_MALI_PAGE_SIZE),
-				    (unsigned int)((atomic_read(&session->mali_mem_array[MALI_MEM_DMA_BUF])) * _MALI_OSK_MALI_PAGE_SIZE)
-				   );
-#endif
+				    session->mali_mem_array[MALI_MEM_OS] + session->mali_mem_array[MALI_MEM_BLOCK], session->max_mali_mem_allocated,
+				    session->mali_mem_array[MALI_MEM_EXTERNAL], session->mali_mem_array[MALI_MEM_UMP],
+				    session->mali_mem_array[MALI_MEM_DMA_BUF]);
 	}
 	mali_session_unlock();
 	mali_mem_usage  = _mali_ukk_report_memory_usage();
 	total_mali_mem_size = _mali_ukk_report_total_memory_size();
 	_mali_osk_ctxprintf(print_ctx, "Mali mem usage: %u\nMali mem limit: %u\n", mali_mem_usage, total_mali_mem_size);
-#ifdef MALI_MEM_SWAP_TRACKING
-	mali_mem_swap_tracking(&swap_pool_size, &swap_unlock_size);
-	_mali_osk_ctxprintf(print_ctx, "Mali swap mem pool : %u\nMali swap mem unlock: %u\n", swap_pool_size, swap_unlock_size);
-#endif
 }
diff --git a/drivers/gpu/arm/mali/common/mali_session.h b/drivers/gpu/arm/mali/common/mali_session.h
old mode 100755
new mode 100644
index 9184ff26..2a49e5a5
--- a/drivers/gpu/arm/mali/common/mali_session.h
+++ b/drivers/gpu/arm/mali/common/mali_session.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -23,14 +23,11 @@ struct mali_soft_system;
 /* Number of frame builder job lists per session. */
 #define MALI_PP_JOB_FB_LOOKUP_LIST_SIZE 16
 #define MALI_PP_JOB_FB_LOOKUP_LIST_MASK (MALI_PP_JOB_FB_LOOKUP_LIST_SIZE - 1)
-/*Max pending big job allowed in kernel*/
-#define MALI_MAX_PENDING_BIG_JOB (2)
 
 struct mali_session_data {
 	_mali_osk_notification_queue_t *ioctl_queue;
 
 	_mali_osk_mutex_t *memory_lock; /**< Lock protecting the vm manipulation */
-	_mali_osk_mutex_t *cow_lock; /** < Lock protecting the cow memory free manipulation */
 #if 0
 	_mali_osk_list_t memory_head; /**< Track all the memory allocated in this session, for freeing on abnormal termination */
 #endif
@@ -52,16 +49,10 @@ struct mali_session_data {
 	mali_bool use_high_priority_job_queue; /**< If MALI_TRUE, jobs added from this session will use the high priority job queues. */
 	u32 pid;
 	char *comm;
-	atomic_t mali_mem_array[MALI_MEM_TYPE_MAX]; /**< The array to record mem types' usage for this session. */
-	atomic_t mali_mem_allocated_pages; /** The current allocated mali memory pages, which include mali os memory and mali dedicated memory.*/
-	size_t max_mali_mem_allocated_size; /**< The past max mali memory allocated size, which include mali os memory and mali dedicated memory. */
+	size_t mali_mem_array[MALI_MEM_TYPE_MAX]; /**< The array to record all mali mem types' usage for this session. */
+	size_t max_mali_mem_allocated; /**< The past max mali memory usage for this session. */
 	/* Added for new memroy system */
 	struct mali_allocation_manager allocation_mgr;
-
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-	u32 fence_context;      /** <  The execution dma fence context this fence is run on. */
-	_mali_osk_atomic_t fence_seqno; /** < Alinear increasing sequence number for this dma fence context. */
-#endif
 };
 
 _mali_osk_errcode_t mali_session_initialize(void);
@@ -85,7 +76,6 @@ MALI_STATIC_INLINE void mali_session_unlock(void)
 void mali_session_add(struct mali_session_data *session);
 void mali_session_remove(struct mali_session_data *session);
 u32 mali_session_get_count(void);
-wait_queue_head_t *mali_session_get_wait_queue(void);
 
 #define MALI_SESSION_FOREACH(session, tmp, link) \
 	_MALI_OSK_LIST_FOREACHENTRY(session, tmp, &mali_sessions, struct mali_session_data, link)
diff --git a/drivers/gpu/arm/mali/common/mali_soft_job.c b/drivers/gpu/arm/mali/common/mali_soft_job.c
old mode 100755
new mode 100644
index c76d1fef..db0ceaa4
--- a/drivers/gpu/arm/mali/common/mali_soft_job.c
+++ b/drivers/gpu/arm/mali/common/mali_soft_job.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_soft_job.h b/drivers/gpu/arm/mali/common/mali_soft_job.h
old mode 100755
new mode 100644
index 4dd05897..41383697
--- a/drivers/gpu/arm/mali/common/mali_soft_job.h
+++ b/drivers/gpu/arm/mali/common/mali_soft_job.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_spinlock_reentrant.c b/drivers/gpu/arm/mali/common/mali_spinlock_reentrant.c
old mode 100755
new mode 100644
index 28e2e171..99ac9492
--- a/drivers/gpu/arm/mali/common/mali_spinlock_reentrant.c
+++ b/drivers/gpu/arm/mali/common/mali_spinlock_reentrant.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_spinlock_reentrant.h b/drivers/gpu/arm/mali/common/mali_spinlock_reentrant.h
old mode 100755
new mode 100644
index 793875a0..9775315d
--- a/drivers/gpu/arm/mali/common/mali_spinlock_reentrant.h
+++ b/drivers/gpu/arm/mali/common/mali_spinlock_reentrant.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_timeline.c b/drivers/gpu/arm/mali/common/mali_timeline.c
old mode 100755
new mode 100644
index bdbbc768..25b6c3a9
--- a/drivers/gpu/arm/mali/common/mali_timeline.c
+++ b/drivers/gpu/arm/mali/common/mali_timeline.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -237,20 +237,18 @@ static void mali_timeline_destroy(struct mali_timeline *timeline)
 		MALI_DEBUG_ASSERT(NULL != timeline->system);
 		MALI_DEBUG_ASSERT(MALI_TIMELINE_MAX > timeline->id);
 
-		if (NULL != timeline->delayed_work) {
-			_mali_osk_wq_delayed_cancel_work_sync(timeline->delayed_work);
-			_mali_osk_wq_delayed_delete_work_nonflush(timeline->delayed_work);
-		}
-
 #if defined(CONFIG_SYNC)
 		if (NULL != timeline->sync_tl) {
 			sync_timeline_destroy(timeline->sync_tl);
 		}
 #endif /* defined(CONFIG_SYNC) */
 
-#ifndef CONFIG_SYNC
+		if (NULL != timeline->delayed_work) {
+			_mali_osk_wq_delayed_cancel_work_sync(timeline->delayed_work);
+			_mali_osk_wq_delayed_delete_work_nonflush(timeline->delayed_work);
+		}
+
 		_mali_osk_free(timeline);
-#endif
 	}
 }
 
@@ -308,19 +306,11 @@ static struct mali_timeline *mali_timeline_create(struct mali_timeline_system *s
 			return NULL;
 		}
 
-		timeline->destroyed = MALI_FALSE;
-
 		timeline->sync_tl = mali_sync_timeline_create(timeline, timeline_name);
 		if (NULL == timeline->sync_tl) {
 			mali_timeline_destroy(timeline);
 			return NULL;
 		}
-
-		timeline->spinlock = mali_spinlock_reentrant_init(_MALI_OSK_LOCK_ORDER_TIMELINE_SYSTEM);
-		if (NULL == timeline->spinlock) {
-			mali_timeline_destroy(timeline);
-			return NULL;
-		}
 	}
 #endif /* defined(CONFIG_SYNC) */
 
@@ -657,12 +647,13 @@ static mali_scheduler_mask mali_timeline_tracker_activate(struct mali_timeline_t
 		_mali_osk_atomic_dec(&gp_tracker_count);
 		break;
 	case MALI_TIMELINE_TRACKER_PP:
+		schedule_mask = mali_scheduler_activate_pp_job((struct mali_pp_job *) tracker->job);
+
 		if (mali_pp_job_is_virtual((struct mali_pp_job *)tracker->job)) {
 			_mali_osk_atomic_dec(&virt_pp_tracker_count);
 		} else {
 			_mali_osk_atomic_dec(&phy_pp_tracker_count);
 		}
-		schedule_mask = mali_scheduler_activate_pp_job((struct mali_pp_job *) tracker->job);
 		break;
 	case MALI_TIMELINE_TRACKER_SOFT:
 		timeline = tracker->timeline;
@@ -912,9 +903,6 @@ void mali_timeline_system_destroy(struct mali_timeline_system *system)
 {
 	u32 i;
 	struct mali_timeline_waiter *waiter, *next;
-#if defined(CONFIG_SYNC)
-	u32 tid = _mali_osk_get_tid();
-#endif
 
 	MALI_DEBUG_ASSERT_POINTER(system);
 	MALI_DEBUG_ASSERT_POINTER(system->session);
@@ -922,7 +910,6 @@ void mali_timeline_system_destroy(struct mali_timeline_system *system)
 	MALI_DEBUG_PRINT(4, ("Mali Timeline: destroying timeline system\n"));
 
 	if (NULL != system) {
-
 		/* There should be no waiters left on this queue. */
 		if (NULL != system->wait_queue) {
 			_mali_osk_wait_queue_term(system->wait_queue);
@@ -941,14 +928,6 @@ void mali_timeline_system_destroy(struct mali_timeline_system *system)
 		if (NULL != system->signaled_sync_tl) {
 			sync_timeline_destroy(system->signaled_sync_tl);
 		}
-
-		for (i = 0; i < MALI_TIMELINE_MAX; ++i) {
-			if ((NULL != system->timelines[i]) && (NULL != system->timelines[i]->spinlock)) {
-				mali_spinlock_reentrant_wait(system->timelines[i]->spinlock, tid);
-				system->timelines[i]->destroyed = MALI_TRUE;
-				mali_spinlock_reentrant_signal(system->timelines[i]->spinlock, tid);
-			}
-		}
 #endif /* defined(CONFIG_SYNC) */
 
 		for (i = 0; i < MALI_TIMELINE_MAX; ++i) {
@@ -956,7 +935,6 @@ void mali_timeline_system_destroy(struct mali_timeline_system *system)
 				mali_timeline_destroy(system->timelines[i]);
 			}
 		}
-
 		if (NULL != system->spinlock) {
 			mali_spinlock_reentrant_term(system->spinlock);
 		}
@@ -1202,49 +1180,8 @@ static void mali_timeline_system_create_waiters_and_unlock(struct mali_timeline_
 
 		sync_fence = NULL;
 	}
-#endif /* defined(CONFIG_SYNC)*/
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-	if ((NULL != tracker->timeline) && (MALI_TIMELINE_PP == tracker->timeline->id)) {
-
-		struct mali_pp_job *job = (struct mali_pp_job *)tracker->job;
-
-		if (0 < job->dma_fence_context.num_dma_fence_waiter) {
-			struct mali_timeline_waiter *waiter;
-			/* Check if we have a zeroed waiter object available. */
-			if (unlikely(NULL == waiter_tail)) {
-				MALI_PRINT_ERROR(("Mali Timeline: failed to allocate memory for waiter\n"));
-				goto exit;
-			}
-
-			/* Grab new zeroed waiter object. */
-			waiter = waiter_tail;
-			waiter_tail = waiter_tail->tracker_next;
-
-			/* Increase the trigger ref count of the tracker. */
-			tracker->trigger_ref_count++;
-
-			waiter->point   = MALI_TIMELINE_NO_POINT;
-			waiter->tracker = tracker;
-
-			/* Insert waiter on tracker's singly-linked waiter list. */
-			if (NULL == tracker->waiter_head) {
-				/* list is empty */
-				MALI_DEBUG_ASSERT(NULL == tracker->waiter_tail);
-				tracker->waiter_tail = waiter;
-			} else {
-				tracker->waiter_head->tracker_next = waiter;
-			}
-			tracker->waiter_head = waiter;
-
-			/* Also store waiter in separate field for easy access by sync callback. */
-			tracker->waiter_dma_fence = waiter;
-		}
-	}
-#endif /* defined(CONFIG_MALI_DMA_BUF_FENCE)*/
-
-#if defined(CONFIG_MALI_DMA_BUF_FENCE) ||defined(CONFIG_SYNC)
 exit:
-#endif /* defined(CONFIG_MALI_DMA_BUF_FENCE) || defined(CONFIG_SYNC) */
+#endif /* defined(CONFIG_SYNC) */
 
 	if (NULL != waiter_tail) {
 		mali_timeline_system_release_waiter_list(system, waiter_tail, waiter_head);
@@ -1276,7 +1213,6 @@ mali_timeline_point mali_timeline_system_add_tracker(struct mali_timeline_system
 	int num_waiters = 0;
 	struct mali_timeline_waiter *waiter_tail, *waiter_head;
 	u32 tid = _mali_osk_get_tid();
-
 	mali_timeline_point point = MALI_TIMELINE_NO_POINT;
 
 	MALI_DEBUG_ASSERT_POINTER(system);
@@ -1296,14 +1232,6 @@ mali_timeline_point mali_timeline_system_add_tracker(struct mali_timeline_system
 
 	num_waiters = mali_timeline_fence_num_waiters(&tracker->fence);
 
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-	if (MALI_TIMELINE_PP == timeline_id) {
-		struct mali_pp_job *job = (struct mali_pp_job *)tracker->job;
-		if (0 < job->dma_fence_context.num_dma_fence_waiter)
-			num_waiters++;
-	}
-#endif
-
 	/* Allocate waiters. */
 	mali_timeline_system_allocate_waiters(system, &waiter_tail, &waiter_head, num_waiters);
 	MALI_DEBUG_ASSERT(MALI_TIMELINE_SYSTEM_LOCKED(system));
@@ -1510,11 +1438,11 @@ void mali_timeline_debug_print_tracker(struct mali_timeline_tracker *tracker, _m
 				    is_waiting_on_timeline(tracker, MALI_TIMELINE_GP) ? "WaitGP" : " ", tracker->fence.points[0],
 				    is_waiting_on_timeline(tracker, MALI_TIMELINE_PP) ? "WaitPP" : " ", tracker->fence.points[1],
 				    is_waiting_on_timeline(tracker, MALI_TIMELINE_SOFT) ? "WaitSOFT" : " ", tracker->fence.points[2],
-				    tracker->fence.sync_fd, (unsigned int)(uintptr_t)(tracker->sync_fence), (unsigned int)(uintptr_t)(tracker->job));
+				    tracker->fence.sync_fd, tracker->sync_fence, tracker->job);
 	} else {
 		_mali_osk_ctxprintf(print_ctx, "TL:  %s %u %c  fd:%d  fence:(0x%08X)  job:(0x%08X)\n",
 				    tracker_type, tracker->point, state_char,
-				    tracker->fence.sync_fd, (unsigned int)(uintptr_t)(tracker->sync_fence), (unsigned int)(uintptr_t)(tracker->job));
+				    tracker->fence.sync_fd, tracker->sync_fence, tracker->job);
 	}
 #else
 	if (0 != tracker->trigger_ref_count) {
@@ -1523,11 +1451,11 @@ void mali_timeline_debug_print_tracker(struct mali_timeline_tracker *tracker, _m
 				    is_waiting_on_timeline(tracker, MALI_TIMELINE_GP) ? "WaitGP" : " ", tracker->fence.points[0],
 				    is_waiting_on_timeline(tracker, MALI_TIMELINE_PP) ? "WaitPP" : " ", tracker->fence.points[1],
 				    is_waiting_on_timeline(tracker, MALI_TIMELINE_SOFT) ? "WaitSOFT" : " ", tracker->fence.points[2],
-				    (unsigned int)(uintptr_t)(tracker->job));
+				    tracker->job);
 	} else {
 		_mali_osk_ctxprintf(print_ctx, "TL:  %s %u %c  job:(0x%08X)\n",
 				    tracker_type, tracker->point, state_char,
-				    (unsigned int)(uintptr_t)(tracker->job));
+				    tracker->job);
 	}
 #endif
 }
@@ -1545,62 +1473,6 @@ void mali_timeline_debug_print_timeline(struct mali_timeline *timeline, _mali_os
 	}
 }
 
-#if !(LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0))
-void mali_timeline_debug_direct_print_tracker(struct mali_timeline_tracker *tracker)
-{
-	const char *tracker_state = "IWAF";
-	char state_char = 'I';
-	char tracker_type[32] = {0};
-
-	MALI_DEBUG_ASSERT_POINTER(tracker);
-
-	state_char = *(tracker_state + mali_timeline_debug_get_tracker_state(tracker));
-	_mali_osk_snprintf(tracker_type, sizeof(tracker_type), "%s", timeline_tracker_type_to_string(tracker->type));
-
-#if defined(CONFIG_SYNC)
-	if (0 != tracker->trigger_ref_count) {
-		MALI_PRINT(("TL:  %s %u %c - ref_wait:%u [%s(%u),%s(%u),%s(%u), fd:%d, fence:(0x%08X)]  job:(0x%08X)\n",
-			    tracker_type, tracker->point, state_char, tracker->trigger_ref_count,
-			    is_waiting_on_timeline(tracker, MALI_TIMELINE_GP) ? "WaitGP" : " ", tracker->fence.points[0],
-			    is_waiting_on_timeline(tracker, MALI_TIMELINE_PP) ? "WaitPP" : " ", tracker->fence.points[1],
-			    is_waiting_on_timeline(tracker, MALI_TIMELINE_SOFT) ? "WaitSOFT" : " ", tracker->fence.points[2],
-			    tracker->fence.sync_fd, tracker->sync_fence, tracker->job));
-	} else {
-		MALI_PRINT(("TL:  %s %u %c  fd:%d  fence:(0x%08X)  job:(0x%08X)\n",
-			    tracker_type, tracker->point, state_char,
-			    tracker->fence.sync_fd, tracker->sync_fence, tracker->job));
-	}
-#else
-	if (0 != tracker->trigger_ref_count) {
-		MALI_PRINT(("TL:  %s %u %c - ref_wait:%u [%s(%u),%s(%u),%s(%u)]  job:(0x%08X)\n",
-			    tracker_type, tracker->point, state_char, tracker->trigger_ref_count,
-			    is_waiting_on_timeline(tracker, MALI_TIMELINE_GP) ? "WaitGP" : " ", tracker->fence.points[0],
-			    is_waiting_on_timeline(tracker, MALI_TIMELINE_PP) ? "WaitPP" : " ", tracker->fence.points[1],
-			    is_waiting_on_timeline(tracker, MALI_TIMELINE_SOFT) ? "WaitSOFT" : " ", tracker->fence.points[2],
-			    tracker->job));
-	} else {
-		MALI_PRINT(("TL:  %s %u %c  job:(0x%08X)\n",
-			    tracker_type, tracker->point, state_char,
-			    tracker->job));
-	}
-#endif
-}
-
-void mali_timeline_debug_direct_print_timeline(struct mali_timeline *timeline)
-{
-	struct mali_timeline_tracker *tracker = NULL;
-
-	MALI_DEBUG_ASSERT_POINTER(timeline);
-
-	tracker = timeline->tracker_tail;
-	while (NULL != tracker) {
-		mali_timeline_debug_direct_print_tracker(tracker);
-		tracker = tracker->timeline_next;
-	}
-}
-
-#endif
-
 void mali_timeline_debug_print_system(struct mali_timeline_system *system, _mali_osk_print_ctx *print_ctx)
 {
 	int i;
@@ -1634,41 +1506,3 @@ void mali_timeline_debug_print_system(struct mali_timeline_system *system, _mali
 }
 
 #endif /* defined(MALI_TIMELINE_DEBUG_FUNCTIONS) */
-
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-void mali_timeline_dma_fence_callback(void *pp_job_ptr)
-{
-	struct mali_timeline_system  *system;
-	struct mali_timeline_waiter  *waiter;
-	struct mali_timeline_tracker *tracker;
-	struct mali_pp_job *pp_job = (struct mali_pp_job *)pp_job_ptr;
-	mali_scheduler_mask schedule_mask = MALI_SCHEDULER_MASK_EMPTY;
-	u32 tid = _mali_osk_get_tid();
-	mali_bool is_aborting = MALI_FALSE;
-
-	MALI_DEBUG_ASSERT_POINTER(pp_job);
-
-
-	tracker = &pp_job->tracker;
-	MALI_DEBUG_ASSERT_POINTER(tracker);
-
-	system = tracker->system;
-	MALI_DEBUG_ASSERT_POINTER(system);
-	MALI_DEBUG_ASSERT_POINTER(system->session);
-
-	mali_spinlock_reentrant_wait(system->spinlock, tid);
-
-	waiter = tracker->waiter_dma_fence;
-	MALI_DEBUG_ASSERT_POINTER(waiter);
-
-	schedule_mask |= mali_timeline_system_release_waiter(system, waiter);
-
-	is_aborting = system->session->is_aborting;
-
-	mali_spinlock_reentrant_signal(system->spinlock, tid);
-
-	if (!is_aborting) {
-		mali_executor_schedule_from_mask(schedule_mask, MALI_TRUE);
-	}
-}
-#endif
diff --git a/drivers/gpu/arm/mali/common/mali_timeline.h b/drivers/gpu/arm/mali/common/mali_timeline.h
old mode 100755
new mode 100644
index 7696d78a..76dee790
--- a/drivers/gpu/arm/mali/common/mali_timeline.h
+++ b/drivers/gpu/arm/mali/common/mali_timeline.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -18,7 +18,6 @@
 #include "mali_spinlock_reentrant.h"
 #include "mali_sync.h"
 #include "mali_scheduler_types.h"
-#include <linux/version.h>
 
 /**
  * Soft job timeout.
@@ -141,8 +140,6 @@ struct mali_timeline {
 
 #if defined(CONFIG_SYNC)
 	struct sync_timeline         *sync_tl;      /**< Sync timeline that corresponds to this timeline. */
-	mali_bool destroyed;
-	struct mali_spinlock_reentrant *spinlock;       /**< Spin lock protecting the timeline system */
 #endif /* defined(CONFIG_SYNC) */
 
 	/* The following fields are used to time out soft job trackers. */
@@ -191,10 +188,6 @@ struct mali_timeline_tracker {
 	_mali_osk_list_t               sync_fence_cancel_list; /**< List node used to cancel sync fence waiters. */
 #endif /* defined(CONFIG_SYNC) */
 
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-	struct mali_timeline_waiter   *waiter_dma_fence; /**< A direct pointer to timeline waiter representing dma fence. */
-#endif
-
 	struct mali_timeline_system   *system;       /**< Timeline system. */
 	struct mali_timeline          *timeline;     /**< Timeline, or NULL if not on a timeline. */
 	enum mali_timeline_tracker_type type;        /**< Type of tracker. */
@@ -522,11 +515,6 @@ void mali_timeline_debug_print_tracker(struct mali_timeline_tracker *tracker, _m
  */
 void mali_timeline_debug_print_timeline(struct mali_timeline *timeline, _mali_osk_print_ctx *print_ctx);
 
-#if !(LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0))
-void mali_timeline_debug_direct_print_tracker(struct mali_timeline_tracker *tracker);
-void mali_timeline_debug_direct_print_timeline(struct mali_timeline *timeline);
-#endif
-
 /**
  * Print debug information about timeline system.
  *
@@ -536,13 +524,4 @@ void mali_timeline_debug_print_system(struct mali_timeline_system *system, _mali
 
 #endif /* defined(MALI_TIMELINE_DEBUG_FUNCTIONS) */
 
-#if defined(CONFIG_MALI_DMA_BUF_FENCE)
-/**
- * The timeline dma fence callback when dma fence signal.
- *
- * @param pp_job_ptr The pointer to pp job that link to the signaled dma fence.
- */
-void mali_timeline_dma_fence_callback(void *pp_job_ptr);
-#endif
-
 #endif /* __MALI_TIMELINE_H__ */
diff --git a/drivers/gpu/arm/mali/common/mali_timeline_fence_wait.c b/drivers/gpu/arm/mali/common/mali_timeline_fence_wait.c
old mode 100755
new mode 100644
index 1f5d4217..330de8e4
--- a/drivers/gpu/arm/mali/common/mali_timeline_fence_wait.c
+++ b/drivers/gpu/arm/mali/common/mali_timeline_fence_wait.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_timeline_fence_wait.h b/drivers/gpu/arm/mali/common/mali_timeline_fence_wait.h
old mode 100755
new mode 100644
index 348652b4..8dddaf16
--- a/drivers/gpu/arm/mali/common/mali_timeline_fence_wait.h
+++ b/drivers/gpu/arm/mali/common/mali_timeline_fence_wait.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_timeline_sync_fence.c b/drivers/gpu/arm/mali/common/mali_timeline_sync_fence.c
old mode 100755
new mode 100644
index a83252b7..4b762413
--- a/drivers/gpu/arm/mali/common/mali_timeline_sync_fence.c
+++ b/drivers/gpu/arm/mali/common/mali_timeline_sync_fence.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_timeline_sync_fence.h b/drivers/gpu/arm/mali/common/mali_timeline_sync_fence.h
old mode 100755
new mode 100644
index 6662b25b..049a3d51
--- a/drivers/gpu/arm/mali/common/mali_timeline_sync_fence.h
+++ b/drivers/gpu/arm/mali/common/mali_timeline_sync_fence.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_ukk.h b/drivers/gpu/arm/mali/common/mali_ukk.h
old mode 100755
new mode 100644
index 79829b9d..9668b3ee
--- a/drivers/gpu/arm/mali/common/mali_ukk.h
+++ b/drivers/gpu/arm/mali/common/mali_ukk.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -271,11 +271,6 @@ _mali_osk_errcode_t _mali_ukk_get_user_setting(_mali_uk_get_user_setting_s *args
  */
 _mali_osk_errcode_t _mali_ukk_request_high_priority(_mali_uk_request_high_priority_s *args);
 
-/** @brief Make process sleep if the pending big job in kernel  >= MALI_MAX_PENDING_BIG_JOB
- *
- */
-_mali_osk_errcode_t _mali_ukk_pending_submit(_mali_uk_pending_submit_s *args);
-
 /** @} */ /* end group _mali_uk_core */
 
 
@@ -489,17 +484,12 @@ _mali_osk_errcode_t _mali_ukk_gp_suspend_response(_mali_uk_gp_suspend_response_s
  */
 _mali_osk_errcode_t _mali_ukk_profiling_add_event(_mali_uk_profiling_add_event_s *args);
 
-/** @brief Get profiling stream fd.
+/** @brief Return the total memory usage
  *
- * @param args see _mali_uk_profiling_stream_fd_get_s in "mali_utgard_uk_types.h"
- */
-_mali_osk_errcode_t _mali_ukk_profiling_stream_fd_get(_mali_uk_profiling_stream_fd_get_s *args);
-
-/** @brief Profiling control set.
- *
- * @param args see _mali_uk_profiling_control_set_s in "mali_utgard_uk_types.h"
+ * @param args see _mali_uk_profiling_memory_usage_get_s in "mali_utgard_uk_types.h"
+ * @return _MALI_OSK_ERR_OK on success, otherwise a suitable _mali_osk_errcode_t on failure.
  */
-_mali_osk_errcode_t _mali_ukk_profiling_control_set(_mali_uk_profiling_control_set_s *args);
+_mali_osk_errcode_t _mali_ukk_profiling_memory_usage_get(_mali_uk_profiling_memory_usage_get_s *args);
 
 /** @} */ /* end group _mali_uk_profiling */
 #endif
diff --git a/drivers/gpu/arm/mali/common/mali_user_settings_db.c b/drivers/gpu/arm/mali/common/mali_user_settings_db.c
old mode 100755
new mode 100644
index a1a613fd..ec3bbf5b
--- a/drivers/gpu/arm/mali/common/mali_user_settings_db.c
+++ b/drivers/gpu/arm/mali/common/mali_user_settings_db.c
@@ -1,9 +1,9 @@
 /**
- * Copyright (C) 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/common/mali_user_settings_db.h b/drivers/gpu/arm/mali/common/mali_user_settings_db.h
old mode 100755
new mode 100644
index 6828dc7b..19941a67
--- a/drivers/gpu/arm/mali/common/mali_user_settings_db.h
+++ b/drivers/gpu/arm/mali/common/mali_user_settings_db.h
@@ -1,9 +1,9 @@
 /**
- * Copyright (C) 2012-2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/include/linux/mali/mali_utgard.h b/drivers/gpu/arm/mali/include/linux/mali/mali_utgard.h
old mode 100755
new mode 100644
index e58ed1f9..911d1458
--- a/drivers/gpu/arm/mali/include/linux/mali/mali_utgard.h
+++ b/drivers/gpu/arm/mali/include/linux/mali/mali_utgard.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -17,13 +17,6 @@
 #define __MALI_UTGARD_H__
 
 #include "mali_osk_types.h"
-#ifdef CONFIG_MALI_DEVFREQ
-#include <linux/devfreq.h>
-#include "mali_pm_metrics.h"
-#ifdef CONFIG_DEVFREQ_THERMAL
-#include <linux/devfreq_cooling.h>
-#endif
-#endif
 
 #define MALI_GPU_NAME_UTGARD "mali-utgard"
 
@@ -57,7 +50,6 @@
 #define MALI450_OFFSET_L2_CACHE0          MALI_OFFSET_L2_RESOURCE1
 #define MALI450_OFFSET_L2_CACHE1          MALI_OFFSET_L2_RESOURCE0
 #define MALI450_OFFSET_L2_CACHE2          MALI_OFFSET_L2_RESOURCE2
-#define MALI470_OFFSET_L2_CACHE1          MALI_OFFSET_L2_RESOURCE0
 
 #define MALI_OFFSET_BCAST                 0x13000
 #define MALI_OFFSET_DLBU                  0x14000
@@ -215,65 +207,6 @@
 	MALI_GPU_RESOURCES_MALI450_MP8(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp1_irq, pp1_mmu_irq, pp2_irq, pp2_mmu_irq, pp3_irq, pp3_mmu_irq, pp4_irq, pp4_mmu_irq, pp5_irq, pp5_mmu_irq, pp6_irq, pp6_mmu_irq, pp7_irq, pp7_mmu_irq, pp_bcast_irq) \
 	MALI_GPU_RESOURCE_PMU(base_addr + MALI_OFFSET_PMU) \
 
-	/* Mali - 470 */
-#define MALI_GPU_RESOURCES_MALI470_MP1(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp_bcast_irq) \
-	MALI_GPU_RESOURCE_L2(base_addr + MALI470_OFFSET_L2_CACHE1) \
-	MALI_GPU_RESOURCE_GP_WITH_MMU(base_addr + MALI_OFFSET_GP, gp_irq, base_addr + MALI_OFFSET_GP_MMU, gp_mmu_irq) \
-	MALI_GPU_RESOURCE_PP_WITH_MMU(0, base_addr + MALI_OFFSET_PP0, pp0_irq, base_addr + MALI_OFFSET_PP0_MMU, pp0_mmu_irq) \
-	MALI_GPU_RESOURCE_BCAST(base_addr + MALI_OFFSET_BCAST) \
-	MALI_GPU_RESOURCE_DLBU(base_addr + MALI_OFFSET_DLBU) \
-	MALI_GPU_RESOURCE_PP_BCAST(base_addr + MALI_OFFSET_PP_BCAST, pp_bcast_irq) \
-	MALI_GPU_RESOURCE_PP_MMU_BCAST(base_addr + MALI_OFFSET_PP_BCAST_MMU)
-
-#define MALI_GPU_RESOURCES_MALI470_MP1_PMU(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp_bcast_irq) \
-	MALI_GPU_RESOURCES_MALI470_MP1(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp_bcast_irq) \
-	MALI_GPU_RESOURCE_PMU(base_addr + MALI_OFFSET_PMU) \
-
-#define MALI_GPU_RESOURCES_MALI470_MP2(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp1_irq, pp1_mmu_irq, pp_bcast_irq) \
-	MALI_GPU_RESOURCE_L2(base_addr + MALI470_OFFSET_L2_CACHE1) \
-	MALI_GPU_RESOURCE_GP_WITH_MMU(base_addr + MALI_OFFSET_GP, gp_irq, base_addr + MALI_OFFSET_GP_MMU, gp_mmu_irq) \
-	MALI_GPU_RESOURCE_PP_WITH_MMU(0, base_addr + MALI_OFFSET_PP0, pp0_irq, base_addr + MALI_OFFSET_PP0_MMU, pp0_mmu_irq) \
-	MALI_GPU_RESOURCE_PP_WITH_MMU(1, base_addr + MALI_OFFSET_PP1, pp1_irq, base_addr + MALI_OFFSET_PP1_MMU, pp1_mmu_irq) \
-	MALI_GPU_RESOURCE_BCAST(base_addr + MALI_OFFSET_BCAST) \
-	MALI_GPU_RESOURCE_DLBU(base_addr + MALI_OFFSET_DLBU) \
-	MALI_GPU_RESOURCE_PP_BCAST(base_addr + MALI_OFFSET_PP_BCAST, pp_bcast_irq) \
-	MALI_GPU_RESOURCE_PP_MMU_BCAST(base_addr + MALI_OFFSET_PP_BCAST_MMU)
-
-#define MALI_GPU_RESOURCES_MALI470_MP2_PMU(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp1_irq, pp1_mmu_irq, pp_bcast_irq) \
-	MALI_GPU_RESOURCES_MALI470_MP2(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp1_irq, pp1_mmu_irq, pp_bcast_irq) \
-	MALI_GPU_RESOURCE_PMU(base_addr + MALI_OFFSET_PMU) \
-
-#define MALI_GPU_RESOURCES_MALI470_MP3(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp1_irq, pp1_mmu_irq, pp2_irq, pp2_mmu_irq, pp_bcast_irq) \
-	MALI_GPU_RESOURCE_L2(base_addr + MALI470_OFFSET_L2_CACHE1) \
-	MALI_GPU_RESOURCE_GP_WITH_MMU(base_addr + MALI_OFFSET_GP, gp_irq, base_addr + MALI_OFFSET_GP_MMU, gp_mmu_irq) \
-	MALI_GPU_RESOURCE_PP_WITH_MMU(0, base_addr + MALI_OFFSET_PP0, pp0_irq, base_addr + MALI_OFFSET_PP0_MMU, pp0_mmu_irq) \
-	MALI_GPU_RESOURCE_PP_WITH_MMU(1, base_addr + MALI_OFFSET_PP1, pp1_irq, base_addr + MALI_OFFSET_PP1_MMU, pp1_mmu_irq) \
-	MALI_GPU_RESOURCE_PP_WITH_MMU(2, base_addr + MALI_OFFSET_PP2, pp2_irq, base_addr + MALI_OFFSET_PP2_MMU, pp2_mmu_irq) \
-	MALI_GPU_RESOURCE_BCAST(base_addr + MALI_OFFSET_BCAST) \
-	MALI_GPU_RESOURCE_DLBU(base_addr + MALI_OFFSET_DLBU) \
-	MALI_GPU_RESOURCE_PP_BCAST(base_addr + MALI_OFFSET_PP_BCAST, pp_bcast_irq) \
-	MALI_GPU_RESOURCE_PP_MMU_BCAST(base_addr + MALI_OFFSET_PP_BCAST_MMU)
-
-#define MALI_GPU_RESOURCES_MALI470_MP3_PMU(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp1_irq, pp1_mmu_irq, pp2_irq, pp2_mmu_irq, pp_bcast_irq) \
-	MALI_GPU_RESOURCES_MALI470_MP3(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp1_irq, pp1_mmu_irq, pp2_irq, pp2_mmu_irq, pp_bcast_irq) \
-	MALI_GPU_RESOURCE_PMU(base_addr + MALI_OFFSET_PMU) \
-
-#define MALI_GPU_RESOURCES_MALI470_MP4(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp1_irq, pp1_mmu_irq, pp2_irq, pp2_mmu_irq, pp3_irq, pp3_mmu_irq, pp_bcast_irq) \
-	MALI_GPU_RESOURCE_L2(base_addr + MALI470_OFFSET_L2_CACHE1) \
-	MALI_GPU_RESOURCE_GP_WITH_MMU(base_addr + MALI_OFFSET_GP, gp_irq, base_addr + MALI_OFFSET_GP_MMU, gp_mmu_irq) \
-	MALI_GPU_RESOURCE_PP_WITH_MMU(0, base_addr + MALI_OFFSET_PP0, pp0_irq, base_addr + MALI_OFFSET_PP0_MMU, pp0_mmu_irq) \
-	MALI_GPU_RESOURCE_PP_WITH_MMU(1, base_addr + MALI_OFFSET_PP1, pp1_irq, base_addr + MALI_OFFSET_PP1_MMU, pp1_mmu_irq) \
-	MALI_GPU_RESOURCE_PP_WITH_MMU(2, base_addr + MALI_OFFSET_PP2, pp2_irq, base_addr + MALI_OFFSET_PP2_MMU, pp2_mmu_irq) \
-	MALI_GPU_RESOURCE_PP_WITH_MMU(3, base_addr + MALI_OFFSET_PP3, pp3_irq, base_addr + MALI_OFFSET_PP3_MMU, pp3_mmu_irq) \
-	MALI_GPU_RESOURCE_BCAST(base_addr + MALI_OFFSET_BCAST) \
-	MALI_GPU_RESOURCE_DLBU(base_addr + MALI_OFFSET_DLBU) \
-	MALI_GPU_RESOURCE_PP_BCAST(base_addr + MALI_OFFSET_PP_BCAST, pp_bcast_irq) \
-	MALI_GPU_RESOURCE_PP_MMU_BCAST(base_addr + MALI_OFFSET_PP_BCAST_MMU)
-
-#define MALI_GPU_RESOURCES_MALI470_MP4_PMU(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp1_irq, pp1_mmu_irq, pp2_irq, pp2_mmu_irq, pp3_irq, pp3_mmu_irq, pp_bcast_irq) \
-	MALI_GPU_RESOURCES_MALI470_MP4(base_addr, gp_irq, gp_mmu_irq, pp0_irq, pp0_mmu_irq, pp1_irq, pp1_mmu_irq, pp2_irq, pp2_mmu_irq, pp3_irq, pp3_mmu_irq, pp_bcast_irq) \
-	MALI_GPU_RESOURCE_PMU(base_addr + MALI_OFFSET_PMU) \
-
 #define MALI_GPU_RESOURCE_L2(addr) \
 	{ \
 		.name = "Mali_L2", \
@@ -487,18 +420,6 @@
 		void (*get_clock_info)(struct mali_gpu_clock **data);
 		/* Function that get the current clock info, needed when CONFIG_MALI_DVFS enabled */
 		int (*get_freq)(void);
-		/* Function that init the mali gpu secure mode */
-		int (*secure_mode_init)(void);
-		/* Function that deinit the mali gpu secure mode */
-		void (*secure_mode_deinit)(void);
-		/* Function that reset GPU and enable gpu secure mode */
-		int (*gpu_reset_and_secure_mode_enable)(void);
-		/* Function that Reset GPU and disable gpu secure mode */
-		int (*gpu_reset_and_secure_mode_disable)(void);
-		/* ipa related interface customer need register */
-#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_DEVFREQ_THERMAL)
-		struct devfreq_cooling_power *gpu_cooling_ops;
-#endif
 	};
 
 	/**
diff --git a/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_counters.h b/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_counters.h
old mode 100755
new mode 100644
index b3caaa12..38a3c48f
--- a/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_counters.h
+++ b/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_counters.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_ioctl.h b/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_ioctl.h
old mode 100755
new mode 100644
index dfe152ba..8d9136cb
--- a/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_ioctl.h
+++ b/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_ioctl.h
@@ -1,21 +1,11 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-
- * Class Path Exception
- * Linking this library statically or dynamically with other modules is making a combined work based on this library. 
- * Thus, the terms and conditions of the GNU General Public License cover the whole combination.
- * As a special exception, the copyright holders of this library give you permission to link this library with independent modules 
- * to produce an executable, regardless of the license terms of these independent modules, and to copy and distribute the resulting 
- * executable under terms of your choice, provided that you also meet, for each linked independent module, the terms and conditions 
- * of the license of that module. An independent module is a module which is not derived from or based on this library. If you modify 
- * this library, you may extend this exception to your version of the library, but you are not obligated to do so. 
- * If you do not wish to do so, delete this exception statement from your version.
  */
 
 #ifndef __MALI_UTGARD_IOCTL_H__
@@ -60,15 +50,11 @@ extern "C" {
 #define MALI_IOC_TIMELINE_CREATE_SYNC_FENCE _IOWR(MALI_IOC_CORE_BASE, _MALI_UK_TIMELINE_CREATE_SYNC_FENCE, _mali_uk_timeline_create_sync_fence_s)
 #define MALI_IOC_SOFT_JOB_START             _IOWR(MALI_IOC_CORE_BASE, _MALI_UK_SOFT_JOB_START, _mali_uk_soft_job_start_s)
 #define MALI_IOC_SOFT_JOB_SIGNAL            _IOWR(MALI_IOC_CORE_BASE, _MALI_UK_SOFT_JOB_SIGNAL, _mali_uk_soft_job_signal_s)
-#define MALI_IOC_PENDING_SUBMIT             _IOWR(MALI_IOC_CORE_BASE, _MALI_UK_PENDING_SUBMIT, _mali_uk_pending_submit_s)
 
 #define MALI_IOC_MEM_ALLOC                  _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_ALLOC_MEM, _mali_uk_alloc_mem_s)
 #define MALI_IOC_MEM_FREE                   _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_FREE_MEM, _mali_uk_free_mem_s)
 #define MALI_IOC_MEM_BIND                   _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_BIND_MEM, _mali_uk_bind_mem_s)
 #define MALI_IOC_MEM_UNBIND                 _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_UNBIND_MEM, _mali_uk_unbind_mem_s)
-#define MALI_IOC_MEM_COW                    _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_COW_MEM, _mali_uk_cow_mem_s)
-#define MALI_IOC_MEM_COW_MODIFY_RANGE       _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_COW_MODIFY_RANGE, _mali_uk_cow_modify_range_s)
-#define MALI_IOC_MEM_RESIZE                 _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_RESIZE_MEM, _mali_uk_mem_resize_s)
 #define MALI_IOC_MEM_DMA_BUF_GET_SIZE       _IOR(MALI_IOC_MEMORY_BASE, _MALI_UK_DMA_BUF_GET_SIZE, _mali_uk_dma_buf_get_size_s)
 #define MALI_IOC_MEM_QUERY_MMU_PAGE_TABLE_DUMP_SIZE _IOR (MALI_IOC_MEMORY_BASE, _MALI_UK_QUERY_MMU_PAGE_TABLE_DUMP_SIZE, _mali_uk_query_mmu_page_table_dump_size_s)
 #define MALI_IOC_MEM_DUMP_MMU_PAGE_TABLE    _IOWR(MALI_IOC_MEMORY_BASE, _MALI_UK_DUMP_MMU_PAGE_TABLE, _mali_uk_dump_mmu_page_table_s)
@@ -88,8 +74,6 @@ extern "C" {
 #define MALI_IOC_PROFILING_ADD_EVENT        _IOWR(MALI_IOC_PROFILING_BASE, _MALI_UK_PROFILING_ADD_EVENT, _mali_uk_profiling_add_event_s)
 #define MALI_IOC_PROFILING_REPORT_SW_COUNTERS  _IOW (MALI_IOC_PROFILING_BASE, _MALI_UK_PROFILING_REPORT_SW_COUNTERS, _mali_uk_sw_counters_report_s)
 #define MALI_IOC_PROFILING_MEMORY_USAGE_GET _IOR(MALI_IOC_PROFILING_BASE, _MALI_UK_PROFILING_MEMORY_USAGE_GET, _mali_uk_profiling_memory_usage_get_s)
-#define MALI_IOC_PROFILING_STREAM_FD_GET        _IOR(MALI_IOC_PROFILING_BASE, _MALI_UK_PROFILING_STREAM_FD_GET, _mali_uk_profiling_stream_fd_get_s)
-#define MALI_IOC_PROILING_CONTROL_SET   _IOR(MALI_IOC_PROFILING_BASE, _MALI_UK_PROFILING_CONTROL_SET, _mali_uk_profiling_control_set_s)
 
 #define MALI_IOC_VSYNC_EVENT_REPORT         _IOW (MALI_IOC_VSYNC_BASE, _MALI_UK_VSYNC_EVENT_REPORT, _mali_uk_vsync_event_report_s)
 
diff --git a/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_profiling_events.h b/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_profiling_events.h
old mode 100755
new mode 100644
index f505e91e..9725fc04
--- a/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_profiling_events.h
+++ b/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_profiling_events.h
@@ -1,21 +1,11 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-
- * Class Path Exception
- * Linking this library statically or dynamically with other modules is making a combined work based on this library. 
- * Thus, the terms and conditions of the GNU General Public License cover the whole combination.
- * As a special exception, the copyright holders of this library give you permission to link this library with independent modules 
- * to produce an executable, regardless of the license terms of these independent modules, and to copy and distribute the resulting 
- * executable under terms of your choice, provided that you also meet, for each linked independent module, the terms and conditions 
- * of the license of that module. An independent module is a module which is not derived from or based on this library. If you modify 
- * this library, you may extend this exception to your version of the library, but you are not obligated to do so. 
- * If you do not wish to do so, delete this exception statement from your version.
  */
 
 #ifndef _MALI_UTGARD_PROFILING_EVENTS_H_
@@ -141,7 +131,6 @@ typedef enum {
 	MALI_PROFILING_EVENT_REASON_SUSPEND_RESUME_SW_FB_JOBS_WAIT             = 46, /* USED */
 	MALI_PROFILING_EVENT_REASON_SUSPEND_RESUME_SW_FB_NOFRAMES_WAIT         = 47, /* USED */
 	MALI_PROFILING_EVENT_REASON_SUSPEND_RESUME_SW_FB_NOJOBS_WAIT           = 48, /* USED */
-	MALI_PROFILING_EVENT_REASON_SUSPEND_RESUME_SW_SUBMIT_LIMITER_WAIT      = 49, /* USED */
 } cinstr_profiling_event_reason_suspend_resume_sw_t;
 
 /**
diff --git a/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_profiling_gator_api.h b/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_profiling_gator_api.h
old mode 100755
new mode 100644
index c82d8b15..fcaea7ee
--- a/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_profiling_gator_api.h
+++ b/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_profiling_gator_api.h
@@ -1,21 +1,11 @@
 /*
- * Copyright (C) 2013, 2015-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-
- * Class Path Exception
- * Linking this library statically or dynamically with other modules is making a combined work based on this library. 
- * Thus, the terms and conditions of the GNU General Public License cover the whole combination.
- * As a special exception, the copyright holders of this library give you permission to link this library with independent modules 
- * to produce an executable, regardless of the license terms of these independent modules, and to copy and distribute the resulting 
- * executable under terms of your choice, provided that you also meet, for each linked independent module, the terms and conditions 
- * of the license of that module. An independent module is a module which is not derived from or based on this library. If you modify 
- * this library, you may extend this exception to your version of the library, but you are not obligated to do so. 
- * If you do not wish to do so, delete this exception statement from your version.
  */
 
 #ifndef __MALI_UTGARD_PROFILING_GATOR_API_H__
@@ -31,39 +21,6 @@ extern "C" {
 #define MAX_NUM_FP_CORES 8
 #define MAX_NUM_VP_CORES 1
 
-#define _MALI_SPCIAL_COUNTER_DESCRIPTIONS \
-	{                                           \
-		"Filmstrip_cnt0",                 \
-		"Frequency",       \
-		"Voltage",       \
-		"vertex",     \
-		"fragment",         \
-		"Total_alloc_pages",        \
-	};
-
-#define _MALI_MEM_COUTNER_DESCRIPTIONS \
-	{                                           \
-		"untyped_memory",                 \
-		"vertex_index_buffer",       \
-		"texture_buffer",       \
-		"varying_buffer",     \
-		"render_target",         \
-		"pbuffer_buffer",        \
-		"plbu_heap",            \
-		"pointer_array_buffer",             \
-		"slave_tilelist",          \
-		"untyped_gp_cmdlist",     \
-		"polygon_cmdlist",               \
-		"texture_descriptor",               \
-		"render_state_word",               \
-		"shader",               \
-		"stream_buffer",               \
-		"fragment_stack",               \
-		"uniform",               \
-		"untyped_frame_pool",               \
-		"untyped_surface",               \
-	};
-
 /** The list of events supported by the Mali DDK. */
 typedef enum {
 	/* Vertex processor activity */
@@ -159,41 +116,8 @@ typedef enum {
 	COUNTER_GLES_STRIP_LINES_COUNT,
 	COUNTER_GLES_LOOP_LINES_COUNT,
 
-	/* Special counter */
-
 	/* Framebuffer capture pseudo-counter */
 	COUNTER_FILMSTRIP,
-	COUNTER_FREQUENCY,
-	COUNTER_VOLTAGE,
-	COUNTER_VP_ACTIVITY,
-	COUNTER_FP_ACTIVITY,
-	COUNTER_TOTAL_ALLOC_PAGES,
-
-	/* Memory usage counter */
-	COUNTER_MEM_UNTYPED,
-	COUNTER_MEM_VB_IB,
-	COUNTER_MEM_TEXTURE,
-	COUNTER_MEM_VARYING,
-	COUNTER_MEM_RT,
-	COUNTER_MEM_PBUFFER,
-	/* memory usages for gp command */
-	COUNTER_MEM_PLBU_HEAP,
-	COUNTER_MEM_POINTER_ARRAY,
-	COUNTER_MEM_SLAVE_TILELIST,
-	COUNTER_MEM_UNTYPE_GP_CMDLIST,
-	/* memory usages for polygon list command */
-	COUNTER_MEM_POLYGON_CMDLIST,
-	/* memory usages for pp command */
-	COUNTER_MEM_TD,
-	COUNTER_MEM_RSW,
-	/* other memory usages */
-	COUNTER_MEM_SHADER,
-	COUNTER_MEM_STREAMS,
-	COUNTER_MEM_FRAGMENT_STACK,
-	COUNTER_MEM_UNIFORM,
-	/* Special mem usage, which is used for mem pool allocation */
-	COUNTER_MEM_UNTYPE_MEM_POOL,
-	COUNTER_MEM_UNTYPE_SURFACE,
 
 	NUMBER_OF_EVENTS
 } _mali_osk_counter_id;
@@ -208,34 +132,7 @@ typedef enum {
 #define LAST_SW_COUNTER         COUNTER_GLES_LOOP_LINES_COUNT
 
 #define FIRST_SPECIAL_COUNTER   COUNTER_FILMSTRIP
-#define LAST_SPECIAL_COUNTER    COUNTER_TOTAL_ALLOC_PAGES
-
-#define FIRST_MEM_COUNTER               COUNTER_MEM_UNTYPED
-#define LAST_MEM_COUNTER                COUNTER_MEM_UNTYPE_SURFACE
-
-#define MALI_PROFILING_MEM_COUNTERS_NUM (LAST_MEM_COUNTER - FIRST_MEM_COUNTER + 1)
-#define MALI_PROFILING_SPECIAL_COUNTERS_NUM     (LAST_SPECIAL_COUNTER - FIRST_SPECIAL_COUNTER + 1)
-#define MALI_PROFILING_SW_COUNTERS_NUM  (LAST_SW_COUNTER - FIRST_SW_COUNTER + 1)
-
-/**
- * Define the stream header type for porfiling stream.
- */
-#define  STREAM_HEADER_FRAMEBUFFER 0x05         /* The stream packet header type for framebuffer dumping. */
-#define STREAM_HEADER_COUNTER_VALUE  0x09       /* The stream packet header type for hw/sw/memory counter sampling. */
-#define STREAM_HEADER_CORE_ACTIVITY 0x0a                /* The stream packet header type for activity counter sampling. */
-#define STREAM_HEADER_SIZE      5
-
-/**
- * Define the packet header type of profiling control packet.
- */
-#define PACKET_HEADER_ERROR            0x80             /* The response packet header type if error. */
-#define PACKET_HEADER_ACK              0x81             /* The response packet header type if OK. */
-#define PACKET_HEADER_COUNTERS_REQUEST 0x82             /* The control packet header type to request counter information from ddk. */
-#define PACKET_HEADER_COUNTERS_ACK         0x83         /* The response packet header type to send out counter information. */
-#define PACKET_HEADER_COUNTERS_ENABLE  0x84             /* The control packet header type to enable counters. */
-#define PACKET_HEADER_START_CAPTURE_VALUE            0x85               /* The control packet header type to start capture values. */
-
-#define PACKET_HEADER_SIZE      5
+#define LAST_SPECIAL_COUNTER    COUNTER_FILMSTRIP
 
 /**
  * Structure to pass performance counter data of a Mali core
@@ -273,19 +170,6 @@ typedef struct _mali_profiling_mali_version {
 	u32 num_of_vp_cores;
 } _mali_profiling_mali_version;
 
-/**
- * Structure to define the mali profiling counter struct.
- */
-typedef struct mali_profiling_counter {
-	char counter_name[40];
-	u32 counter_id;
-	u32 counter_event;
-	u32 prev_counter_value;
-	u32 current_counter_value;
-	u32 key;
-	int enabled;
-} mali_profiling_counter;
-
 /*
  * List of possible actions to be controlled by Streamline.
  * The following numbers are used by gator to control the frame buffer dumping and s/w counter reporting.
@@ -295,8 +179,6 @@ typedef struct mali_profiling_counter {
 #define FBDUMP_CONTROL_RATE (2)
 #define SW_COUNTER_ENABLE (3)
 #define FBDUMP_CONTROL_RESIZE_FACTOR (4)
-#define MEM_COUNTER_ENABLE (5)
-#define ANNOTATE_PROFILING_ENABLE (6)
 
 void _mali_profiling_control(u32 action, u32 value);
 
diff --git a/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_uk_types.h b/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_uk_types.h
old mode 100755
new mode 100644
index 99835a5c..e76ec6a7
--- a/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_uk_types.h
+++ b/drivers/gpu/arm/mali/include/linux/mali/mali_utgard_uk_types.h
@@ -1,21 +1,11 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
-
- * Class Path Exception
- * Linking this library statically or dynamically with other modules is making a combined work based on this library. 
- * Thus, the terms and conditions of the GNU General Public License cover the whole combination.
- * As a special exception, the copyright holders of this library give you permission to link this library with independent modules 
- * to produce an executable, regardless of the license terms of these independent modules, and to copy and distribute the resulting 
- * executable under terms of your choice, provided that you also meet, for each linked independent module, the terms and conditions 
- * of the license of that module. An independent module is a module which is not derived from or based on this library. If you modify 
- * this library, you may extend this exception to your version of the library, but you are not obligated to do so. 
- * If you do not wish to do so, delete this exception statement from your version.
  */
 
 /**
@@ -36,8 +26,6 @@ extern "C" {
 #define MALI_UK_TIMELINE_SOFT 2
 #define MALI_UK_TIMELINE_MAX  3
 
-#define MALI_UK_BIG_VARYING_SIZE  (1024*1024*2)
-
 typedef struct {
 	u32 points[MALI_UK_TIMELINE_MAX];
 	s32 sync_fd;
@@ -93,17 +81,13 @@ typedef enum {
 	_MALI_UK_TIMELINE_CREATE_SYNC_FENCE,  /**< _mali_ukk_timeline_create_sync_fence() */
 	_MALI_UK_SOFT_JOB_START,              /**< _mali_ukk_soft_job_start() */
 	_MALI_UK_SOFT_JOB_SIGNAL,             /**< _mali_ukk_soft_job_signal() */
-	_MALI_UK_PENDING_SUBMIT,             /**< _mali_ukk_pending_submit() */
 
 	/** Memory functions */
 
-	_MALI_UK_ALLOC_MEM                = 0,   /**< _mali_ukk_alloc_mem() */
-	_MALI_UK_FREE_MEM,                       /**< _mali_ukk_free_mem() */
-	_MALI_UK_BIND_MEM,                       /**< _mali_ukk_mem_bind() */
-	_MALI_UK_UNBIND_MEM,                     /**< _mali_ukk_mem_unbind() */
-	_MALI_UK_COW_MEM,                        /**< _mali_ukk_mem_cow() */
-	_MALI_UK_COW_MODIFY_RANGE,               /**< _mali_ukk_mem_cow_modify_range() */
-	_MALI_UK_RESIZE_MEM,                     /**<._mali_ukk_mem_resize() */
+	_MALI_UK_ALLOC_MEM                = 0,   /**< _mali_ukk_init_mem() */
+	_MALI_UK_FREE_MEM,                       /**< _mali_ukk_term_mem() */
+	_MALI_UK_BIND_MEM,                       /**< _mali_ukk_mem_mmap() */
+	_MALI_UK_UNBIND_MEM,                     /**< _mali_ukk_mem_munmap() */
 	_MALI_UK_QUERY_MMU_PAGE_TABLE_DUMP_SIZE, /**< _mali_ukk_mem_get_mmu_page_table_dump_size() */
 	_MALI_UK_DUMP_MMU_PAGE_TABLE,            /**< _mali_ukk_mem_dump_mmu_page_table() */
 	_MALI_UK_DMA_BUF_GET_SIZE,               /**< _mali_ukk_dma_buf_get_size() */
@@ -135,8 +119,6 @@ typedef enum {
 	_MALI_UK_PROFILING_ADD_EVENT     = 0, /**< __mali_uku_profiling_add_event() */
 	_MALI_UK_PROFILING_REPORT_SW_COUNTERS,/**< __mali_uku_profiling_report_sw_counters() */
 	_MALI_UK_PROFILING_MEMORY_USAGE_GET,  /**< __mali_uku_profiling_memory_usage_get() */
-	_MALI_UK_PROFILING_STREAM_FD_GET, /** < __mali_uku_profiling_stream_fd_get() */
-	_MALI_UK_PROFILING_CONTROL_SET, /** < __mali_uku_profiling_control_set() */
 
 	/** VSYNC reporting fuctions */
 	_MALI_UK_VSYNC_EVENT_REPORT      = 0, /**< _mali_ukk_vsync_event_report() */
@@ -279,9 +261,6 @@ typedef struct {
 	u32 flush_id;                       /**< [in] flush id within the originating frame builder */
 	_mali_uk_fence_t fence;             /**< [in] fence this job must wait on */
 	u64 timeline_point_ptr;            /**< [in,out] pointer to u32: location where point on gp timeline for this job will be written */
-	u32 varying_memsize;            /** < [in] size of varying memory to use deffer bind*/
-	u32 deferred_mem_num;
-	u64 deferred_mem_list;         /** < [in] memory hanlde list of varying buffer to use deffer bind */
 } _mali_uk_gp_start_job_s;
 
 #define _MALI_PERFORMANCE_COUNTER_FLAG_SRC0_ENABLE (1<<0) /**< Enable performance counter SRC0 for a job */
@@ -296,7 +275,6 @@ typedef struct {
 	u32 heap_current_addr;          /**< [out] value of the GP PLB PL heap start address register */
 	u32 perf_counter0;              /**< [out] value of performance counter 0 (see ARM DDI0415A) */
 	u32 perf_counter1;              /**< [out] value of performance counter 1 (see ARM DDI0415A) */
-	u32 pending_big_job_num;
 } _mali_uk_gp_job_finished_s;
 
 typedef struct {
@@ -321,7 +299,6 @@ typedef struct {
 /** Flag for _mali_uk_pp_start_job_s */
 #define _MALI_PP_JOB_FLAG_NO_NOTIFICATION (1<<0)
 #define _MALI_PP_JOB_FLAG_IS_WINDOW_SURFACE (1<<1)
-#define _MALI_PP_JOB_FLAG_PROTECTED (1<<2)
 
 /** @defgroup _mali_uk_ppstartjob_s Fragment Processor Start Job
  * @{ */
@@ -460,18 +437,6 @@ typedef struct {
 
 /** @} */ /* end group _mali_uk_soft_job */
 
-typedef struct {
-	u32 counter_id;
-	u32 key;
-	int enable;
-} _mali_uk_annotate_profiling_mem_counter_s;
-
-typedef struct {
-	u32 sampling_rate;
-	int enable;
-} _mali_uk_annotate_profiling_enable_s;
-
-
 /** @addtogroup _mali_uk_core U/K Core
  * @{ */
 
@@ -506,9 +471,6 @@ typedef enum {
 	_MALI_NOTIFICATION_GP_FINISHED = (_MALI_UK_GP_SUBSYSTEM << 16) | 0x10,
 	_MALI_NOTIFICATION_GP_STALLED = (_MALI_UK_GP_SUBSYSTEM << 16) | 0x20,
 
-	/** Profiling notifications */
-	_MALI_NOTIFICATION_ANNOTATE_PROFILING_MEM_COUNTER = (_MALI_UK_PROFILING_SUBSYSTEM << 16) | 0x10,
-	_MALI_NOTIFICATION_ANNOTATE_PROFILING_ENABLE = (_MALI_UK_PROFILING_SUBSYSTEM << 16) | 0x20,
 } _mali_uk_notification_type;
 
 /** to assist in splitting up 32-bit notification value in subsystem and id value */
@@ -613,8 +575,6 @@ typedef struct {
 		_mali_uk_pp_job_finished_s  pp_job_finished; /**< [out] Notification data for _MALI_NOTIFICATION_PP_FINISHED notification type */
 		_mali_uk_settings_changed_s setting_changed;/**< [out] Notification data for _MALI_NOTIFICAATION_SETTINGS_CHANGED notification type */
 		_mali_uk_soft_job_activated_s soft_job_activated; /**< [out] Notification data for _MALI_NOTIFICATION_SOFT_ACTIVATED notification type */
-		_mali_uk_annotate_profiling_mem_counter_s profiling_mem_counter;
-		_mali_uk_annotate_profiling_enable_s profiling_enable;
 	} data;
 } _mali_uk_wait_for_notification_s;
 
@@ -658,7 +618,7 @@ typedef struct {
  * The 16bit integer is stored twice in a 32bit integer
  * For example, for version 1 the value would be 0x00010001
  */
-#define _MALI_API_VERSION 900
+#define _MALI_API_VERSION 800
 #define _MALI_UK_API_VERSION _MAKE_VERSION_ID(_MALI_API_VERSION)
 
 /**
@@ -738,11 +698,6 @@ typedef struct {
 	u64 ctx;                       /**< [in,out] user-kernel context (trashed on output) */
 } _mali_uk_request_high_priority_s;
 
-/** @brief Arguments for _mali_ukk_pending_submit() */
-typedef struct {
-	u64 ctx;                       /**< [in,out] user-kernel context (trashed on output) */
-} _mali_uk_pending_submit_s;
-
 /** @} */ /* end group _mali_uk_core */
 
 
@@ -751,26 +706,24 @@ typedef struct {
 
 #define _MALI_MEMORY_ALLOCATE_RESIZEABLE  (1<<4) /* BUFFER can trim dow/grow*/
 #define _MALI_MEMORY_ALLOCATE_NO_BIND_GPU (1<<5) /*Not map to GPU when allocate, must call bind later*/
-#define _MALI_MEMORY_ALLOCATE_SWAPPABLE   (1<<6) /* Allocate swappale memory. */
-#define _MALI_MEMORY_ALLOCATE_DEFER_BIND (1<<7) /*Not map to GPU when allocate, must call bind later*/
-#define _MALI_MEMORY_ALLOCATE_SECURE (1<<8) /* Allocate secure memory. */
-
 
 typedef struct {
 	u64 ctx;                                          /**< [in,out] user-kernel context (trashed on output) */
-	u32 gpu_vaddr;                                    /**< [in] GPU virtual address */
+	u32 gpu_vaddr;                            /**< [in] GPU virtual address */
 	u32 vsize;                                        /**< [in] vitrual size of the allocation */
 	u32 psize;                                        /**< [in] physical size of the allocation */
 	u32 flags;
-	u64 backend_handle;                               /**< [out] backend handle */
-	s32 secure_shared_fd;                           /** < [in] the mem handle for secure mem */
+	u64 backend_handle;          /**< [out] backend handle */
+	struct {
+		/* buffer types*/
+		/* CPU read/write info*/
+	} buffer_info;
 } _mali_uk_alloc_mem_s;
 
 
 typedef struct {
-	u64 ctx;                      /**< [in,out] user-kernel context (trashed on output) */
+	u64 ctx;                                          /**< [in,out] user-kernel context (trashed on output) */
 	u32 gpu_vaddr;                /**< [in] use as handle to free allocation */
-	u32 free_pages_nr;      /** < [out] record the number of free pages */
 } _mali_uk_free_mem_s;
 
 
@@ -794,22 +747,25 @@ typedef struct {
 
 
 typedef struct {
-	u64 ctx;                                        /**< [in,out] user-kernel context (trashed on output) */
-	u32 vaddr;                                      /**< [in] mali address to map the physical memory to */
-	u32 size;                                       /**< [in] size */
-	u32 flags;                                      /**< [in] see_MALI_MEMORY_BIND_BACKEND_* */
-	u32 padding;                                    /** padding for 32/64 struct alignment */
+	u64 ctx;                                          /**< [in,out] user-kernel context (trashed on output) */
+	u32 vaddr;                    /**< [in] mali address to map the physical memory to */
+	u32 size;                                         /**< [in] size */
+	u32 flags;                    /**< [in] see_MALI_MEMORY_BIND_BACKEND_* */
+	u32 padding;                              /** padding for 32/64 struct alignment */
 	union {
 		struct {
-			u32 secure_id;                  /**< [in] secure id */
-			u32 rights;                     /**< [in] rights necessary for accessing memory */
-			u32 flags;                      /**< [in] flags, see \ref _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE */
+			u32 secure_id;                                  /**< [in] secure id */
+			u32 rights;                                     /**< [in] rights necessary for accessing memory */
+			u32 flags;                                              /**< [in] flags, see \ref _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE */
 		} bind_ump;
 		struct {
 			u32 mem_fd;                     /**< [in] Memory descriptor */
 			u32 rights;                     /**< [in] rights necessary for accessing memory */
 			u32 flags;                      /**< [in] flags, see \ref _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE */
 		} bind_dma_buf;
+		struct {
+			/**/
+		} bind_mali_memory;
 		struct {
 			u32 phys_addr;                  /**< [in] physical address */
 			u32 rights;                     /**< [in] rights necessary for accessing memory */
@@ -819,32 +775,20 @@ typedef struct {
 } _mali_uk_bind_mem_s;
 
 typedef struct {
-	u64 ctx;                                        /**< [in,out] user-kernel context (trashed on output) */
-	u32 flags;                                      /**< [in] see_MALI_MEMORY_BIND_BACKEND_* */
-	u32 vaddr;                                      /**<  [in] identifier for mapped memory object in kernel space  */
+	u64 ctx;                                          /**< [in,out] user-kernel context (trashed on output) */
+	u32 flags;                    /**< [in] see_MALI_MEMORY_BIND_BACKEND_* */
+	u32 vaddr;                   /**<  [in] identifier for mapped memory object in kernel space  */
 } _mali_uk_unbind_mem_s;
 
 typedef struct {
-	u64 ctx;                                        /**< [in,out] user-kernel context (trashed on output) */
-	u32 target_handle;                              /**< [in] handle of allocation need to do COW */
-	u32 target_offset;                              /**< [in] offset in target allocation to do COW(for support COW  a memory allocated from memory_bank, PAGE_SIZE align)*/
-	u32 target_size;                                /**< [in] size of target allocation to do COW (for support memory bank, PAGE_SIZE align)(in byte) */
-	u32 range_start;                                /**< [in] re allocate range start offset, offset from the start of allocation (PAGE_SIZE align)*/
-	u32 range_size;                                 /**< [in] re allocate size (PAGE_SIZE align)*/
-	u32 vaddr;                                      /**< [in] mali address for the new allocaiton */
-	u32 backend_handle;                             /**< [out] backend handle */
-	u32 flags;
+	u64 ctx;                                                                /**< [in,out] user-kernel context (trashed on output) */
+	u32 target_handle;                                              /**< [in] handle of allocation need to do COW */
+	u32 range_start;                                                /**< [in] re allocate range start offset, offset from the start of allocation */
+	u32 size;                                                               /**< [in] re allocate size*/
+	u32 vaddr;                                                              /**< [in] mali address for the new allocaiton */
+	u32 backend_handle;                                             /**< [out] backend handle */
 } _mali_uk_cow_mem_s;
 
-typedef struct {
-	u64 ctx;                                        /**< [in,out] user-kernel context (trashed on output) */
-	u32 range_start;                                /**< [in] re allocate range start offset, offset from the start of allocation */
-	u32 size;                                       /**< [in] re allocate size*/
-	u32 vaddr;                                      /**< [in] mali address for the new allocaiton */
-	s32 change_pages_nr;                            /**< [out] record the page number change for cow operation */
-} _mali_uk_cow_modify_range_s;
-
-
 typedef struct {
 	u64 ctx;                      /**< [in,out] user-kernel context (trashed on output) */
 	u32 mem_fd;                     /**< [in] Memory descriptor */
@@ -853,13 +797,22 @@ typedef struct {
 
 /** Flag for _mali_uk_map_external_mem_s, _mali_uk_attach_ump_mem_s and _mali_uk_attach_dma_buf_s */
 #define _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE (1<<0)
-
+#if 0
+typedef struct {
+	u64 ctx;                      /**< [in,out] user-kernel context (trashed on output) */
+	u32 phys_addr;                  /**< [in] physical address */
+	u32 size;                       /**< [in] size */
+	u32 mali_address;               /**< [in] mali address to map the physical memory to */
+	u32 rights;                     /**< [in] rights necessary for accessing memory */
+	u32 flags;                      /**< [in] flags, see \ref _MALI_MAP_EXTERNAL_MAP_GUARD_PAGE */
+	u32 cookie;                     /**< [out] identifier for mapped memory object in kernel space  */
+} _mali_uk_map_external_mem_s;
 
 typedef struct {
-	u64 ctx;                                /**< [in,out] user-kernel context (trashed on output) */
-	u64 vaddr;                              /* the buffer to do resize*/
-	u32 psize;                              /* wanted physical size of this memory */
-} _mali_uk_mem_resize_s;
+	u64 ctx;                      /**< [in,out] user-kernel context (trashed on output) */
+	u32 cookie;                     /**< [out] identifier for mapped memory object in kernel space  */
+} _mali_uk_unmap_external_mem_s;
+#endif
 
 /**
  * @brief Arguments for _mali_uk[uk]_mem_write_safe()
@@ -955,8 +908,6 @@ typedef struct {
 typedef struct {
 	u64 ctx;                     /**< [in,out] user-kernel context (trashed on output) */
 	u32 memory_usage;              /**< [out] total memory usage */
-	u32 vaddr;                                      /**< [in] mali address for the cow allocaiton */
-	s32 change_pages_nr;            /**< [out] record the page number change for cow operation */
 } _mali_uk_profiling_memory_usage_get_s;
 
 
@@ -994,7 +945,6 @@ typedef struct {
 	void *mapping;                  /**< [out] Returns user-space virtual address for the mapping */
 	u32 size;                       /**< [in] Size of the requested mapping */
 	u32 phys_addr;                  /**< [in] Physical address - could be offset, depending on caller+callee convention */
-	mali_bool writeable;
 } _mali_uk_mem_mmap_s;
 
 /** @brief Arguments to _mali_ukk_mem_munmap()
@@ -1080,19 +1030,6 @@ typedef struct {
 
 /** @} */ /* end group uddapi */
 
-typedef struct {
-	u64 ctx;                 /**< [in,out] user-kernel context (trashed on output) */
-	s32 stream_fd;   /**< [in] The profiling kernel base stream fd handle */
-} _mali_uk_profiling_stream_fd_get_s;
-
-typedef struct {
-	u64 ctx;        /**< [in,out] user-kernel context (trashed on output) */
-	u64 control_packet_data; /**< [in] the control packet data for control settings */
-	u32 control_packet_size;  /**< [in] The control packet size */
-	u64 response_packet_data; /** < [out] The response packet data */
-	u32 response_packet_size; /** < [in,out] The response packet data */
-} _mali_uk_profiling_control_set_s;
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/gpu/arm/mali/linux/license/gpl/mali_kernel_license.h b/drivers/gpu/arm/mali/linux/license/gpl/mali_kernel_license.h
old mode 100755
new mode 100644
index 264555dd..c498cf9d
--- a/drivers/gpu/arm/mali/linux/license/gpl/mali_kernel_license.h
+++ b/drivers/gpu/arm/mali/linux/license/gpl/mali_kernel_license.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_devfreq.c b/drivers/gpu/arm/mali/linux/mali_devfreq.c
deleted file mode 100755
index 0b0ba148..00000000
--- a/drivers/gpu/arm/mali/linux/mali_devfreq.c
+++ /dev/null
@@ -1,310 +0,0 @@
-/*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#include "mali_osk_mali.h"
-#include "mali_kernel_common.h"
-
-#include <linux/clk.h>
-#include <linux/devfreq.h>
-#include <linux/regulator/consumer.h>
-#include <linux/regulator/driver.h>
-#ifdef CONFIG_DEVFREQ_THERMAL
-#include <linux/devfreq_cooling.h>
-#endif
-
-#include <linux/version.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
-#include <linux/pm_opp.h>
-#else /* Linux >= 3.13 */
-/* In 3.13 the OPP include header file, types, and functions were all
- * renamed. Use the old filename for the include, and define the new names to
- * the old, when an old kernel is detected.
- */
-#include <linux/opp.h>
-#define dev_pm_opp opp
-#define dev_pm_opp_get_voltage opp_get_voltage
-#define dev_pm_opp_get_opp_count opp_get_opp_count
-#define dev_pm_opp_find_freq_ceil opp_find_freq_ceil
-#endif /* Linux >= 3.13 */
-
-#include "mali_pm_metrics.h"
-
-static int
-mali_devfreq_target(struct device *dev, unsigned long *target_freq, u32 flags)
-{
-	struct mali_device *mdev = dev_get_drvdata(dev);
-	struct dev_pm_opp *opp;
-	unsigned long freq = 0;
-	unsigned long voltage;
-	int err;
-
-	freq = *target_freq;
-
-	rcu_read_lock();
-	opp = devfreq_recommended_opp(dev, &freq, flags);
-	voltage = dev_pm_opp_get_voltage(opp);
-	rcu_read_unlock();
-	if (IS_ERR_OR_NULL(opp)) {
-		MALI_PRINT_ERROR(("Failed to get opp (%ld)\n", PTR_ERR(opp)));
-		return PTR_ERR(opp);
-	}
-
-	MALI_DEBUG_PRINT(2, ("mali_devfreq_target:set_freq = %lld flags = 0x%x\n", freq, flags));
-	/*
-	 * Only update if there is a change of frequency
-	 */
-	if (mdev->current_freq == freq) {
-		*target_freq = freq;
-		mali_pm_reset_dvfs_utilisation(mdev);
-		return 0;
-	}
-
-#ifdef CONFIG_REGULATOR
-	if (mdev->regulator && mdev->current_voltage != voltage
-	    && mdev->current_freq < freq) {
-		err = regulator_set_voltage(mdev->regulator, voltage, voltage);
-		if (err) {
-			MALI_PRINT_ERROR(("Failed to increase voltage (%d)\n", err));
-			return err;
-		}
-	}
-#endif
-
-	err = clk_set_rate(mdev->clock, freq);
-	if (err) {
-		MALI_PRINT_ERROR(("Failed to set clock %lu (target %lu)\n", freq, *target_freq));
-		return err;
-	}
-
-#ifdef CONFIG_REGULATOR
-	if (mdev->regulator && mdev->current_voltage != voltage
-	    && mdev->current_freq > freq) {
-		err = regulator_set_voltage(mdev->regulator, voltage, voltage);
-		if (err) {
-			MALI_PRINT_ERROR(("Failed to decrease voltage (%d)\n", err));
-			return err;
-		}
-	}
-#endif
-
-	*target_freq = freq;
-	mdev->current_voltage = voltage;
-	mdev->current_freq = freq;
-
-	mali_pm_reset_dvfs_utilisation(mdev);
-
-	return err;
-}
-
-static int
-mali_devfreq_cur_freq(struct device *dev, unsigned long *freq)
-{
-	struct mali_device *mdev = dev_get_drvdata(dev);
-
-	*freq = mdev->current_freq;
-
-	MALI_DEBUG_PRINT(2, ("mali_devfreq_cur_freq: freq = %d \n", *freq));
-	return 0;
-}
-
-static int
-mali_devfreq_status(struct device *dev, struct devfreq_dev_status *stat)
-{
-	struct mali_device *mdev = dev_get_drvdata(dev);
-
-	stat->current_frequency = mdev->current_freq;
-
-	mali_pm_get_dvfs_utilisation(mdev,
-				     &stat->total_time, &stat->busy_time);
-
-	stat->private_data = NULL;
-
-#ifdef CONFIG_DEVFREQ_THERMAL
-	memcpy(&mdev->devfreq->last_status, stat, sizeof(*stat));
-#endif
-
-	return 0;
-}
-
-/* setup platform specific opp in platform.c*/
-int __weak setup_opps(void)
-{
-	return 0;
-}
-
-/* term platform specific opp in platform.c*/
-int __weak term_opps(struct device *dev)
-{
-	return 0;
-}
-
-static int mali_devfreq_init_freq_table(struct mali_device *mdev,
-					struct devfreq_dev_profile *dp)
-{
-	int err, count;
-	int i = 0;
-	unsigned long freq = 0;
-	struct dev_pm_opp *opp;
-
-	err = setup_opps();
-	if (err)
-		return err;
-
-	rcu_read_lock();
-	count = dev_pm_opp_get_opp_count(mdev->dev);
-	if (count < 0) {
-		rcu_read_unlock();
-		return count;
-	}
-	rcu_read_unlock();
-
-	MALI_DEBUG_PRINT(2, ("mali devfreq table count %d\n", count));
-
-	dp->freq_table = kmalloc_array(count, sizeof(dp->freq_table[0]),
-				       GFP_KERNEL);
-	if (!dp->freq_table)
-		return -ENOMEM;
-
-	rcu_read_lock();
-	for (i = 0; i < count; i++, freq++) {
-		opp = dev_pm_opp_find_freq_ceil(mdev->dev, &freq);
-		if (IS_ERR(opp))
-			break;
-
-		dp->freq_table[i] = freq;
-		MALI_DEBUG_PRINT(2, ("mali devfreq table array[%d] = %d\n", i, freq));
-	}
-	rcu_read_unlock();
-
-	if (count != i)
-		MALI_PRINT_ERROR(("Unable to enumerate all OPPs (%d!=%d)\n",
-				  count, i));
-
-	dp->max_state = i;
-
-	return 0;
-}
-
-static void mali_devfreq_term_freq_table(struct mali_device *mdev)
-{
-	struct devfreq_dev_profile *dp = mdev->devfreq->profile;
-
-	kfree(dp->freq_table);
-	term_opps(mdev->dev);
-}
-
-static void mali_devfreq_exit(struct device *dev)
-{
-	struct mali_device *mdev = dev_get_drvdata(dev);
-
-	mali_devfreq_term_freq_table(mdev);
-}
-
-int mali_devfreq_init(struct mali_device *mdev)
-{
-#ifdef CONFIG_DEVFREQ_THERMAL
-	struct devfreq_cooling_power *callbacks = NULL;
-	_mali_osk_device_data data;
-#endif
-	struct devfreq_dev_profile *dp;
-	int err;
-
-	MALI_DEBUG_PRINT(2, ("Init Mali devfreq\n"));
-
-	if (!mdev->clock)
-		return -ENODEV;
-
-	mdev->current_freq = clk_get_rate(mdev->clock);
-
-	dp = &mdev->devfreq_profile;
-
-	dp->initial_freq = mdev->current_freq;
-	dp->polling_ms = 100;
-	dp->target = mali_devfreq_target;
-	dp->get_dev_status = mali_devfreq_status;
-	dp->get_cur_freq = mali_devfreq_cur_freq;
-	dp->exit = mali_devfreq_exit;
-
-	if (mali_devfreq_init_freq_table(mdev, dp))
-		return -EFAULT;
-
-	mdev->devfreq = devfreq_add_device(mdev->dev, dp,
-					   "simple_ondemand", NULL);
-	if (IS_ERR(mdev->devfreq)) {
-		mali_devfreq_term_freq_table(mdev);
-		return PTR_ERR(mdev->devfreq);
-	}
-
-	err = devfreq_register_opp_notifier(mdev->dev, mdev->devfreq);
-	if (err) {
-		MALI_PRINT_ERROR(("Failed to register OPP notifier (%d)\n", err));
-		goto opp_notifier_failed;
-	}
-
-#ifdef CONFIG_DEVFREQ_THERMAL
-	/* Initilization last_status it will be used when first power allocate called */
-	mdev->devfreq->last_status.current_frequency = mdev->current_freq;
-
-	if (_MALI_OSK_ERR_OK == _mali_osk_device_data_get(&data)) {
-		if (NULL != data.gpu_cooling_ops) {
-			callbacks = data.gpu_cooling_ops;
-			MALI_DEBUG_PRINT(2, ("Mali GPU Thermal: Callback handler installed \n"));
-		}
-	}
-
-	if (callbacks) {
-		mdev->devfreq_cooling = of_devfreq_cooling_register_power(
-						mdev->dev->of_node,
-						mdev->devfreq,
-						callbacks);
-		if (IS_ERR_OR_NULL(mdev->devfreq_cooling)) {
-			err = PTR_ERR(mdev->devfreq_cooling);
-			MALI_PRINT_ERROR(("Failed to register cooling device (%d)\n", err));
-			goto cooling_failed;
-		} else {
-			MALI_DEBUG_PRINT(2, ("Mali GPU Thermal Cooling installed \n"));
-		}
-	}
-#endif
-
-	return 0;
-
-#ifdef CONFIG_DEVFREQ_THERMAL
-cooling_failed:
-	devfreq_unregister_opp_notifier(mdev->dev, mdev->devfreq);
-#endif /* CONFIG_DEVFREQ_THERMAL */
-opp_notifier_failed:
-	err = devfreq_remove_device(mdev->devfreq);
-	if (err)
-		MALI_PRINT_ERROR(("Failed to terminate devfreq (%d)\n", err));
-	else
-		mdev->devfreq = NULL;
-
-	return err;
-}
-
-void mali_devfreq_term(struct mali_device *mdev)
-{
-	int err;
-
-	MALI_DEBUG_PRINT(2, ("Term Mali devfreq\n"));
-
-#ifdef CONFIG_DEVFREQ_THERMAL
-	devfreq_cooling_unregister(mdev->devfreq_cooling);
-#endif
-
-	devfreq_unregister_opp_notifier(mdev->dev, mdev->devfreq);
-
-	err = devfreq_remove_device(mdev->devfreq);
-	if (err)
-		MALI_PRINT_ERROR(("Failed to terminate devfreq (%d)\n", err));
-	else
-		mdev->devfreq = NULL;
-}
diff --git a/drivers/gpu/arm/mali/linux/mali_devfreq.h b/drivers/gpu/arm/mali/linux/mali_devfreq.h
deleted file mode 100755
index faf84f25..00000000
--- a/drivers/gpu/arm/mali/linux/mali_devfreq.h
+++ /dev/null
@@ -1,17 +0,0 @@
-/*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-#ifndef _MALI_DEVFREQ_H_
-#define _MALI_DEVFREQ_H_
-
-int mali_devfreq_init(struct mali_device *mdev);
-
-void mali_devfreq_term(struct mali_device *mdev);
-
-#endif
diff --git a/drivers/gpu/arm/mali/linux/mali_device_pause_resume.c b/drivers/gpu/arm/mali/linux/mali_device_pause_resume.c
old mode 100755
new mode 100644
index cb2f702f..f54f4e67
--- a/drivers/gpu/arm/mali/linux/mali_device_pause_resume.c
+++ b/drivers/gpu/arm/mali/linux/mali_device_pause_resume.c
@@ -1,9 +1,9 @@
 /**
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_dma_fence.c b/drivers/gpu/arm/mali/linux/mali_dma_fence.c
deleted file mode 100755
index 9f9a5b6c..00000000
--- a/drivers/gpu/arm/mali/linux/mali_dma_fence.c
+++ /dev/null
@@ -1,354 +0,0 @@
-/*
- * Copyright (C) 2012-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-#include <linux/version.h>
-#include "mali_osk.h"
-#include "mali_kernel_common.h"
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
-#include "mali_dma_fence.h"
-#include <linux/atomic.h>
-#include <linux/workqueue.h>
-#endif
-
-static DEFINE_SPINLOCK(mali_dma_fence_lock);
-
-static bool mali_dma_fence_enable_signaling(struct fence *fence)
-{
-	MALI_IGNORE(fence);
-	return true;
-}
-
-static const char *mali_dma_fence_get_driver_name(struct fence *fence)
-{
-	MALI_IGNORE(fence);
-	return "mali";
-}
-
-static const char *mali_dma_fence_get_timeline_name(struct fence *fence)
-{
-	MALI_IGNORE(fence);
-	return "mali_dma_fence";
-}
-
-static const struct fence_ops mali_dma_fence_ops = {
-	.get_driver_name = mali_dma_fence_get_driver_name,
-	.get_timeline_name = mali_dma_fence_get_timeline_name,
-	.enable_signaling = mali_dma_fence_enable_signaling,
-	.signaled = NULL,
-	.wait = fence_default_wait,
-	.release = NULL
-};
-
-static void mali_dma_fence_context_cleanup(struct mali_dma_fence_context *dma_fence_context)
-{
-	u32 i;
-
-	MALI_DEBUG_ASSERT_POINTER(dma_fence_context);
-
-	for (i = 0; i < dma_fence_context->num_dma_fence_waiter; i++) {
-		if (dma_fence_context->mali_dma_fence_waiters[i]) {
-			fence_remove_callback(dma_fence_context->mali_dma_fence_waiters[i]->fence,
-					      &dma_fence_context->mali_dma_fence_waiters[i]->base);
-			fence_put(dma_fence_context->mali_dma_fence_waiters[i]->fence);
-			kfree(dma_fence_context->mali_dma_fence_waiters[i]);
-			dma_fence_context->mali_dma_fence_waiters[i] = NULL;
-		}
-	}
-
-	if (NULL != dma_fence_context->mali_dma_fence_waiters)
-		kfree(dma_fence_context->mali_dma_fence_waiters);
-
-	dma_fence_context->mali_dma_fence_waiters = NULL;
-	dma_fence_context->num_dma_fence_waiter = 0;
-}
-
-static void mali_dma_fence_context_work_func(struct work_struct *work_handle)
-{
-	struct mali_dma_fence_context *dma_fence_context;
-
-	MALI_DEBUG_ASSERT_POINTER(work_handle);
-
-	dma_fence_context = container_of(work_handle, struct mali_dma_fence_context, work_handle);
-
-	mali_dma_fence_context_cleanup(dma_fence_context);
-
-	dma_fence_context->cb_func(dma_fence_context->pp_job_ptr);
-}
-
-static void mali_dma_fence_callback(struct fence *fence, struct fence_cb *cb)
-{
-	struct mali_dma_fence_waiter *dma_fence_waiter = NULL;
-	struct mali_dma_fence_context *dma_fence_context = NULL;
-
-	MALI_DEBUG_ASSERT_POINTER(fence);
-	MALI_DEBUG_ASSERT_POINTER(cb);
-
-	MALI_IGNORE(fence);
-
-	dma_fence_waiter = container_of(cb, struct mali_dma_fence_waiter, base);
-	dma_fence_context = dma_fence_waiter->parent;
-
-	MALI_DEBUG_ASSERT_POINTER(dma_fence_context);
-
-	if (atomic_dec_and_test(&dma_fence_context->count))
-		schedule_work(&dma_fence_context->work_handle);
-}
-
-static _mali_osk_errcode_t mali_dma_fence_add_callback(struct mali_dma_fence_context *dma_fence_context, struct fence *fence)
-{
-	int ret = 0;
-	struct mali_dma_fence_waiter *dma_fence_waiter;
-	struct mali_dma_fence_waiter **dma_fence_waiters;
-
-	MALI_DEBUG_ASSERT_POINTER(dma_fence_context);
-	MALI_DEBUG_ASSERT_POINTER(fence);
-
-	dma_fence_waiters = krealloc(dma_fence_context->mali_dma_fence_waiters,
-				     (dma_fence_context->num_dma_fence_waiter + 1)
-				     * sizeof(struct mali_dma_fence_waiter *),
-				     GFP_KERNEL);
-
-	if (NULL == dma_fence_waiters) {
-		MALI_DEBUG_PRINT(1, ("Mali dma fence: failed to realloc the dma fence waiters.\n"));
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	dma_fence_context->mali_dma_fence_waiters = dma_fence_waiters;
-
-	dma_fence_waiter = kzalloc(sizeof(struct mali_dma_fence_waiter), GFP_KERNEL);
-
-	if (NULL == dma_fence_waiter) {
-		MALI_DEBUG_PRINT(1, ("Mali dma fence: failed to create mali dma fence waiter.\n"));
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	fence_get(fence);
-
-	dma_fence_waiter->fence = fence;
-	dma_fence_waiter->parent = dma_fence_context;
-	atomic_inc(&dma_fence_context->count);
-
-	ret = fence_add_callback(fence, &dma_fence_waiter->base,
-				 mali_dma_fence_callback);
-	if (0 > ret) {
-		fence_put(fence);
-		kfree(dma_fence_waiter);
-		atomic_dec(&dma_fence_context->count);
-		if (-ENOENT == ret) {
-			/*-ENOENT if fence has already been signaled, return _MALI_OSK_ERR_OK*/
-			return _MALI_OSK_ERR_OK;
-		}
-		/* Failed to add the fence callback into fence, return _MALI_OSK_ERR_FAULT*/
-		MALI_DEBUG_PRINT(1, ("Mali dma fence: failed to add callback into fence.\n"));
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	dma_fence_context->mali_dma_fence_waiters[dma_fence_context->num_dma_fence_waiter] = dma_fence_waiter;
-	dma_fence_context->num_dma_fence_waiter++;
-
-	return _MALI_OSK_ERR_OK;
-}
-
-
-struct fence *mali_dma_fence_new(u32  context, u32 seqno)
-{
-	struct fence *fence = NULL;
-
-	fence = kzalloc(sizeof(*fence), GFP_KERNEL);
-
-	if (NULL == fence) {
-		MALI_DEBUG_PRINT(1, ("Mali dma fence: failed to create dma fence.\n"));
-		return fence;
-	}
-
-	fence_init(fence,
-		   &mali_dma_fence_ops,
-		   &mali_dma_fence_lock,
-		   context, seqno);
-
-	return fence;
-}
-
-void mali_dma_fence_signal_and_put(struct fence **fence)
-{
-	MALI_DEBUG_ASSERT_POINTER(fence);
-	MALI_DEBUG_ASSERT_POINTER(*fence);
-
-	fence_signal(*fence);
-	fence_put(*fence);
-	*fence = NULL;
-}
-
-void mali_dma_fence_context_init(struct mali_dma_fence_context *dma_fence_context,
-				 mali_dma_fence_context_callback_func_t  cb_func,
-				 void *pp_job_ptr)
-{
-	MALI_DEBUG_ASSERT_POINTER(dma_fence_context);
-
-	INIT_WORK(&dma_fence_context->work_handle, mali_dma_fence_context_work_func);
-	atomic_set(&dma_fence_context->count, 1);
-	dma_fence_context->num_dma_fence_waiter = 0;
-	dma_fence_context->mali_dma_fence_waiters = NULL;
-	dma_fence_context->cb_func = cb_func;
-	dma_fence_context->pp_job_ptr = pp_job_ptr;
-}
-
-_mali_osk_errcode_t mali_dma_fence_context_add_waiters(struct mali_dma_fence_context *dma_fence_context,
-		struct reservation_object *dma_reservation_object)
-{
-	_mali_osk_errcode_t ret = _MALI_OSK_ERR_OK;
-	struct fence *exclusive_fence = NULL;
-	u32 shared_count = 0, i;
-	struct fence **shared_fences = NULL;
-
-	MALI_DEBUG_ASSERT_POINTER(dma_fence_context);
-	MALI_DEBUG_ASSERT_POINTER(dma_reservation_object);
-
-	/* Get all the shared/exclusive fences in the reservation object of dma buf*/
-	ret = reservation_object_get_fences_rcu(dma_reservation_object, &exclusive_fence,
-						&shared_count, &shared_fences);
-	if (ret < 0) {
-		MALI_DEBUG_PRINT(1, ("Mali dma fence: failed to get  shared or exclusive_fence dma fences from  the reservation object of dma buf.\n"));
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	if (exclusive_fence) {
-		ret = mali_dma_fence_add_callback(dma_fence_context, exclusive_fence);
-		if (_MALI_OSK_ERR_OK != ret) {
-			MALI_DEBUG_PRINT(1, ("Mali dma fence: failed to add callback into exclusive fence.\n"));
-			mali_dma_fence_context_cleanup(dma_fence_context);
-			goto ended;
-		}
-	}
-
-
-	for (i = 0; i < shared_count; i++) {
-		ret = mali_dma_fence_add_callback(dma_fence_context, shared_fences[i]);
-		if (_MALI_OSK_ERR_OK != ret) {
-			MALI_DEBUG_PRINT(1, ("Mali dma fence: failed to add callback into shared fence [%d].\n", i));
-			mali_dma_fence_context_cleanup(dma_fence_context);
-			break;
-		}
-	}
-
-ended:
-
-	if (exclusive_fence)
-		fence_put(exclusive_fence);
-
-	if (shared_fences) {
-		for (i = 0; i < shared_count; i++) {
-			fence_put(shared_fences[i]);
-		}
-		kfree(shared_fences);
-	}
-
-	return ret;
-}
-
-
-void mali_dma_fence_context_term(struct mali_dma_fence_context *dma_fence_context)
-{
-	MALI_DEBUG_ASSERT_POINTER(dma_fence_context);
-	atomic_set(&dma_fence_context->count, 0);
-	if (dma_fence_context->work_handle.func) {
-		cancel_work_sync(&dma_fence_context->work_handle);
-	}
-	mali_dma_fence_context_cleanup(dma_fence_context);
-}
-
-void mali_dma_fence_context_dec_count(struct mali_dma_fence_context *dma_fence_context)
-{
-	MALI_DEBUG_ASSERT_POINTER(dma_fence_context);
-
-	if (atomic_dec_and_test(&dma_fence_context->count))
-		schedule_work(&dma_fence_context->work_handle);
-}
-
-
-void mali_dma_fence_add_reservation_object_list(struct reservation_object *dma_reservation_object,
-		struct reservation_object **dma_reservation_object_list,
-		u32 *num_dma_reservation_object)
-{
-	u32 i;
-
-	MALI_DEBUG_ASSERT_POINTER(dma_reservation_object);
-	MALI_DEBUG_ASSERT_POINTER(dma_reservation_object_list);
-	MALI_DEBUG_ASSERT_POINTER(num_dma_reservation_object);
-
-	for (i = 0; i < *num_dma_reservation_object; i++) {
-		if (dma_reservation_object_list[i] == dma_reservation_object)
-			return;
-	}
-
-	dma_reservation_object_list[*num_dma_reservation_object] = dma_reservation_object;
-	(*num_dma_reservation_object)++;
-}
-
-int mali_dma_fence_lock_reservation_object_list(struct reservation_object **dma_reservation_object_list,
-		u32 num_dma_reservation_object, struct ww_acquire_ctx *ww_actx)
-{
-	u32 i;
-
-	struct reservation_object *reservation_object_to_slow_lock = NULL;
-
-	MALI_DEBUG_ASSERT_POINTER(dma_reservation_object_list);
-	MALI_DEBUG_ASSERT_POINTER(ww_actx);
-
-	ww_acquire_init(ww_actx, &reservation_ww_class);
-
-again:
-	for (i = 0; i < num_dma_reservation_object; i++) {
-		int ret;
-
-		if (dma_reservation_object_list[i] == reservation_object_to_slow_lock) {
-			reservation_object_to_slow_lock = NULL;
-			continue;
-		}
-
-		ret = ww_mutex_lock(&dma_reservation_object_list[i]->lock, ww_actx);
-
-		if (ret < 0) {
-			u32  slow_lock_index = i;
-
-			/* unlock all pre locks we have already locked.*/
-			while (i > 0) {
-				i--;
-				ww_mutex_unlock(&dma_reservation_object_list[i]->lock);
-			}
-
-			if (NULL != reservation_object_to_slow_lock)
-				ww_mutex_unlock(&reservation_object_to_slow_lock->lock);
-
-			if (ret == -EDEADLK) {
-				reservation_object_to_slow_lock = dma_reservation_object_list[slow_lock_index];
-				ww_mutex_lock_slow(&reservation_object_to_slow_lock->lock, ww_actx);
-				goto again;
-			}
-			ww_acquire_fini(ww_actx);
-			MALI_DEBUG_PRINT(1, ("Mali dma fence: failed to lock all dma reservation objects.\n", i));
-			return ret;
-		}
-	}
-
-	ww_acquire_done(ww_actx);
-	return 0;
-}
-
-void mali_dma_fence_unlock_reservation_object_list(struct reservation_object **dma_reservation_object_list,
-		u32 num_dma_reservation_object, struct ww_acquire_ctx *ww_actx)
-{
-	u32 i;
-
-	for (i = 0; i < num_dma_reservation_object; i++)
-		ww_mutex_unlock(&dma_reservation_object_list[i]->lock);
-
-	ww_acquire_fini(ww_actx);
-}
diff --git a/drivers/gpu/arm/mali/linux/mali_dma_fence.h b/drivers/gpu/arm/mali/linux/mali_dma_fence.h
deleted file mode 100755
index 35534e2c..00000000
--- a/drivers/gpu/arm/mali/linux/mali_dma_fence.h
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (C) 2012-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-/**
- * @file mali_dma_fence.h
- *
- * Mali interface for Linux dma buf fence objects.
- */
-
-#ifndef _MALI_DMA_FENCE_H_
-#define _MALI_DMA_FENCE_H_
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 17, 0)
-#include <linux/fence.h>
-#include <linux/reservation.h>
-#endif
-
-struct mali_dma_fence_context;
-
-/* The mali dma fence context callback function */
-typedef void (*mali_dma_fence_context_callback_func_t)(void *pp_job_ptr);
-
-struct mali_dma_fence_waiter {
-	struct fence_cb base;
-	struct mali_dma_fence_context *parent;
-	struct fence *fence;
-};
-
-struct mali_dma_fence_context {
-	struct work_struct work_handle;
-	struct mali_dma_fence_waiter **mali_dma_fence_waiters;
-	u32 num_dma_fence_waiter;
-	atomic_t count;
-	void *pp_job_ptr; /* the mali pp job pointer */;
-	mali_dma_fence_context_callback_func_t cb_func;
-};
-
-/* Create a dma fence
- * @param context The execution context this fence is run on
- * @param seqno A linearly increasing sequence number for this context
- * @return the new dma fence if success, or NULL on failure.
- */
-struct fence *mali_dma_fence_new(u32  context, u32 seqno);
-
-/* Signal and put dma fence
- * @param fence The dma fence to signal and put
- */
-void mali_dma_fence_signal_and_put(struct fence **fence);
-
-/**
- * Initialize a mali dma fence context for pp job.
- * @param dma_fence_context The mali dma fence context to initialize.
- * @param cb_func The dma fence context callback function to call when all dma fence release.
- * @param pp_job_ptr The pp_job to call function with.
- */
-void mali_dma_fence_context_init(struct mali_dma_fence_context *dma_fence_context,
-				 mali_dma_fence_context_callback_func_t  cb_func,
-				 void *pp_job_ptr);
-
-/**
- * Add new mali dma fence waiter into mali dma fence context
- * @param dma_fence_context The mali dma fence context
- * @param dma_reservation_object the reservation object to create new mali dma fence waiters
- * @return _MALI_OSK_ERR_OK if success, or not.
- */
-_mali_osk_errcode_t mali_dma_fence_context_add_waiters(struct mali_dma_fence_context *dma_fence_context,
-		struct reservation_object *dma_reservation_object);
-
-/**
- * Release the dma fence context
- * @param dma_fence_text The mali dma fence context.
- */
-void mali_dma_fence_context_term(struct mali_dma_fence_context *dma_fence_context);
-
-/**
- * Decrease the dma fence context atomic count
- * @param dma_fence_text The mali dma fence context.
- */
-void mali_dma_fence_context_dec_count(struct mali_dma_fence_context *dma_fence_context);
-
-/**
- * Get all reservation object
- * @param dma_reservation_object The reservation object to add into the reservation object list
- * @param dma_reservation_object_list The reservation object list to store all reservation object
- * @param num_dma_reservation_object The number of all reservation object
- */
-void mali_dma_fence_add_reservation_object_list(struct reservation_object *dma_reservation_object,
-		struct reservation_object **dma_reservation_object_list,
-		u32 *num_dma_reservation_object);
-
-/**
- * Wait/wound mutex lock to lock all reservation object.
- */
-int mali_dma_fence_lock_reservation_object_list(struct reservation_object **dma_reservation_object_list,
-		u32  num_dma_reservation_object, struct ww_acquire_ctx *ww_actx);
-
-/**
- * Wait/wound mutex lock to unlock all reservation object.
- */
-void mali_dma_fence_unlock_reservation_object_list(struct reservation_object **dma_reservation_object_list,
-		u32 num_dma_reservation_object, struct ww_acquire_ctx *ww_actx);
-#endif
diff --git a/drivers/gpu/arm/mali/linux/mali_kernel_linux.c b/drivers/gpu/arm/mali/linux/mali_kernel_linux.c
old mode 100755
new mode 100644
index 736e068c..4cd2f704
--- a/drivers/gpu/arm/mali/linux/mali_kernel_linux.c
+++ b/drivers/gpu/arm/mali/linux/mali_kernel_linux.c
@@ -1,9 +1,9 @@
 /**
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -24,8 +24,6 @@
 #include <linux/miscdevice.h>
 #include <linux/bug.h>
 #include <linux/of.h>
-#include <linux/clk.h>
-#include <linux/regulator/consumer.h>
 
 #include <linux/mali/mali_utgard.h>
 #include "mali_kernel_common.h"
@@ -41,14 +39,12 @@
 #include "mali_memory.h"
 #include "mali_memory_dma_buf.h"
 #include "mali_memory_manager.h"
-#include "mali_memory_swap_alloc.h"
 #if defined(CONFIG_MALI400_INTERNAL_PROFILING)
 #include "mali_profiling_internal.h"
 #endif
 #if defined(CONFIG_MALI400_PROFILING) && defined(CONFIG_MALI_DVFS)
 #include "mali_osk_profiling.h"
 #include "mali_dvfs_policy.h"
-
 static int is_first_resume = 1;
 /*Store the clk and vol for boot/insmod and mali_resume*/
 static struct mali_gpu_clk_item mali_gpu_clk[2];
@@ -65,31 +61,12 @@ EXPORT_TRACEPOINT_SYMBOL_GPL(mali_hw_counter);
 EXPORT_TRACEPOINT_SYMBOL_GPL(mali_sw_counters);
 #endif /* CONFIG_TRACEPOINTS */
 
-#ifdef CONFIG_MALI_DEVFREQ
-#include "mali_devfreq.h"
-#include "mali_osk_mali.h"
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
-#include <linux/pm_opp.h>
-#else
-/* In 3.13 the OPP include header file, types, and functions were all
- * renamed. Use the old filename for the include, and define the new names to
- * the old, when an old kernel is detected.
- */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
-#include <linux/pm_opp.h>
-#else
-#include <linux/opp.h>
-#endif /* Linux >= 3.13*/
-#define dev_pm_opp_of_add_table of_init_opp_table
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
-#define dev_pm_opp_of_remove_table of_free_opp_table
-#endif /* Linux >= 3.19 */
-#endif /* Linux >= 4.4.0 */
-#endif
-
 /* from the __malidrv_build_info.c file that is generated during build */
 extern const char *__malidrv_build_info(void);
+extern void mali_post_init(void);
+extern int mali_pdev_dts_init(struct platform_device* mali_gpu_device);
+extern int mpgpu_class_init(void);
+extern void mpgpu_class_exit(void);
 
 /* Module parameter to control log level */
 int mali_debug_level = 2;
@@ -130,10 +107,6 @@ extern int mali_max_pp_cores_group_2;
 module_param(mali_max_pp_cores_group_2, int, S_IRUSR | S_IRGRP | S_IROTH);
 MODULE_PARM_DESC(mali_max_pp_cores_group_2, "Limit the number of PP cores to use from second PP group (Mali-450 only).");
 
-extern unsigned int mali_mem_swap_out_threshold_value;
-module_param(mali_mem_swap_out_threshold_value, uint, S_IRUSR | S_IRGRP | S_IROTH);
-MODULE_PARM_DESC(mali_mem_swap_out_threshold_value, "Threshold value used to limit how much swappable memory cached in Mali driver.");
-
 #if defined(CONFIG_MALI_DVFS)
 /** the max fps the same as display vsync default 60, can set by module insert parameter */
 extern int mali_max_system_fps;
@@ -231,7 +204,7 @@ static struct of_device_id base_dt_ids[] = {
 	{.compatible = "arm,mali-300"},
 	{.compatible = "arm,mali-400"},
 	{.compatible = "arm,mali-450"},
-	{.compatible = "arm,mali-470"},
+	{.compatible = "arm,mali-utgard"},
 	{},
 };
 
@@ -254,7 +227,7 @@ static struct platform_driver mali_platform_driver = {
 		.pm = &mali_dev_pm_ops,
 #endif
 #ifdef CONFIG_MALI_DT
-		.of_match_table = amlogic_mesonstream_dt_match,
+		.of_match_table = of_match_ptr(base_dt_ids),
 #endif
 	},
 };
@@ -391,9 +364,6 @@ void mali_init_cpu_time_counters_on_all_cpus(int print_only)
 }
 #endif
 
-extern int mpgpu_class_init(void);
-extern int mali_platform_device_register(void);
-
 int mali_module_init(void)
 {
 	int err = 0;
@@ -410,11 +380,15 @@ int mali_module_init(void)
 #endif
 
 	/* Initialize module wide settings */
+#ifdef MALI_FAKE_PLATFORM_DEVICE
+#ifndef CONFIG_MALI_DT
 	MALI_DEBUG_PRINT(2, ("mali_module_init() registering device\n"));
 	err = mali_platform_device_register();
 	if (0 != err) {
 		return err;
 	}
+#endif
+#endif
 
 	MALI_DEBUG_PRINT(2, ("mali_module_init() registering driver\n"));
 
@@ -451,9 +425,10 @@ int mali_module_init(void)
 				      0, 0, 0);
 #endif
 
-	mpgpu_class_init();
 	MALI_PRINT(("Mali device driver loaded\n"));
 
+	mpgpu_class_init();
+
 	return 0; /* Success */
 }
 
@@ -483,28 +458,14 @@ void mali_module_exit(void)
 #if defined(CONFIG_MALI400_INTERNAL_PROFILING)
 	_mali_internal_profiling_term();
 #endif
+	mpgpu_class_exit();
 
 	MALI_PRINT(("Mali device driver unloaded\n"));
 }
 
-#ifdef CONFIG_MALI_DEVFREQ
-struct mali_device *mali_device_alloc(void)
-{
-	return kzalloc(sizeof(struct mali_device), GFP_KERNEL);
-}
-
-void mali_device_free(struct mali_device *mdev)
-{
-	kfree(mdev);
-}
-#endif
-
 static int mali_probe(struct platform_device *pdev)
 {
 	int err;
-#ifdef CONFIG_MALI_DEVFREQ
-	struct mali_device *mdev;
-#endif
 
 	MALI_DEBUG_PRINT(2, ("mali_probe(): Called for platform device %s\n", pdev->name));
 
@@ -521,66 +482,10 @@ static int mali_probe(struct platform_device *pdev)
 	err = mali_platform_device_init(mali_platform_device);
 	if (0 != err) {
 		MALI_PRINT_ERROR(("mali_probe(): Failed to initialize platform device."));
-		mali_platform_device = NULL;
 		return -EFAULT;
 	}
 #endif
 
-#ifdef CONFIG_MALI_DEVFREQ
-	mdev = mali_device_alloc();
-	if (!mdev) {
-		MALI_PRINT_ERROR(("Can't allocate mali device private data\n"));
-		return -ENOMEM;
-	}
-
-	mdev->dev = &pdev->dev;
-	dev_set_drvdata(mdev->dev, mdev);
-
-	/*Initilization clock and regulator*/
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)) && defined(CONFIG_OF) \
-                        && defined(CONFIG_REGULATOR)
-	mdev->regulator = regulator_get_optional(mdev->dev, "mali");
-	if (IS_ERR_OR_NULL(mdev->regulator)) {
-		MALI_DEBUG_PRINT(2, ("Continuing without Mali regulator control\n"));
-		mdev->regulator = NULL;
-		/* Allow probe to continue without regulator */
-	}
-#endif /* LINUX_VERSION_CODE >= 3, 12, 0 */
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 7, 0)) && defined(CONFIG_OF) \
-                        && defined(CONFIG_PM_OPP)
-	/* Register the OPPs if they are available in device tree */
-	if (dev_pm_opp_of_add_table(mdev->dev) < 0)
-		MALI_DEBUG_PRINT(3, ("OPP table not found\n"));
-#endif
-
-	/* Need to name the gpu clock "clk_mali" in the device tree */
-	mdev->clock = clk_get(mdev->dev, "clk_mali");
-	if (IS_ERR_OR_NULL(mdev->clock)) {
-		MALI_DEBUG_PRINT(2, ("Continuing without Mali clock control\n"));
-		mdev->clock = NULL;
-		/* Allow probe to continue without clock. */
-	} else {
-		err = clk_prepare_enable(mdev->clock);
-		if (err) {
-			MALI_PRINT_ERROR(("Failed to prepare and enable clock (%d)\n", err));
-			goto clock_prepare_failed;
-		}
-	}
-
-	/* initilize pm metrics related */
-	if (mali_pm_metrics_init(mdev) < 0) {
-		MALI_DEBUG_PRINT(2, ("mali pm metrics init failed\n"));
-		goto pm_metrics_init_failed;
-	}
-
-	if (mali_devfreq_init(mdev) < 0) {
-		MALI_DEBUG_PRINT(2, ("mali devfreq init failed\n"));
-		goto devfreq_init_failed;
-	}
-#endif
-
-
 	if (_MALI_OSK_ERR_OK == _mali_osk_wq_init()) {
 		/* Initialize the Mali GPU HW specified by pdev */
 		if (_MALI_OSK_ERR_OK == mali_initialize_subsystems()) {
@@ -591,6 +496,7 @@ static int mali_probe(struct platform_device *pdev)
 				err = mali_sysfs_register(mali_dev_name);
 
 				if (0 == err) {
+					mali_post_init();
 					MALI_DEBUG_PRINT(2, ("mali_probe(): Successfully initialized driver for platform device %s\n", pdev->name));
 
 					return 0;
@@ -608,67 +514,17 @@ static int mali_probe(struct platform_device *pdev)
 		_mali_osk_wq_term();
 	}
 
-#ifdef CONFIG_MALI_DEVFREQ
-	mali_devfreq_term(mdev);
-devfreq_init_failed:
-	mali_pm_metrics_term(mdev);
-pm_metrics_init_failed:
-	clk_disable_unprepare(mdev->clock);
-clock_prepare_failed:
-	clk_put(mdev->clock);
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)) && defined(CONFIG_OF) \
-                        && defined(CONFIG_PM_OPP)
-	dev_pm_opp_of_remove_table(mdev->dev);
-#endif
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)) && defined(CONFIG_OF) \
-                        && defined(CONFIG_REGULATOR)
-	regulator_put(mdev->regulator);
-#endif /* LINUX_VERSION_CODE >= 3, 12, 0 */
-	mali_device_free(mdev);
-#endif
-
-#ifdef CONFIG_MALI_DT
-	mali_platform_device_deinit(mali_platform_device);
-#endif
 	mali_platform_device = NULL;
 	return -EFAULT;
 }
 
 static int mali_remove(struct platform_device *pdev)
 {
-#ifdef CONFIG_MALI_DEVFREQ
-	struct mali_device *mdev = dev_get_drvdata(&pdev->dev);
-#endif
-
 	MALI_DEBUG_PRINT(2, ("mali_remove() called for platform device %s\n", pdev->name));
 	mali_sysfs_unregister();
 	mali_miscdevice_unregister();
 	mali_terminate_subsystems();
 	_mali_osk_wq_term();
-
-#ifdef CONFIG_MALI_DEVFREQ
-	mali_devfreq_term(mdev);
-
-	mali_pm_metrics_term(mdev);
-
-	if (mdev->clock) {
-		clk_disable_unprepare(mdev->clock);
-		clk_put(mdev->clock);
-		mdev->clock = NULL;
-	}
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)) && defined(CONFIG_OF) \
-                        && defined(CONFIG_PM_OPP)
-	dev_pm_opp_of_remove_table(mdev->dev);
-#endif
-
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 12, 0)) && defined(CONFIG_OF) \
-                        && defined(CONFIG_REGULATOR)
-	regulator_put(mdev->regulator);
-#endif /* LINUX_VERSION_CODE >= 3, 12, 0 */
-	mali_device_free(mdev);
-#endif
-
 #ifdef CONFIG_MALI_DT
 	mali_platform_device_deinit(mali_platform_device);
 #endif
@@ -700,17 +556,6 @@ static void mali_miscdevice_unregister(void)
 
 static int mali_driver_suspend_scheduler(struct device *dev)
 {
-#ifdef CONFIG_MALI_DEVFREQ
-	struct mali_device *mdev = dev_get_drvdata(dev);
-	if (!mdev)
-		return -ENODEV;
-#endif
-
-#if defined(CONFIG_MALI_DEVFREQ) && \
-                (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
-	devfreq_suspend_device(mdev->devfreq);
-#endif
-
 	mali_pm_os_suspend(MALI_TRUE);
 	/* Tracing the frequency and voltage after mali is suspended */
 	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
@@ -724,12 +569,6 @@ static int mali_driver_suspend_scheduler(struct device *dev)
 
 static int mali_driver_resume_scheduler(struct device *dev)
 {
-#ifdef CONFIG_MALI_DEVFREQ
-	struct mali_device *mdev = dev_get_drvdata(dev);
-	if (!mdev)
-		return -ENODEV;
-#endif
-
 	/* Tracing the frequency and voltage after mali is resumed */
 #if defined(CONFIG_MALI400_PROFILING) && defined(CONFIG_MALI_DVFS)
 	/* Just call mali_get_current_gpu_clk_item() once,to record current clk info.*/
@@ -745,24 +584,12 @@ static int mali_driver_resume_scheduler(struct device *dev)
 				      0, 0, 0);
 #endif
 	mali_pm_os_resume();
-
-#if defined(CONFIG_MALI_DEVFREQ) && \
-                (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
-	devfreq_resume_device(mdev->devfreq);
-#endif
-
 	return 0;
 }
 
 #ifdef CONFIG_PM_RUNTIME
 static int mali_driver_runtime_suspend(struct device *dev)
 {
-#ifdef CONFIG_MALI_DEVFREQ
-	struct mali_device *mdev = dev_get_drvdata(dev);
-	if (!mdev)
-		return -ENODEV;
-#endif
-
 	if (MALI_TRUE == mali_pm_runtime_suspend()) {
 		/* Tracing the frequency and voltage after mali is suspended */
 		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
@@ -772,12 +599,6 @@ static int mali_driver_runtime_suspend(struct device *dev)
 					      0,
 					      0, 0, 0);
 
-#if defined(CONFIG_MALI_DEVFREQ) && \
-                (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
-		MALI_DEBUG_PRINT(4, ("devfreq_suspend_device: stop devfreq monitor\n"));
-		devfreq_suspend_device(mdev->devfreq);
-#endif
-
 		return 0;
 	} else {
 		return -EBUSY;
@@ -786,12 +607,6 @@ static int mali_driver_runtime_suspend(struct device *dev)
 
 static int mali_driver_runtime_resume(struct device *dev)
 {
-#ifdef CONFIG_MALI_DEVFREQ
-	struct mali_device *mdev = dev_get_drvdata(dev);
-	if (!mdev)
-		return -ENODEV;
-#endif
-
 	/* Tracing the frequency and voltage after mali is resumed */
 #if defined(CONFIG_MALI400_PROFILING) && defined(CONFIG_MALI_DVFS)
 	/* Just call mali_get_current_gpu_clk_item() once,to record current clk info.*/
@@ -808,12 +623,6 @@ static int mali_driver_runtime_resume(struct device *dev)
 #endif
 
 	mali_pm_runtime_resume();
-
-#if defined(CONFIG_MALI_DEVFREQ) && \
-                (LINUX_VERSION_CODE >= KERNEL_VERSION(3, 8, 0))
-	MALI_DEBUG_PRINT(4, ("devfreq_resume_device: start devfreq monitor\n"));
-	devfreq_resume_device(mdev->devfreq);
-#endif
 	return 0;
 }
 
@@ -845,8 +654,6 @@ static int mali_open(struct inode *inode, struct file *filp)
 	/* link in our session data */
 	filp->private_data = (void *)session_data;
 
-	filp->f_mapping = mali_mem_swap_get_global_swap_file()->f_mapping;
-
 	return 0;
 }
 
@@ -947,11 +754,6 @@ static int mali_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
 		err = request_high_priority_wrapper(session_data, (_mali_uk_request_high_priority_s __user *)arg);
 		break;
 
-	case MALI_IOC_PENDING_SUBMIT:
-		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_pending_submit_s), sizeof(u64)));
-		err = pending_submit_wrapper(session_data, (_mali_uk_pending_submit_s __user *)arg);
-		break;
-
 #if defined(CONFIG_MALI400_PROFILING)
 	case MALI_IOC_PROFILING_ADD_EVENT:
 		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_profiling_add_event_s), sizeof(u64)));
@@ -963,28 +765,22 @@ static int mali_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
 		err = profiling_report_sw_counters_wrapper(session_data, (_mali_uk_sw_counters_report_s __user *)arg);
 		break;
 
-	case MALI_IOC_PROFILING_STREAM_FD_GET:
-		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_profiling_stream_fd_get_s), sizeof(u64)));
-		err = profiling_get_stream_fd_wrapper(session_data, (_mali_uk_profiling_stream_fd_get_s __user *)arg);
-		break;
 
-	case MALI_IOC_PROILING_CONTROL_SET:
-		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_profiling_control_set_s), sizeof(u64)));
-		err = profiling_control_set_wrapper(session_data, (_mali_uk_profiling_control_set_s __user *)arg);
+	case MALI_IOC_PROFILING_MEMORY_USAGE_GET:
+		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_profiling_memory_usage_get_s), sizeof(u64)));
+		err = profiling_memory_usage_get_wrapper(session_data, (_mali_uk_profiling_memory_usage_get_s __user *)arg);
 		break;
+
 #else
 
 	case MALI_IOC_PROFILING_ADD_EVENT:          /* FALL-THROUGH */
 	case MALI_IOC_PROFILING_REPORT_SW_COUNTERS: /* FALL-THROUGH */
+	case MALI_IOC_PROFILING_MEMORY_USAGE_GET:   /* FALL-THROUGH */
 		MALI_DEBUG_PRINT(2, ("Profiling not supported\n"));
 		err = -ENOTTY;
 		break;
-#endif
 
-	case MALI_IOC_PROFILING_MEMORY_USAGE_GET:
-		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_profiling_memory_usage_get_s), sizeof(u64)));
-		err = mem_usage_get_wrapper(session_data, (_mali_uk_profiling_memory_usage_get_s __user *)arg);
-		break;
+#endif
 
 	case MALI_IOC_MEM_ALLOC:
 		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_alloc_mem_s), sizeof(u64)));
@@ -1006,21 +802,6 @@ static int mali_ioctl(struct inode *inode, struct file *filp, unsigned int cmd,
 		err = mem_unbind_wrapper(session_data, (_mali_uk_unbind_mem_s __user *)arg);
 		break;
 
-	case MALI_IOC_MEM_COW:
-		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_cow_mem_s), sizeof(u64)));
-		err = mem_cow_wrapper(session_data, (_mali_uk_cow_mem_s __user *)arg);
-		break;
-
-	case MALI_IOC_MEM_COW_MODIFY_RANGE:
-		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_cow_modify_range_s), sizeof(u64)));
-		err = mem_cow_modify_range_wrapper(session_data, (_mali_uk_cow_modify_range_s __user *)arg);
-		break;
-
-	case MALI_IOC_MEM_RESIZE:
-		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_mem_resize_s), sizeof(u64)));
-		err = mem_resize_mem_wrapper(session_data, (_mali_uk_mem_resize_s __user *)arg);
-		break;
-
 	case MALI_IOC_MEM_WRITE_SAFE:
 		BUILD_BUG_ON(!IS_ALIGNED(sizeof(_mali_uk_mem_write_safe_s), sizeof(u64)));
 		err = mem_write_safe_wrapper(session_data, (_mali_uk_mem_write_safe_s __user *)arg);
diff --git a/drivers/gpu/arm/mali/linux/mali_kernel_linux.h b/drivers/gpu/arm/mali/linux/mali_kernel_linux.h
old mode 100755
new mode 100644
index 9b4307ef..2794bf2e
--- a/drivers/gpu/arm/mali/linux/mali_kernel_linux.h
+++ b/drivers/gpu/arm/mali/linux/mali_kernel_linux.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -20,15 +20,9 @@ extern "C" {
 #include <linux/rbtree.h>
 #include "mali_kernel_license.h"
 #include "mali_osk_types.h"
-#include <linux/version.h>
 
 extern struct platform_device *mali_platform_device;
 
-/* After 3.19.0 kenrel droped CONFIG_PM_RUNTIME define,define by ourself */
-#if defined(CONFIG_PM) && LINUX_VERSION_CODE >= KERNEL_VERSION(3, 19, 0)
-#define CONFIG_PM_RUNTIME 1
-#endif
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/gpu/arm/mali/linux/mali_kernel_sysfs.c b/drivers/gpu/arm/mali/linux/mali_kernel_sysfs.c
old mode 100755
new mode 100644
index 3b50af60..036f06fb
--- a/drivers/gpu/arm/mali/linux/mali_kernel_sysfs.c
+++ b/drivers/gpu/arm/mali/linux/mali_kernel_sysfs.c
@@ -1,9 +1,9 @@
 /**
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -880,17 +880,10 @@ static const struct file_operations profiling_events_human_readable_fops = {
 
 static int memory_debugfs_show(struct seq_file *s, void *private_data)
 {
-#ifdef MALI_MEM_SWAP_TRACKING
-	seq_printf(s, "  %-25s  %-10s  %-10s  %-15s  %-15s  %-10s  %-10s %-10s \n"\
-		   "=================================================================================================================================\n",
-		   "Name (:bytes)", "pid", "mali_mem", "max_mali_mem",
-		   "external_mem", "ump_mem", "dma_mem", "swap_mem");
-#else
-	seq_printf(s, "  %-25s  %-10s  %-10s  %-15s  %-15s  %-10s  %-10s \n"\
-		   "========================================================================================================================\n",
+	seq_printf(s, "  %-25s  %-10s  %-10s  %-15s  %-15s  %-10s  %-10s\n"\
+		   "==============================================================================================================\n",
 		   "Name (:bytes)", "pid", "mali_mem", "max_mali_mem",
 		   "external_mem", "ump_mem", "dma_mem");
-#endif
 	mali_session_memory_tracking(s);
 	return 0;
 }
@@ -1143,9 +1136,6 @@ static ssize_t version_read(struct file *filp, char __user *buf, size_t count, l
 	case _MALI_PRODUCT_ID_MALI450:
 		r = snprintf(buffer, 64, "Mali-450 MP\n");
 		break;
-	case _MALI_PRODUCT_ID_MALI470:
-		r = snprintf(buffer, 64, "Mali-470 MP\n");
-		break;
 	case _MALI_PRODUCT_ID_UNKNOWN:
 		return -EINVAL;
 		break;
diff --git a/drivers/gpu/arm/mali/linux/mali_kernel_sysfs.h b/drivers/gpu/arm/mali/linux/mali_kernel_sysfs.h
old mode 100755
new mode 100644
index 9dad7f24..11fa091e
--- a/drivers/gpu/arm/mali/linux/mali_kernel_sysfs.h
+++ b/drivers/gpu/arm/mali/linux/mali_kernel_sysfs.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_linux_trace.h b/drivers/gpu/arm/mali/linux/mali_linux_trace.h
old mode 100755
new mode 100644
index 2c91ddcd..5248b26e
--- a/drivers/gpu/arm/mali/linux/mali_linux_trace.h
+++ b/drivers/gpu/arm/mali/linux/mali_linux_trace.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_memory.c b/drivers/gpu/arm/mali/linux/mali_memory.c
old mode 100755
new mode 100644
index 3300885b..349ca0f2
--- a/drivers/gpu/arm/mali/linux/mali_memory.c
+++ b/drivers/gpu/arm/mali/linux/mali_memory.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -27,18 +27,11 @@
 #include "mali_memory_util.h"
 #include "mali_memory_virtual.h"
 #include "mali_memory_manager.h"
-#include "mali_memory_cow.h"
-#include "mali_memory_swap_alloc.h"
-#include "mali_memory_defer_bind.h"
-#if defined(CONFIG_DMA_SHARED_BUFFER)
-#include "mali_memory_secure.h"
-#endif
 
 extern unsigned int mali_dedicated_mem_size;
 extern unsigned int mali_shared_mem_size;
 
-#define MALI_VM_NUM_FAULT_PREFETCH (0x8)
-
+/* session->memory_lock must be held when calling this function */
 static void mali_mem_vma_open(struct vm_area_struct *vma)
 {
 	mali_mem_allocation *alloc = (mali_mem_allocation *)vma->vm_private_data;
@@ -59,75 +52,9 @@ static void mali_mem_vma_close(struct vm_area_struct *vma)
 
 static int mali_mem_vma_fault(struct vm_area_struct *vma, struct vm_fault *vmf)
 {
-	mali_mem_allocation *alloc = (mali_mem_allocation *)vma->vm_private_data;
-	mali_mem_backend *mem_bkend = NULL;
-	int ret;
-	int prefetch_num = MALI_VM_NUM_FAULT_PREFETCH;
-
-	unsigned long address = (unsigned long)vmf->virtual_address;
-	MALI_DEBUG_ASSERT(alloc->backend_handle);
-	MALI_DEBUG_ASSERT((unsigned long)alloc->cpu_mapping.addr <= address);
-
-	/* Get backend memory & Map on CPU */
-	mutex_lock(&mali_idr_mutex);
-	if (!(mem_bkend = idr_find(&mali_backend_idr, alloc->backend_handle))) {
-		MALI_DEBUG_PRINT(1, ("Can't find memory backend in mmap!\n"));
-		mutex_unlock(&mali_idr_mutex);
-		return VM_FAULT_SIGBUS;
-	}
-	mutex_unlock(&mali_idr_mutex);
-	MALI_DEBUG_ASSERT(mem_bkend->type == alloc->type);
-
-	if ((mem_bkend->type == MALI_MEM_COW && (MALI_MEM_BACKEND_FLAG_SWAP_COWED !=
-			(mem_bkend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED))) &&
-	    (mem_bkend->flags & MALI_MEM_BACKEND_FLAG_COW_CPU_NO_WRITE)) {
-		/*check if use page fault to do COW*/
-		MALI_DEBUG_PRINT(4, ("mali_vma_fault: do cow allocate on demand!, address=0x%x\n", address));
-		mutex_lock(&mem_bkend->mutex);
-		ret = mali_mem_cow_allocate_on_demand(mem_bkend,
-						      (address - vma->vm_start) / PAGE_SIZE);
-		mutex_unlock(&mem_bkend->mutex);
-
-		if (ret != _MALI_OSK_ERR_OK) {
-			return VM_FAULT_OOM;
-		}
-		prefetch_num = 1;
-
-		/* handle COW modified range cpu mapping
-		 we zap the mapping in cow_modify_range, it will trigger page fault
-		 when CPU access it, so here we map it to CPU*/
-		mutex_lock(&mem_bkend->mutex);
-		ret = mali_mem_cow_cpu_map_pages_locked(mem_bkend, vma, address, prefetch_num);
-		mutex_unlock(&mem_bkend->mutex);
-
-		if (unlikely(ret != _MALI_OSK_ERR_OK)) {
-			return VM_FAULT_SIGBUS;
-		}
-	} else if ((mem_bkend->type == MALI_MEM_SWAP) ||
-		   (mem_bkend->type == MALI_MEM_COW && (mem_bkend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED))) {
-		u32 offset_in_bkend = (address - vma->vm_start) / PAGE_SIZE;
-		int ret = _MALI_OSK_ERR_OK;
-
-		mutex_lock(&mem_bkend->mutex);
-		if (mem_bkend->flags & MALI_MEM_BACKEND_FLAG_COW_CPU_NO_WRITE) {
-			ret = mali_mem_swap_cow_page_on_demand(mem_bkend, offset_in_bkend, &vmf->page);
-		} else {
-			ret = mali_mem_swap_allocate_page_on_demand(mem_bkend, offset_in_bkend, &vmf->page);
-		}
-		mutex_unlock(&mem_bkend->mutex);
-
-		if (ret != _MALI_OSK_ERR_OK) {
-			MALI_DEBUG_PRINT(2, ("Mali swap memory page fault process failed, address=0x%x\n", address));
-			return VM_FAULT_OOM;
-		} else {
-			return VM_FAULT_LOCKED;
-		}
-	} else {
-		MALI_PRINT_ERROR(("Mali vma fault! It never happen, indicating some logic errors in caller.\n"));
-		/*NOT support yet or OOM*/
-		return VM_FAULT_OOM;
-	}
-	return VM_FAULT_NOPAGE;
+	/* Not support yet */
+	MALI_DEBUG_ASSERT(0);
+	return 0;
 }
 
 static struct vm_operations_struct mali_kernel_vm_ops = {
@@ -155,7 +82,7 @@ int mali_mmap(struct file *filp, struct vm_area_struct *vma)
 	u32 mali_addr = vma->vm_pgoff << PAGE_SHIFT;
 	struct mali_vma_node *mali_vma_node = NULL;
 	mali_mem_backend *mem_bkend = NULL;
-	int ret = -EFAULT;
+	int ret;
 
 	session = (struct mali_session_data *)filp->private_data;
 	if (NULL == session) {
@@ -167,8 +94,25 @@ int mali_mmap(struct file *filp, struct vm_area_struct *vma)
 			     (unsigned int)vma->vm_start, (unsigned int)(vma->vm_pgoff << PAGE_SHIFT),
 			     (unsigned int)(vma->vm_end - vma->vm_start), vma->vm_flags));
 
+	/* Set some bits which indicate that, the memory is IO memory, meaning
+	 * that no paging is to be performed and the memory should not be
+	 * included in crash dumps. And that the memory is reserved, meaning
+	 * that it's present and can never be paged out (see also previous
+	 * entry)
+	 */
+	vma->vm_flags |= VM_IO;
+	vma->vm_flags |= VM_DONTCOPY;
+	vma->vm_flags |= VM_PFNMAP;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0)
+	vma->vm_flags |= VM_RESERVED;
+#else
+	vma->vm_flags |= VM_DONTDUMP;
+	vma->vm_flags |= VM_DONTEXPAND;
+#endif
+
+	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
+	vma->vm_ops = &mali_kernel_vm_ops;
 	/* Operations used on any memory system */
-	/* do not need to anything in vm open/close now */
 
 	/* find mali allocation structure by vaddress*/
 	mali_vma_node = mali_vma_offset_search(&session->allocation_mgr, mali_addr, 0);
@@ -177,7 +121,6 @@ int mali_mmap(struct file *filp, struct vm_area_struct *vma)
 		MALI_DEBUG_ASSERT(mali_addr == mali_vma_node->vm_node.start);
 		if (unlikely(mali_addr != mali_vma_node->vm_node.start)) {
 			/* only allow to use start address for mmap */
-			MALI_DEBUG_PRINT(1, ("mali_addr != mali_vma_node->vm_node.start\n"));
 			return -EFAULT;
 		}
 	} else {
@@ -187,11 +130,6 @@ int mali_mmap(struct file *filp, struct vm_area_struct *vma)
 
 	mali_alloc->cpu_mapping.addr = (void __user *)vma->vm_start;
 
-	if (mali_alloc->flags & _MALI_MEMORY_ALLOCATE_DEFER_BIND) {
-		MALI_DEBUG_PRINT(1, ("ERROR : trying to access varying memory by CPU!\n"));
-		return -EFAULT;
-	}
-
 	/* Get backend memory & Map on CPU */
 	mutex_lock(&mali_idr_mutex);
 	if (!(mem_bkend = idr_find(&mali_backend_idr, mali_alloc->backend_handle))) {
@@ -201,77 +139,22 @@ int mali_mmap(struct file *filp, struct vm_area_struct *vma)
 	}
 	mutex_unlock(&mali_idr_mutex);
 
-	if (!(MALI_MEM_SWAP == mali_alloc->type ||
-	      (MALI_MEM_COW == mali_alloc->type && (mem_bkend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED)))) {
-		/* Set some bits which indicate that, the memory is IO memory, meaning
-		 * that no paging is to be performed and the memory should not be
-		 * included in crash dumps. And that the memory is reserved, meaning
-		 * that it's present and can never be paged out (see also previous
-		 * entry)
-		 */
-		vma->vm_flags |= VM_IO;
-		vma->vm_flags |= VM_DONTCOPY;
-		vma->vm_flags |= VM_PFNMAP;
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 7, 0)
-		vma->vm_flags |= VM_RESERVED;
-#else
-		vma->vm_flags |= VM_DONTDUMP;
-		vma->vm_flags |= VM_DONTEXPAND;
-#endif
-	} else if (MALI_MEM_SWAP == mali_alloc->type) {
-		vma->vm_pgoff = mem_bkend->start_idx;
-	}
-
-	vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
-	vma->vm_ops = &mali_kernel_vm_ops;
-
-	mali_alloc->cpu_mapping.addr = (void __user *)vma->vm_start;
-
-	/* If it's a copy-on-write mapping, map to read only */
-	if (!(vma->vm_flags & VM_WRITE)) {
-		MALI_DEBUG_PRINT(4, ("mmap allocation with read only !\n"));
-		/* add VM_WRITE for do_page_fault will check this when a write fault */
-		vma->vm_flags |= VM_WRITE | VM_READ;
-		vma->vm_page_prot = PAGE_READONLY;
-		vma->vm_page_prot = pgprot_writecombine(vma->vm_page_prot);
-		mem_bkend->flags |= MALI_MEM_BACKEND_FLAG_COW_CPU_NO_WRITE;
-		goto out;
-	}
-
 	if (mem_bkend->type == MALI_MEM_OS) {
-		ret = mali_mem_os_cpu_map(mem_bkend, vma);
-	} else if (mem_bkend->type == MALI_MEM_COW &&
-		   (MALI_MEM_BACKEND_FLAG_SWAP_COWED != (mem_bkend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED))) {
-		ret = mali_mem_cow_cpu_map(mem_bkend, vma);
+		ret = mali_mem_os_cpu_map(&mem_bkend->os_mem, vma);
 	} else if (mem_bkend->type == MALI_MEM_BLOCK) {
 		ret = mali_mem_block_cpu_map(mem_bkend, vma);
-	} else if ((mem_bkend->type == MALI_MEM_SWAP) || (mem_bkend->type == MALI_MEM_COW &&
-			(MALI_MEM_BACKEND_FLAG_SWAP_COWED == (mem_bkend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED)))) {
-		/*For swappable memory, CPU page table will be created by page fault handler. */
-		ret = 0;
-	} else if (mem_bkend->type == MALI_MEM_SECURE) {
-#if defined(CONFIG_DMA_SHARED_BUFFER)
-		ret = mali_mem_secure_cpu_map(mem_bkend, vma);
-#else
-		MALI_DEBUG_PRINT(1, ("DMA not supported for mali secure memory\n"));
-		return -EFAULT;
-#endif
 	} else {
 		/* Not support yet*/
-		MALI_DEBUG_PRINT_ERROR(("Invalid type of backend memory! \n"));
-		return -EFAULT;
+		MALI_DEBUG_ASSERT(0);
+		ret = -EFAULT;
 	}
 
-	if (ret != 0) {
-		MALI_DEBUG_PRINT(1, ("ret != 0\n"));
+	if (ret != 0)
 		return -EFAULT;
-	}
-out:
+
 	MALI_DEBUG_ASSERT(MALI_MEM_ALLOCATION_VALID_MAGIC == mali_alloc->magic);
 
 	vma->vm_private_data = (void *)mali_alloc;
-	mali_alloc->cpu_mapping.vma = vma;
-
 	mali_allocation_ref(mali_alloc);
 
 	return 0;
@@ -293,23 +176,6 @@ _mali_osk_errcode_t mali_mem_mali_map_prepare(mali_mem_allocation *descriptor)
 	return mali_mmu_pagedir_map(session->page_directory, descriptor->mali_vma_node.vm_node.start, size);
 }
 
-_mali_osk_errcode_t mali_mem_mali_map_resize(mali_mem_allocation *descriptor, u32 new_size)
-{
-	u32 old_size = descriptor->psize;
-	struct mali_session_data *session = descriptor->session;
-
-	MALI_DEBUG_ASSERT(MALI_MEM_ALLOCATION_VALID_MAGIC == descriptor->magic);
-
-	if (descriptor->flags & MALI_MEM_FLAG_MALI_GUARD_PAGE) {
-		new_size  += MALI_MMU_PAGE_SIZE;
-	}
-
-	if (new_size > old_size) {
-		MALI_DEBUG_ASSERT(new_size <= descriptor->mali_vma_node.vm_node.size);
-		return mali_mmu_pagedir_map(session->page_directory, descriptor->mali_vma_node.vm_node.start + old_size, new_size - old_size);
-	}
-	return _MALI_OSK_ERR_OK;
-}
 
 void mali_mem_mali_map_free(struct mali_session_data *session, u32 size, mali_address_t vaddr, u32 flags)
 {
@@ -355,12 +221,6 @@ _mali_osk_errcode_t mali_memory_session_begin(struct mali_session_data *session_
 				    _MALI_OSK_LOCK_ORDER_MEM_SESSION);
 
 	if (NULL == session_data->memory_lock) {
-		MALI_ERROR(_MALI_OSK_ERR_FAULT);
-	}
-
-	session_data->cow_lock = _mali_osk_mutex_init(_MALI_OSK_LOCKFLAG_UNORDERED, 0);
-	if (NULL == session_data->cow_lock) {
-		_mali_osk_mutex_term(session_data->memory_lock);
 		_mali_osk_free(session_data);
 		MALI_ERROR(_MALI_OSK_ERR_FAULT);
 	}
@@ -386,33 +246,19 @@ void mali_memory_session_end(struct mali_session_data *session)
 
 	/* Free the lock */
 	_mali_osk_mutex_term(session->memory_lock);
-	_mali_osk_mutex_term(session->cow_lock);
+
 	return;
 }
 
 _mali_osk_errcode_t mali_memory_initialize(void)
 {
-	_mali_osk_errcode_t err;
-
 	idr_init(&mali_backend_idr);
 	mutex_init(&mali_idr_mutex);
-
-	err = mali_mem_swap_init();
-	if (err != _MALI_OSK_ERR_OK) {
-		return err;
-	}
-	err = mali_mem_os_init();
-	if (_MALI_OSK_ERR_OK == err) {
-		err = mali_mem_defer_bind_manager_init();
-	}
-
-	return err;
+	return mali_mem_os_init();
 }
 
 void mali_memory_terminate(void)
 {
-	mali_mem_swap_term();
-	mali_mem_defer_bind_manager_destory();
 	mali_mem_os_term();
 	if (mali_memory_have_dedicated_memory()) {
 		mali_mem_block_allocator_destroy();
@@ -420,112 +266,3 @@ void mali_memory_terminate(void)
 }
 
 
-struct mali_page_node *_mali_page_node_allocate(mali_page_node_type type)
-{
-	mali_page_node *page_node = NULL;
-
-	page_node = kzalloc(sizeof(mali_page_node), GFP_KERNEL);
-	MALI_DEBUG_ASSERT(NULL != page_node);
-
-	if (page_node) {
-		page_node->type = type;
-		INIT_LIST_HEAD(&page_node->list);
-	}
-
-	return page_node;
-}
-
-void _mali_page_node_ref(struct mali_page_node *node)
-{
-	if (node->type == MALI_PAGE_NODE_OS) {
-		/* add ref to this page */
-		get_page(node->page);
-	} else if (node->type == MALI_PAGE_NODE_BLOCK) {
-		mali_mem_block_add_ref(node);
-	} else if (node->type == MALI_PAGE_NODE_SWAP) {
-		atomic_inc(&node->swap_it->ref_count);
-	} else {
-		MALI_DEBUG_PRINT_ERROR(("Invalid type of mali page node! \n"));
-	}
-}
-
-void _mali_page_node_unref(struct mali_page_node *node)
-{
-	if (node->type == MALI_PAGE_NODE_OS) {
-		/* unref to this page */
-		put_page(node->page);
-	} else if (node->type == MALI_PAGE_NODE_BLOCK) {
-		mali_mem_block_dec_ref(node);
-	} else {
-		MALI_DEBUG_PRINT_ERROR(("Invalid type of mali page node! \n"));
-	}
-}
-
-
-void _mali_page_node_add_page(struct mali_page_node *node, struct page *page)
-{
-	MALI_DEBUG_ASSERT(MALI_PAGE_NODE_OS == node->type);
-	node->page = page;
-}
-
-
-void _mali_page_node_add_swap_item(struct mali_page_node *node, struct mali_swap_item *item)
-{
-	MALI_DEBUG_ASSERT(MALI_PAGE_NODE_SWAP == node->type);
-	node->swap_it = item;
-}
-
-void _mali_page_node_add_block_item(struct mali_page_node *node, mali_block_item *item)
-{
-	MALI_DEBUG_ASSERT(MALI_PAGE_NODE_BLOCK == node->type);
-	node->blk_it = item;
-}
-
-
-int _mali_page_node_get_ref_count(struct mali_page_node *node)
-{
-	if (node->type == MALI_PAGE_NODE_OS) {
-		/* get ref count of this page */
-		return page_count(node->page);
-	} else if (node->type == MALI_PAGE_NODE_BLOCK) {
-		return mali_mem_block_get_ref_count(node);
-	} else if (node->type == MALI_PAGE_NODE_SWAP) {
-		return atomic_read(&node->swap_it->ref_count);
-	} else {
-		MALI_DEBUG_PRINT_ERROR(("Invalid type of mali page node! \n"));
-	}
-	return -1;
-}
-
-
-dma_addr_t _mali_page_node_get_dma_addr(struct mali_page_node *node)
-{
-	if (node->type == MALI_PAGE_NODE_OS) {
-		return page_private(node->page);
-	} else if (node->type == MALI_PAGE_NODE_BLOCK) {
-		return _mali_blk_item_get_phy_addr(node->blk_it);
-	} else if (node->type == MALI_PAGE_NODE_SWAP) {
-		return node->swap_it->dma_addr;
-	} else {
-		MALI_DEBUG_PRINT_ERROR(("Invalid type of mali page node! \n"));
-	}
-	return 0;
-}
-
-
-unsigned long _mali_page_node_get_pfn(struct mali_page_node *node)
-{
-	if (node->type == MALI_PAGE_NODE_OS) {
-		return page_to_pfn(node->page);
-	} else if (node->type == MALI_PAGE_NODE_BLOCK) {
-		/* get phy addr for BLOCK page*/
-		return _mali_blk_item_get_pfn(node->blk_it);
-	} else if (node->type == MALI_PAGE_NODE_SWAP) {
-		return page_to_pfn(node->swap_it->page);
-	} else {
-		MALI_DEBUG_PRINT_ERROR(("Invalid type of mali page node! \n"));
-	}
-	return 0;
-}
-
-
diff --git a/drivers/gpu/arm/mali/linux/mali_memory.h b/drivers/gpu/arm/mali/linux/mali_memory.h
old mode 100755
new mode 100644
index e5e4f66e..cf4bea93
--- a/drivers/gpu/arm/mali/linux/mali_memory.h
+++ b/drivers/gpu/arm/mali/linux/mali_memory.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -87,18 +87,6 @@ void mali_memory_session_end(struct mali_session_data *session);
  */
 _mali_osk_errcode_t mali_mem_mali_map_prepare(mali_mem_allocation *descriptor);
 
-/** @brief Resize Mali page tables for mapping
- *
- * This function will Resize the Mali page tables for mapping the memory
- * described by \a descriptor.
- *
- * Page tables will be reference counted and allocated, if not yet present.
- *
- * @param descriptor Pointer to the memory descriptor to the mapping
- * @param new_size The new size of descriptor
- */
-_mali_osk_errcode_t mali_mem_mali_map_resize(mali_mem_allocation *descriptor, u32 new_size);
-
 /** @brief Free Mali page tables for mapping
  *
  * This function will unmap pages from Mali memory and free the page tables
@@ -110,6 +98,7 @@ _mali_osk_errcode_t mali_mem_mali_map_resize(mali_mem_allocation *descriptor, u3
  */
 void mali_mem_mali_map_free(struct mali_session_data *session, u32 size, mali_address_t vaddr, u32 flags);
 
+
 /** @brief Parse resource and prepare the OS memory allocator
  *
  * @param size Maximum size to allocate for Mali GPU.
@@ -126,18 +115,4 @@ _mali_osk_errcode_t mali_memory_core_resource_os_memory(u32 size);
 _mali_osk_errcode_t mali_memory_core_resource_dedicated_memory(u32 start, u32 size);
 
 
-struct mali_page_node *_mali_page_node_allocate(mali_page_node_type type);
-
-void _mali_page_node_ref(struct mali_page_node *node);
-void _mali_page_node_unref(struct mali_page_node *node);
-void _mali_page_node_add_page(struct mali_page_node *node, struct page *page);
-
-void _mali_page_node_add_block_item(struct mali_page_node *node, mali_block_item *item);
-
-void _mali_page_node_add_swap_item(struct mali_page_node *node, struct mali_swap_item *item);
-
-int _mali_page_node_get_ref_count(struct mali_page_node *node);
-dma_addr_t _mali_page_node_get_dma_addr(struct mali_page_node *node);
-unsigned long _mali_page_node_get_pfn(struct mali_page_node *node);
-
 #endif /* __MALI_MEMORY_H__ */
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_block_alloc.c b/drivers/gpu/arm/mali/linux/mali_memory_block_alloc.c
old mode 100755
new mode 100644
index deb2ee84..22a7fdf4
--- a/drivers/gpu/arm/mali/linux/mali_memory_block_alloc.c
+++ b/drivers/gpu/arm/mali/linux/mali_memory_block_alloc.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -15,6 +15,80 @@
 #include <linux/mutex.h>
 
 
+struct mali_block_node *_mali_block_node_allocate(mali_page_node_type type)
+{
+	mali_block_node *block_node = NULL;
+
+	block_node = kzalloc(sizeof(mali_block_node), GFP_KERNEL);
+	MALI_DEBUG_ASSERT(NULL != block_node);
+
+	if (block_node) {
+		block_node->type = type;
+		INIT_LIST_HEAD(&block_node->list);
+	}
+
+	return block_node;
+}
+
+void _mali_block_node_ref(struct mali_block_node *node)
+{
+	if (node->type == MALI_PAGE_NODE_BLOCK) {
+		mali_mem_block_add_ref(node);
+	} else
+		MALI_DEBUG_ASSERT(0);
+}
+
+void _mali_block_node_unref(struct mali_block_node *node)
+{
+	if (node->type == MALI_PAGE_NODE_BLOCK) {
+		mali_mem_block_dec_ref(node);
+	} else
+		MALI_DEBUG_ASSERT(0);
+}
+
+
+
+void _mali_block_node_add_block_item(struct mali_block_node *node, mali_block_item *item)
+{
+	MALI_DEBUG_ASSERT(MALI_PAGE_NODE_BLOCK == node->type);
+	node->blk_it = item;
+}
+
+
+int _mali_block_node_get_ref_count(struct mali_block_node *node)
+{
+	if (node->type == MALI_PAGE_NODE_BLOCK) {
+		return mali_mem_block_get_ref_count(node);
+	} else {
+		MALI_DEBUG_ASSERT(0);
+	}
+	return -1;
+}
+
+
+dma_addr_t _mali_block_node_get_phy_addr(struct mali_block_node *node)
+{
+	if (node->type == MALI_PAGE_NODE_BLOCK) {
+		return _mali_blk_item_get_phy_addr(node->blk_it);
+	} else {
+		MALI_DEBUG_ASSERT(0);
+	}
+	return 0;
+}
+
+
+unsigned long _mali_block_node_get_pfn(struct mali_block_node *node)
+{
+	if (node->type == MALI_PAGE_NODE_BLOCK) {
+		/* get phy addr for BLOCK page*/
+		return _mali_blk_item_get_pfn(node->blk_it);
+	} else {
+		MALI_DEBUG_ASSERT(0);
+	}
+	return 0;
+}
+
+
 static mali_block_allocator *mali_mem_block_gobal_allocator = NULL;
 
 unsigned long _mali_blk_item_get_phy_addr(mali_block_item *item)
@@ -29,7 +103,7 @@ unsigned long _mali_blk_item_get_pfn(mali_block_item *item)
 }
 
 
-u32 mali_mem_block_get_ref_count(mali_page_node *node)
+u32 mali_mem_block_get_ref_count(mali_block_node *node)
 {
 	MALI_DEBUG_ASSERT(node->type == MALI_PAGE_NODE_BLOCK);
 	return (node->blk_it->phy_addr & MALI_BLOCK_REF_MASK);
@@ -40,7 +114,7 @@ u32 mali_mem_block_get_ref_count(mali_page_node *node)
 * It not atomic, so it need to get sp_lock before call this function
 */
 
-u32 mali_mem_block_add_ref(mali_page_node *node)
+u32 mali_mem_block_add_ref(mali_block_node *node)
 {
 	MALI_DEBUG_ASSERT(node->type == MALI_PAGE_NODE_BLOCK);
 	MALI_DEBUG_ASSERT(mali_mem_block_get_ref_count(node) < MALI_BLOCK_MAX_REF_COUNT);
@@ -50,7 +124,7 @@ u32 mali_mem_block_add_ref(mali_page_node *node)
 /* Decase the refence count
 * It not atomic, so it need to get sp_lock before call this function
 */
-u32 mali_mem_block_dec_ref(mali_page_node *node)
+u32 mali_mem_block_dec_ref(mali_block_node *node)
 {
 	MALI_DEBUG_ASSERT(node->type == MALI_PAGE_NODE_BLOCK);
 	MALI_DEBUG_ASSERT(mali_mem_block_get_ref_count(node) > 0);
@@ -63,7 +137,7 @@ static mali_block_allocator *mali_mem_block_allocator_create(u32 base_address, u
 	mali_block_allocator *info;
 	u32 usable_size;
 	u32 num_blocks;
-	mali_page_node *m_node;
+	mali_block_node *m_node;
 	mali_block_item *mali_blk_items = NULL;
 	int i = 0;
 
@@ -92,10 +166,10 @@ static mali_block_allocator *mali_mem_block_allocator_create(u32 base_address, u
 				/* add block information*/
 				mali_blk_items[i].phy_addr = base_address + (i * MALI_BLOCK_SIZE);
 				/* add  to free list */
-				m_node = _mali_page_node_allocate(MALI_PAGE_NODE_BLOCK);
+				m_node = _mali_block_node_allocate(MALI_PAGE_NODE_BLOCK);
 				if (m_node == NULL)
 					goto fail;
-				_mali_page_node_add_block_item(m_node, &(mali_blk_items[i]));
+				_mali_block_node_add_block_item(m_node, &(mali_blk_items[i]));
 				list_add_tail(&m_node->list, &info->free);
 				atomic_add(1, &info->free_num);
 			}
@@ -109,7 +183,7 @@ fail:
 
 void mali_mem_block_allocator_destroy(void)
 {
-	struct mali_page_node *m_page, *m_tmp;
+	struct mali_block_node *m_page, *m_tmp;
 	mali_block_allocator *info = mali_mem_block_gobal_allocator;
 	MALI_DEBUG_ASSERT_POINTER(info);
 	MALI_DEBUG_PRINT(4, ("Memory block destroy !\n"));
@@ -127,24 +201,22 @@ void mali_mem_block_allocator_destroy(void)
 	_mali_osk_free(info);
 }
 
-u32 mali_mem_block_release(mali_mem_backend *mem_bkend)
+void mali_mem_block_release(mali_mem_backend *mem_bkend)
 {
-	mali_mem_allocation *alloc = mem_bkend->mali_allocation;
-	u32 free_pages_nr = 0;
+	mali_mem_allocation *alloc = mem_bkend->mali_allocation;;
+	MALI_DEBUG_PRINT(4, ("BLOCK Mem: Release size = 0x%x\n", mem_bkend->size));
+
 	MALI_DEBUG_ASSERT(mem_bkend->type == MALI_MEM_BLOCK);
 
 	/* Unmap the memory from the mali virtual address space. */
 	mali_mem_block_mali_unmap(alloc);
-	mutex_lock(&mem_bkend->mutex);
-	free_pages_nr = mali_mem_block_free(&mem_bkend->block_mem);
-	mutex_unlock(&mem_bkend->mutex);
-	return free_pages_nr;
+	mali_mem_block_free(&mem_bkend->block_mem);
 }
 
 
 int mali_mem_block_alloc(mali_mem_block_mem *block_mem, u32 size)
 {
-	struct mali_page_node *m_page, *m_tmp;
+	struct mali_block_node *m_page, *m_tmp;
 	size_t page_count = PAGE_ALIGN(size) / _MALI_OSK_MALI_PAGE_SIZE;
 	mali_block_allocator *info = mali_mem_block_gobal_allocator;
 	MALI_DEBUG_ASSERT_POINTER(info);
@@ -163,7 +235,7 @@ int mali_mem_block_alloc(mali_mem_block_mem *block_mem, u32 size)
 				list_move(&m_page->list, &block_mem->pfns);
 				block_mem->count++;
 				atomic_dec(&info->free_num);
-				_mali_page_node_ref(m_page);
+				_mali_block_node_ref(m_page);
 			} else {
 				break;
 			}
@@ -179,99 +251,62 @@ int mali_mem_block_alloc(mali_mem_block_mem *block_mem, u32 size)
 	return 0;
 }
 
-u32 mali_mem_block_free(mali_mem_block_mem *block_mem)
+void mali_mem_block_free(mali_mem_block_mem *block_mem)
 {
-	u32 free_pages_nr = 0;
-
-	free_pages_nr = mali_mem_block_free_list(&block_mem->pfns);
-	MALI_DEBUG_PRINT(4, ("BLOCK Mem free : allocated size = 0x%x, free size = 0x%x\n", block_mem->count * _MALI_OSK_MALI_PAGE_SIZE,
-			     free_pages_nr * _MALI_OSK_MALI_PAGE_SIZE));
+	mali_mem_block_free_list(&block_mem->pfns);
+	MALI_DEBUG_PRINT(4, ("BLOCK Mem free : size = 0x%x\n", block_mem->count * _MALI_OSK_MALI_PAGE_SIZE));
 	block_mem->count = 0;
 	MALI_DEBUG_ASSERT(list_empty(&block_mem->pfns));
-
-	return free_pages_nr;
 }
 
 
-u32 mali_mem_block_free_list(struct list_head *list)
+void mali_mem_block_free_list(struct list_head *list)
 {
-	struct mali_page_node *m_page, *m_tmp;
+	struct mali_block_node *m_page, *m_tmp;
 	mali_block_allocator *info = mali_mem_block_gobal_allocator;
-	u32 free_pages_nr = 0;
 
 	if (info) {
 		spin_lock(&info->sp_lock);
 		list_for_each_entry_safe(m_page, m_tmp , list, list) {
-			if (1 == _mali_page_node_get_ref_count(m_page)) {
-				free_pages_nr++;
-			}
 			mali_mem_block_free_node(m_page);
 		}
 		spin_unlock(&info->sp_lock);
 	}
-	return free_pages_nr;
 }
 
 /* free the node,*/
-void mali_mem_block_free_node(struct mali_page_node *node)
+void mali_mem_block_free_node(struct mali_block_node *node)
 {
 	mali_block_allocator *info = mali_mem_block_gobal_allocator;
 
 	/* only handle BLOCK node */
 	if (node->type == MALI_PAGE_NODE_BLOCK && info) {
 		/*Need to make this atomic?*/
-		if (1 == _mali_page_node_get_ref_count(node)) {
+		if (1 == _mali_block_node_get_ref_count(node)) {
 			/*Move to free list*/
-			_mali_page_node_unref(node);
+			_mali_block_node_unref(node);
 			list_move_tail(&node->list, &info->free);
 			atomic_add(1, &info->free_num);
 		} else {
-			_mali_page_node_unref(node);
+			_mali_block_node_unref(node);
 			list_del(&node->list);
 			kfree(node);
 		}
 	}
 }
 
-/* unref the node, but not free it */
-_mali_osk_errcode_t mali_mem_block_unref_node(struct mali_page_node *node)
-{
-	mali_block_allocator *info = mali_mem_block_gobal_allocator;
-	mali_page_node *new_node;
-
-	/* only handle BLOCK node */
-	if (node->type == MALI_PAGE_NODE_BLOCK && info) {
-		/*Need to make this atomic?*/
-		if (1 == _mali_page_node_get_ref_count(node)) {
-			/* allocate a  new node, Add to free list, keep the old node*/
-			_mali_page_node_unref(node);
-			new_node = _mali_page_node_allocate(MALI_PAGE_NODE_BLOCK);
-			if (new_node) {
-				memcpy(new_node, node, sizeof(mali_page_node));
-				list_add(&new_node->list, &info->free);
-				atomic_add(1, &info->free_num);
-			} else
-				return _MALI_OSK_ERR_FAULT;
-
-		} else {
-			_mali_page_node_unref(node);
-		}
-	}
-	return _MALI_OSK_ERR_OK;
-}
-
 
 int mali_mem_block_mali_map(mali_mem_block_mem *block_mem, struct mali_session_data *session, u32 vaddr, u32 props)
 {
 	struct mali_page_directory *pagedir = session->page_directory;
-	struct mali_page_node *m_page;
+	struct mali_block_node *m_page;
 	dma_addr_t phys;
 	u32 virt = vaddr;
 	u32 prop = props;
 
 	list_for_each_entry(m_page, &block_mem->pfns, list) {
 		MALI_DEBUG_ASSERT(m_page->type == MALI_PAGE_NODE_BLOCK);
-		phys = _mali_page_node_get_dma_addr(m_page);
+		phys = _mali_block_node_get_phy_addr(m_page);
 #if defined(CONFIG_ARCH_DMA_ADDR_T_64BIT)
 		/* Verify that the "physical" address is 32-bit and
 		 * usable for Mali, when on a system with bus addresses
@@ -295,6 +330,7 @@ void mali_mem_block_mali_unmap(mali_mem_allocation *alloc)
 	mali_session_memory_lock(session);
 	mali_mem_mali_map_free(session, alloc->psize, alloc->mali_vma_node.vm_node.start,
 			       alloc->flags);
+	session->mali_mem_array[alloc->type] -= alloc->psize;
 	mali_session_memory_unlock(session);
 }
 
@@ -304,12 +340,12 @@ int mali_mem_block_cpu_map(mali_mem_backend *mem_bkend, struct vm_area_struct *v
 	int ret;
 	mali_mem_block_mem *block_mem = &mem_bkend->block_mem;
 	unsigned long addr = vma->vm_start;
-	struct mali_page_node *m_page;
+	struct mali_block_node *m_page;
 	MALI_DEBUG_ASSERT(mem_bkend->type == MALI_MEM_BLOCK);
 
 	list_for_each_entry(m_page, &block_mem->pfns, list) {
 		MALI_DEBUG_ASSERT(m_page->type == MALI_PAGE_NODE_BLOCK);
-		ret = vm_insert_pfn(vma, addr, _mali_page_node_get_pfn(m_page));
+		ret = vm_insert_pfn(vma, addr, _mali_block_node_get_pfn(m_page));
 
 		if (unlikely(0 != ret)) {
 			return -EFAULT;
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_block_alloc.h b/drivers/gpu/arm/mali/linux/mali_memory_block_alloc.h
old mode 100755
new mode 100644
index 3e11ef25..65b4969a
--- a/drivers/gpu/arm/mali/linux/mali_memory_block_alloc.h
+++ b/drivers/gpu/arm/mali/linux/mali_memory_block_alloc.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2013, 2015-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -37,10 +37,10 @@ typedef struct mali_block_allocator {
 
 unsigned long _mali_blk_item_get_phy_addr(mali_block_item *item);
 unsigned long _mali_blk_item_get_pfn(mali_block_item *item);
-u32 mali_mem_block_get_ref_count(mali_page_node *node);
-u32 mali_mem_block_add_ref(mali_page_node *node);
-u32 mali_mem_block_dec_ref(mali_page_node *node);
-u32 mali_mem_block_release(mali_mem_backend *mem_bkend);
+u32 mali_mem_block_get_ref_count(mali_block_node *node);
+u32 mali_mem_block_add_ref(mali_block_node *node);
+u32 mali_mem_block_dec_ref(mali_block_node *node);
+void mali_mem_block_release(mali_mem_backend *mem_bkend);
 int mali_mem_block_alloc(mali_mem_block_mem *block_mem, u32 size);
 int mali_mem_block_mali_map(mali_mem_block_mem *block_mem, struct mali_session_data *session, u32 vaddr, u32 props);
 void mali_mem_block_mali_unmap(mali_mem_allocation *alloc);
@@ -48,11 +48,10 @@ void mali_mem_block_mali_unmap(mali_mem_allocation *alloc);
 int mali_mem_block_cpu_map(mali_mem_backend *mem_bkend, struct vm_area_struct *vma);
 _mali_osk_errcode_t mali_memory_core_resource_dedicated_memory(u32 start, u32 size);
 mali_bool mali_memory_have_dedicated_memory(void);
-u32 mali_mem_block_free(mali_mem_block_mem *block_mem);
-u32 mali_mem_block_free_list(struct list_head *list);
-void mali_mem_block_free_node(struct mali_page_node *node);
+void mali_mem_block_free(mali_mem_block_mem *block_mem);
+void mali_mem_block_free_list(struct list_head *list);
+void mali_mem_block_free_node(struct mali_block_node *node);
 void mali_mem_block_allocator_destroy(void);
-_mali_osk_errcode_t mali_mem_block_unref_node(struct mali_page_node *node);
 u32 mali_mem_block_allocator_stat(void);
 
 #endif /* __MALI_BLOCK_ALLOCATOR_H__ */
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_cow.c b/drivers/gpu/arm/mali/linux/mali_memory_cow.c
deleted file mode 100755
index 54c66b81..00000000
--- a/drivers/gpu/arm/mali/linux/mali_memory_cow.c
+++ /dev/null
@@ -1,776 +0,0 @@
-/*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-#include <linux/mm.h>
-#include <linux/list.h>
-#include <linux/mm_types.h>
-#include <linux/fs.h>
-#include <linux/dma-mapping.h>
-#include <linux/highmem.h>
-#include <asm/cacheflush.h>
-#include <linux/sched.h>
-#ifdef CONFIG_ARM
-#include <asm/outercache.h>
-#endif
-#include <asm/dma-mapping.h>
-
-#include "mali_memory.h"
-#include "mali_kernel_common.h"
-#include "mali_uk_types.h"
-#include "mali_osk.h"
-#include "mali_kernel_linux.h"
-#include "mali_memory_cow.h"
-#include "mali_memory_block_alloc.h"
-#include "mali_memory_swap_alloc.h"
-
-/**
-* allocate pages for COW backend and flush cache
-*/
-static struct page *mali_mem_cow_alloc_page(void)
-
-{
-	mali_mem_os_mem os_mem;
-	struct mali_page_node *node;
-	struct page *new_page;
-
-	int ret = 0;
-	/* allocate pages from os mem */
-	ret = mali_mem_os_alloc_pages(&os_mem, _MALI_OSK_MALI_PAGE_SIZE);
-
-	if (ret) {
-		return NULL;
-	}
-
-	MALI_DEBUG_ASSERT(1 == os_mem.count);
-
-	node = _MALI_OSK_CONTAINER_OF(os_mem.pages.next, struct mali_page_node, list);
-	new_page = node->page;
-	node->page = NULL;
-	list_del(&node->list);
-	kfree(node);
-
-	return new_page;
-}
-
-
-static struct list_head *_mali_memory_cow_get_node_list(mali_mem_backend *target_bk,
-		u32 target_offset,
-		u32 target_size)
-{
-	MALI_DEBUG_ASSERT(MALI_MEM_OS == target_bk->type || MALI_MEM_COW == target_bk->type ||
-			  MALI_MEM_BLOCK == target_bk->type || MALI_MEM_SWAP == target_bk->type);
-
-	if (MALI_MEM_OS == target_bk->type) {
-		MALI_DEBUG_ASSERT(&target_bk->os_mem);
-		MALI_DEBUG_ASSERT(((target_size + target_offset) / _MALI_OSK_MALI_PAGE_SIZE) <= target_bk->os_mem.count);
-		return &target_bk->os_mem.pages;
-	} else if (MALI_MEM_COW == target_bk->type) {
-		MALI_DEBUG_ASSERT(&target_bk->cow_mem);
-		MALI_DEBUG_ASSERT(((target_size + target_offset) / _MALI_OSK_MALI_PAGE_SIZE) <= target_bk->cow_mem.count);
-		return  &target_bk->cow_mem.pages;
-	} else if (MALI_MEM_BLOCK == target_bk->type) {
-		MALI_DEBUG_ASSERT(&target_bk->block_mem);
-		MALI_DEBUG_ASSERT(((target_size + target_offset) / _MALI_OSK_MALI_PAGE_SIZE) <= target_bk->block_mem.count);
-		return  &target_bk->block_mem.pfns;
-	} else if (MALI_MEM_SWAP == target_bk->type) {
-		MALI_DEBUG_ASSERT(&target_bk->swap_mem);
-		MALI_DEBUG_ASSERT(((target_size + target_offset) / _MALI_OSK_MALI_PAGE_SIZE) <= target_bk->swap_mem.count);
-		return  &target_bk->swap_mem.pages;
-	}
-
-	return NULL;
-}
-
-/**
-* Do COW for os memory - support do COW for memory from bank memory
-* The range_start/size can be zero, which means it will call cow_modify_range
-* latter.
-* This function allocate new pages for COW backend from os mem for a modified range
-* It will keep the page which not in the modified range and Add ref to it
-*
-* @target_bk - target allocation's backend(the allocation need to do COW)
-* @target_offset - the offset in target allocation to do COW(for support COW  a memory allocated from memory_bank, 4K align)
-* @target_size - size of target allocation to do COW (for support memory bank)
-* @backend -COW backend
-* @range_start - offset of modified range (4K align)
-* @range_size - size of modified range
-*/
-_mali_osk_errcode_t mali_memory_cow_os_memory(mali_mem_backend *target_bk,
-		u32 target_offset,
-		u32 target_size,
-		mali_mem_backend *backend,
-		u32 range_start,
-		u32 range_size)
-{
-	mali_mem_cow *cow = &backend->cow_mem;
-	struct mali_page_node *m_page, *m_tmp, *page_node;
-	int target_page = 0;
-	struct page *new_page;
-	struct list_head *pages = NULL;
-
-	pages = _mali_memory_cow_get_node_list(target_bk, target_offset, target_size);
-
-	if (NULL == pages) {
-		MALI_DEBUG_PRINT_ERROR(("No memory page  need to cow ! \n"));
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	MALI_DEBUG_ASSERT(0 == cow->count);
-
-	INIT_LIST_HEAD(&cow->pages);
-	mutex_lock(&target_bk->mutex);
-	list_for_each_entry_safe(m_page, m_tmp, pages, list) {
-		/* add page from (target_offset,target_offset+size) to cow backend */
-		if ((target_page >= target_offset / _MALI_OSK_MALI_PAGE_SIZE) &&
-		    (target_page < ((target_size + target_offset) / _MALI_OSK_MALI_PAGE_SIZE))) {
-
-			/* allocate a new page node, alway use OS memory for COW */
-			page_node = _mali_page_node_allocate(MALI_PAGE_NODE_OS);
-
-			if (NULL == page_node) {
-				mutex_unlock(&target_bk->mutex);
-				goto error;
-			}
-
-			INIT_LIST_HEAD(&page_node->list);
-
-			/* check if in the modified range*/
-			if ((cow->count >= range_start / _MALI_OSK_MALI_PAGE_SIZE) &&
-			    (cow->count < (range_start + range_size) / _MALI_OSK_MALI_PAGE_SIZE)) {
-				/* need to allocate a new page */
-				/* To simplify the case, All COW memory is allocated from os memory ?*/
-				new_page = mali_mem_cow_alloc_page();
-
-				if (NULL == new_page) {
-					kfree(page_node);
-					mutex_unlock(&target_bk->mutex);
-					goto error;
-				}
-
-				_mali_page_node_add_page(page_node, new_page);
-			} else {
-				/*Add Block memory case*/
-				if (m_page->type != MALI_PAGE_NODE_BLOCK) {
-					_mali_page_node_add_page(page_node, m_page->page);
-				} else {
-					page_node->type = MALI_PAGE_NODE_BLOCK;
-					_mali_page_node_add_block_item(page_node, m_page->blk_it);
-				}
-
-				/* add ref to this page */
-				_mali_page_node_ref(m_page);
-			}
-
-			/* add it to COW backend page list */
-			list_add_tail(&page_node->list, &cow->pages);
-			cow->count++;
-		}
-		target_page++;
-	}
-	mutex_unlock(&target_bk->mutex);
-	return _MALI_OSK_ERR_OK;
-error:
-	mali_mem_cow_release(backend, MALI_FALSE);
-	return _MALI_OSK_ERR_FAULT;
-}
-
-_mali_osk_errcode_t mali_memory_cow_swap_memory(mali_mem_backend *target_bk,
-		u32 target_offset,
-		u32 target_size,
-		mali_mem_backend *backend,
-		u32 range_start,
-		u32 range_size)
-{
-	mali_mem_cow *cow = &backend->cow_mem;
-	struct mali_page_node *m_page, *m_tmp, *page_node;
-	int target_page = 0;
-	struct mali_swap_item *swap_item;
-	struct list_head *pages = NULL;
-
-	pages = _mali_memory_cow_get_node_list(target_bk, target_offset, target_size);
-	if (NULL == pages) {
-		MALI_DEBUG_PRINT_ERROR(("No swap memory page need to cow ! \n"));
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	MALI_DEBUG_ASSERT(0 == cow->count);
-
-	INIT_LIST_HEAD(&cow->pages);
-	mutex_lock(&target_bk->mutex);
-
-	backend->flags |= MALI_MEM_BACKEND_FLAG_UNSWAPPED_IN;
-
-	list_for_each_entry_safe(m_page, m_tmp, pages, list) {
-		/* add page from (target_offset,target_offset+size) to cow backend */
-		if ((target_page >= target_offset / _MALI_OSK_MALI_PAGE_SIZE) &&
-		    (target_page < ((target_size + target_offset) / _MALI_OSK_MALI_PAGE_SIZE))) {
-
-			/* allocate a new page node, use swap memory for COW memory swap cowed flag. */
-			page_node = _mali_page_node_allocate(MALI_PAGE_NODE_SWAP);
-
-			if (NULL == page_node) {
-				mutex_unlock(&target_bk->mutex);
-				goto error;
-			}
-
-			/* check if in the modified range*/
-			if ((cow->count >= range_start / _MALI_OSK_MALI_PAGE_SIZE) &&
-			    (cow->count < (range_start + range_size) / _MALI_OSK_MALI_PAGE_SIZE)) {
-				/* need to allocate a new page */
-				/* To simplify the case, All COW memory is allocated from os memory ?*/
-				swap_item = mali_mem_swap_alloc_swap_item();
-
-				if (NULL == swap_item) {
-					kfree(page_node);
-					mutex_unlock(&target_bk->mutex);
-					goto error;
-				}
-
-				swap_item->idx = mali_mem_swap_idx_alloc();
-
-				if (_MALI_OSK_BITMAP_INVALIDATE_INDEX == swap_item->idx) {
-					MALI_DEBUG_PRINT(1, ("Failed to allocate swap index in swap CoW.\n"));
-					kfree(page_node);
-					kfree(swap_item);
-					mutex_unlock(&target_bk->mutex);
-					goto error;
-				}
-
-				_mali_page_node_add_swap_item(page_node, swap_item);
-			} else {
-				_mali_page_node_add_swap_item(page_node, m_page->swap_it);
-
-				/* add ref to this page */
-				_mali_page_node_ref(m_page);
-			}
-
-			list_add_tail(&page_node->list, &cow->pages);
-			cow->count++;
-		}
-		target_page++;
-	}
-	mutex_unlock(&target_bk->mutex);
-
-	return _MALI_OSK_ERR_OK;
-error:
-	mali_mem_swap_release(backend, MALI_FALSE);
-	return _MALI_OSK_ERR_FAULT;
-
-}
-
-
-_mali_osk_errcode_t _mali_mem_put_page_node(mali_page_node *node)
-{
-	if (node->type == MALI_PAGE_NODE_OS) {
-		return mali_mem_os_put_page(node->page);
-	} else if (node->type == MALI_PAGE_NODE_BLOCK) {
-		return mali_mem_block_unref_node(node);
-	} else if (node->type == MALI_PAGE_NODE_SWAP) {
-		return _mali_mem_swap_put_page_node(node);
-	} else
-		MALI_DEBUG_ASSERT(0);
-	return _MALI_OSK_ERR_FAULT;
-}
-
-
-/**
-* Modify a range of a exist COW backend
-* @backend -COW backend
-* @range_start - offset of modified range (4K align)
-* @range_size - size of modified range(in byte)
-*/
-_mali_osk_errcode_t mali_memory_cow_modify_range(mali_mem_backend *backend,
-		u32 range_start,
-		u32 range_size)
-{
-	mali_mem_allocation *alloc = NULL;
-	struct mali_session_data *session;
-	mali_mem_cow *cow = &backend->cow_mem;
-	struct mali_page_node *m_page, *m_tmp;
-	LIST_HEAD(pages);
-	struct page *new_page;
-	u32 count = 0;
-	s32 change_pages_nr = 0;
-	_mali_osk_errcode_t ret = _MALI_OSK_ERR_OK;
-
-	if (range_start % _MALI_OSK_MALI_PAGE_SIZE) MALI_ERROR(_MALI_OSK_ERR_INVALID_ARGS);
-	if (range_size % _MALI_OSK_MALI_PAGE_SIZE) MALI_ERROR(_MALI_OSK_ERR_INVALID_ARGS);
-
-	alloc = backend->mali_allocation;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-
-	session = alloc->session;
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	MALI_DEBUG_ASSERT(MALI_MEM_COW == backend->type);
-	MALI_DEBUG_ASSERT(((range_start + range_size) / _MALI_OSK_MALI_PAGE_SIZE) <= cow->count);
-
-	mutex_lock(&backend->mutex);
-
-	/* free pages*/
-	list_for_each_entry_safe(m_page, m_tmp, &cow->pages, list) {
-
-		/* check if in the modified range*/
-		if ((count >= range_start / _MALI_OSK_MALI_PAGE_SIZE) &&
-		    (count < (range_start + range_size) / _MALI_OSK_MALI_PAGE_SIZE)) {
-			if (MALI_PAGE_NODE_SWAP != m_page->type) {
-				new_page = mali_mem_cow_alloc_page();
-
-				if (NULL == new_page) {
-					goto error;
-				}
-				if (1 != _mali_page_node_get_ref_count(m_page))
-					change_pages_nr++;
-				/* unref old page*/
-				_mali_osk_mutex_wait(session->cow_lock);
-				if (_mali_mem_put_page_node(m_page)) {
-					__free_page(new_page);
-					_mali_osk_mutex_signal(session->cow_lock);
-					goto error;
-				}
-				_mali_osk_mutex_signal(session->cow_lock);
-				/* add new page*/
-				/* always use OS for COW*/
-				m_page->type = MALI_PAGE_NODE_OS;
-				_mali_page_node_add_page(m_page, new_page);
-			} else {
-				struct mali_swap_item *swap_item;
-
-				swap_item = mali_mem_swap_alloc_swap_item();
-
-				if (NULL == swap_item) {
-					goto error;
-				}
-
-				swap_item->idx = mali_mem_swap_idx_alloc();
-
-				if (_MALI_OSK_BITMAP_INVALIDATE_INDEX == swap_item->idx) {
-					MALI_DEBUG_PRINT(1, ("Failed to allocate swap index in swap CoW modify range.\n"));
-					kfree(swap_item);
-					goto error;
-				}
-
-				if (1 != _mali_page_node_get_ref_count(m_page)) {
-					change_pages_nr++;
-				}
-
-				if (_mali_mem_put_page_node(m_page)) {
-					mali_mem_swap_free_swap_item(swap_item);
-					goto error;
-				}
-
-				_mali_page_node_add_swap_item(m_page, swap_item);
-			}
-		}
-		count++;
-	}
-	cow->change_pages_nr  = change_pages_nr;
-
-	MALI_DEBUG_ASSERT(MALI_MEM_COW == alloc->type);
-
-	/* ZAP cpu mapping(modified range), and do cpu mapping here if need */
-	if (NULL != alloc->cpu_mapping.vma) {
-		MALI_DEBUG_ASSERT(0 != alloc->backend_handle);
-		MALI_DEBUG_ASSERT(NULL != alloc->cpu_mapping.vma);
-		MALI_DEBUG_ASSERT(alloc->cpu_mapping.vma->vm_end - alloc->cpu_mapping.vma->vm_start >= range_size);
-
-		if (MALI_MEM_BACKEND_FLAG_SWAP_COWED != (backend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED)) {
-			zap_vma_ptes(alloc->cpu_mapping.vma, alloc->cpu_mapping.vma->vm_start + range_start, range_size);
-
-			ret = mali_mem_cow_cpu_map_pages_locked(backend, alloc->cpu_mapping.vma, alloc->cpu_mapping.vma->vm_start  + range_start, range_size / _MALI_OSK_MALI_PAGE_SIZE);
-
-			if (unlikely(ret != _MALI_OSK_ERR_OK)) {
-				MALI_DEBUG_PRINT(2, ("mali_memory_cow_modify_range: cpu mapping failed !\n"));
-				ret =  _MALI_OSK_ERR_FAULT;
-			}
-		} else {
-			/* used to trigger page fault for swappable cowed memory. */
-			alloc->cpu_mapping.vma->vm_flags |= VM_PFNMAP;
-			alloc->cpu_mapping.vma->vm_flags |= VM_MIXEDMAP;
-
-			zap_vma_ptes(alloc->cpu_mapping.vma, alloc->cpu_mapping.vma->vm_start + range_start, range_size);
-			/* delete this flag to let swappble is ummapped regard to stauct page not page frame. */
-			alloc->cpu_mapping.vma->vm_flags &= ~VM_PFNMAP;
-			alloc->cpu_mapping.vma->vm_flags &= ~VM_MIXEDMAP;
-		}
-	}
-
-error:
-	mutex_unlock(&backend->mutex);
-	return ret;
-
-}
-
-
-/**
-* Allocate pages for COW backend
-* @alloc  -allocation for COW allocation
-* @target_bk - target allocation's backend(the allocation need to do COW)
-* @target_offset - the offset in target allocation to do COW(for support COW  a memory allocated from memory_bank, 4K align)
-* @target_size - size of target allocation to do COW (for support memory bank)(in byte)
-* @backend -COW backend
-* @range_start - offset of modified range (4K align)
-* @range_size - size of modified range(in byte)
-*/
-_mali_osk_errcode_t mali_memory_do_cow(mali_mem_backend *target_bk,
-				       u32 target_offset,
-				       u32 target_size,
-				       mali_mem_backend *backend,
-				       u32 range_start,
-				       u32 range_size)
-{
-	struct mali_session_data *session = backend->mali_allocation->session;
-
-	MALI_CHECK_NON_NULL(session, _MALI_OSK_ERR_INVALID_ARGS);
-
-	/* size & offset must be a multiple of the system page size */
-	if (target_size % _MALI_OSK_MALI_PAGE_SIZE) MALI_ERROR(_MALI_OSK_ERR_INVALID_ARGS);
-	if (range_size % _MALI_OSK_MALI_PAGE_SIZE) MALI_ERROR(_MALI_OSK_ERR_INVALID_ARGS);
-	if (target_offset % _MALI_OSK_MALI_PAGE_SIZE) MALI_ERROR(_MALI_OSK_ERR_INVALID_ARGS);
-	if (range_start % _MALI_OSK_MALI_PAGE_SIZE) MALI_ERROR(_MALI_OSK_ERR_INVALID_ARGS);
-
-	/* check backend type */
-	MALI_DEBUG_ASSERT(MALI_MEM_COW == backend->type);
-
-	switch (target_bk->type) {
-	case MALI_MEM_OS:
-	case MALI_MEM_BLOCK:
-		return mali_memory_cow_os_memory(target_bk, target_offset, target_size, backend, range_start, range_size);
-		break;
-	case MALI_MEM_COW:
-		if (backend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED) {
-			return mali_memory_cow_swap_memory(target_bk, target_offset, target_size, backend, range_start, range_size);
-		} else {
-			return mali_memory_cow_os_memory(target_bk, target_offset, target_size, backend, range_start, range_size);
-		}
-		break;
-	case MALI_MEM_SWAP:
-		return mali_memory_cow_swap_memory(target_bk, target_offset, target_size, backend, range_start, range_size);
-		break;
-	case MALI_MEM_EXTERNAL:
-		/*NOT support yet*/
-		MALI_DEBUG_PRINT_ERROR(("External physical memory not supported ! \n"));
-		return _MALI_OSK_ERR_UNSUPPORTED;
-		break;
-	case MALI_MEM_DMA_BUF:
-		/*NOT support yet*/
-		MALI_DEBUG_PRINT_ERROR(("DMA buffer not supported ! \n"));
-		return _MALI_OSK_ERR_UNSUPPORTED;
-		break;
-	case MALI_MEM_UMP:
-		/*NOT support yet*/
-		MALI_DEBUG_PRINT_ERROR(("UMP buffer not supported ! \n"));
-		return _MALI_OSK_ERR_UNSUPPORTED;
-		break;
-	default:
-		/*Not support yet*/
-		MALI_DEBUG_PRINT_ERROR(("Invalid memory type not supported ! \n"));
-		return _MALI_OSK_ERR_UNSUPPORTED;
-		break;
-	}
-	return _MALI_OSK_ERR_OK;
-}
-
-
-/**
-* Map COW backend memory to mali
-* Support OS/BLOCK for mali_page_node
-*/
-int mali_mem_cow_mali_map(mali_mem_backend *mem_bkend, u32 range_start, u32 range_size)
-{
-	mali_mem_allocation *cow_alloc;
-	struct mali_page_node *m_page;
-	struct mali_session_data *session;
-	struct mali_page_directory *pagedir;
-	u32 virt, start;
-
-	cow_alloc = mem_bkend->mali_allocation;
-	virt = cow_alloc->mali_vma_node.vm_node.start;
-	start = virt;
-
-	MALI_DEBUG_ASSERT_POINTER(mem_bkend);
-	MALI_DEBUG_ASSERT(MALI_MEM_COW == mem_bkend->type);
-	MALI_DEBUG_ASSERT_POINTER(cow_alloc);
-
-	session = cow_alloc->session;
-	pagedir = session->page_directory;
-	MALI_CHECK_NON_NULL(session, _MALI_OSK_ERR_INVALID_ARGS);
-	list_for_each_entry(m_page, &mem_bkend->cow_mem.pages, list) {
-		if ((virt - start >= range_start) && (virt - start < range_start + range_size)) {
-			dma_addr_t phys = _mali_page_node_get_dma_addr(m_page);
-#if defined(CONFIG_ARCH_DMA_ADDR_T_64BIT)
-			MALI_DEBUG_ASSERT(0 == (phys >> 32));
-#endif
-			mali_mmu_pagedir_update(pagedir, virt, (mali_dma_addr)phys,
-						MALI_MMU_PAGE_SIZE, MALI_MMU_FLAGS_DEFAULT);
-		}
-		virt += MALI_MMU_PAGE_SIZE;
-	}
-	return 0;
-}
-
-/**
-* Map COW backend to cpu
-* support OS/BLOCK memory
-*/
-int mali_mem_cow_cpu_map(mali_mem_backend *mem_bkend, struct vm_area_struct *vma)
-{
-	mali_mem_cow *cow = &mem_bkend->cow_mem;
-	struct mali_page_node *m_page;
-	int ret;
-	unsigned long addr = vma->vm_start;
-	MALI_DEBUG_ASSERT(mem_bkend->type == MALI_MEM_COW);
-
-	list_for_each_entry(m_page, &cow->pages, list) {
-		/* We should use vm_insert_page, but it does a dcache
-		 * flush which makes it way slower than remap_pfn_range or vm_insert_pfn.
-		ret = vm_insert_page(vma, addr, page);
-		*/
-		ret = vm_insert_pfn(vma, addr, _mali_page_node_get_pfn(m_page));
-
-		if (unlikely(0 != ret)) {
-			return ret;
-		}
-		addr += _MALI_OSK_MALI_PAGE_SIZE;
-	}
-
-	return 0;
-}
-
-/**
-* Map some pages(COW backend) to CPU vma@vaddr
-*@ mem_bkend - COW backend
-*@ vma
-*@ vaddr -start CPU vaddr mapped to
-*@ num - max number of pages to map to CPU vaddr
-*/
-_mali_osk_errcode_t mali_mem_cow_cpu_map_pages_locked(mali_mem_backend *mem_bkend,
-		struct vm_area_struct *vma,
-		unsigned long vaddr,
-		int num)
-{
-	mali_mem_cow *cow = &mem_bkend->cow_mem;
-	struct mali_page_node *m_page;
-	int ret;
-	int offset;
-	int count ;
-	unsigned long vstart = vma->vm_start;
-	count = 0;
-	MALI_DEBUG_ASSERT(mem_bkend->type == MALI_MEM_COW);
-	MALI_DEBUG_ASSERT(0 == vaddr % _MALI_OSK_MALI_PAGE_SIZE);
-	MALI_DEBUG_ASSERT(0 == vstart % _MALI_OSK_MALI_PAGE_SIZE);
-	offset = (vaddr - vstart) / _MALI_OSK_MALI_PAGE_SIZE;
-
-	list_for_each_entry(m_page, &cow->pages, list) {
-		if ((count >= offset) && (count < offset + num)) {
-			ret = vm_insert_pfn(vma, vaddr, _mali_page_node_get_pfn(m_page));
-
-			if (unlikely(0 != ret)) {
-				if (count == offset) {
-					return _MALI_OSK_ERR_FAULT;
-				} else {
-					/* ret is EBUSY when page isn't in modify range, but now it's OK*/
-					return _MALI_OSK_ERR_OK;
-				}
-			}
-			vaddr += _MALI_OSK_MALI_PAGE_SIZE;
-		}
-		count++;
-	}
-	return _MALI_OSK_ERR_OK;
-}
-
-/**
-* Release COW backend memory
-* free it directly(put_page--unref page), not put into pool
-*/
-u32 mali_mem_cow_release(mali_mem_backend *mem_bkend, mali_bool is_mali_mapped)
-{
-	mali_mem_allocation *alloc;
-	struct mali_session_data *session;
-	u32 free_pages_nr = 0;
-	MALI_DEBUG_ASSERT_POINTER(mem_bkend);
-	MALI_DEBUG_ASSERT(MALI_MEM_COW == mem_bkend->type);
-	alloc = mem_bkend->mali_allocation;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-
-	session = alloc->session;
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	if (MALI_MEM_BACKEND_FLAG_SWAP_COWED != (MALI_MEM_BACKEND_FLAG_SWAP_COWED & mem_bkend->flags)) {
-		/* Unmap the memory from the mali virtual address space. */
-		if (MALI_TRUE == is_mali_mapped)
-			mali_mem_os_mali_unmap(alloc);
-		/* free cow backend list*/
-		_mali_osk_mutex_wait(session->cow_lock);
-		free_pages_nr = mali_mem_os_free(&mem_bkend->cow_mem.pages, mem_bkend->cow_mem.count, MALI_TRUE);
-		_mali_osk_mutex_signal(session->cow_lock);
-
-		free_pages_nr += mali_mem_block_free_list(&mem_bkend->cow_mem.pages);
-
-		MALI_DEBUG_ASSERT(list_empty(&mem_bkend->cow_mem.pages));
-	} else {
-		free_pages_nr = mali_mem_swap_release(mem_bkend, is_mali_mapped);
-	}
-
-
-	MALI_DEBUG_PRINT(4, ("COW Mem free : allocated size = 0x%x, free size = 0x%x\n", mem_bkend->cow_mem.count * _MALI_OSK_MALI_PAGE_SIZE,
-			     free_pages_nr * _MALI_OSK_MALI_PAGE_SIZE));
-
-	mem_bkend->cow_mem.count = 0;
-	return free_pages_nr;
-}
-
-
-/* Dst node could os node or swap node. */
-void _mali_mem_cow_copy_page(mali_page_node *src_node, mali_page_node *dst_node)
-{
-	void *dst, *src;
-	struct page *dst_page;
-	dma_addr_t dma_addr;
-
-	MALI_DEBUG_ASSERT(src_node != NULL);
-	MALI_DEBUG_ASSERT(dst_node != NULL);
-	MALI_DEBUG_ASSERT(dst_node->type == MALI_PAGE_NODE_OS
-			  || dst_node->type == MALI_PAGE_NODE_SWAP);
-
-	if (dst_node->type == MALI_PAGE_NODE_OS) {
-		dst_page = dst_node->page;
-	} else {
-		dst_page = dst_node->swap_it->page;
-	}
-
-	dma_unmap_page(&mali_platform_device->dev, _mali_page_node_get_dma_addr(dst_node),
-		       _MALI_OSK_MALI_PAGE_SIZE, DMA_BIDIRECTIONAL);
-
-	/* map it , and copy the content*/
-	dst = kmap_atomic(dst_page);
-
-	if (src_node->type == MALI_PAGE_NODE_OS ||
-	    src_node->type == MALI_PAGE_NODE_SWAP) {
-		struct page *src_page;
-
-		if (src_node->type == MALI_PAGE_NODE_OS) {
-			src_page = src_node->page;
-		} else {
-			src_page = src_node->swap_it->page;
-		}
-
-		/* Clear and invaliate cache */
-		/* In ARM architecture, speculative read may pull stale data into L1 cache
-		 * for kernel linear mapping page table. DMA_BIDIRECTIONAL could
-		 * invalidate the L1 cache so that following read get the latest data
-		*/
-		dma_unmap_page(&mali_platform_device->dev, _mali_page_node_get_dma_addr(src_node),
-			       _MALI_OSK_MALI_PAGE_SIZE, DMA_BIDIRECTIONAL);
-
-		src = kmap_atomic(src_page);
-		memcpy(dst, src , _MALI_OSK_MALI_PAGE_SIZE);
-		kunmap_atomic(src);
-		dma_addr = dma_map_page(&mali_platform_device->dev, src_page,
-					0, _MALI_OSK_MALI_PAGE_SIZE, DMA_BIDIRECTIONAL);
-
-		if (src_node->type == MALI_PAGE_NODE_SWAP) {
-			src_node->swap_it->dma_addr = dma_addr;
-		}
-	} else if (src_node->type == MALI_PAGE_NODE_BLOCK) {
-		/*
-		* use ioremap to map src for BLOCK memory
-		*/
-		src = ioremap_nocache(_mali_page_node_get_dma_addr(src_node), _MALI_OSK_MALI_PAGE_SIZE);
-		memcpy(dst, src , _MALI_OSK_MALI_PAGE_SIZE);
-		iounmap(src);
-	}
-	kunmap_atomic(dst);
-	dma_addr = dma_map_page(&mali_platform_device->dev, dst_page,
-				0, _MALI_OSK_MALI_PAGE_SIZE, DMA_TO_DEVICE);
-
-	if (dst_node->type == MALI_PAGE_NODE_SWAP) {
-		dst_node->swap_it->dma_addr = dma_addr;
-	}
-}
-
-
-/*
-* allocate page on demand when CPU access it,
-* THis used in page fault handler
-*/
-_mali_osk_errcode_t mali_mem_cow_allocate_on_demand(mali_mem_backend *mem_bkend, u32 offset_page)
-{
-	struct page *new_page = NULL;
-	struct mali_page_node *new_node = NULL;
-	int i = 0;
-	struct mali_page_node *m_page, *found_node = NULL;
-	struct  mali_session_data *session = NULL;
-	mali_mem_cow *cow = &mem_bkend->cow_mem;
-	MALI_DEBUG_ASSERT(MALI_MEM_COW == mem_bkend->type);
-	MALI_DEBUG_ASSERT(offset_page < mem_bkend->size / _MALI_OSK_MALI_PAGE_SIZE);
-	MALI_DEBUG_PRINT(4, ("mali_mem_cow_allocate_on_demand !, offset_page =0x%x\n", offset_page));
-
-	/* allocate new page here */
-	new_page = mali_mem_cow_alloc_page();
-	if (!new_page)
-		return _MALI_OSK_ERR_NOMEM;
-
-	new_node = _mali_page_node_allocate(MALI_PAGE_NODE_OS);
-	if (!new_node) {
-		__free_page(new_page);
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	/* find the page in backend*/
-	list_for_each_entry(m_page, &cow->pages, list) {
-		if (i == offset_page) {
-			found_node = m_page;
-			break;
-		}
-		i++;
-	}
-	MALI_DEBUG_ASSERT(found_node);
-	if (NULL == found_node) {
-		__free_page(new_page);
-		kfree(new_node);
-		return _MALI_OSK_ERR_ITEM_NOT_FOUND;
-	}
-
-	_mali_page_node_add_page(new_node, new_page);
-
-	/* Copy the src page's content to new page */
-	_mali_mem_cow_copy_page(found_node, new_node);
-
-	MALI_DEBUG_ASSERT_POINTER(mem_bkend->mali_allocation);
-	session = mem_bkend->mali_allocation->session;
-	MALI_DEBUG_ASSERT_POINTER(session);
-	if (1 != _mali_page_node_get_ref_count(found_node)) {
-		atomic_add(1, &session->mali_mem_allocated_pages);
-		if (atomic_read(&session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE > session->max_mali_mem_allocated_size) {
-			session->max_mali_mem_allocated_size = atomic_read(&session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE;
-		}
-		mem_bkend->cow_mem.change_pages_nr++;
-	}
-
-	_mali_osk_mutex_wait(session->cow_lock);
-	if (_mali_mem_put_page_node(found_node)) {
-		__free_page(new_page);
-		kfree(new_node);
-		_mali_osk_mutex_signal(session->cow_lock);
-		return _MALI_OSK_ERR_NOMEM;
-	}
-	_mali_osk_mutex_signal(session->cow_lock);
-
-	list_replace(&found_node->list, &new_node->list);
-
-	kfree(found_node);
-
-	/* map to GPU side*/
-	_mali_osk_mutex_wait(session->memory_lock);
-	mali_mem_cow_mali_map(mem_bkend, offset_page * _MALI_OSK_MALI_PAGE_SIZE, _MALI_OSK_MALI_PAGE_SIZE);
-	_mali_osk_mutex_signal(session->memory_lock);
-	return _MALI_OSK_ERR_OK;
-}
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_cow.h b/drivers/gpu/arm/mali/linux/mali_memory_cow.h
deleted file mode 100755
index 9b9e8349..00000000
--- a/drivers/gpu/arm/mali/linux/mali_memory_cow.h
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#ifndef __MALI_MEMORY_COW_H__
-#define __MALI_MEMORY_COW_H__
-
-#include "mali_osk.h"
-#include "mali_session.h"
-#include "mali_memory_types.h"
-
-int mali_mem_cow_cpu_map(mali_mem_backend *mem_bkend, struct vm_area_struct *vma);
-_mali_osk_errcode_t mali_mem_cow_cpu_map_pages_locked(mali_mem_backend *mem_bkend,
-		struct vm_area_struct *vma,
-		unsigned long vaddr,
-		int num);
-
-_mali_osk_errcode_t mali_memory_do_cow(mali_mem_backend *target_bk,
-				       u32 target_offset,
-				       u32 target_size,
-				       mali_mem_backend *backend,
-				       u32 range_start,
-				       u32 range_size);
-
-_mali_osk_errcode_t mali_memory_cow_modify_range(mali_mem_backend *backend,
-		u32 range_start,
-		u32 range_size);
-
-_mali_osk_errcode_t mali_memory_cow_os_memory(mali_mem_backend *target_bk,
-		u32 target_offset,
-		u32 target_size,
-		mali_mem_backend *backend,
-		u32 range_start,
-		u32 range_size);
-
-void _mali_mem_cow_copy_page(mali_page_node *src_node, mali_page_node *dst_node);
-
-int mali_mem_cow_mali_map(mali_mem_backend *mem_bkend, u32 range_start, u32 range_size);
-u32 mali_mem_cow_release(mali_mem_backend *mem_bkend, mali_bool is_mali_mapped);
-_mali_osk_errcode_t mali_mem_cow_allocate_on_demand(mali_mem_backend *mem_bkend, u32 offset_page);
-#endif
-
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_defer_bind.c b/drivers/gpu/arm/mali/linux/mali_memory_defer_bind.c
deleted file mode 100755
index a13eea0c..00000000
--- a/drivers/gpu/arm/mali/linux/mali_memory_defer_bind.c
+++ /dev/null
@@ -1,262 +0,0 @@
-/*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-#include <linux/mm.h>
-#include <linux/list.h>
-#include <linux/mm_types.h>
-#include <linux/fs.h>
-#include <linux/dma-mapping.h>
-#include <linux/highmem.h>
-#include <asm/cacheflush.h>
-#include <linux/sched.h>
-#ifdef CONFIG_ARM
-#include <asm/outercache.h>
-#endif
-#include <asm/dma-mapping.h>
-
-#include "mali_memory.h"
-#include "mali_kernel_common.h"
-#include "mali_uk_types.h"
-#include "mali_osk.h"
-#include "mali_kernel_linux.h"
-#include "mali_memory_defer_bind.h"
-#include "mali_executor.h"
-#include "mali_osk.h"
-#include "mali_scheduler.h"
-#include "mali_gp_job.h"
-
-mali_defer_bind_manager *mali_dmem_man = NULL;
-
-static u32 mali_dmem_get_gp_varying_size(struct mali_gp_job *gp_job)
-{
-	return gp_job->required_varying_memsize / _MALI_OSK_MALI_PAGE_SIZE;
-}
-
-_mali_osk_errcode_t mali_mem_defer_bind_manager_init(void)
-{
-	mali_dmem_man = _mali_osk_calloc(1, sizeof(struct mali_defer_bind_manager));
-	if (!mali_dmem_man)
-		return _MALI_OSK_ERR_NOMEM;
-
-	atomic_set(&mali_dmem_man->num_used_pages, 0);
-	atomic_set(&mali_dmem_man->num_dmem, 0);
-
-	return _MALI_OSK_ERR_OK;
-}
-
-
-void mali_mem_defer_bind_manager_destory(void)
-{
-	if (mali_dmem_man) {
-		MALI_DEBUG_ASSERT(0 == atomic_read(&mali_dmem_man->num_dmem));
-		kfree(mali_dmem_man);
-	}
-	mali_dmem_man = NULL;
-}
-
-
-/*allocate pages from OS memory*/
-_mali_osk_errcode_t mali_mem_defer_alloc_mem(u32 require, struct mali_session_data *session, mali_defer_mem_block *dblock)
-{
-	int retval = 0;
-	u32 num_pages = require;
-	mali_mem_os_mem os_mem;
-
-	retval = mali_mem_os_alloc_pages(&os_mem, num_pages * _MALI_OSK_MALI_PAGE_SIZE);
-
-	/* add to free pages list */
-	if (0 == retval) {
-		MALI_DEBUG_PRINT(4, ("mali_mem_defer_alloc_mem ,,*** pages allocate = 0x%x \n", num_pages));
-		list_splice(&os_mem.pages, &dblock->free_pages);
-		atomic_add(os_mem.count, &dblock->num_free_pages);
-		atomic_add(os_mem.count, &session->mali_mem_allocated_pages);
-		if (atomic_read(&session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE > session->max_mali_mem_allocated_size) {
-			session->max_mali_mem_allocated_size = atomic_read(&session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE;
-		}
-		return _MALI_OSK_ERR_OK;
-	} else
-		return _MALI_OSK_ERR_FAULT;
-}
-
-_mali_osk_errcode_t mali_mem_prepare_mem_for_job(struct mali_gp_job *next_gp_job, mali_defer_mem_block *dblock)
-{
-	u32 require_page;
-
-	if (!next_gp_job)
-		return _MALI_OSK_ERR_FAULT;
-
-	require_page = mali_dmem_get_gp_varying_size(next_gp_job);
-
-	MALI_DEBUG_PRINT(4, ("mali_mem_defer_prepare_mem_work, require alloc page 0x%x\n",
-			     require_page));
-	/* allocate more pages from OS */
-	if (_MALI_OSK_ERR_OK != mali_mem_defer_alloc_mem(require_page, next_gp_job->session, dblock)) {
-		MALI_DEBUG_PRINT(1, ("ERROR##mali_mem_defer_prepare_mem_work, allocate page failed!!"));
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	next_gp_job->bind_flag = MALI_DEFER_BIND_MEMORY_PREPARED;
-
-	return _MALI_OSK_ERR_OK;
-}
-
-
-/* do preparetion for allocation before defer bind */
-_mali_osk_errcode_t mali_mem_defer_bind_allocation_prepare(mali_mem_allocation *alloc, struct list_head *list, u32 *required_varying_memsize)
-{
-	mali_mem_backend *mem_bkend = NULL;
-	struct mali_backend_bind_list *bk_list = _mali_osk_calloc(1, sizeof(struct mali_backend_bind_list));
-	if (NULL == bk_list)
-		return _MALI_OSK_ERR_FAULT;
-
-	INIT_LIST_HEAD(&bk_list->node);
-	/* Get backend memory */
-	mutex_lock(&mali_idr_mutex);
-	if (!(mem_bkend = idr_find(&mali_backend_idr, alloc->backend_handle))) {
-		MALI_DEBUG_PRINT(1, ("Can't find memory backend in defer bind!\n"));
-		mutex_unlock(&mali_idr_mutex);
-		_mali_osk_free(bk_list);
-		return _MALI_OSK_ERR_FAULT;
-	}
-	mutex_unlock(&mali_idr_mutex);
-
-	/* If the mem backend has already been bound, no need to bind again.*/
-	if (mem_bkend->os_mem.count > 0) {
-		_mali_osk_free(bk_list);
-		return _MALI_OSK_ERR_OK;
-	}
-
-	MALI_DEBUG_PRINT(4, ("bind_allocation_prepare:: allocation =%x vaddr=0x%x!\n", alloc, alloc->mali_vma_node.vm_node.start));
-
-	INIT_LIST_HEAD(&mem_bkend->os_mem.pages);
-
-	bk_list->bkend = mem_bkend;
-	bk_list->vaddr = alloc->mali_vma_node.vm_node.start;
-	bk_list->session = alloc->session;
-	bk_list->page_num = mem_bkend->size / _MALI_OSK_MALI_PAGE_SIZE;
-	*required_varying_memsize +=  mem_bkend->size;
-	MALI_DEBUG_ASSERT(mem_bkend->type == MALI_MEM_OS);
-
-	/* add to job to do list */
-	list_add(&bk_list->node, list);
-
-	return _MALI_OSK_ERR_OK;
-}
-
-
-
-/* bind phyiscal memory to allocation
-This function will be called in IRQ handler*/
-static _mali_osk_errcode_t mali_mem_defer_bind_allocation(struct mali_backend_bind_list *bk_node,
-		struct list_head *pages)
-{
-	struct mali_session_data *session = bk_node->session;
-	mali_mem_backend *mem_bkend = bk_node->bkend;
-	MALI_DEBUG_PRINT(4, ("mali_mem_defer_bind_allocation, bind bkend = %x page num=0x%x vaddr=%x session=%x\n", mem_bkend, bk_node->page_num, bk_node->vaddr, session));
-
-	MALI_DEBUG_ASSERT(mem_bkend->type == MALI_MEM_OS);
-	list_splice(pages, &mem_bkend->os_mem.pages);
-	mem_bkend->os_mem.count = bk_node->page_num;
-
-	if (mem_bkend->type == MALI_MEM_OS) {
-		mali_mem_os_mali_map(&mem_bkend->os_mem, session, bk_node->vaddr, 0,
-				     mem_bkend->os_mem.count, MALI_MMU_FLAGS_DEFAULT);
-	}
-	smp_wmb();
-	bk_node->flag = MALI_DEFER_BIND_MEMORY_BINDED;
-	mem_bkend->flags &= ~MALI_MEM_BACKEND_FLAG_NOT_BINDED;
-	mem_bkend->flags |= MALI_MEM_BACKEND_FLAG_BINDED;
-	return _MALI_OSK_ERR_OK;
-}
-
-
-static struct list_head *mali_mem_defer_get_free_page_list(u32 count, struct list_head *pages, mali_defer_mem_block *dblock)
-{
-	int i = 0;
-	struct mali_page_node *m_page, *m_tmp;
-
-	if (atomic_read(&dblock->num_free_pages) < count) {
-		return NULL;
-	} else {
-		list_for_each_entry_safe(m_page, m_tmp, &dblock->free_pages, list) {
-			if (i < count) {
-				list_move_tail(&m_page->list, pages);
-			} else {
-				break;
-			}
-			i++;
-		}
-		MALI_DEBUG_ASSERT(i == count);
-		atomic_sub(count, &dblock->num_free_pages);
-		return pages;
-	}
-}
-
-
-/* called in job start IOCTL to bind physical memory for each allocations
-@ bk_list backend list to do defer bind
-@ pages page list to do this bind
-@ count number of pages
-*/
-_mali_osk_errcode_t mali_mem_defer_bind(struct mali_gp_job *gp,
-					struct mali_defer_mem_block *dmem_block)
-{
-	struct mali_defer_mem *dmem = NULL;
-	struct mali_backend_bind_list *bkn, *bkn_tmp;
-	LIST_HEAD(pages);
-
-	if (gp->required_varying_memsize != (atomic_read(&dmem_block->num_free_pages) * _MALI_OSK_MALI_PAGE_SIZE)) {
-		MALI_DEBUG_PRINT_ERROR(("#BIND:  The memsize of varying buffer not match to the pagesize of the dmem_block!!## \n"));
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	MALI_DEBUG_PRINT(4, ("#BIND: GP job=%x## \n", gp));
-	dmem = (mali_defer_mem *)_mali_osk_calloc(1, sizeof(struct mali_defer_mem));
-	if (dmem) {
-		INIT_LIST_HEAD(&dmem->node);
-		gp->dmem = dmem;
-	} else {
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	atomic_add(1, &mali_dmem_man->num_dmem);
-	/* for each bk_list backend, do bind */
-	list_for_each_entry_safe(bkn, bkn_tmp , &gp->vary_todo, node) {
-		INIT_LIST_HEAD(&pages);
-		if (likely(mali_mem_defer_get_free_page_list(bkn->page_num, &pages, dmem_block))) {
-			list_del(&bkn->node);
-			mali_mem_defer_bind_allocation(bkn, &pages);
-			_mali_osk_free(bkn);
-		} else {
-			/* not enough memory will not happen */
-			MALI_DEBUG_PRINT_ERROR(("#BIND: NOT enough memory when binded !!## \n"));
-			_mali_osk_free(gp->dmem);
-			return _MALI_OSK_ERR_NOMEM;
-		}
-	}
-
-	if (!list_empty(&gp->vary_todo)) {
-		MALI_DEBUG_PRINT_ERROR(("#BIND:  The deferbind backend list isn't empty !!## \n"));
-		_mali_osk_free(gp->dmem);
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	dmem->flag = MALI_DEFER_BIND_MEMORY_BINDED;
-
-	return _MALI_OSK_ERR_OK;
-}
-
-void mali_mem_defer_dmem_free(struct mali_gp_job *gp)
-{
-	if (gp->dmem) {
-		atomic_dec(&mali_dmem_man->num_dmem);
-		_mali_osk_free(gp->dmem);
-	}
-}
-
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_defer_bind.h b/drivers/gpu/arm/mali/linux/mali_memory_defer_bind.h
deleted file mode 100755
index 4cf6f169..00000000
--- a/drivers/gpu/arm/mali/linux/mali_memory_defer_bind.h
+++ /dev/null
@@ -1,64 +0,0 @@
-/*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-#ifndef __MALI_MEMORY_DEFER_BIND_H_
-#define __MALI_MEMORY_DEFER_BIND_H_
-
-
-#include "mali_osk.h"
-#include "mali_session.h"
-
-#include <linux/list.h>
-#include <linux/mm.h>
-#include <linux/rbtree.h>
-#include <linux/spinlock.h>
-#include <linux/types.h>
-
-
-#include "mali_memory_types.h"
-#include "mali_memory_os_alloc.h"
-#include "mali_uk_types.h"
-
-struct mali_gp_job;
-
-typedef struct mali_defer_mem {
-	struct list_head node;   /*dlist node in bind manager */
-	u32 flag;
-} mali_defer_mem;
-
-
-typedef struct mali_defer_mem_block {
-	struct list_head free_pages; /* page pool */
-	atomic_t num_free_pages;
-} mali_defer_mem_block;
-
-/* varying memory list need to bind */
-typedef struct mali_backend_bind_list {
-	struct list_head node;
-	struct mali_mem_backend *bkend;
-	u32 vaddr;
-	u32 page_num;
-	struct mali_session_data *session;
-	u32 flag;
-} mali_backend_bind_lists;
-
-
-typedef struct mali_defer_bind_manager {
-	atomic_t num_used_pages;
-	atomic_t num_dmem;
-} mali_defer_bind_manager;
-
-_mali_osk_errcode_t mali_mem_defer_bind_manager_init(void);
-void mali_mem_defer_bind_manager_destory(void);
-_mali_osk_errcode_t mali_mem_defer_bind(struct mali_gp_job *gp, struct mali_defer_mem_block *dmem_block);
-_mali_osk_errcode_t mali_mem_defer_bind_allocation_prepare(mali_mem_allocation *alloc, struct list_head *list,  u32 *required_varying_memsize);
-_mali_osk_errcode_t mali_mem_prepare_mem_for_job(struct mali_gp_job *next_gp_job, mali_defer_mem_block *dblock);
-void mali_mem_defer_dmem_free(struct mali_gp_job *gp);
-
-#endif
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_dma_buf.c b/drivers/gpu/arm/mali/linux/mali_memory_dma_buf.c
old mode 100755
new mode 100644
index f0d1e07b..ec7388e8
--- a/drivers/gpu/arm/mali/linux/mali_memory_dma_buf.c
+++ b/drivers/gpu/arm/mali/linux/mali_memory_dma_buf.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -29,6 +29,35 @@
 #include "mali_memory_virtual.h"
 #include "mali_pp_job.h"
 
+static void mali_dma_buf_unmap(mali_mem_allocation *alloc, struct mali_dma_buf_attachment *mem);
+
+void mali_mem_dma_buf_release(mali_mem_backend *mem_backend)
+{
+	struct mali_dma_buf_attachment *mem;
+	MALI_DEBUG_ASSERT_POINTER(mem_backend);
+	MALI_DEBUG_ASSERT(MALI_MEM_DMA_BUF == mem_backend->type);
+
+	mem = mem_backend->dma_buf.attachment;
+	MALI_DEBUG_ASSERT_POINTER(mem);
+	MALI_DEBUG_ASSERT_POINTER(mem->attachment);
+	MALI_DEBUG_ASSERT_POINTER(mem->buf);
+	MALI_DEBUG_PRINT(3, ("Mali DMA-buf: release attachment %p\n", mem));
+
+#if defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
+	MALI_DEBUG_ASSERT_POINTER(mem_backend->mali_allocation);
+	/* We mapped implicitly on attach, so we need to unmap on release */
+	mali_dma_buf_unmap(mem_backend->mali_allocation, mem);
+#endif
+	/* Wait for buffer to become unmapped */
+	wait_event(mem->wait_queue, !mem->is_mapped);
+	MALI_DEBUG_ASSERT(!mem->is_mapped);
+
+	dma_buf_detach(mem->buf, mem->attachment);
+	dma_buf_put(mem->buf);
+
+	_mali_osk_free(mem);
+}
+
 /*
  * Map DMA buf attachment \a mem into \a session at virtual address \a virt.
  */
@@ -109,6 +138,7 @@ static int mali_dma_buf_map(mali_mem_backend *mem_backend)
 		}
 
 		mem->is_mapped = MALI_TRUE;
+		session->mali_mem_array[mem_backend->type] += mem_backend->size;
 		mali_session_memory_unlock(session);
 		/* Wake up any thread waiting for buffer to become mapped */
 		wake_up_all(&mem->wait_queue);
@@ -140,6 +170,7 @@ static void mali_dma_buf_unmap(mali_mem_allocation *alloc, struct mali_dma_buf_a
 					       alloc->flags);
 		}
 		mem->is_mapped = MALI_FALSE;
+		alloc->session->mali_mem_array[alloc->type] -= alloc->psize;
 	}
 	mali_session_memory_unlock(alloc->session);
 	/* Wake up any thread waiting for buffer to become unmapped */
@@ -271,7 +302,7 @@ int mali_dma_buf_get_size(struct mali_session_data *session, _mali_uk_dma_buf_ge
 	return 0;
 }
 
-_mali_osk_errcode_t mali_mem_bind_dma_buf(mali_mem_allocation *alloc,
+_mali_osk_errcode_t mali_memory_bind_dma_buf(mali_mem_allocation *alloc,
 		mali_mem_backend *mem_backend,
 		int fd, u32 flags)
 {
@@ -341,29 +372,11 @@ failed_alloc_mem:
 	return _MALI_OSK_ERR_FAULT;
 }
 
-void mali_mem_unbind_dma_buf(mali_mem_backend *mem_backend)
+
+void mali_memory_unbind_dma_buf(mali_mem_backend *mem_backend)
 {
-	struct mali_dma_buf_attachment *mem;
 	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-	MALI_DEBUG_ASSERT(MALI_MEM_DMA_BUF == mem_backend->type);
-
-	mem = mem_backend->dma_buf.attachment;
-	MALI_DEBUG_ASSERT_POINTER(mem);
-	MALI_DEBUG_ASSERT_POINTER(mem->attachment);
-	MALI_DEBUG_ASSERT_POINTER(mem->buf);
-	MALI_DEBUG_PRINT(3, ("Mali DMA-buf: release attachment %p\n", mem));
-
-#if defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
-	MALI_DEBUG_ASSERT_POINTER(mem_backend->mali_allocation);
-	/* We mapped implicitly on attach, so we need to unmap on release */
-	mali_dma_buf_unmap(mem_backend->mali_allocation, mem);
-#endif
-	/* Wait for buffer to become unmapped */
-	wait_event(mem->wait_queue, !mem->is_mapped);
-	MALI_DEBUG_ASSERT(!mem->is_mapped);
+	mali_mem_dma_buf_release(mem_backend);
+}
 
-	dma_buf_detach(mem->buf, mem->attachment);
-	dma_buf_put(mem->buf);
 
-	_mali_osk_free(mem);
-}
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_dma_buf.h b/drivers/gpu/arm/mali/linux/mali_memory_dma_buf.h
old mode 100755
new mode 100644
index 37b6f6b4..5c97b57f
--- a/drivers/gpu/arm/mali/linux/mali_memory_dma_buf.h
+++ b/drivers/gpu/arm/mali/linux/mali_memory_dma_buf.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -35,12 +35,14 @@ struct mali_dma_buf_attachment {
 
 int mali_dma_buf_get_size(struct mali_session_data *session, _mali_uk_dma_buf_get_size_s __user *arg);
 
-void mali_mem_unbind_dma_buf(mali_mem_backend *mem_backend);
+void mali_mem_dma_buf_release(mali_mem_backend *mem_backend);
 
-_mali_osk_errcode_t mali_mem_bind_dma_buf(mali_mem_allocation *alloc,
+_mali_osk_errcode_t mali_memory_bind_dma_buf(mali_mem_allocation *alloc,
 		mali_mem_backend *mem_backend,
 		int fd, u32 flags);
 
+void mali_memory_unbind_dma_buf(mali_mem_backend *mem_backend);
+
 #if !defined(CONFIG_MALI_DMA_BUF_MAP_ON_ATTACH)
 int mali_dma_buf_map_job(struct mali_pp_job *job);
 void mali_dma_buf_unmap_job(struct mali_pp_job *job);
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_external.c b/drivers/gpu/arm/mali/linux/mali_memory_external.c
old mode 100755
new mode 100644
index c0097f67..b262fbce
--- a/drivers/gpu/arm/mali/linux/mali_memory_external.c
+++ b/drivers/gpu/arm/mali/linux/mali_memory_external.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -15,7 +15,7 @@
 #include "mali_mem_validation.h"
 #include "mali_uk_types.h"
 
-void mali_mem_unbind_ext_buf(mali_mem_backend *mem_backend)
+void mali_mem_external_release(mali_mem_backend *mem_backend)
 {
 	mali_mem_allocation *alloc;
 	struct mali_session_data *session;
@@ -29,10 +29,11 @@ void mali_mem_unbind_ext_buf(mali_mem_backend *mem_backend)
 	mali_session_memory_lock(session);
 	mali_mem_mali_map_free(session, alloc->psize, alloc->mali_vma_node.vm_node.start,
 			       alloc->flags);
+	session->mali_mem_array[mem_backend->type] -= mem_backend->size;
 	mali_session_memory_unlock(session);
 }
 
-_mali_osk_errcode_t mali_mem_bind_ext_buf(mali_mem_allocation *alloc,
+_mali_osk_errcode_t mali_memory_bind_ext_mem(mali_mem_allocation *alloc,
 		mali_mem_backend *mem_backend,
 		u32 phys_addr,
 		u32 flag)
@@ -82,8 +83,16 @@ _mali_osk_errcode_t mali_mem_bind_ext_buf(mali_mem_allocation *alloc,
 			 ("Requested to map physical memory 0x%x-0x%x into virtual memory 0x%x\n",
 			  phys_addr, (phys_addr + size - 1),
 			  virt));
+	session->mali_mem_array[mem_backend->type] += mem_backend->size;
 	mali_session_memory_unlock(session);
 
 	MALI_SUCCESS;
 }
 
+
+void mali_memory_unbind_ext_mem(mali_mem_backend *mem_backend)
+{
+	MALI_DEBUG_ASSERT_POINTER(mem_backend);
+	mali_mem_external_release(mem_backend);
+}
+
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_external.h b/drivers/gpu/arm/mali/linux/mali_memory_external.h
old mode 100755
new mode 100644
index ba387b8a..9e9a9e90
--- a/drivers/gpu/arm/mali/linux/mali_memory_external.h
+++ b/drivers/gpu/arm/mali/linux/mali_memory_external.h
@@ -1,10 +1,10 @@
 
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -16,11 +16,16 @@
 extern "C" {
 #endif
 
-_mali_osk_errcode_t mali_mem_bind_ext_buf(mali_mem_allocation *alloc,
+_mali_osk_errcode_t mali_memory_bind_ext_mem(mali_mem_allocation *alloc,
 		mali_mem_backend *mem_backend,
 		u32 phys_addr,
 		u32 flag);
-void mali_mem_unbind_ext_buf(mali_mem_backend *mem_backend);
+
+void mali_memory_unbind_ext_mem(mali_mem_backend *mem_backend);
+
+void mali_mem_external_release(mali_mem_backend *mem_backend);
+
+
 
 #ifdef __cplusplus
 }
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_manager.c b/drivers/gpu/arm/mali/linux/mali_memory_manager.c
old mode 100755
new mode 100644
index 814eb7f4..510c82e2
--- a/drivers/gpu/arm/mali/linux/mali_memory_manager.c
+++ b/drivers/gpu/arm/mali/linux/mali_memory_manager.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -15,8 +15,6 @@
 #include <linux/dma-mapping.h>
 #include <linux/slab.h>
 #include <linux/version.h>
-#include <linux/sched.h>
-
 #include <linux/platform_device.h>
 #if defined(CONFIG_DMA_SHARED_BUFFER)
 #include <linux/dma-buf.h>
@@ -31,7 +29,6 @@
 #include "mali_memory_os_alloc.h"
 #if defined(CONFIG_DMA_SHARED_BUFFER)
 #include "mali_memory_dma_buf.h"
-#include "mali_memory_secure.h"
 #endif
 #if defined(CONFIG_MALI400_UMP)
 #include "mali_memory_ump.h"
@@ -40,10 +37,9 @@
 #include "mali_memory_virtual.h"
 #include "mali_memory_util.h"
 #include "mali_memory_external.h"
-#include "mali_memory_cow.h"
 #include "mali_memory_block_alloc.h"
-#include "mali_ukk.h"
-#include "mali_memory_swap_alloc.h"
+
+#define MALI_S32_MAX 0x7fffffff
 
 /*
 * New memory system interface
@@ -65,11 +61,11 @@ int mali_memory_manager_init(struct mali_allocation_manager *mgr)
 
 	/* init RB tree */
 	mgr->allocation_mgr_rb = RB_ROOT;
-	mgr->mali_allocation_num = 0;
+	mgr->mali_allocation_nr = 0;
 	return 0;
 }
 
-/* Deinit allocation manager
+/* deinit allocation manager
 * Do some check for debug
 */
 void mali_memory_manager_uninit(struct mali_allocation_manager *mgr)
@@ -99,26 +95,27 @@ static mali_mem_allocation *mali_mem_allocation_struct_create(struct mali_sessio
 	mali_allocation->session = session;
 
 	INIT_LIST_HEAD(&mali_allocation->list);
-	_mali_osk_atomic_init(&mali_allocation->mem_alloc_refcount, 1);
+	kref_init(&mali_allocation->ref);
 
 	/**
 	*add to session list
 	*/
 	mutex_lock(&session->allocation_mgr.list_mutex);
 	list_add_tail(&mali_allocation->list, &session->allocation_mgr.head);
-	session->allocation_mgr.mali_allocation_num++;
+	session->allocation_mgr.mali_allocation_nr++;
 	mutex_unlock(&session->allocation_mgr.list_mutex);
 
 	return mali_allocation;
 }
 
+
 void  mali_mem_allocation_struct_destory(mali_mem_allocation *alloc)
 {
 	MALI_DEBUG_ASSERT_POINTER(alloc);
 	MALI_DEBUG_ASSERT_POINTER(alloc->session);
 	mutex_lock(&alloc->session->allocation_mgr.list_mutex);
 	list_del(&alloc->list);
-	alloc->session->allocation_mgr.mali_allocation_num--;
+	alloc->session->allocation_mgr.mali_allocation_nr--;
 	mutex_unlock(&alloc->session->allocation_mgr.list_mutex);
 
 	kfree(alloc);
@@ -136,11 +133,6 @@ int mali_mem_backend_struct_create(mali_mem_backend **backend, u32 psize)
 	}
 	mem_backend = *backend;
 	mem_backend->size = psize;
-	mutex_init(&mem_backend->mutex);
-	INIT_LIST_HEAD(&mem_backend->list);
-	mem_backend->using_count = 0;
-
-
 	/* link backend with id */
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 9, 0)
 again:
@@ -172,7 +164,6 @@ again:
 	return index;
 }
 
-
 static void mali_mem_backend_struct_destory(mali_mem_backend **backend, s32 backend_handle)
 {
 	mali_mem_backend *mem_backend = *backend;
@@ -184,177 +175,11 @@ static void mali_mem_backend_struct_destory(mali_mem_backend **backend, s32 back
 	*backend = NULL;
 }
 
-mali_mem_backend *mali_mem_backend_struct_search(struct mali_session_data *session, u32 mali_address)
-{
-	struct mali_vma_node *mali_vma_node = NULL;
-	mali_mem_backend *mem_bkend = NULL;
-	mali_mem_allocation *mali_alloc = NULL;
-	MALI_DEBUG_ASSERT_POINTER(session);
-	mali_vma_node = mali_vma_offset_search(&session->allocation_mgr, mali_address, 0);
-	if (NULL == mali_vma_node)  {
-		MALI_DEBUG_PRINT(1, ("mali_mem_backend_struct_search:vma node was NULL\n"));
-		return NULL;
-	}
-	mali_alloc = container_of(mali_vma_node, struct mali_mem_allocation, mali_vma_node);
-	/* Get backend memory & Map on CPU */
-	mutex_lock(&mali_idr_mutex);
-	mem_bkend = idr_find(&mali_backend_idr, mali_alloc->backend_handle);
-	mutex_unlock(&mali_idr_mutex);
-	MALI_DEBUG_ASSERT(NULL != mem_bkend);
-	return mem_bkend;
-}
-
-static _mali_osk_errcode_t mali_mem_resize(struct mali_session_data *session, mali_mem_backend *mem_backend, u32 physical_size)
-{
-	_mali_osk_errcode_t ret = _MALI_OSK_ERR_FAULT;
-	int retval = 0;
-	mali_mem_allocation *mali_allocation = NULL;
-	mali_mem_os_mem tmp_os_mem;
-	s32 change_page_count;
-
-	MALI_DEBUG_ASSERT_POINTER(session);
-	MALI_DEBUG_ASSERT_POINTER(mem_backend);
-	MALI_DEBUG_PRINT(4, (" mali_mem_resize_memory called! \n"));
-	MALI_DEBUG_ASSERT(0 == physical_size %  MALI_MMU_PAGE_SIZE);
-
-	mali_allocation = mem_backend->mali_allocation;
-	MALI_DEBUG_ASSERT_POINTER(mali_allocation);
-
-	MALI_DEBUG_ASSERT(MALI_MEM_FLAG_CAN_RESIZE & mali_allocation->flags);
-	MALI_DEBUG_ASSERT(MALI_MEM_OS == mali_allocation->type);
-
-	mutex_lock(&mem_backend->mutex);
-
-	/* Do resize*/
-	if (physical_size > mem_backend->size) {
-		u32 add_size = physical_size - mem_backend->size;
-
-		MALI_DEBUG_ASSERT(0 == add_size %  MALI_MMU_PAGE_SIZE);
-
-		/* Allocate new pages from os mem */
-		retval = mali_mem_os_alloc_pages(&tmp_os_mem, add_size);
-
-		if (retval) {
-			if (-ENOMEM == retval) {
-				ret = _MALI_OSK_ERR_NOMEM;
-			} else {
-				ret = _MALI_OSK_ERR_FAULT;
-			}
-			MALI_DEBUG_PRINT(2, ("_mali_ukk_mem_resize: memory allocation failed !\n"));
-			goto failed_alloc_memory;
-		}
-
-		MALI_DEBUG_ASSERT(tmp_os_mem.count == add_size / MALI_MMU_PAGE_SIZE);
-
-		/* Resize the memory of the backend */
-		ret = mali_mem_os_resize_pages(&tmp_os_mem, &mem_backend->os_mem, 0, tmp_os_mem.count);
-
-		if (ret) {
-			MALI_DEBUG_PRINT(2, ("_mali_ukk_mem_resize: memory	resizing failed !\n"));
-			goto failed_resize_pages;
-		}
-
-		/*Resize cpu mapping */
-		if (NULL != mali_allocation->cpu_mapping.vma) {
-			ret = mali_mem_os_resize_cpu_map_locked(mem_backend, mali_allocation->cpu_mapping.vma, mali_allocation->cpu_mapping.vma->vm_start  + mem_backend->size, add_size);
-			if (unlikely(ret != _MALI_OSK_ERR_OK)) {
-				MALI_DEBUG_PRINT(2, ("_mali_ukk_mem_resize: cpu mapping failed !\n"));
-				goto  failed_cpu_map;
-			}
-		}
-
-		/* Resize mali mapping */
-		_mali_osk_mutex_wait(session->memory_lock);
-		ret = mali_mem_mali_map_resize(mali_allocation, physical_size);
-
-		if (ret) {
-			MALI_DEBUG_PRINT(1, ("_mali_ukk_mem_resize: mali map resize fail !\n"));
-			goto failed_gpu_map;
-		}
-
-		ret = mali_mem_os_mali_map(&mem_backend->os_mem, session, mali_allocation->mali_vma_node.vm_node.start,
-					   mali_allocation->psize / MALI_MMU_PAGE_SIZE, add_size / MALI_MMU_PAGE_SIZE, mali_allocation->mali_mapping.properties);
-		if (ret) {
-			MALI_DEBUG_PRINT(2, ("_mali_ukk_mem_resize: mali mapping failed !\n"));
-			goto failed_gpu_map;
-		}
-
-		_mali_osk_mutex_signal(session->memory_lock);
-	} else {
-		u32 dec_size, page_count;
-		u32 vaddr = 0;
-		INIT_LIST_HEAD(&tmp_os_mem.pages);
-		tmp_os_mem.count = 0;
-
-		dec_size = mem_backend->size - physical_size;
-		MALI_DEBUG_ASSERT(0 == dec_size %  MALI_MMU_PAGE_SIZE);
-
-		page_count = dec_size / MALI_MMU_PAGE_SIZE;
-		vaddr = mali_allocation->mali_vma_node.vm_node.start + physical_size;
-
-		/* Resize the memory of the backend */
-		ret = mali_mem_os_resize_pages(&mem_backend->os_mem, &tmp_os_mem, physical_size / MALI_MMU_PAGE_SIZE, page_count);
-
-		if (ret) {
-			MALI_DEBUG_PRINT(4, ("_mali_ukk_mem_resize: mali map resize failed!\n"));
-			goto failed_resize_pages;
-		}
-
-		/* Resize mali map */
-		_mali_osk_mutex_wait(session->memory_lock);
-		mali_mem_mali_map_free(session, dec_size, vaddr, mali_allocation->flags);
-		_mali_osk_mutex_signal(session->memory_lock);
-
-		/* Zap cpu mapping */
-		if (0 != mali_allocation->cpu_mapping.addr) {
-			MALI_DEBUG_ASSERT(NULL != mali_allocation->cpu_mapping.vma);
-			zap_vma_ptes(mali_allocation->cpu_mapping.vma, mali_allocation->cpu_mapping.vma->vm_start + physical_size, dec_size);
-		}
-
-		/* Free those extra pages */
-		mali_mem_os_free(&tmp_os_mem.pages, tmp_os_mem.count, MALI_FALSE);
-	}
-
-	/* Resize memory allocation and memory backend */
-	change_page_count = (s32)(physical_size - mem_backend->size) / MALI_MMU_PAGE_SIZE;
-	mali_allocation->psize = physical_size;
-	mem_backend->size = physical_size;
-	mutex_unlock(&mem_backend->mutex);
-
-	if (change_page_count > 0) {
-		atomic_add(change_page_count, &session->mali_mem_allocated_pages);
-		if (atomic_read(&session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE > session->max_mali_mem_allocated_size) {
-			session->max_mali_mem_allocated_size = atomic_read(&session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE;
-		}
-
-	} else {
-		atomic_sub((s32)(-change_page_count), &session->mali_mem_allocated_pages);
-	}
-
-	return _MALI_OSK_ERR_OK;
-
-failed_gpu_map:
-	_mali_osk_mutex_signal(session->memory_lock);
-failed_cpu_map:
-	if (physical_size > mem_backend->size) {
-		mali_mem_os_resize_pages(&mem_backend->os_mem, &tmp_os_mem, mem_backend->size / MALI_MMU_PAGE_SIZE,
-					 (physical_size - mem_backend->size) / MALI_MMU_PAGE_SIZE);
-	} else {
-		mali_mem_os_resize_pages(&tmp_os_mem, &mem_backend->os_mem, 0, tmp_os_mem.count);
-	}
-failed_resize_pages:
-	if (0 != tmp_os_mem.count)
-		mali_mem_os_free(&tmp_os_mem.pages, tmp_os_mem.count, MALI_FALSE);
-failed_alloc_memory:
-
-	mutex_unlock(&mem_backend->mutex);
-	return ret;
-}
-
 
 /* Set GPU MMU properties */
 static void _mali_memory_gpu_map_property_set(u32 *properties, u32 flags)
 {
+
 	if (_MALI_MEMORY_GPU_READ_ALLOCATE & flags) {
 		*properties = MALI_MMU_FLAGS_FORCE_GP_READ_ALLOCATE;
 	} else {
@@ -362,38 +187,6 @@ static void _mali_memory_gpu_map_property_set(u32 *properties, u32 flags)
 	}
 }
 
-_mali_osk_errcode_t mali_mem_add_mem_size(struct mali_session_data *session, u32 mali_addr, u32 add_size)
-{
-	mali_mem_backend *mem_backend = NULL;
-	_mali_osk_errcode_t ret = _MALI_OSK_ERR_FAULT;
-	mali_mem_allocation *mali_allocation = NULL;
-	u32 new_physical_size;
-	MALI_DEBUG_ASSERT_POINTER(session);
-	MALI_DEBUG_ASSERT(0 == add_size %  MALI_MMU_PAGE_SIZE);
-
-	/* Get the memory backend that need to be resize. */
-	mem_backend = mali_mem_backend_struct_search(session, mali_addr);
-
-	if (NULL == mem_backend)  {
-		MALI_DEBUG_PRINT(2, ("_mali_ukk_mem_resize: memory backend = NULL!\n"));
-		return ret;
-	}
-
-	mali_allocation = mem_backend->mali_allocation;
-
-	MALI_DEBUG_ASSERT_POINTER(mali_allocation);
-
-	new_physical_size = add_size + mem_backend->size;
-
-	if (new_physical_size > (mali_allocation->mali_vma_node.vm_node.size))
-		return ret;
-
-	MALI_DEBUG_ASSERT(new_physical_size != mem_backend->size);
-
-	ret = mali_mem_resize(session, mem_backend, new_physical_size);
-
-	return ret;
-}
 
 /**
 *  function@_mali_ukk_mem_allocate - allocate mali memory
@@ -410,17 +203,18 @@ _mali_osk_errcode_t _mali_ukk_mem_allocate(_mali_uk_alloc_mem_s *args)
 	MALI_DEBUG_PRINT(4, (" _mali_ukk_mem_allocate, vaddr=0x%x, size =0x%x! \n", args->gpu_vaddr, args->psize));
 
 	/* Check if the address is allocated
+	*  Can we trust User mode?
 	*/
 	mali_vma_node = mali_vma_offset_search(&session->allocation_mgr, args->gpu_vaddr, 0);
-
 	if (unlikely(mali_vma_node)) {
-		MALI_DEBUG_PRINT_ERROR(("The mali virtual address has already been used ! \n"));
+		/* Not support yet */
+		MALI_DEBUG_ASSERT(0);
 		return _MALI_OSK_ERR_FAULT;
 	}
+
 	/**
 	*create mali memory allocation
 	*/
-
 	mali_allocation = mali_mem_allocation_struct_create(session);
 
 	if (mali_allocation == NULL) {
@@ -430,19 +224,8 @@ _mali_osk_errcode_t _mali_ukk_mem_allocate(_mali_uk_alloc_mem_s *args)
 	mali_allocation->psize = args->psize;
 	mali_allocation->vsize = args->vsize;
 
-	/* MALI_MEM_OS if need to support mem resize,
-	 * or MALI_MEM_BLOCK if have dedicated memory,
-	 * or MALI_MEM_OS,
-	 * or MALI_MEM_SWAP.
-	 */
-	if (args->flags & _MALI_MEMORY_ALLOCATE_SWAPPABLE) {
-		mali_allocation->type = MALI_MEM_SWAP;
-	} else if (args->flags & _MALI_MEMORY_ALLOCATE_RESIZEABLE) {
-		mali_allocation->type = MALI_MEM_OS;
-		mali_allocation->flags |= MALI_MEM_FLAG_CAN_RESIZE;
-	} else if (args->flags & _MALI_MEMORY_ALLOCATE_SECURE) {
-		mali_allocation->type = MALI_MEM_SECURE;
-	} else if (MALI_TRUE == mali_memory_have_dedicated_memory()) {
+	/* check if have dedicated memory */
+	if (MALI_TRUE == mali_memory_have_dedicated_memory()) {
 		mali_allocation->type = MALI_MEM_BLOCK;
 	} else {
 		mali_allocation->type = MALI_MEM_OS;
@@ -456,140 +239,89 @@ _mali_osk_errcode_t _mali_ukk_mem_allocate(_mali_uk_alloc_mem_s *args)
 
 	mali_vma_offset_add(&session->allocation_mgr, &mali_allocation->mali_vma_node);
 
-	mali_allocation->backend_handle = mali_mem_backend_struct_create(&mem_backend, args->psize);
-	if (mali_allocation->backend_handle < 0) {
-		ret = _MALI_OSK_ERR_NOMEM;
-		MALI_DEBUG_PRINT(1, ("mali_allocation->backend_handle < 0! \n"));
-		goto failed_alloc_backend;
-	}
-
-
-	mem_backend->mali_allocation = mali_allocation;
-	mem_backend->type = mali_allocation->type;
-
-	mali_allocation->mali_mapping.addr = args->gpu_vaddr;
-
-	/* set gpu mmu propery */
-	_mali_memory_gpu_map_property_set(&mali_allocation->mali_mapping.properties, args->flags);
-	/* do prepare for MALI mapping */
-	if (!(args->flags & _MALI_MEMORY_ALLOCATE_NO_BIND_GPU) && mali_allocation->psize > 0) {
-		_mali_osk_mutex_wait(session->memory_lock);
-
-		ret = mali_mem_mali_map_prepare(mali_allocation);
-		if (0 != ret) {
-			_mali_osk_mutex_signal(session->memory_lock);
-			goto failed_prepare_map;
-		}
-		_mali_osk_mutex_signal(session->memory_lock);
-	}
-
-	if (mali_allocation->psize == 0) {
-		mem_backend->os_mem.count = 0;
-		INIT_LIST_HEAD(&mem_backend->os_mem.pages);
-		goto done;
-	}
-
-	if (args->flags & _MALI_MEMORY_ALLOCATE_DEFER_BIND) {
-		mali_allocation->flags |= _MALI_MEMORY_ALLOCATE_DEFER_BIND;
-		mem_backend->flags |= MALI_MEM_BACKEND_FLAG_NOT_BINDED;
-		/* init for defer bind backend*/
-		mem_backend->os_mem.count = 0;
-		INIT_LIST_HEAD(&mem_backend->os_mem.pages);
-
-		goto done;
-	}
+	/* check if need to allocate backend */
+	if (mali_allocation->psize == 0)
+		return _MALI_OSK_ERR_OK;
 
+	/**
+	*allocate physical backend & pages
+	*/
 	if (likely(mali_allocation->psize > 0)) {
+		mali_allocation->backend_handle = mali_mem_backend_struct_create(&mem_backend, args->psize);
+		if (mali_allocation->backend_handle < 0) {
+			ret = _MALI_OSK_ERR_NOMEM;
+			MALI_DEBUG_PRINT(1, ("mali_allocation->backend_handle < 0! \n"));
+			goto failed_alloc_backend;
+		}
 
-		if (MALI_MEM_SECURE == mem_backend->type) {
-#if defined(CONFIG_DMA_SHARED_BUFFER)
-			ret = mali_mem_secure_attach_dma_buf(&mem_backend->secure_mem, mem_backend->size, args->secure_shared_fd);
-			if (_MALI_OSK_ERR_OK != ret) {
-				MALI_DEBUG_PRINT(1, ("Failed to attach dma buf for secure memory! \n"));
-				goto failed_alloc_pages;
-			}
-#else
-			ret = _MALI_OSK_ERR_UNSUPPORTED;
-			MALI_DEBUG_PRINT(1, ("DMA not supported for mali secure memory! \n"));
-			goto failed_alloc_pages;
-#endif
-		} else {
+		mem_backend->mali_allocation = mali_allocation;
+		mem_backend->type = mali_allocation->type;
 
-			/**
-			*allocate physical memory
-			*/
-			if (mem_backend->type == MALI_MEM_OS) {
+		if (mem_backend->type == MALI_MEM_OS) {
+			retval = mali_mem_os_alloc_pages(&mem_backend->os_mem, mem_backend->size);
+		} else if (mem_backend->type == MALI_MEM_BLOCK) {
+			/* try to allocated from BLOCK memory first, then try OS memory if failed.*/
+			if (mali_mem_block_alloc(&mem_backend->block_mem, mem_backend->size)) {
 				retval = mali_mem_os_alloc_pages(&mem_backend->os_mem, mem_backend->size);
-			} else if (mem_backend->type == MALI_MEM_BLOCK) {
-				/* try to allocated from BLOCK memory first, then try OS memory if failed.*/
-				if (mali_mem_block_alloc(&mem_backend->block_mem, mem_backend->size)) {
-					retval = mali_mem_os_alloc_pages(&mem_backend->os_mem, mem_backend->size);
-					mem_backend->type = MALI_MEM_OS;
-					mali_allocation->type = MALI_MEM_OS;
-				}
-			} else if (MALI_MEM_SWAP == mem_backend->type) {
-				retval = mali_mem_swap_alloc_pages(&mem_backend->swap_mem, mali_allocation->mali_vma_node.vm_node.size, &mem_backend->start_idx);
-			}  else {
-				/* ONLY support mem_os type */
-				MALI_DEBUG_ASSERT(0);
+				mem_backend->type = MALI_MEM_OS;
+				mali_allocation->type = MALI_MEM_OS;
 			}
+		} else {
+			/* ONLY support mem_os type */
+			MALI_DEBUG_ASSERT(0);
+		}
 
-			if (retval) {
-				ret = _MALI_OSK_ERR_NOMEM;
-				MALI_DEBUG_PRINT(1, (" can't allocate enough pages! \n"));
-				goto failed_alloc_pages;
-			}
+		if (retval) {
+			ret = _MALI_OSK_ERR_NOMEM;
+			MALI_DEBUG_PRINT(1, (" can't allocate enough pages! \n"));
+			goto failed_alloc_pages;
 		}
 	}
 
 	/**
 	*map to GPU side
 	*/
+	mali_allocation->mali_mapping.addr = args->gpu_vaddr;
+
+	/* set gpu mmu propery */
+	_mali_memory_gpu_map_property_set(&mali_allocation->mali_mapping.properties, args->flags);
+
 	if (!(args->flags & _MALI_MEMORY_ALLOCATE_NO_BIND_GPU) && mali_allocation->psize > 0) {
 		_mali_osk_mutex_wait(session->memory_lock);
 		/* Map on Mali */
-
+		ret = mali_mem_mali_map_prepare(mali_allocation);
+		if (0 != ret) {
+			MALI_DEBUG_PRINT(1, (" prepare map fail! \n"));
+			goto failed_gpu_map;
+		}
+		/* only support os memory type now */
 		if (mem_backend->type == MALI_MEM_OS) {
-			ret = mali_mem_os_mali_map(&mem_backend->os_mem, session, args->gpu_vaddr, 0,
-						   mem_backend->size / MALI_MMU_PAGE_SIZE, mali_allocation->mali_mapping.properties);
-
+			mali_mem_os_mali_map(mem_backend, args->gpu_vaddr,
+					     mali_allocation->mali_mapping.properties);
 		} else if (mem_backend->type == MALI_MEM_BLOCK) {
 			mali_mem_block_mali_map(&mem_backend->block_mem, session, args->gpu_vaddr,
 						mali_allocation->mali_mapping.properties);
-		} else if (mem_backend->type == MALI_MEM_SWAP) {
-			ret = mali_mem_swap_mali_map(&mem_backend->swap_mem, session, args->gpu_vaddr,
-						     mali_allocation->mali_mapping.properties);
-		} else if (mem_backend->type == MALI_MEM_SECURE) {
-#if defined(CONFIG_DMA_SHARED_BUFFER)
-			ret = mali_mem_secure_mali_map(&mem_backend->secure_mem, session, args->gpu_vaddr, mali_allocation->mali_mapping.properties);
-#endif
-		} else { /* unsupport type */
+		} else {
+			/* Not support yet */
 			MALI_DEBUG_ASSERT(0);
 		}
-
+		session->mali_mem_array[mem_backend->type] += mem_backend->size;
+		if (session->mali_mem_array[MALI_MEM_OS] + session->mali_mem_array[MALI_MEM_BLOCK] > session->max_mali_mem_allocated) {
+			session->max_mali_mem_allocated = session->mali_mem_array[MALI_MEM_OS] + session->mali_mem_array[MALI_MEM_BLOCK];
+		}
 		_mali_osk_mutex_signal(session->memory_lock);
 	}
-done:
-	if (MALI_MEM_OS == mem_backend->type) {
-		atomic_add(mem_backend->os_mem.count, &session->mali_mem_allocated_pages);
-	} else if (MALI_MEM_BLOCK == mem_backend->type) {
-		atomic_add(mem_backend->block_mem.count, &session->mali_mem_allocated_pages);
-	} else if (MALI_MEM_SECURE == mem_backend->type) {
-		atomic_add(mem_backend->secure_mem.count, &session->mali_mem_allocated_pages);
-	} else {
-		MALI_DEBUG_ASSERT(MALI_MEM_SWAP == mem_backend->type);
-		atomic_add(mem_backend->swap_mem.count, &session->mali_mem_allocated_pages);
-		atomic_add(mem_backend->swap_mem.count, &session->mali_mem_array[mem_backend->type]);
-	}
 
-	if (atomic_read(&session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE > session->max_mali_mem_allocated_size) {
-		session->max_mali_mem_allocated_size = atomic_read(&session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE;
-	}
 	return _MALI_OSK_ERR_OK;
 
+failed_gpu_map:
+	_mali_osk_mutex_signal(session->memory_lock);
+	if (mem_backend->type == MALI_MEM_OS) {
+		mali_mem_os_free(&mem_backend->os_mem);
+	} else {
+		mali_mem_block_free(&mem_backend->block_mem);
+	}
 failed_alloc_pages:
-	mali_mem_mali_map_free(session, mali_allocation->psize, mali_allocation->mali_vma_node.vm_node.start, mali_allocation->flags);
-failed_prepare_map:
 	mali_mem_backend_struct_destory(&mem_backend, mali_allocation->backend_handle);
 failed_alloc_backend:
 
@@ -609,16 +341,13 @@ _mali_osk_errcode_t _mali_ukk_mem_free(_mali_uk_free_mem_s *args)
 
 	/* find mali allocation structure by vaddress*/
 	mali_vma_node = mali_vma_offset_search(&session->allocation_mgr, vaddr, 0);
-	if (NULL == mali_vma_node) {
-		MALI_DEBUG_PRINT(1, ("_mali_ukk_mem_free: invalid addr: 0x%x\n", vaddr));
-		return _MALI_OSK_ERR_INVALID_ARGS;
-	}
+
 	MALI_DEBUG_ASSERT(NULL != mali_vma_node);
 	mali_alloc = container_of(mali_vma_node, struct mali_mem_allocation, mali_vma_node);
 
 	if (mali_alloc)
 		/* check ref_count */
-		args->free_pages_nr = mali_allocation_unref(&mali_alloc);
+		mali_allocation_unref(&mali_alloc);
 
 	return _MALI_OSK_ERR_OK;
 }
@@ -677,8 +406,8 @@ _mali_osk_errcode_t _mali_ukk_mem_bind(_mali_uk_bind_mem_s *args)
 #if defined(CONFIG_MALI400_UMP)
 		mali_allocation->type = MALI_MEM_UMP;
 		mem_backend->type = MALI_MEM_UMP;
-		ret = mali_mem_bind_ump_buf(mali_allocation, mem_backend,
-					    args->mem_union.bind_ump.secure_id, args->mem_union.bind_ump.flags);
+		ret = mali_memory_bind_ump_buf(mali_allocation, mem_backend,
+					       args->mem_union.bind_ump.secure_id, args->mem_union.bind_ump.flags);
 		if (_MALI_OSK_ERR_OK != ret) {
 			MALI_DEBUG_PRINT(1, ("Bind ump buf failed\n"));
 			goto  Failed_bind_backend;
@@ -692,8 +421,8 @@ _mali_osk_errcode_t _mali_ukk_mem_bind(_mali_uk_bind_mem_s *args)
 #if defined(CONFIG_DMA_SHARED_BUFFER)
 		mali_allocation->type = MALI_MEM_DMA_BUF;
 		mem_backend->type = MALI_MEM_DMA_BUF;
-		ret = mali_mem_bind_dma_buf(mali_allocation, mem_backend,
-					    args->mem_union.bind_dma_buf.mem_fd, args->mem_union.bind_dma_buf.flags);
+		ret = mali_memory_bind_dma_buf(mali_allocation, mem_backend,
+					       args->mem_union.bind_dma_buf.mem_fd, args->mem_union.bind_dma_buf.flags);
 		if (_MALI_OSK_ERR_OK != ret) {
 			MALI_DEBUG_PRINT(1, ("Bind dma buf failed\n"));
 			goto Failed_bind_backend;
@@ -705,15 +434,14 @@ _mali_osk_errcode_t _mali_ukk_mem_bind(_mali_uk_bind_mem_s *args)
 		break;
 	case _MALI_MEMORY_BIND_BACKEND_MALI_MEMORY:
 		/* not allowed */
-		MALI_DEBUG_PRINT_ERROR(("Mali internal memory type not supported !\n"));
-		goto Failed_bind_backend;
+		MALI_DEBUG_ASSERT(0);
 		break;
 
 	case _MALI_MEMORY_BIND_BACKEND_EXTERNAL_MEMORY:
 		mali_allocation->type = MALI_MEM_EXTERNAL;
 		mem_backend->type = MALI_MEM_EXTERNAL;
-		ret = mali_mem_bind_ext_buf(mali_allocation, mem_backend, args->mem_union.bind_ext_memory.phys_addr,
-					    args->mem_union.bind_ext_memory.flags);
+		ret = mali_memory_bind_ext_mem(mali_allocation, mem_backend, args->mem_union.bind_ext_memory.phys_addr,
+					       args->mem_union.bind_ext_memory.flags);
 		if (_MALI_OSK_ERR_OK != ret) {
 			MALI_DEBUG_PRINT(1, ("Bind external buf failed\n"));
 			goto Failed_bind_backend;
@@ -722,19 +450,16 @@ _mali_osk_errcode_t _mali_ukk_mem_bind(_mali_uk_bind_mem_s *args)
 
 	case _MALI_MEMORY_BIND_BACKEND_EXT_COW:
 		/* not allowed */
-		MALI_DEBUG_PRINT_ERROR(("External cow memory  type not supported !\n"));
-		goto Failed_bind_backend;
+		MALI_DEBUG_ASSERT(0);
 		break;
 
 	default:
-		MALI_DEBUG_PRINT_ERROR(("Invalid memory type  not supported !\n"));
-		goto Failed_bind_backend;
+		MALI_DEBUG_ASSERT(0);
 		break;
 	}
-	MALI_DEBUG_ASSERT(0 == mem_backend->size % MALI_MMU_PAGE_SIZE);
-	atomic_add(mem_backend->size / MALI_MMU_PAGE_SIZE, &session->mali_mem_array[mem_backend->type]);
 	return _MALI_OSK_ERR_OK;
 
+
 Failed_bind_backend:
 	mali_mem_backend_struct_destory(&mem_backend, mali_allocation->backend_handle);
 
@@ -768,6 +493,8 @@ _mali_osk_errcode_t _mali_ukk_mem_unbind(_mali_uk_unbind_mem_s *args)
 		mali_allocation = container_of(mali_vma_node, struct mali_mem_allocation, mali_vma_node);
 	} else {
 		MALI_DEBUG_ASSERT(NULL != mali_vma_node);
+		/* Not support yet */
+		MALI_DEBUG_ASSERT(0);
 		return _MALI_OSK_ERR_INVALID_ARGS;
 	}
 
@@ -777,6 +504,8 @@ _mali_osk_errcode_t _mali_ukk_mem_unbind(_mali_uk_unbind_mem_s *args)
 	return _MALI_OSK_ERR_OK;
 }
 
+
+
 /*
 * Function _mali_ukk_mem_cow --  COW for an allocation
 * This function allocate new pages for  a range (range, range+size) of allocation
@@ -785,209 +514,30 @@ _mali_osk_errcode_t _mali_ukk_mem_unbind(_mali_uk_unbind_mem_s *args)
 _mali_osk_errcode_t _mali_ukk_mem_cow(_mali_uk_cow_mem_s *args)
 {
 	_mali_osk_errcode_t ret = _MALI_OSK_ERR_FAULT;
-	mali_mem_backend *target_backend = NULL;
-	mali_mem_backend *mem_backend = NULL;
-	struct mali_vma_node *mali_vma_node = NULL;
-	mali_mem_allocation *mali_allocation = NULL;
-
-	struct  mali_session_data *session = (struct mali_session_data *)(uintptr_t)args->ctx;
-	/* Get the target backend for cow */
-	target_backend = mali_mem_backend_struct_search(session, args->target_handle);
 
-	if (NULL == target_backend || 0 == target_backend->size) {
-		MALI_DEBUG_ASSERT_POINTER(target_backend);
-		MALI_DEBUG_ASSERT(0 != target_backend->size);
-		return ret;
-	}
-
-	/*Cow not support resized mem */
-	MALI_DEBUG_ASSERT(MALI_MEM_FLAG_CAN_RESIZE != (MALI_MEM_FLAG_CAN_RESIZE & target_backend->mali_allocation->flags));
-
-	/* Check if the new mali address is allocated */
-	mali_vma_node = mali_vma_offset_search(&session->allocation_mgr, args->vaddr, 0);
-
-	if (unlikely(mali_vma_node)) {
-		MALI_DEBUG_PRINT_ERROR(("The mali virtual address has already been used ! \n"));
-		return ret;
-	}
-
-	/* create new alloction for COW*/
-	mali_allocation = mali_mem_allocation_struct_create(session);
-	if (mali_allocation == NULL) {
-		MALI_DEBUG_PRINT(1, ("_mali_ukk_mem_cow: Failed to create allocation struct!\n"));
-		return _MALI_OSK_ERR_NOMEM;
-	}
-	mali_allocation->psize = args->target_size;
-	mali_allocation->vsize = args->target_size;
-	mali_allocation->type = MALI_MEM_COW;
-
-	/*add allocation node to RB tree for index*/
-	mali_allocation->mali_vma_node.vm_node.start = args->vaddr;
-	mali_allocation->mali_vma_node.vm_node.size = mali_allocation->vsize;
-	mali_vma_offset_add(&session->allocation_mgr, &mali_allocation->mali_vma_node);
+	/* create new alloction if needed */
 
-	/* create new backend for COW memory */
-	mali_allocation->backend_handle = mali_mem_backend_struct_create(&mem_backend, mali_allocation->psize);
-	if (mali_allocation->backend_handle < 0) {
-		ret = _MALI_OSK_ERR_NOMEM;
-		MALI_DEBUG_PRINT(1, ("mali_allocation->backend_handle < 0! \n"));
-		goto failed_alloc_backend;
-	}
-	mem_backend->mali_allocation = mali_allocation;
-	mem_backend->type = mali_allocation->type;
-
-	if (target_backend->type == MALI_MEM_SWAP ||
-	    (MALI_MEM_COW == target_backend->type && (MALI_MEM_BACKEND_FLAG_SWAP_COWED & target_backend->flags))) {
-		mem_backend->flags |= MALI_MEM_BACKEND_FLAG_SWAP_COWED;
-		/**
-		 *     CoWed swap backends couldn't be mapped as non-linear vma, because if one
-		 * vma is set with flag VM_NONLINEAR, the vma->vm_private_data will be used by kernel,
-		 * while in mali driver, we use this variable to store the pointer of mali_allocation, so there
-		 * is a conflict.
-		 *     To resolve this problem, we have to do some fake things, we reserved about 64MB
-		 * space from index 0, there isn't really page's index will be set from 0 to (64MB>>PAGE_SHIFT_NUM),
-		 * and all of CoWed swap memory backends' start_idx will be assigned with 0, and these
-		 * backends will be mapped as linear and will add to priority tree of global swap file, while
-		 * these vmas will never be found by using normal page->index, these pages in those vma
-		 * also couldn't be swapped out.
-		 */
-		mem_backend->start_idx = 0;
-	}
+	/* Get the target allocation and it's backend*/
 
-	/* Add the target backend's cow count, also allocate new pages for COW backend from os mem
-	*for a modified range and keep the page which not in the modified range and Add ref to it
-	*/
-	MALI_DEBUG_PRINT(3, ("Cow mapping: target_addr: 0x%x;  cow_addr: 0x%x,  size: %u\n", target_backend->mali_allocation->mali_vma_node.vm_node.start,
-			     mali_allocation->mali_vma_node.vm_node.start, mali_allocation->mali_vma_node.vm_node.size));
+	/* allocate new pages from os mem for modified range */
 
-	ret = mali_memory_do_cow(target_backend, args->target_offset, args->target_size, mem_backend, args->range_start, args->range_size);
-	if (_MALI_OSK_ERR_OK != ret) {
-		MALI_DEBUG_PRINT(1, ("_mali_ukk_mem_cow: Failed to cow!\n"));
-		goto failed_do_cow;
-	}
 
-	/**
-	*map to GPU side
+	/* fill the COW backend, all pages for this allocation
+	*  including the new page for modified range and pages not modified in old allocation.
+	* Do Add ref to pages from target allocation
 	*/
-	mali_allocation->mali_mapping.addr = args->vaddr;
-	/* set gpu mmu propery */
-	_mali_memory_gpu_map_property_set(&mali_allocation->mali_mapping.properties, args->flags);
-
-	_mali_osk_mutex_wait(session->memory_lock);
-	/* Map on Mali */
-	ret = mali_mem_mali_map_prepare(mali_allocation);
-	if (0 != ret) {
-		MALI_DEBUG_PRINT(1, (" prepare map fail! \n"));
-		goto failed_gpu_map;
-	}
-
-	if (!(mem_backend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED)) {
-		mali_mem_cow_mali_map(mem_backend, 0, mem_backend->size);
-	}
-
-	_mali_osk_mutex_signal(session->memory_lock);
-
-	mutex_lock(&target_backend->mutex);
-	target_backend->flags |= MALI_MEM_BACKEND_FLAG_COWED;
-	mutex_unlock(&target_backend->mutex);
-
-	atomic_add(args->range_size / MALI_MMU_PAGE_SIZE, &session->mali_mem_allocated_pages);
-	if (atomic_read(&session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE > session->max_mali_mem_allocated_size) {
-		session->max_mali_mem_allocated_size = atomic_read(&session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE;
-	}
-	return _MALI_OSK_ERR_OK;
 
-failed_gpu_map:
-	_mali_osk_mutex_signal(session->memory_lock);
-	mali_mem_cow_release(mem_backend, MALI_FALSE);
-	mem_backend->cow_mem.count = 0;
-failed_do_cow:
-	mali_mem_backend_struct_destory(&mem_backend, mali_allocation->backend_handle);
-failed_alloc_backend:
-	mali_vma_offset_remove(&session->allocation_mgr, &mali_allocation->mali_vma_node);
-	mali_mem_allocation_struct_destory(mali_allocation);
 
+	/* map it to GPU side */
 	return ret;
 }
 
-_mali_osk_errcode_t _mali_ukk_mem_cow_modify_range(_mali_uk_cow_modify_range_s *args)
-{
-	_mali_osk_errcode_t ret = _MALI_OSK_ERR_FAULT;
-	mali_mem_backend *mem_backend = NULL;
-	struct  mali_session_data *session = (struct mali_session_data *)(uintptr_t)args->ctx;
-
-	MALI_DEBUG_PRINT(4, (" _mali_ukk_mem_cow_modify_range called! \n"));
-	/* Get the backend that need to be modified. */
-	mem_backend = mali_mem_backend_struct_search(session, args->vaddr);
-
-	if (NULL == mem_backend || 0 == mem_backend->size) {
-		MALI_DEBUG_ASSERT_POINTER(mem_backend);
-		MALI_DEBUG_ASSERT(0 != mem_backend->size);
-		return ret;
-	}
-
-	MALI_DEBUG_ASSERT(MALI_MEM_COW  == mem_backend->type);
-
-	ret =  mali_memory_cow_modify_range(mem_backend, args->range_start, args->size);
-	args->change_pages_nr = mem_backend->cow_mem.change_pages_nr;
-	if (_MALI_OSK_ERR_OK != ret)
-		return  ret;
-	_mali_osk_mutex_wait(session->memory_lock);
-	if (!(mem_backend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED)) {
-		mali_mem_cow_mali_map(mem_backend, args->range_start, args->size);
-	}
-	_mali_osk_mutex_signal(session->memory_lock);
-
-	atomic_add(args->change_pages_nr, &session->mali_mem_allocated_pages);
-	if (atomic_read(&session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE > session->max_mali_mem_allocated_size) {
-		session->max_mali_mem_allocated_size = atomic_read(&session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE;
-	}
-
-	return _MALI_OSK_ERR_OK;
-}
-
-
-_mali_osk_errcode_t _mali_ukk_mem_resize(_mali_uk_mem_resize_s *args)
-{
-	mali_mem_backend *mem_backend = NULL;
-	_mali_osk_errcode_t ret = _MALI_OSK_ERR_FAULT;
-
-	struct  mali_session_data *session = (struct mali_session_data *)(uintptr_t)args->ctx;
-
-	MALI_DEBUG_ASSERT_POINTER(session);
-	MALI_DEBUG_PRINT(4, (" mali_mem_resize_memory called! \n"));
-	MALI_DEBUG_ASSERT(0 == args->psize %  MALI_MMU_PAGE_SIZE);
-
-	/* Get the memory backend that need to be resize. */
-	mem_backend = mali_mem_backend_struct_search(session, args->vaddr);
-
-	if (NULL == mem_backend)  {
-		MALI_DEBUG_PRINT(2, ("_mali_ukk_mem_resize: memory backend = NULL!\n"));
-		return ret;
-	}
-
-	MALI_DEBUG_ASSERT(args->psize != mem_backend->size);
-
-	ret = mali_mem_resize(session, mem_backend, args->psize);
+/**
+*  attach a backend to an exist mali allocation
+*/
 
-	return ret;
-}
 
-_mali_osk_errcode_t _mali_ukk_mem_usage_get(_mali_uk_profiling_memory_usage_get_s *args)
-{
-	args->memory_usage = _mali_ukk_report_memory_usage();
-	if (0 != args->vaddr) {
-		mali_mem_backend *mem_backend = NULL;
-		struct  mali_session_data *session = (struct mali_session_data *)(uintptr_t)args->ctx;
-		/* Get the backend that need to be modified. */
-		mem_backend = mali_mem_backend_struct_search(session, args->vaddr);
-		if (NULL == mem_backend) {
-			MALI_DEBUG_ASSERT_POINTER(mem_backend);
-			return _MALI_OSK_ERR_FAULT;
-		}
+/**
+*  deattach a backend from an exist mali allocation
+*/
 
-		if (MALI_MEM_COW == mem_backend->type)
-			args->change_pages_nr = mem_backend->cow_mem.change_pages_nr;
-	}
-	return _MALI_OSK_ERR_OK;
-}
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_manager.h b/drivers/gpu/arm/mali/linux/mali_memory_manager.h
old mode 100755
new mode 100644
index 0ced2802..e44c032c
--- a/drivers/gpu/arm/mali/linux/mali_memory_manager.h
+++ b/drivers/gpu/arm/mali/linux/mali_memory_manager.h
@@ -1,51 +1,47 @@
-/*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+/*
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#ifndef __MALI_MEMORY_MANAGER_H__
-#define __MALI_MEMORY_MANAGER_H__
-
-#include "mali_osk.h"
-#include <linux/list.h>
-#include <linux/mm.h>
-#include <linux/rbtree.h>
-#include <linux/spinlock.h>
-#include <linux/types.h>
-#include "mali_memory_types.h"
-#include "mali_memory_os_alloc.h"
-#include "mali_uk_types.h"
-
-struct mali_allocation_manager {
-	rwlock_t vm_lock;
-	struct rb_root allocation_mgr_rb;
-	struct list_head head;
-	struct mutex list_mutex;
-	u32 mali_allocation_num;
-};
-
-extern struct idr mali_backend_idr;
-extern struct mutex mali_idr_mutex;
-
-int mali_memory_manager_init(struct mali_allocation_manager *mgr);
-void mali_memory_manager_uninit(struct mali_allocation_manager *mgr);
-
-void  mali_mem_allocation_struct_destory(mali_mem_allocation *alloc);
-_mali_osk_errcode_t mali_mem_add_mem_size(struct mali_session_data *session, u32 mali_addr, u32 add_size);
-mali_mem_backend *mali_mem_backend_struct_search(struct mali_session_data *session, u32 mali_address);
-_mali_osk_errcode_t _mali_ukk_mem_allocate(_mali_uk_alloc_mem_s *args);
-_mali_osk_errcode_t _mali_ukk_mem_free(_mali_uk_free_mem_s *args);
-_mali_osk_errcode_t _mali_ukk_mem_bind(_mali_uk_bind_mem_s *args);
-_mali_osk_errcode_t _mali_ukk_mem_unbind(_mali_uk_unbind_mem_s *args);
-_mali_osk_errcode_t _mali_ukk_mem_cow(_mali_uk_cow_mem_s *args);
-_mali_osk_errcode_t _mali_ukk_mem_cow_modify_range(_mali_uk_cow_modify_range_s *args);
-_mali_osk_errcode_t _mali_ukk_mem_usage_get(_mali_uk_profiling_memory_usage_get_s *args);
-_mali_osk_errcode_t _mali_ukk_mem_resize(_mali_uk_mem_resize_s *args);
-
-#endif
-
+ */
+
+#ifndef __MALI_MEMORY_MANAGER_H__
+#define __MALI_MEMORY_MANAGER_H__
+
+#include "mali_osk.h"
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/rbtree.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include "mali_memory_types.h"
+#include "mali_memory_os_alloc.h"
+#include "mali_uk_types.h"
+
+struct mali_allocation_manager {
+	rwlock_t vm_lock;
+	struct rb_root allocation_mgr_rb;
+	struct list_head head;
+	struct mutex list_mutex;
+	u32 mali_allocation_nr;
+};
+
+extern struct idr mali_backend_idr;
+extern struct mutex mali_idr_mutex;
+
+int mali_memory_manager_init(struct mali_allocation_manager *mgr);
+void mali_memory_manager_uninit(struct mali_allocation_manager *mgr);
+
+void  mali_mem_allocation_struct_destory(mali_mem_allocation *alloc);
+
+_mali_osk_errcode_t _mali_ukk_mem_allocate(_mali_uk_alloc_mem_s *args);
+_mali_osk_errcode_t _mali_ukk_mem_free(_mali_uk_free_mem_s *args);
+_mali_osk_errcode_t _mali_ukk_mem_bind(_mali_uk_bind_mem_s *args);
+_mali_osk_errcode_t _mali_ukk_mem_unbind(_mali_uk_unbind_mem_s *args);
+
+
+#endif
+
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_os_alloc.c b/drivers/gpu/arm/mali/linux/mali_memory_os_alloc.c
old mode 100755
new mode 100644
index 7f229eb4..a765b072
--- a/drivers/gpu/arm/mali/linux/mali_memory_os_alloc.c
+++ b/drivers/gpu/arm/mali/linux/mali_memory_os_alloc.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -46,8 +46,21 @@ static unsigned long mali_mem_os_shrink_count(struct shrinker *shrinker, struct
 #endif
 #endif
 static void mali_mem_os_trim_pool(struct work_struct *work);
+static void mali_mem_os_free_page(struct mali_page_node *m_page);
 
-struct mali_mem_os_allocator mali_mem_os_allocator = {
+
+static struct mali_mem_os_allocator {
+	spinlock_t pool_lock;
+	struct list_head pool_pages;
+	size_t pool_count;
+
+	atomic_t allocated_pages;
+	size_t allocation_limit;
+
+	struct shrinker shrinker;
+	struct delayed_work timed_shrinker;
+	struct workqueue_struct *wq;
+} mali_mem_os_allocator = {
 	.pool_lock = __SPIN_LOCK_UNLOCKED(pool_lock),
 	.pool_pages = LIST_HEAD_INIT(mali_mem_os_allocator.pool_pages),
 	.pool_count = 0,
@@ -71,87 +84,36 @@ struct mali_mem_os_allocator mali_mem_os_allocator = {
 #endif
 };
 
-u32 mali_mem_os_free(struct list_head *os_pages, u32 pages_count, mali_bool cow_flag)
+void mali_mem_os_free(mali_mem_os_mem *os_mem)
 {
 	LIST_HEAD(pages);
-	struct mali_page_node *m_page, *m_tmp;
-	u32 free_pages_nr = 0;
-
-	if (MALI_TRUE == cow_flag) {
-		list_for_each_entry_safe(m_page, m_tmp, os_pages, list) {
-			/*only handle OS node here */
-			if (m_page->type == MALI_PAGE_NODE_OS) {
-				if (1 == _mali_page_node_get_ref_count(m_page)) {
-					list_move(&m_page->list, &pages);
-					atomic_sub(1, &mali_mem_os_allocator.allocated_pages);
-					free_pages_nr ++;
-				} else {
-					_mali_page_node_unref(m_page);
-					m_page->page = NULL;
-					list_del(&m_page->list);
-					kfree(m_page);
-				}
-			}
-		}
-	} else {
-		list_cut_position(&pages, os_pages, os_pages->prev);
-		atomic_sub(pages_count, &mali_mem_os_allocator.allocated_pages);
-		free_pages_nr = pages_count;
-	}
+
+	atomic_sub(os_mem->count, &mali_mem_os_allocator.allocated_pages);
 
 	/* Put pages on pool. */
+	list_cut_position(&pages, &os_mem->pages, os_mem->pages.prev);
+
 	spin_lock(&mali_mem_os_allocator.pool_lock);
+
 	list_splice(&pages, &mali_mem_os_allocator.pool_pages);
-	mali_mem_os_allocator.pool_count += free_pages_nr;
+	mali_mem_os_allocator.pool_count += os_mem->count;
+
 	spin_unlock(&mali_mem_os_allocator.pool_lock);
 
 	if (MALI_OS_MEMORY_KERNEL_BUFFER_SIZE_IN_PAGES < mali_mem_os_allocator.pool_count) {
 		MALI_DEBUG_PRINT(5, ("OS Mem: Starting pool trim timer %u\n", mali_mem_os_allocator.pool_count));
 		queue_delayed_work(mali_mem_os_allocator.wq, &mali_mem_os_allocator.timed_shrinker, MALI_OS_MEMORY_POOL_TRIM_JIFFIES);
 	}
-	return free_pages_nr;
 }
 
 /**
-* put page without put it into page pool
-*/
-_mali_osk_errcode_t mali_mem_os_put_page(struct page *page)
-{
-	MALI_DEBUG_ASSERT_POINTER(page);
-	if (1 == page_count(page)) {
-		atomic_sub(1, &mali_mem_os_allocator.allocated_pages);
-		dma_unmap_page(&mali_platform_device->dev, page_private(page),
-			       _MALI_OSK_MALI_PAGE_SIZE, DMA_TO_DEVICE);
-		ClearPagePrivate(page);
-	}
-	put_page(page);
-	return _MALI_OSK_ERR_OK;
-}
+* free memory without put it into page pool
 
-_mali_osk_errcode_t mali_mem_os_resize_pages(mali_mem_os_mem *mem_from, mali_mem_os_mem *mem_to, u32 start_page, u32 page_count)
+void mali_mem_os_free_not_pooled(mali_mem_os_mem *os_mem)
 {
-	struct mali_page_node *m_page, *m_tmp;
-	u32 i = 0;
 
-	MALI_DEBUG_ASSERT_POINTER(mem_from);
-	MALI_DEBUG_ASSERT_POINTER(mem_to);
-
-	if (mem_from->count < start_page + page_count) {
-		return _MALI_OSK_ERR_INVALID_ARGS;
-	}
-
-	list_for_each_entry_safe(m_page, m_tmp, &mem_from->pages, list) {
-		if (i >= start_page && i < start_page + page_count) {
-			list_move_tail(&m_page->list, &mem_to->pages);
-			mem_from->count--;
-			mem_to->count++;
-		}
-		i++;
-	}
-
-	return _MALI_OSK_ERR_OK;
 }
-
+*/
 
 int mali_mem_os_alloc_pages(mali_mem_os_mem *os_mem, u32 size)
 {
@@ -200,23 +162,18 @@ int mali_mem_os_alloc_pages(mali_mem_os_mem *os_mem, u32 size)
 	/* Allocate new pages, if needed. */
 	for (i = 0; i < remaining; i++) {
 		dma_addr_t dma_addr;
-		gfp_t flags = __GFP_ZERO | __GFP_REPEAT | __GFP_NOWARN | __GFP_COLD;
+		struct mali_page_node *new_page_node = NULL;
+		gfp_t flags = __GFP_ZERO | __GFP_NORETRY | __GFP_NOWARN | __GFP_COLD;
 		int err;
 
 #if defined(CONFIG_ARM) && !defined(CONFIG_ARM_LPAE)
 		flags |= GFP_HIGHUSER;
 #else
-#ifdef CONFIG_ZONE_DMA32
+		/* After 3.15.0 kernel use ZONE_DMA replace ZONE_DMA32 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
 		flags |= GFP_DMA32;
 #else
-#ifdef CONFIG_ZONE_DMA
 		flags |= GFP_DMA;
-#else
-		/* arm64 utgard only work on < 4G, but the kernel
-		 * didn't provide method to allocte memory < 4G
-		 */
-		MALI_DEBUG_ASSERT(0);
-#endif
 #endif
 #endif
 
@@ -226,7 +183,7 @@ int mali_mem_os_alloc_pages(mali_mem_os_mem *os_mem, u32 size)
 			/* Calculate the number of pages actually allocated, and free them. */
 			os_mem->count = (page_count - remaining) + i;
 			atomic_add(os_mem->count, &mali_mem_os_allocator.allocated_pages);
-			mali_mem_os_free(&os_mem->pages, os_mem->count, MALI_FALSE);
+			mali_mem_os_free(os_mem);
 			return -ENOMEM;
 		}
 
@@ -241,7 +198,7 @@ int mali_mem_os_alloc_pages(mali_mem_os_mem *os_mem, u32 size)
 			__free_page(new_page);
 			os_mem->count = (page_count - remaining) + i;
 			atomic_add(os_mem->count, &mali_mem_os_allocator.allocated_pages);
-			mali_mem_os_free(&os_mem->pages, os_mem->count, MALI_FALSE);
+			mali_mem_os_free(os_mem);
 			return -EFAULT;
 		}
 
@@ -249,8 +206,8 @@ int mali_mem_os_alloc_pages(mali_mem_os_mem *os_mem, u32 size)
 		SetPagePrivate(new_page);
 		set_page_private(new_page, dma_addr);
 
-		m_page = _mali_page_node_allocate(MALI_PAGE_NODE_OS);
-		if (unlikely(NULL == m_page)) {
+		new_page_node = kmalloc(sizeof(mali_page_node), GFP_KERNEL);
+		if (unlikely(NULL == new_page_node)) {
 			MALI_PRINT_ERROR(("OS Mem: Can't allocate mali_page node! \n"));
 			dma_unmap_page(&mali_platform_device->dev, page_private(new_page),
 				       _MALI_OSK_MALI_PAGE_SIZE, DMA_TO_DEVICE);
@@ -258,12 +215,13 @@ int mali_mem_os_alloc_pages(mali_mem_os_mem *os_mem, u32 size)
 			__free_page(new_page);
 			os_mem->count = (page_count - remaining) + i;
 			atomic_add(os_mem->count, &mali_mem_os_allocator.allocated_pages);
-			mali_mem_os_free(&os_mem->pages, os_mem->count, MALI_FALSE);
+			mali_mem_os_free(os_mem);
 			return -EFAULT;
 		}
-		m_page->page = new_page;
+		new_page_node->page = new_page;
+		INIT_LIST_HEAD(&new_page_node->list);
 
-		list_add_tail(&m_page->list, &os_mem->pages);
+		list_add_tail(&new_page_node->list, &os_mem->pages);
 	}
 
 	atomic_add(page_count, &mali_mem_os_allocator.allocated_pages);
@@ -277,66 +235,38 @@ int mali_mem_os_alloc_pages(mali_mem_os_mem *os_mem, u32 size)
 }
 
 
-_mali_osk_errcode_t mali_mem_os_mali_map(mali_mem_os_mem *os_mem, struct mali_session_data *session, u32 vaddr, u32 start_page, u32 mapping_pgae_num, u32 props)
+void mali_mem_os_mali_map(mali_mem_backend *mem_bkend, u32 vaddr, u32 props)
 {
-	struct mali_page_directory *pagedir = session->page_directory;
+	struct mali_session_data *session;
+	struct mali_page_directory *pagedir;
 	struct mali_page_node *m_page;
-	u32 virt;
+	u32 virt = vaddr;
 	u32 prop = props;
 
-	MALI_DEBUG_ASSERT_POINTER(session);
-	MALI_DEBUG_ASSERT_POINTER(os_mem);
-
-	MALI_DEBUG_ASSERT(start_page <= os_mem->count);
-	MALI_DEBUG_ASSERT((start_page + mapping_pgae_num) <= os_mem->count);
-
-	if ((start_page + mapping_pgae_num) == os_mem->count) {
+	MALI_DEBUG_ASSERT_POINTER(mem_bkend);
+	MALI_DEBUG_ASSERT_POINTER(mem_bkend->mali_allocation);
 
-		virt = vaddr + MALI_MMU_PAGE_SIZE * (start_page + mapping_pgae_num);
+	session = mem_bkend->mali_allocation->session;
+	MALI_DEBUG_ASSERT_POINTER(session);
+	pagedir = session->page_directory;
 
-		list_for_each_entry_reverse(m_page, &os_mem->pages, list) {
+	list_for_each_entry(m_page, &mem_bkend->os_mem.pages, list) {
+		dma_addr_t phys = page_private(m_page->page);
 
-			virt -= MALI_MMU_PAGE_SIZE;
-			if (mapping_pgae_num > 0) {
-				dma_addr_t phys = page_private(m_page->page);
 #if defined(CONFIG_ARCH_DMA_ADDR_T_64BIT)
-				/* Verify that the "physical" address is 32-bit and
-				* usable for Mali, when on a system with bus addresses
-				* wider than 32-bit. */
-				MALI_DEBUG_ASSERT(0 == (phys >> 32));
+		/* Verify that the "physical" address is 32-bit and
+		 * usable for Mali, when on a system with bus addresses
+		 * wider than 32-bit. */
+		MALI_DEBUG_ASSERT(0 == (phys >> 32));
 #endif
-				mali_mmu_pagedir_update(pagedir, virt, (mali_dma_addr)phys, MALI_MMU_PAGE_SIZE, prop);
-			} else {
-				break;
-			}
-			mapping_pgae_num--;
-		}
-
-	} else {
-		u32 i = 0;
-		virt = vaddr;
-		list_for_each_entry(m_page, &os_mem->pages, list) {
-
-			if (i >= start_page) {
-				dma_addr_t phys = page_private(m_page->page);
 
-#if defined(CONFIG_ARCH_DMA_ADDR_T_64BIT)
-				/* Verify that the "physical" address is 32-bit and
-				* usable for Mali, when on a system with bus addresses
-				* wider than 32-bit. */
-				MALI_DEBUG_ASSERT(0 == (phys >> 32));
-#endif
-				mali_mmu_pagedir_update(pagedir, virt, (mali_dma_addr)phys, MALI_MMU_PAGE_SIZE, prop);
-			}
-			i++;
-			virt += MALI_MMU_PAGE_SIZE;
-		}
+		mali_mmu_pagedir_update(pagedir, virt, (mali_dma_addr)phys, MALI_MMU_PAGE_SIZE, prop);
+		virt += MALI_MMU_PAGE_SIZE;
 	}
-	return _MALI_OSK_ERR_OK;
 }
 
 
-void mali_mem_os_mali_unmap(mali_mem_allocation *alloc)
+static void mali_mem_os_mali_unmap(mali_mem_allocation *alloc)
 {
 	struct mali_session_data *session;
 	MALI_DEBUG_ASSERT_POINTER(alloc);
@@ -346,17 +276,16 @@ void mali_mem_os_mali_unmap(mali_mem_allocation *alloc)
 	mali_session_memory_lock(session);
 	mali_mem_mali_map_free(session, alloc->psize, alloc->mali_vma_node.vm_node.start,
 			       alloc->flags);
+	session->mali_mem_array[alloc->type] -= alloc->psize;
 	mali_session_memory_unlock(session);
 }
 
-int mali_mem_os_cpu_map(mali_mem_backend *mem_bkend, struct vm_area_struct *vma)
+int mali_mem_os_cpu_map(mali_mem_os_mem *os_mem, struct vm_area_struct *vma)
 {
-	mali_mem_os_mem *os_mem = &mem_bkend->os_mem;
 	struct mali_page_node *m_page;
 	struct page *page;
 	int ret;
 	unsigned long addr = vma->vm_start;
-	MALI_DEBUG_ASSERT(MALI_MEM_OS == mem_bkend->type);
 
 	list_for_each_entry(m_page, &os_mem->pages, list) {
 		/* We should use vm_insert_page, but it does a dcache
@@ -375,110 +304,21 @@ int mali_mem_os_cpu_map(mali_mem_backend *mem_bkend, struct vm_area_struct *vma)
 	return 0;
 }
 
-_mali_osk_errcode_t mali_mem_os_resize_cpu_map_locked(mali_mem_backend *mem_bkend, struct vm_area_struct *vma, unsigned long start_vaddr, u32 mappig_size)
-{
-	mali_mem_os_mem *os_mem = &mem_bkend->os_mem;
-	struct mali_page_node *m_page;
-	int ret;
-	int offset;
-	int mapping_page_num;
-	int count ;
-
-	unsigned long vstart = vma->vm_start;
-	count = 0;
-	MALI_DEBUG_ASSERT(mem_bkend->type == MALI_MEM_OS);
-	MALI_DEBUG_ASSERT(0 == start_vaddr % _MALI_OSK_MALI_PAGE_SIZE);
-	MALI_DEBUG_ASSERT(0 == vstart % _MALI_OSK_MALI_PAGE_SIZE);
-	offset = (start_vaddr - vstart) / _MALI_OSK_MALI_PAGE_SIZE;
-	MALI_DEBUG_ASSERT(offset <= os_mem->count);
-	mapping_page_num = mappig_size / _MALI_OSK_MALI_PAGE_SIZE;
-	MALI_DEBUG_ASSERT((offset + mapping_page_num) <= os_mem->count);
-
-	if ((offset + mapping_page_num) == os_mem->count) {
-
-		unsigned long vm_end = start_vaddr + mappig_size;
-
-		list_for_each_entry_reverse(m_page, &os_mem->pages, list) {
-
-			vm_end -= _MALI_OSK_MALI_PAGE_SIZE;
-			if (mapping_page_num > 0) {
-				ret = vm_insert_pfn(vma, vm_end, page_to_pfn(m_page->page));
-
-				if (unlikely(0 != ret)) {
-					/*will return -EBUSY If the page has already been mapped into table, but it's OK*/
-					if (-EBUSY == ret) {
-						break;
-					} else {
-						MALI_DEBUG_PRINT(1, ("OS Mem: mali_mem_os_resize_cpu_map_locked failed, ret = %d, offset is %d,page_count is %d\n",
-								     ret,  offset + mapping_page_num, os_mem->count));
-					}
-					return _MALI_OSK_ERR_FAULT;
-				}
-			} else {
-				break;
-			}
-			mapping_page_num--;
-
-		}
-	} else {
-
-		list_for_each_entry(m_page, &os_mem->pages, list) {
-			if (count >= offset) {
-
-				ret = vm_insert_pfn(vma, vstart, page_to_pfn(m_page->page));
-
-				if (unlikely(0 != ret)) {
-					/*will return -EBUSY If the page has already been mapped into table, but it's OK*/
-					if (-EBUSY == ret) {
-						break;
-					} else {
-						MALI_DEBUG_PRINT(1, ("OS Mem: mali_mem_os_resize_cpu_map_locked failed, ret = %d, count is %d, offset is %d,page_count is %d\n",
-								     ret, count, offset, os_mem->count));
-					}
-					return _MALI_OSK_ERR_FAULT;
-				}
-			}
-			count++;
-			vstart += _MALI_OSK_MALI_PAGE_SIZE;
-		}
-	}
-	return _MALI_OSK_ERR_OK;
-}
-
-u32 mali_mem_os_release(mali_mem_backend *mem_bkend)
+void mali_mem_os_release(mali_mem_backend *mem_bkend)
 {
 
 	mali_mem_allocation *alloc;
-	struct mali_session_data *session;
-	u32 free_pages_nr = 0;
 	MALI_DEBUG_ASSERT_POINTER(mem_bkend);
 	MALI_DEBUG_ASSERT(MALI_MEM_OS == mem_bkend->type);
 
 	alloc = mem_bkend->mali_allocation;
 	MALI_DEBUG_ASSERT_POINTER(alloc);
 
-	session = alloc->session;
-	MALI_DEBUG_ASSERT_POINTER(session);
-
 	/* Unmap the memory from the mali virtual address space. */
 	mali_mem_os_mali_unmap(alloc);
-	mutex_lock(&mem_bkend->mutex);
-	/* Free pages */
-	if (MALI_MEM_BACKEND_FLAG_COWED & mem_bkend->flags) {
-		/* Lock to avoid the free race condition for the cow shared memory page node. */
-		_mali_osk_mutex_wait(session->cow_lock);
-		free_pages_nr = mali_mem_os_free(&mem_bkend->os_mem.pages, mem_bkend->os_mem.count, MALI_TRUE);
-		_mali_osk_mutex_signal(session->cow_lock);
-	} else {
-		free_pages_nr = mali_mem_os_free(&mem_bkend->os_mem.pages, mem_bkend->os_mem.count, MALI_FALSE);
-	}
-	mutex_unlock(&mem_bkend->mutex);
-
-	MALI_DEBUG_PRINT(4, ("OS Mem free : allocated size = 0x%x, free size = 0x%x\n", mem_bkend->os_mem.count * _MALI_OSK_MALI_PAGE_SIZE,
-			     free_pages_nr * _MALI_OSK_MALI_PAGE_SIZE));
 
-	mem_bkend->os_mem.count = 0;
-	return free_pages_nr;
+	/* Free pages */
+	mali_mem_os_free(&mem_bkend->os_mem);
 }
 
 
@@ -561,19 +401,17 @@ void mali_mem_os_release_table_page(mali_dma_addr phys, void *virt)
 	}
 }
 
-void mali_mem_os_free_page_node(struct mali_page_node *m_page)
+static void mali_mem_os_free_page(struct mali_page_node *m_page)
 {
 	struct page *page = m_page->page;
-	MALI_DEBUG_ASSERT(m_page->type == MALI_PAGE_NODE_OS);
+	BUG_ON(page_count(page) != 1);
+
+	dma_unmap_page(&mali_platform_device->dev, page_private(page),
+		       _MALI_OSK_MALI_PAGE_SIZE, DMA_TO_DEVICE);
+
+	ClearPagePrivate(page);
 
-	if (1  == page_count(page)) {
-		dma_unmap_page(&mali_platform_device->dev, page_private(page),
-			       _MALI_OSK_MALI_PAGE_SIZE, DMA_TO_DEVICE);
-		ClearPagePrivate(page);
-	}
 	__free_page(page);
-	m_page->page = NULL;
-	list_del(&m_page->list);
 	kfree(m_page);
 }
 
@@ -692,7 +530,7 @@ static unsigned long mali_mem_os_shrink(struct shrinker *shrinker, struct shrink
 	spin_unlock_irqrestore(&mali_mem_os_allocator.pool_lock, flags);
 
 	list_for_each_entry_safe(m_page, m_tmp, &pages, list) {
-		mali_mem_os_free_page_node(m_page);
+		mali_mem_os_free_page(m_page);
 	}
 
 	if (MALI_OS_MEMORY_KERNEL_BUFFER_SIZE_IN_PAGES > mali_mem_os_allocator.pool_count) {
@@ -738,7 +576,7 @@ static void mali_mem_os_trim_pool(struct work_struct *data)
 	spin_unlock(&mali_mem_os_allocator.pool_lock);
 
 	list_for_each_entry_safe(m_page, m_tmp, &pages, list) {
-		mali_mem_os_free_page_node(m_page);
+		mali_mem_os_free_page(m_page);
 	}
 
 	/* Release some pages from page table page pool */
@@ -779,7 +617,7 @@ void mali_mem_os_term(void)
 
 	spin_lock(&mali_mem_os_allocator.pool_lock);
 	list_for_each_entry_safe(m_page, m_tmp, &mali_mem_os_allocator.pool_pages, list) {
-		mali_mem_os_free_page_node(m_page);
+		mali_mem_os_free_page(m_page);
 
 		--mali_mem_os_allocator.pool_count;
 	}
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_os_alloc.h b/drivers/gpu/arm/mali/linux/mali_memory_os_alloc.h
old mode 100755
new mode 100644
index b92fffe0..90001e94
--- a/drivers/gpu/arm/mali/linux/mali_memory_os_alloc.h
+++ b/drivers/gpu/arm/mali/linux/mali_memory_os_alloc.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -14,41 +14,26 @@
 #include "mali_osk.h"
 #include "mali_memory_types.h"
 
-
 /** @brief Release Mali OS memory
  *
  * The session memory_lock must be held when calling this function.
  *
  * @param mem_bkend Pointer to the mali_mem_backend to release
  */
-u32 mali_mem_os_release(mali_mem_backend *mem_bkend);
+void mali_mem_os_release(mali_mem_backend *mem_bkend);
 
 _mali_osk_errcode_t mali_mem_os_get_table_page(mali_dma_addr *phys, mali_io_address *mapping);
 
 void mali_mem_os_release_table_page(mali_dma_addr phys, void *virt);
 
 _mali_osk_errcode_t mali_mem_os_init(void);
-
 void mali_mem_os_term(void);
-
 u32 mali_mem_os_stat(void);
 
-void mali_mem_os_free_page_node(struct mali_page_node *m_page);
-
 int mali_mem_os_alloc_pages(mali_mem_os_mem *os_mem, u32 size);
+void mali_mem_os_free(mali_mem_os_mem *os_mem);
+void mali_mem_os_mali_map(mali_mem_backend *mem_bkend, u32 vaddr, u32 props);
+int mali_mem_os_cpu_map(mali_mem_os_mem *os_mem, struct vm_area_struct *vma);
 
-u32 mali_mem_os_free(struct list_head *os_pages, u32 pages_count, mali_bool cow_flag);
-
-_mali_osk_errcode_t mali_mem_os_put_page(struct page *page);
-
-_mali_osk_errcode_t mali_mem_os_resize_pages(mali_mem_os_mem *mem_from, mali_mem_os_mem *mem_to, u32 start_page, u32 page_count);
-
-_mali_osk_errcode_t mali_mem_os_mali_map(mali_mem_os_mem *os_mem, struct mali_session_data *session, u32 vaddr, u32 start_page, u32 mapping_pgae_num, u32 props);
-
-void mali_mem_os_mali_unmap(mali_mem_allocation *alloc);
-
-int mali_mem_os_cpu_map(mali_mem_backend *mem_bkend, struct vm_area_struct *vma);
-
-_mali_osk_errcode_t mali_mem_os_resize_cpu_map_locked(mali_mem_backend *mem_bkend, struct vm_area_struct *vma, unsigned long start_vaddr, u32 mappig_size);
 
 #endif /* __MALI_MEMORY_OS_ALLOC_H__ */
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_secure.c b/drivers/gpu/arm/mali/linux/mali_memory_secure.c
deleted file mode 100755
index 7856ae6c..00000000
--- a/drivers/gpu/arm/mali/linux/mali_memory_secure.c
+++ /dev/null
@@ -1,169 +0,0 @@
-/*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#include "mali_kernel_common.h"
-#include "mali_memory.h"
-#include "mali_memory_secure.h"
-#include "mali_osk.h"
-#include <linux/mutex.h>
-#include <linux/dma-mapping.h>
-#include <linux/dma-buf.h>
-
-_mali_osk_errcode_t mali_mem_secure_attach_dma_buf(mali_mem_secure *secure_mem, u32 size, int mem_fd)
-{
-	struct dma_buf *buf;
-	MALI_DEBUG_ASSERT_POINTER(secure_mem);
-
-	/* get dma buffer */
-	buf = dma_buf_get(mem_fd);
-	if (IS_ERR_OR_NULL(buf)) {
-		MALI_DEBUG_PRINT_ERROR(("Failed to get dma buf!\n"));
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	if (size != buf->size) {
-		MALI_DEBUG_PRINT_ERROR(("The secure mem size not match to the dma buf size!\n"));
-		goto failed_alloc_mem;
-	}
-
-	secure_mem->buf =  buf;
-	secure_mem->attachment = dma_buf_attach(secure_mem->buf, &mali_platform_device->dev);
-	if (NULL == secure_mem->attachment) {
-		MALI_DEBUG_PRINT_ERROR(("Failed to get dma buf attachment!\n"));
-		goto failed_dma_attach;
-	}
-
-	secure_mem->sgt = dma_buf_map_attachment(secure_mem->attachment, DMA_BIDIRECTIONAL);
-	if (IS_ERR_OR_NULL(secure_mem->sgt)) {
-		MALI_DEBUG_PRINT_ERROR(("Failed to map dma buf attachment\n"));
-		goto  failed_dma_map;
-	}
-
-	secure_mem->count = size / MALI_MMU_PAGE_SIZE;
-
-	return _MALI_OSK_ERR_OK;
-
-failed_dma_map:
-	dma_buf_detach(secure_mem->buf, secure_mem->attachment);
-failed_dma_attach:
-failed_alloc_mem:
-	dma_buf_put(buf);
-	return _MALI_OSK_ERR_FAULT;
-}
-
-_mali_osk_errcode_t mali_mem_secure_mali_map(mali_mem_secure *secure_mem, struct mali_session_data *session, u32 vaddr, u32 props)
-{
-	struct mali_page_directory *pagedir;
-	struct scatterlist *sg;
-	u32 virt = vaddr;
-	u32 prop = props;
-	int i;
-
-	MALI_DEBUG_ASSERT_POINTER(secure_mem);
-	MALI_DEBUG_ASSERT_POINTER(secure_mem->sgt);
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	pagedir = session->page_directory;
-
-	for_each_sg(secure_mem->sgt->sgl, sg, secure_mem->sgt->nents, i) {
-		u32 size = sg_dma_len(sg);
-		dma_addr_t phys = sg_dma_address(sg);
-
-		/* sg must be page aligned. */
-		MALI_DEBUG_ASSERT(0 == size % MALI_MMU_PAGE_SIZE);
-		MALI_DEBUG_ASSERT(0 == (phys & ~(uintptr_t)0xFFFFFFFF));
-
-		mali_mmu_pagedir_update(pagedir, virt, phys, size, prop);
-
-		MALI_DEBUG_PRINT(3, ("The secure mem physical address: 0x%x gpu virtual address: 0x%x! \n", phys, virt));
-		virt += size;
-	}
-
-	return _MALI_OSK_ERR_OK;
-}
-
-void mali_mem_secure_mali_unmap(mali_mem_allocation *alloc)
-{
-	struct mali_session_data *session;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-	session = alloc->session;
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	mali_session_memory_lock(session);
-	mali_mem_mali_map_free(session, alloc->psize, alloc->mali_vma_node.vm_node.start,
-			       alloc->flags);
-	mali_session_memory_unlock(session);
-}
-
-
-int mali_mem_secure_cpu_map(mali_mem_backend *mem_bkend, struct vm_area_struct *vma)
-{
-
-	int ret = 0;
-	struct scatterlist *sg;
-	mali_mem_secure *secure_mem = &mem_bkend->secure_mem;
-	unsigned long addr = vma->vm_start;
-	int i;
-
-	MALI_DEBUG_ASSERT(mem_bkend->type == MALI_MEM_SECURE);
-
-	for_each_sg(secure_mem->sgt->sgl, sg, secure_mem->sgt->nents, i) {
-		phys_addr_t phys;
-		dma_addr_t dev_addr;
-		u32 size, j;
-		dev_addr = sg_dma_address(sg);
-#if defined(CONFIG_ARM64) ||LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
-		phys =  dma_to_phys(&mali_platform_device->dev, dev_addr);
-#else
-		phys = page_to_phys(pfn_to_page(dma_to_pfn(&mali_platform_device->dev, dev_addr)));
-#endif
-		size = sg_dma_len(sg);
-		MALI_DEBUG_ASSERT(0 == size % _MALI_OSK_MALI_PAGE_SIZE);
-
-		for (j = 0; j < size / _MALI_OSK_MALI_PAGE_SIZE; j++) {
-			ret = vm_insert_pfn(vma, addr, PFN_DOWN(phys));
-
-			if (unlikely(0 != ret)) {
-				return -EFAULT;
-			}
-			addr += _MALI_OSK_MALI_PAGE_SIZE;
-			phys += _MALI_OSK_MALI_PAGE_SIZE;
-
-			MALI_DEBUG_PRINT(3, ("The secure mem physical address: 0x%x , cpu virtual address: 0x%x! \n", phys, addr));
-		}
-	}
-	return ret;
-}
-
-u32 mali_mem_secure_release(mali_mem_backend *mem_bkend)
-{
-	struct mali_mem_secure *mem;
-	mali_mem_allocation *alloc = mem_bkend->mali_allocation;
-	u32 free_pages_nr = 0;
-	MALI_DEBUG_ASSERT(mem_bkend->type == MALI_MEM_SECURE);
-
-	mem = &mem_bkend->secure_mem;
-	MALI_DEBUG_ASSERT_POINTER(mem->attachment);
-	MALI_DEBUG_ASSERT_POINTER(mem->buf);
-	MALI_DEBUG_ASSERT_POINTER(mem->sgt);
-	/* Unmap the memory from the mali virtual address space. */
-	mali_mem_secure_mali_unmap(alloc);
-	mutex_lock(&mem_bkend->mutex);
-	dma_buf_unmap_attachment(mem->attachment, mem->sgt, DMA_BIDIRECTIONAL);
-	dma_buf_detach(mem->buf, mem->attachment);
-	dma_buf_put(mem->buf);
-	mutex_unlock(&mem_bkend->mutex);
-
-	free_pages_nr = mem->count;
-
-	return free_pages_nr;
-}
-
-
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_secure.h b/drivers/gpu/arm/mali/linux/mali_memory_secure.h
deleted file mode 100755
index cb85767c..00000000
--- a/drivers/gpu/arm/mali/linux/mali_memory_secure.h
+++ /dev/null
@@ -1,30 +0,0 @@
-/*
- * Copyright (C) 2010, 2013, 2015-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#ifndef __MALI_MEMORY_SECURE_H__
-#define __MALI_MEMORY_SECURE_H__
-
-#include "mali_session.h"
-#include "mali_memory.h"
-#include <linux/spinlock.h>
-
-#include "mali_memory_types.h"
-
-_mali_osk_errcode_t mali_mem_secure_attach_dma_buf(mali_mem_secure *secure_mem, u32 size, int mem_fd);
-
-_mali_osk_errcode_t mali_mem_secure_mali_map(mali_mem_secure *secure_mem, struct mali_session_data *session, u32 vaddr, u32 props);
-
-void mali_mem_secure_mali_unmap(mali_mem_allocation *alloc);
-
-int mali_mem_secure_cpu_map(mali_mem_backend *mem_bkend, struct vm_area_struct *vma);
-
-u32 mali_mem_secure_release(mali_mem_backend *mem_bkend);
-
-#endif /* __MALI_MEMORY_SECURE_H__ */
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_swap_alloc.c b/drivers/gpu/arm/mali/linux/mali_memory_swap_alloc.c
deleted file mode 100755
index 47933283..00000000
--- a/drivers/gpu/arm/mali/linux/mali_memory_swap_alloc.c
+++ /dev/null
@@ -1,942 +0,0 @@
-/*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#include <linux/list.h>
-#include <linux/mm.h>
-#include <linux/mm_types.h>
-#include <linux/fs.h>
-#include <linux/dma-mapping.h>
-#include <linux/slab.h>
-#include <linux/version.h>
-#include <linux/sched.h>
-#include <linux/idr.h>
-#include <linux/platform_device.h>
-#include <linux/workqueue.h>
-#include <linux/shmem_fs.h>
-#include <linux/file.h>
-#include <linux/swap.h>
-#include <linux/pagemap.h>
-#include "mali_osk.h"
-#include "mali_osk_mali.h"
-#include "mali_memory.h"
-#include "mali_memory_manager.h"
-#include "mali_memory_virtual.h"
-#include "mali_memory_cow.h"
-#include "mali_ukk.h"
-#include "mali_kernel_utilization.h"
-#include "mali_memory_swap_alloc.h"
-
-
-static struct _mali_osk_bitmap idx_mgr;
-static struct file *global_swap_file;
-static struct address_space *global_swap_space;
-static _mali_osk_wq_work_t *mali_mem_swap_out_workq = NULL;
-static u32 mem_backend_swapped_pool_size;
-#ifdef MALI_MEM_SWAP_TRACKING
-static u32 mem_backend_swapped_unlock_size;
-#endif
-/* Lock order: mem_backend_swapped_pool_lock  > each memory backend's mutex lock.
- * This lock used to protect mem_backend_swapped_pool_size and mem_backend_swapped_pool. */
-static struct mutex mem_backend_swapped_pool_lock;
-static struct list_head mem_backend_swapped_pool;
-
-extern struct mali_mem_os_allocator mali_mem_os_allocator;
-
-#define MALI_SWAP_LOW_MEM_DEFAULT_VALUE (60*1024*1024)
-#define MALI_SWAP_INVALIDATE_MALI_ADDRESS (0)               /* Used to mark the given memory cookie is invalidate. */
-#define MALI_SWAP_GLOBAL_SWAP_FILE_SIZE (0xFFFFFFFF)
-#define MALI_SWAP_GLOBAL_SWAP_FILE_INDEX ((MALI_SWAP_GLOBAL_SWAP_FILE_SIZE) >> PAGE_CACHE_SHIFT)
-#define MALI_SWAP_GLOBAL_SWAP_FILE_INDEX_RESERVE (1 << 15) /* Reserved for CoW nonlinear swap backend memory, the space size is 128MB. */
-
-unsigned int mali_mem_swap_out_threshold_value = MALI_SWAP_LOW_MEM_DEFAULT_VALUE;
-
-/**
- * We have two situations to do shrinking things, one is we met low GPU utilization which shows GPU needn't touch too
- * swappable backends in short time, and the other one is we add new swappable backends, the total pool size exceed
- * the threshold value of the swapped pool size.
- */
-typedef enum {
-	MALI_MEM_SWAP_SHRINK_WITH_LOW_UTILIZATION = 100,
-	MALI_MEM_SWAP_SHRINK_FOR_ADDING_NEW_BACKENDS = 257,
-} _mali_mem_swap_pool_shrink_type_t;
-
-static void mali_mem_swap_swapped_bkend_pool_check_for_low_utilization(void *arg);
-
-_mali_osk_errcode_t mali_mem_swap_init(void)
-{
-	gfp_t flags = __GFP_NORETRY | __GFP_NOWARN;
-
-	if (_MALI_OSK_ERR_OK != _mali_osk_bitmap_init(&idx_mgr, MALI_SWAP_GLOBAL_SWAP_FILE_INDEX, MALI_SWAP_GLOBAL_SWAP_FILE_INDEX_RESERVE)) {
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	global_swap_file = shmem_file_setup("mali_swap", MALI_SWAP_GLOBAL_SWAP_FILE_SIZE, VM_NORESERVE);
-	if (IS_ERR(global_swap_file)) {
-		_mali_osk_bitmap_term(&idx_mgr);
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	global_swap_space = global_swap_file->f_path.dentry->d_inode->i_mapping;
-
-	mali_mem_swap_out_workq = _mali_osk_wq_create_work(mali_mem_swap_swapped_bkend_pool_check_for_low_utilization, NULL);
-	if (NULL == mali_mem_swap_out_workq) {
-		_mali_osk_bitmap_term(&idx_mgr);
-		fput(global_swap_file);
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-#if defined(CONFIG_ARM) && !defined(CONFIG_ARM_LPAE)
-	flags |= GFP_HIGHUSER;
-#else
-#ifdef CONFIG_ZONE_DMA32
-	flags |= GFP_DMA32;
-#else
-#ifdef CONFIG_ZONE_DMA
-	flags |= GFP_DMA;
-#else
-	/* arm64 utgard only work on < 4G, but the kernel
-	 * didn't provide method to allocte memory < 4G
-	 */
-	MALI_DEBUG_ASSERT(0);
-#endif
-#endif
-#endif
-
-	/* When we use shmem_read_mapping_page to allocate/swap-in, it will
-	 * use these flags to allocate new page if need.*/
-	mapping_set_gfp_mask(global_swap_space, flags);
-
-	mem_backend_swapped_pool_size = 0;
-#ifdef MALI_MEM_SWAP_TRACKING
-	mem_backend_swapped_unlock_size = 0;
-#endif
-	mutex_init(&mem_backend_swapped_pool_lock);
-	INIT_LIST_HEAD(&mem_backend_swapped_pool);
-
-	MALI_DEBUG_PRINT(2, ("Mali SWAP: Swap out threshold vaule is %uM\n", mali_mem_swap_out_threshold_value >> 20));
-
-	return _MALI_OSK_ERR_OK;
-}
-
-void mali_mem_swap_term(void)
-{
-	_mali_osk_bitmap_term(&idx_mgr);
-
-	fput(global_swap_file);
-
-	_mali_osk_wq_delete_work(mali_mem_swap_out_workq);
-
-	MALI_DEBUG_ASSERT(list_empty(&mem_backend_swapped_pool));
-	MALI_DEBUG_ASSERT(0 == mem_backend_swapped_pool_size);
-
-	return;
-}
-
-struct file *mali_mem_swap_get_global_swap_file(void)
-{
-	return  global_swap_file;
-}
-
-/* Judge if swappable backend in swapped pool. */
-static mali_bool mali_memory_swap_backend_in_swapped_pool(mali_mem_backend *mem_bkend)
-{
-	MALI_DEBUG_ASSERT_POINTER(mem_bkend);
-
-	return !list_empty(&mem_bkend->list);
-}
-
-void mali_memory_swap_list_backend_delete(mali_mem_backend *mem_bkend)
-{
-	MALI_DEBUG_ASSERT_POINTER(mem_bkend);
-
-	mutex_lock(&mem_backend_swapped_pool_lock);
-	mutex_lock(&mem_bkend->mutex);
-
-	if (MALI_FALSE == mali_memory_swap_backend_in_swapped_pool(mem_bkend)) {
-		mutex_unlock(&mem_bkend->mutex);
-		mutex_unlock(&mem_backend_swapped_pool_lock);
-		return;
-	}
-
-	MALI_DEBUG_ASSERT(!list_empty(&mem_bkend->list));
-
-	list_del_init(&mem_bkend->list);
-
-	mutex_unlock(&mem_bkend->mutex);
-
-	mem_backend_swapped_pool_size -= mem_bkend->size;
-
-	mutex_unlock(&mem_backend_swapped_pool_lock);
-}
-
-static void mali_mem_swap_out_page_node(mali_page_node *page_node)
-{
-	MALI_DEBUG_ASSERT(page_node);
-
-	dma_unmap_page(&mali_platform_device->dev, page_node->swap_it->dma_addr,
-		       _MALI_OSK_MALI_PAGE_SIZE, DMA_TO_DEVICE);
-	set_page_dirty(page_node->swap_it->page);
-	page_cache_release(page_node->swap_it->page);
-}
-
-void mali_mem_swap_unlock_single_mem_backend(mali_mem_backend *mem_bkend)
-{
-	mali_page_node *m_page;
-
-	MALI_DEBUG_ASSERT(1 == mutex_is_locked(&mem_bkend->mutex));
-
-	if (MALI_MEM_BACKEND_FLAG_UNSWAPPED_IN == (mem_bkend->flags & MALI_MEM_BACKEND_FLAG_UNSWAPPED_IN)) {
-		return;
-	}
-
-	mem_bkend->flags |= MALI_MEM_BACKEND_FLAG_UNSWAPPED_IN;
-
-	list_for_each_entry(m_page, &mem_bkend->swap_mem.pages, list) {
-		mali_mem_swap_out_page_node(m_page);
-	}
-
-	return;
-}
-
-static void mali_mem_swap_unlock_partial_locked_mem_backend(mali_mem_backend *mem_bkend, mali_page_node *page_node)
-{
-	mali_page_node *m_page;
-
-	MALI_DEBUG_ASSERT(1 == mutex_is_locked(&mem_bkend->mutex));
-
-	list_for_each_entry(m_page, &mem_bkend->swap_mem.pages, list) {
-		if (m_page == page_node) {
-			break;
-		}
-		mali_mem_swap_out_page_node(m_page);
-	}
-}
-
-static void mali_mem_swap_swapped_bkend_pool_shrink(_mali_mem_swap_pool_shrink_type_t shrink_type)
-{
-	mali_mem_backend *bkend, *tmp_bkend;
-	long system_free_size;
-	u32 last_gpu_utilization, gpu_utilization_threshold_value, temp_swap_out_threshold_value;
-
-	MALI_DEBUG_ASSERT(1 == mutex_is_locked(&mem_backend_swapped_pool_lock));
-
-	if (MALI_MEM_SWAP_SHRINK_WITH_LOW_UTILIZATION == shrink_type) {
-		/**
-		 * When we met that system memory is very low and Mali locked swappable memory size is less than
-		 * threshold value, and at the same time, GPU load is very low and don't need high performance,
-		 * at this condition, we can unlock more swap memory backend from swapped backends pool.
-		 */
-		gpu_utilization_threshold_value = MALI_MEM_SWAP_SHRINK_WITH_LOW_UTILIZATION;
-		temp_swap_out_threshold_value = (mali_mem_swap_out_threshold_value >> 2);
-	} else {
-		/* When we add swappable memory backends to swapped pool, we need to think that we couldn't
-		* hold too much swappable backends in Mali driver, and also we need considering performance.
-		* So there is a balance for swapping out memory backend, we should follow the following conditions:
-		* 1. Total memory size in global mem backend swapped pool is more than the defined threshold value.
-		* 2. System level free memory size is less than the defined threshold value.
-		* 3. Please note that GPU utilization problem isn't considered in this condition.
-		*/
-		gpu_utilization_threshold_value = MALI_MEM_SWAP_SHRINK_FOR_ADDING_NEW_BACKENDS;
-		temp_swap_out_threshold_value = mali_mem_swap_out_threshold_value;
-	}
-
-	/* Get system free pages number. */
-	system_free_size = global_page_state(NR_FREE_PAGES) * PAGE_SIZE;
-	last_gpu_utilization = _mali_ukk_utilization_gp_pp();
-
-	if ((last_gpu_utilization < gpu_utilization_threshold_value)
-	    && (system_free_size < mali_mem_swap_out_threshold_value)
-	    && (mem_backend_swapped_pool_size > temp_swap_out_threshold_value)) {
-		list_for_each_entry_safe(bkend, tmp_bkend, &mem_backend_swapped_pool, list) {
-			if (mem_backend_swapped_pool_size <= temp_swap_out_threshold_value) {
-				break;
-			}
-
-			mutex_lock(&bkend->mutex);
-
-			/* check if backend is in use. */
-			if (0 < bkend->using_count) {
-				mutex_unlock(&bkend->mutex);
-				continue;
-			}
-
-			mali_mem_swap_unlock_single_mem_backend(bkend);
-			list_del_init(&bkend->list);
-			mem_backend_swapped_pool_size -= bkend->size;
-#ifdef MALI_MEM_SWAP_TRACKING
-			mem_backend_swapped_unlock_size += bkend->size;
-#endif
-			mutex_unlock(&bkend->mutex);
-		}
-	}
-
-	return;
-}
-
-static void mali_mem_swap_swapped_bkend_pool_check_for_low_utilization(void *arg)
-{
-	MALI_IGNORE(arg);
-
-	mutex_lock(&mem_backend_swapped_pool_lock);
-
-	mali_mem_swap_swapped_bkend_pool_shrink(MALI_MEM_SWAP_SHRINK_WITH_LOW_UTILIZATION);
-
-	mutex_unlock(&mem_backend_swapped_pool_lock);
-}
-
-/**
- * After PP job finished, we add all of swappable memory backend used by this PP
- * job to the tail of the global swapped pool, and if the total size of swappable memory is more than threshold
- * value, we also need to shrink the swapped pool start from the head of the list.
- */
-void mali_memory_swap_list_backend_add(mali_mem_backend *mem_bkend)
-{
-	mutex_lock(&mem_backend_swapped_pool_lock);
-	mutex_lock(&mem_bkend->mutex);
-
-	if (mali_memory_swap_backend_in_swapped_pool(mem_bkend)) {
-		MALI_DEBUG_ASSERT(!list_empty(&mem_bkend->list));
-
-		list_del_init(&mem_bkend->list);
-		list_add_tail(&mem_bkend->list, &mem_backend_swapped_pool);
-		mutex_unlock(&mem_bkend->mutex);
-		mutex_unlock(&mem_backend_swapped_pool_lock);
-		return;
-	}
-
-	list_add_tail(&mem_bkend->list, &mem_backend_swapped_pool);
-
-	mutex_unlock(&mem_bkend->mutex);
-	mem_backend_swapped_pool_size += mem_bkend->size;
-
-	mali_mem_swap_swapped_bkend_pool_shrink(MALI_MEM_SWAP_SHRINK_FOR_ADDING_NEW_BACKENDS);
-
-	mutex_unlock(&mem_backend_swapped_pool_lock);
-	return;
-}
-
-
-u32 mali_mem_swap_idx_alloc(void)
-{
-	return _mali_osk_bitmap_alloc(&idx_mgr);
-}
-
-void mali_mem_swap_idx_free(u32 idx)
-{
-	_mali_osk_bitmap_free(&idx_mgr, idx);
-}
-
-static u32 mali_mem_swap_idx_range_alloc(u32 count)
-{
-	u32 index;
-
-	index = _mali_osk_bitmap_alloc_range(&idx_mgr, count);
-
-	return index;
-}
-
-static void mali_mem_swap_idx_range_free(u32 idx, int num)
-{
-	_mali_osk_bitmap_free_range(&idx_mgr, idx, num);
-}
-
-struct mali_swap_item *mali_mem_swap_alloc_swap_item(void)
-{
-	mali_swap_item *swap_item;
-
-	swap_item = kzalloc(sizeof(mali_swap_item), GFP_KERNEL);
-
-	if (NULL == swap_item) {
-		return NULL;
-	}
-
-	atomic_set(&swap_item->ref_count, 1);
-	swap_item->page = NULL;
-	atomic_add(1, &mali_mem_os_allocator.allocated_pages);
-
-	return swap_item;
-}
-
-void mali_mem_swap_free_swap_item(mali_swap_item *swap_item)
-{
-	struct inode *file_node;
-	long long start, end;
-
-	/* If this swap item is shared, we just reduce the reference counter. */
-	if (0 == atomic_dec_return(&swap_item->ref_count)) {
-		file_node = global_swap_file->f_path.dentry->d_inode;
-		start = swap_item->idx;
-		start = start << 12;
-		end = start + PAGE_SIZE;
-
-		shmem_truncate_range(file_node, start, (end - 1));
-
-		mali_mem_swap_idx_free(swap_item->idx);
-
-		atomic_sub(1, &mali_mem_os_allocator.allocated_pages);
-
-		kfree(swap_item);
-	}
-}
-
-/* Used to allocate new swap item for new memory allocation and cow page for write. */
-struct mali_page_node *_mali_mem_swap_page_node_allocate(void)
-{
-	struct mali_page_node *m_page;
-
-	m_page = _mali_page_node_allocate(MALI_PAGE_NODE_SWAP);
-
-	if (NULL == m_page) {
-		return NULL;
-	}
-
-	m_page->swap_it = mali_mem_swap_alloc_swap_item();
-
-	if (NULL == m_page->swap_it) {
-		kfree(m_page);
-		return NULL;
-	}
-
-	return m_page;
-}
-
-_mali_osk_errcode_t _mali_mem_swap_put_page_node(struct mali_page_node *m_page)
-{
-
-	mali_mem_swap_free_swap_item(m_page->swap_it);
-
-	return _MALI_OSK_ERR_OK;
-}
-
-void _mali_mem_swap_page_node_free(struct mali_page_node *m_page)
-{
-	_mali_mem_swap_put_page_node(m_page);
-
-	kfree(m_page);
-
-	return;
-}
-
-u32 mali_mem_swap_free(mali_mem_swap *swap_mem)
-{
-	struct mali_page_node *m_page, *m_tmp;
-	u32 free_pages_nr = 0;
-
-	MALI_DEBUG_ASSERT_POINTER(swap_mem);
-
-	list_for_each_entry_safe(m_page, m_tmp, &swap_mem->pages, list) {
-		MALI_DEBUG_ASSERT(m_page->type == MALI_PAGE_NODE_SWAP);
-
-		/* free the page node and release the swap item, if the ref count is 1,
-		 * then need also free the swap item. */
-		list_del(&m_page->list);
-		if (1 == _mali_page_node_get_ref_count(m_page)) {
-			free_pages_nr++;
-		}
-
-		_mali_mem_swap_page_node_free(m_page);
-	}
-
-	return free_pages_nr;
-}
-
-static u32 mali_mem_swap_cow_free(mali_mem_cow *cow_mem)
-{
-	struct mali_page_node *m_page, *m_tmp;
-	u32 free_pages_nr = 0;
-
-	MALI_DEBUG_ASSERT_POINTER(cow_mem);
-
-	list_for_each_entry_safe(m_page, m_tmp, &cow_mem->pages, list) {
-		MALI_DEBUG_ASSERT(m_page->type == MALI_PAGE_NODE_SWAP);
-
-		/* free the page node and release the swap item, if the ref count is 1,
-		 * then need also free the swap item. */
-		list_del(&m_page->list);
-		if (1 == _mali_page_node_get_ref_count(m_page)) {
-			free_pages_nr++;
-		}
-
-		_mali_mem_swap_page_node_free(m_page);
-	}
-
-	return free_pages_nr;
-}
-
-u32 mali_mem_swap_release(mali_mem_backend *mem_bkend, mali_bool is_mali_mapped)
-{
-	mali_mem_allocation *alloc;
-	u32 free_pages_nr = 0;
-
-	MALI_DEBUG_ASSERT_POINTER(mem_bkend);
-	alloc = mem_bkend->mali_allocation;
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-
-	if (is_mali_mapped) {
-		mali_mem_swap_mali_unmap(alloc);
-	}
-
-	mali_memory_swap_list_backend_delete(mem_bkend);
-
-	mutex_lock(&mem_bkend->mutex);
-	/* To make sure the given memory backend was unlocked from Mali side,
-	 * and then free this memory block. */
-	mali_mem_swap_unlock_single_mem_backend(mem_bkend);
-	mutex_unlock(&mem_bkend->mutex);
-
-	if (MALI_MEM_SWAP == mem_bkend->type) {
-		free_pages_nr = mali_mem_swap_free(&mem_bkend->swap_mem);
-	} else {
-		free_pages_nr = mali_mem_swap_cow_free(&mem_bkend->cow_mem);
-	}
-
-	return free_pages_nr;
-}
-
-mali_bool mali_mem_swap_in_page_node(struct mali_page_node *page_node)
-{
-	MALI_DEBUG_ASSERT(NULL != page_node);
-
-	page_node->swap_it->page = shmem_read_mapping_page(global_swap_space, page_node->swap_it->idx);
-
-	if (IS_ERR(page_node->swap_it->page)) {
-		MALI_DEBUG_PRINT_ERROR(("SWAP Mem: failed to swap in page with index: %d.\n", page_node->swap_it->idx));
-		return MALI_FALSE;
-	}
-
-	/* Ensure page is flushed from CPU caches. */
-	page_node->swap_it->dma_addr = dma_map_page(&mali_platform_device->dev, page_node->swap_it->page,
-				       0, _MALI_OSK_MALI_PAGE_SIZE, DMA_TO_DEVICE);
-
-	return MALI_TRUE;
-}
-
-int mali_mem_swap_alloc_pages(mali_mem_swap *swap_mem, u32 size, u32 *bkend_idx)
-{
-	size_t page_count = PAGE_ALIGN(size) / PAGE_SIZE;
-	struct mali_page_node *m_page;
-	long system_free_size;
-	u32 i, index;
-	mali_bool ret;
-
-	MALI_DEBUG_ASSERT(NULL != swap_mem);
-	MALI_DEBUG_ASSERT(NULL != bkend_idx);
-	MALI_DEBUG_ASSERT(page_count <= MALI_SWAP_GLOBAL_SWAP_FILE_INDEX_RESERVE);
-
-	if (atomic_read(&mali_mem_os_allocator.allocated_pages) * _MALI_OSK_MALI_PAGE_SIZE + size > mali_mem_os_allocator.allocation_limit) {
-		MALI_DEBUG_PRINT(2, ("Mali Mem: Unable to allocate %u bytes. Currently allocated: %lu, max limit %lu\n",
-				     size,
-				     atomic_read(&mali_mem_os_allocator.allocated_pages) * _MALI_OSK_MALI_PAGE_SIZE,
-				     mali_mem_os_allocator.allocation_limit));
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	INIT_LIST_HEAD(&swap_mem->pages);
-	swap_mem->count = page_count;
-	index = mali_mem_swap_idx_range_alloc(page_count);
-
-	if (_MALI_OSK_BITMAP_INVALIDATE_INDEX == index) {
-		MALI_PRINT_ERROR(("Mali Swap: Failed to allocate continuous index for swappable Mali memory."));
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	for (i = 0; i < page_count; i++) {
-		m_page = _mali_mem_swap_page_node_allocate();
-
-		if (NULL == m_page) {
-			MALI_DEBUG_PRINT_ERROR(("SWAP Mem: Failed to allocate mali page node."));
-			swap_mem->count = i;
-
-			mali_mem_swap_free(swap_mem);
-			mali_mem_swap_idx_range_free(index + i, page_count - i);
-			return _MALI_OSK_ERR_FAULT;
-		}
-
-		m_page->swap_it->idx = index + i;
-
-		ret = mali_mem_swap_in_page_node(m_page);
-
-		if (MALI_FALSE == ret) {
-			MALI_DEBUG_PRINT_ERROR(("SWAP Mem: Allocate new page from SHMEM file failed."));
-			_mali_mem_swap_page_node_free(m_page);
-			mali_mem_swap_idx_range_free(index + i + 1, page_count - i - 1);
-
-			swap_mem->count = i;
-			mali_mem_swap_free(swap_mem);
-			return _MALI_OSK_ERR_NOMEM;
-		}
-
-		list_add_tail(&m_page->list, &swap_mem->pages);
-	}
-
-	system_free_size = global_page_state(NR_FREE_PAGES) * PAGE_SIZE;
-
-	if ((system_free_size < mali_mem_swap_out_threshold_value)
-	    && (mem_backend_swapped_pool_size > (mali_mem_swap_out_threshold_value >> 2))
-	    && mali_utilization_enabled()) {
-		_mali_osk_wq_schedule_work(mali_mem_swap_out_workq);
-	}
-
-	*bkend_idx = index;
-	return 0;
-}
-
-void mali_mem_swap_mali_unmap(mali_mem_allocation *alloc)
-{
-	struct mali_session_data *session;
-
-	MALI_DEBUG_ASSERT_POINTER(alloc);
-	session = alloc->session;
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	mali_session_memory_lock(session);
-	mali_mem_mali_map_free(session, alloc->psize, alloc->mali_vma_node.vm_node.start,
-			       alloc->flags);
-	mali_session_memory_unlock(session);
-}
-
-
-/* Insert these pages from shmem to mali page table*/
-_mali_osk_errcode_t mali_mem_swap_mali_map(mali_mem_swap *swap_mem, struct mali_session_data *session, u32 vaddr, u32 props)
-{
-	struct mali_page_directory *pagedir = session->page_directory;
-	struct mali_page_node *m_page;
-	dma_addr_t phys;
-	u32 virt = vaddr;
-	u32 prop = props;
-
-	list_for_each_entry(m_page, &swap_mem->pages, list) {
-		MALI_DEBUG_ASSERT(NULL != m_page->swap_it->page);
-		phys = m_page->swap_it->dma_addr;
-
-		mali_mmu_pagedir_update(pagedir, virt, phys, MALI_MMU_PAGE_SIZE, prop);
-		virt += MALI_MMU_PAGE_SIZE;
-	}
-
-	return _MALI_OSK_ERR_OK;
-}
-
-int mali_mem_swap_in_pages(struct mali_pp_job *job)
-{
-	u32 num_memory_cookies;
-	struct mali_session_data *session;
-	struct mali_vma_node *mali_vma_node = NULL;
-	mali_mem_allocation *mali_alloc = NULL;
-	mali_mem_backend *mem_bkend = NULL;
-	struct mali_page_node *m_page;
-	mali_bool swap_in_success = MALI_TRUE;
-	int i;
-
-	MALI_DEBUG_ASSERT_POINTER(job);
-
-	num_memory_cookies = mali_pp_job_num_memory_cookies(job);
-	session = mali_pp_job_get_session(job);
-
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	for (i = 0; i < num_memory_cookies; i++) {
-
-		u32 mali_addr  = mali_pp_job_get_memory_cookie(job, i);
-
-		mali_vma_node = mali_vma_offset_search(&session->allocation_mgr, mali_addr, 0);
-		if (NULL == mali_vma_node) {
-			job->memory_cookies[i] = MALI_SWAP_INVALIDATE_MALI_ADDRESS;
-			swap_in_success = MALI_FALSE;
-			MALI_PRINT_ERROR(("SWAP Mem: failed to find mali_vma_node through Mali address: 0x%08x.\n", mali_addr));
-			continue;
-		}
-
-		mali_alloc = container_of(mali_vma_node, struct mali_mem_allocation, mali_vma_node);
-		MALI_DEBUG_ASSERT(NULL != mali_alloc);
-
-		if (MALI_MEM_SWAP != mali_alloc->type &&
-		    MALI_MEM_COW != mali_alloc->type) {
-			continue;
-		}
-
-		/* Get backend memory & Map on GPU */
-		mutex_lock(&mali_idr_mutex);
-		mem_bkend = idr_find(&mali_backend_idr, mali_alloc->backend_handle);
-		mutex_unlock(&mali_idr_mutex);
-		MALI_DEBUG_ASSERT(NULL != mem_bkend);
-
-		/* We neednot hold backend's lock here, race safe.*/
-		if ((MALI_MEM_COW == mem_bkend->type) &&
-		    (!(mem_bkend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED))) {
-			continue;
-		}
-
-		mutex_lock(&mem_bkend->mutex);
-
-		/* When swap_in_success is MALI_FALSE, it means this job has memory backend that could not be swapped in,
-		 * and it will be aborted in mali scheduler, so here, we just mark those memory cookies which
-		 * should not be swapped out when delete job to invalide */
-		if (MALI_FALSE == swap_in_success) {
-			job->memory_cookies[i] = MALI_SWAP_INVALIDATE_MALI_ADDRESS;
-			mutex_unlock(&mem_bkend->mutex);
-			continue;
-		}
-
-		/* Before swap in, checking if this memory backend has been swapped in by the latest flushed jobs. */
-		++mem_bkend->using_count;
-
-		if (1 < mem_bkend->using_count) {
-			MALI_DEBUG_ASSERT(MALI_MEM_BACKEND_FLAG_UNSWAPPED_IN != (MALI_MEM_BACKEND_FLAG_UNSWAPPED_IN & mem_bkend->flags));
-			mutex_unlock(&mem_bkend->mutex);
-			continue;
-		}
-
-		if (MALI_MEM_BACKEND_FLAG_UNSWAPPED_IN != (MALI_MEM_BACKEND_FLAG_UNSWAPPED_IN & mem_bkend->flags)) {
-			mutex_unlock(&mem_bkend->mutex);
-			continue;
-		}
-
-
-		list_for_each_entry(m_page, &mem_bkend->swap_mem.pages, list) {
-			if (MALI_FALSE == mali_mem_swap_in_page_node(m_page)) {
-				/* Don't have enough memory to swap in page, so release pages have already been swapped
-				 * in and then mark this pp job to be fail. */
-				mali_mem_swap_unlock_partial_locked_mem_backend(mem_bkend, m_page);
-				swap_in_success = MALI_FALSE;
-				break;
-			}
-		}
-
-		if (swap_in_success) {
-#ifdef MALI_MEM_SWAP_TRACKING
-			mem_backend_swapped_unlock_size -= mem_bkend->size;
-#endif
-			_mali_osk_mutex_wait(session->memory_lock);
-			mali_mem_swap_mali_map(&mem_bkend->swap_mem, session, mali_alloc->mali_mapping.addr, mali_alloc->mali_mapping.properties);
-			_mali_osk_mutex_signal(session->memory_lock);
-
-			/* Remove the unlock flag from mem backend flags, mark this backend has been swapped in. */
-			mem_bkend->flags &= ~(MALI_MEM_BACKEND_FLAG_UNSWAPPED_IN);
-			mutex_unlock(&mem_bkend->mutex);
-		} else {
-			--mem_bkend->using_count;
-			/* Marking that this backend is not swapped in, need not to be processed anymore. */
-			job->memory_cookies[i] = MALI_SWAP_INVALIDATE_MALI_ADDRESS;
-			mutex_unlock(&mem_bkend->mutex);
-		}
-	}
-
-	job->swap_status = swap_in_success ? MALI_SWAP_IN_SUCC : MALI_SWAP_IN_FAIL;
-
-	return _MALI_OSK_ERR_OK;
-}
-
-int mali_mem_swap_out_pages(struct mali_pp_job *job)
-{
-	u32 num_memory_cookies;
-	struct mali_session_data *session;
-	struct mali_vma_node *mali_vma_node = NULL;
-	mali_mem_allocation *mali_alloc = NULL;
-	mali_mem_backend *mem_bkend = NULL;
-	int i;
-
-	MALI_DEBUG_ASSERT_POINTER(job);
-
-	num_memory_cookies = mali_pp_job_num_memory_cookies(job);
-	session = mali_pp_job_get_session(job);
-
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-
-	for (i = 0; i < num_memory_cookies; i++) {
-		u32 mali_addr  = mali_pp_job_get_memory_cookie(job, i);
-
-		if (MALI_SWAP_INVALIDATE_MALI_ADDRESS == mali_addr) {
-			continue;
-		}
-
-		mali_vma_node = mali_vma_offset_search(&session->allocation_mgr, mali_addr, 0);
-
-		if (NULL == mali_vma_node) {
-			MALI_PRINT_ERROR(("SWAP Mem: failed to find mali_vma_node through Mali address: 0x%08x.\n", mali_addr));
-			continue;
-		}
-
-		mali_alloc = container_of(mali_vma_node, struct mali_mem_allocation, mali_vma_node);
-		MALI_DEBUG_ASSERT(NULL != mali_alloc);
-
-		if (MALI_MEM_SWAP != mali_alloc->type &&
-		    MALI_MEM_COW != mali_alloc->type) {
-			continue;
-		}
-
-		mutex_lock(&mali_idr_mutex);
-		mem_bkend = idr_find(&mali_backend_idr, mali_alloc->backend_handle);
-		mutex_unlock(&mali_idr_mutex);
-		MALI_DEBUG_ASSERT(NULL != mem_bkend);
-
-		/* We neednot hold backend's lock here, race safe.*/
-		if ((MALI_MEM_COW == mem_bkend->type) &&
-		    (!(mem_bkend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED))) {
-			continue;
-		}
-
-		mutex_lock(&mem_bkend->mutex);
-
-		MALI_DEBUG_ASSERT(0 < mem_bkend->using_count);
-
-		/* Reducing the using_count of mem backend means less pp job are using this memory backend,
-		 * if this count get to zero, it means no pp job is using it now, could put it to swap out list. */
-		--mem_bkend->using_count;
-
-		if (0 < mem_bkend->using_count) {
-			mutex_unlock(&mem_bkend->mutex);
-			continue;
-		}
-		mutex_unlock(&mem_bkend->mutex);
-
-		mali_memory_swap_list_backend_add(mem_bkend);
-	}
-
-	return _MALI_OSK_ERR_OK;
-}
-
-int mali_mem_swap_allocate_page_on_demand(mali_mem_backend *mem_bkend, u32 offset, struct page **pagep)
-{
-	struct mali_page_node *m_page, *found_node = NULL;
-	struct page *found_page;
-	mali_mem_swap *swap = NULL;
-	mali_mem_cow *cow = NULL;
-	dma_addr_t dma_addr;
-	u32 i = 0;
-
-	if (MALI_MEM_SWAP == mem_bkend->type) {
-		swap = &mem_bkend->swap_mem;
-		list_for_each_entry(m_page, &swap->pages, list) {
-			if (i == offset) {
-				found_node = m_page;
-				break;
-			}
-			i++;
-		}
-	} else {
-		MALI_DEBUG_ASSERT(MALI_MEM_COW == mem_bkend->type);
-		MALI_DEBUG_ASSERT(MALI_MEM_BACKEND_FLAG_SWAP_COWED == (MALI_MEM_BACKEND_FLAG_SWAP_COWED & mem_bkend->flags));
-
-		cow = &mem_bkend->cow_mem;
-		list_for_each_entry(m_page, &cow->pages, list) {
-			if (i == offset) {
-				found_node = m_page;
-				break;
-			}
-			i++;
-		}
-	}
-
-	if (NULL == found_node) {
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	found_page = shmem_read_mapping_page(global_swap_space, found_node->swap_it->idx);
-
-	if (!IS_ERR(found_page)) {
-		lock_page(found_page);
-		dma_addr = dma_map_page(&mali_platform_device->dev, found_page,
-					0, _MALI_OSK_MALI_PAGE_SIZE, DMA_TO_DEVICE);
-		dma_unmap_page(&mali_platform_device->dev, dma_addr,
-			       _MALI_OSK_MALI_PAGE_SIZE, DMA_TO_DEVICE);
-
-		*pagep = found_page;
-	} else {
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	return _MALI_OSK_ERR_OK;
-}
-
-int mali_mem_swap_cow_page_on_demand(mali_mem_backend *mem_bkend, u32 offset, struct page **pagep)
-{
-	struct mali_page_node *m_page, *found_node = NULL, *new_node = NULL;
-	mali_mem_cow *cow = NULL;
-	u32 i = 0;
-
-	MALI_DEBUG_ASSERT(MALI_MEM_COW == mem_bkend->type);
-	MALI_DEBUG_ASSERT(MALI_MEM_BACKEND_FLAG_SWAP_COWED == (mem_bkend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED));
-	MALI_DEBUG_ASSERT(MALI_MEM_BACKEND_FLAG_UNSWAPPED_IN == (MALI_MEM_BACKEND_FLAG_UNSWAPPED_IN & mem_bkend->flags));
-	MALI_DEBUG_ASSERT(!mali_memory_swap_backend_in_swapped_pool(mem_bkend));
-
-	cow = &mem_bkend->cow_mem;
-	list_for_each_entry(m_page, &cow->pages, list) {
-		if (i == offset) {
-			found_node = m_page;
-			break;
-		}
-		i++;
-	}
-
-	if (NULL == found_node) {
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	new_node = _mali_mem_swap_page_node_allocate();
-
-	if (NULL == new_node) {
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	new_node->swap_it->idx = mali_mem_swap_idx_alloc();
-
-	if (_MALI_OSK_BITMAP_INVALIDATE_INDEX == new_node->swap_it->idx) {
-		MALI_DEBUG_PRINT(1, ("Failed to allocate swap index in swap CoW on demand.\n"));
-		kfree(new_node->swap_it);
-		kfree(new_node);
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	if (MALI_FALSE == mali_mem_swap_in_page_node(new_node)) {
-		_mali_mem_swap_page_node_free(new_node);
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	/* swap in found node for copy in kernel. */
-	if (MALI_FALSE == mali_mem_swap_in_page_node(found_node)) {
-		mali_mem_swap_out_page_node(new_node);
-		_mali_mem_swap_page_node_free(new_node);
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	_mali_mem_cow_copy_page(found_node, new_node);
-
-	list_replace(&found_node->list, &new_node->list);
-
-	if (1 != _mali_page_node_get_ref_count(found_node)) {
-		atomic_add(1, &mem_bkend->mali_allocation->session->mali_mem_allocated_pages);
-		if (atomic_read(&mem_bkend->mali_allocation->session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE > mem_bkend->mali_allocation->session->max_mali_mem_allocated_size) {
-			mem_bkend->mali_allocation->session->max_mali_mem_allocated_size = atomic_read(&mem_bkend->mali_allocation->session->mali_mem_allocated_pages) * MALI_MMU_PAGE_SIZE;
-		}
-		mem_bkend->cow_mem.change_pages_nr++;
-	}
-
-	mali_mem_swap_out_page_node(found_node);
-	_mali_mem_swap_page_node_free(found_node);
-
-	/* When swap in the new page node, we have called dma_map_page for this page.\n */
-	dma_unmap_page(&mali_platform_device->dev, new_node->swap_it->dma_addr,
-		       _MALI_OSK_MALI_PAGE_SIZE, DMA_TO_DEVICE);
-
-	lock_page(new_node->swap_it->page);
-
-	*pagep = new_node->swap_it->page;
-
-	return _MALI_OSK_ERR_OK;
-}
-
-#ifdef MALI_MEM_SWAP_TRACKING
-void mali_mem_swap_tracking(u32 *swap_pool_size, u32 *unlock_size)
-{
-	*swap_pool_size = mem_backend_swapped_pool_size;
-	*unlock_size =  mem_backend_swapped_unlock_size;
-}
-#endif
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_swap_alloc.h b/drivers/gpu/arm/mali/linux/mali_memory_swap_alloc.h
deleted file mode 100755
index 3624d710..00000000
--- a/drivers/gpu/arm/mali/linux/mali_memory_swap_alloc.h
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#ifndef __MALI_MEMORY_SWAP_ALLOC_H__
-#define __MALI_MEMORY_SWAP_ALLOC_H__
-
-#include "mali_osk.h"
-#include "mali_session.h"
-
-#include "mali_memory_types.h"
-#include "mali_pp_job.h"
-
-/**
- * Initialize memory swapping module.
- */
-_mali_osk_errcode_t mali_mem_swap_init(void);
-
-void mali_mem_swap_term(void);
-
-/**
- * Return global share memory file to other modules.
- */
-struct file *mali_mem_swap_get_global_swap_file(void);
-
-/**
- * Unlock the given memory backend and pages in it could be swapped out by kernel.
- */
-void mali_mem_swap_unlock_single_mem_backend(mali_mem_backend *mem_bkend);
-
-/**
- * Remove the given memory backend from global swap list.
- */
-void mali_memory_swap_list_backend_delete(mali_mem_backend *mem_bkend);
-
-/**
- * Add the given memory backend to global swap list.
- */
-void mali_memory_swap_list_backend_add(mali_mem_backend *mem_bkend);
-
-/**
- * Allocate 1 index from bitmap used as page index in global swap file.
- */
-u32 mali_mem_swap_idx_alloc(void);
-
-void mali_mem_swap_idx_free(u32 idx);
-
-/**
- * Allocate a new swap item without page index.
- */
-struct mali_swap_item *mali_mem_swap_alloc_swap_item(void);
-
-/**
- * Free a swap item, truncate the corresponding space in page cache and free index of page.
- */
-void mali_mem_swap_free_swap_item(mali_swap_item *swap_item);
-
-/**
- * Allocate a page node with swap item.
- */
-struct mali_page_node *_mali_mem_swap_page_node_allocate(void);
-
-/**
- * Reduce the reference count of given page node and if return 0, just free this page node.
- */
-_mali_osk_errcode_t _mali_mem_swap_put_page_node(struct mali_page_node *m_page);
-
-void _mali_mem_swap_page_node_free(struct mali_page_node *m_page);
-
-/**
- * Free a swappable memory backend.
- */
-u32 mali_mem_swap_free(mali_mem_swap *swap_mem);
-
-/**
- * Ummap and free.
- */
-u32 mali_mem_swap_release(mali_mem_backend *mem_bkend, mali_bool is_mali_mapped);
-
-/**
- * Read in a page from global swap file with the pre-allcated page index.
- */
-mali_bool mali_mem_swap_in_page_node(struct mali_page_node *page_node);
-
-int mali_mem_swap_alloc_pages(mali_mem_swap *swap_mem, u32 size, u32 *bkend_idx);
-
-_mali_osk_errcode_t mali_mem_swap_mali_map(mali_mem_swap *swap_mem, struct mali_session_data *session, u32 vaddr, u32 props);
-
-void mali_mem_swap_mali_unmap(mali_mem_allocation *alloc);
-
-/**
- * When pp job created, we need swap in all of memory backend needed by this pp job.
- */
-int mali_mem_swap_in_pages(struct mali_pp_job *job);
-
-/**
- * Put all of memory backends used this pp job to the global swap list.
- */
-int mali_mem_swap_out_pages(struct mali_pp_job *job);
-
-/**
- * This will be called in page fault to process CPU read&write.
- */
-int mali_mem_swap_allocate_page_on_demand(mali_mem_backend *mem_bkend, u32 offset, struct page **pagep) ;
-
-/**
- * Used to process cow on demand for swappable memory backend.
- */
-int mali_mem_swap_cow_page_on_demand(mali_mem_backend *mem_bkend, u32 offset, struct page **pagep);
-
-#ifdef MALI_MEM_SWAP_TRACKING
-void mali_mem_swap_tracking(u32 *swap_pool_size, u32 *unlock_size);
-#endif
-#endif /* __MALI_MEMORY_SWAP_ALLOC_H__ */
-
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_types.h b/drivers/gpu/arm/mali/linux/mali_memory_types.h
old mode 100755
new mode 100644
index b63afd10..c62589b0
--- a/drivers/gpu/arm/mali/linux/mali_memory_types.h
+++ b/drivers/gpu/arm/mali/linux/mali_memory_types.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -11,10 +11,8 @@
 #ifndef __MALI_MEMORY_TYPES_H__
 #define __MALI_MEMORY_TYPES_H__
 
-#include <linux/mm.h>
-
 #if defined(CONFIG_MALI400_UMP)
-#include <ump/ump_kernel_interface.h>
+#include "ump_kernel_interface.h"
 #endif
 
 typedef u32 mali_address_t;
@@ -22,12 +20,9 @@ typedef u32 mali_address_t;
 typedef enum mali_mem_type {
 	MALI_MEM_OS,
 	MALI_MEM_EXTERNAL,
-	MALI_MEM_SWAP,
 	MALI_MEM_DMA_BUF,
 	MALI_MEM_UMP,
 	MALI_MEM_BLOCK,
-	MALI_MEM_COW,
-	MALI_MEM_SECURE,
 	MALI_MEM_TYPE_MAX,
 } mali_mem_type;
 
@@ -38,32 +33,20 @@ typedef struct mali_block_item {
 	unsigned long phy_addr;
 } mali_block_item;
 
-/**
- * idx is used to locate the given page in the address space of swap file.
- * ref_count is used to mark how many memory backends are using this item.
- */
-typedef struct mali_swap_item {
-	u32 idx;
-	atomic_t ref_count;
-	struct page *page;
-	dma_addr_t dma_addr;
-} mali_swap_item;
-
 typedef enum mali_page_node_type {
 	MALI_PAGE_NODE_OS,
 	MALI_PAGE_NODE_BLOCK,
-	MALI_PAGE_NODE_SWAP,
 } mali_page_node_type;
 
-typedef struct mali_page_node {
+typedef struct mali_block_node {
 	struct list_head list;
-	union {
-		struct page *page;
-		mali_block_item *blk_it; /*pointer to block item*/
-		mali_swap_item *swap_it;
-	};
-
+	mali_block_item *blk_it; /*pointer to block item*/
 	u32 type;
+} mali_block_node;
+
+typedef struct mali_page_node {
+	struct list_head list;
+	struct page *page;
 } mali_page_node;
 
 typedef struct mali_mem_os_mem {
@@ -107,7 +90,7 @@ typedef struct mali_mem_virt_mali_mapping {
 
 typedef struct mali_mem_virt_cpu_mapping {
 	void __user *addr;
-	struct vm_area_struct *vma;
+	u32 ref;
 } mali_mem_virt_cpu_mapping;
 
 #define MALI_MEM_ALLOCATION_VALID_MAGIC 0xdeda110c
@@ -129,10 +112,22 @@ typedef struct mali_vma_node {
 typedef struct mali_mem_allocation {
 	MALI_DEBUG_CODE(u32 magic);
 	mali_mem_type type;                /**< Type of memory */
+	int id;                            /**< ID in the descriptor map for this allocation */
+
+	u32 size;                          /**< Size of the allocation */
 	u32 flags;                         /**< Flags for this allocation */
 
 	struct mali_session_data *session; /**< Pointer to session that owns the allocation */
 
+	/* Union selected by type. */
+	union {
+		mali_mem_os_mem os_mem;       /**< MALI_MEM_OS */
+		mali_mem_external ext_mem;    /**< MALI_MEM_EXTERNAL */
+		mali_mem_dma_buf dma_buf;     /**< MALI_MEM_DMA_BUF */
+		mali_mem_ump ump_mem;         /**< MALI_MEM_UMP */
+		mali_mem_block_mem block_mem; /**< MALI_MEM_BLOCK */
+	};
+
 	mali_mem_virt_cpu_mapping cpu_mapping; /**< CPU mapping */
 	mali_mem_virt_mali_mapping mali_mapping; /**< Mali mapping */
 
@@ -142,53 +137,17 @@ typedef struct mali_mem_allocation {
 	u32 psize; /* physical backend memory size*/
 	struct list_head list;
 	s32 backend_handle; /* idr for mem_backend */
-	_mali_osk_atomic_t mem_alloc_refcount;
+	struct kref ref;
 } mali_mem_allocation;
 
-struct mali_mem_os_allocator {
-	spinlock_t pool_lock;
-	struct list_head pool_pages;
-	size_t pool_count;
-
-	atomic_t allocated_pages;
-	size_t allocation_limit;
-
-	struct shrinker shrinker;
-	struct delayed_work timed_shrinker;
-	struct workqueue_struct *wq;
-};
 
 /* COW backend memory type */
 typedef struct mali_mem_cow {
 	struct list_head pages;  /**< all pages for this cow backend allocation,
                                                                 including new allocated pages for modified range*/
 	u32 count;               /**< number of pages */
-	s32 change_pages_nr;
 } mali_mem_cow;
 
-typedef struct mali_mem_swap {
-	struct list_head pages;
-	u32 count;
-} mali_mem_swap;
-
-typedef struct mali_mem_secure {
-#if defined(CONFIG_DMA_SHARED_BUFFER)
-	struct dma_buf *buf;
-	struct dma_buf_attachment *attachment;
-	struct sg_table *sgt;
-#endif
-	u32 count;
-} mali_mem_secure;
-
-#define MALI_MEM_BACKEND_FLAG_COWED                   (0x1)  /* COW has happen on this backend */
-#define MALI_MEM_BACKEND_FLAG_COW_CPU_NO_WRITE        (0x2)  /* This is an COW backend, mapped as not allowed cpu to write */
-#define MALI_MEM_BACKEND_FLAG_SWAP_COWED              (0x4)  /* Mark the given backend is cowed from swappable memory. */
-/* Mark this backend is not swapped_in in MALI driver, and before using it,
- * we should swap it in and set up corresponding page table. */
-#define MALI_MEM_BACKEND_FLAG_UNSWAPPED_IN            (0x8)
-#define MALI_MEM_BACKEND_FLAG_NOT_BINDED              (0x1 << 5) /* this backend it not back with physical memory, used for defer bind */
-#define MALI_MEM_BACKEND_FLAG_BINDED              (0x1 << 6) /* this backend it back with physical memory, used for defer bind */
-
 typedef struct mali_mem_backend {
 	mali_mem_type type;                /**< Type of backend memory */
 	u32 flags;                         /**< Flags for this allocation */
@@ -201,19 +160,11 @@ typedef struct mali_mem_backend {
 		mali_mem_ump ump_mem;         /**< MALI_MEM_UMP */
 		mali_mem_block_mem block_mem; /**< MALI_MEM_BLOCK */
 		mali_mem_cow cow_mem;
-		mali_mem_swap swap_mem;
-		mali_mem_secure secure_mem;
 	};
 	mali_mem_allocation *mali_allocation;
-	struct mutex mutex;
-	mali_mem_type cow_type;
-
-	struct list_head list;           /**< Used to link swappable memory backend to the global swappable list */
-	int using_count;                 /**< Mark how many PP jobs are using this memory backend */
-	u32 start_idx;                   /**< If the correspondign vma of this backend is linear, this value will be used to set vma->vm_pgoff */
 } mali_mem_backend;
 
-#define MALI_MEM_FLAG_MALI_GUARD_PAGE (_MALI_MAP_EXTERNAL_MAP_GUARD_PAGE)
+#define MALI_MEM_FLAG_MALI_GUARD_PAGE (1 << 0)
 #define MALI_MEM_FLAG_DONT_CPU_MAP    (1 << 1)
-#define MALI_MEM_FLAG_CAN_RESIZE  (_MALI_MEMORY_ALLOCATE_RESIZEABLE)
+
 #endif /* __MALI_MEMORY_TYPES__ */
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_ump.c b/drivers/gpu/arm/mali/linux/mali_memory_ump.c
old mode 100755
new mode 100644
index 2b1da79c..207ac919
--- a/drivers/gpu/arm/mali/linux/mali_memory_ump.c
+++ b/drivers/gpu/arm/mali/linux/mali_memory_ump.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -14,7 +14,7 @@
 #include "mali_session.h"
 #include "mali_kernel_linux.h"
 #include "mali_memory.h"
-#include <ump/ump_kernel_interface.h>
+#include "ump_kernel_interface.h"
 
 static int mali_mem_ump_map(mali_mem_backend *mem_backend)
 {
@@ -90,6 +90,7 @@ static int mali_mem_ump_map(mali_mem_backend *mem_backend)
 
 		offset += _MALI_OSK_MALI_PAGE_SIZE;
 	}
+	session->mali_mem_array[mem_backend->type] += mem_backend->size;
 	mali_session_memory_unlock(session);
 	_mali_osk_free(ump_blocks);
 	return 0;
@@ -104,10 +105,12 @@ static void mali_mem_ump_unmap(mali_mem_allocation *alloc)
 	mali_session_memory_lock(session);
 	mali_mem_mali_map_free(session, alloc->psize, alloc->mali_vma_node.vm_node.start,
 			       alloc->flags);
+
+	session->mali_mem_array[alloc->type] -= alloc->psize;
 	mali_session_memory_unlock(session);
 }
 
-int mali_mem_bind_ump_buf(mali_mem_allocation *alloc, mali_mem_backend *mem_backend, u32  secure_id, u32 flags)
+int mali_memory_bind_ump_buf(mali_mem_allocation *alloc, mali_mem_backend *mem_backend, u32  secure_id, u32 flags)
 {
 	ump_dd_handle ump_mem;
 	int ret;
@@ -137,7 +140,7 @@ int mali_mem_bind_ump_buf(mali_mem_allocation *alloc, mali_mem_backend *mem_back
 	return _MALI_OSK_ERR_OK;
 }
 
-void mali_mem_unbind_ump_buf(mali_mem_backend *mem_backend)
+void mali_mem_ump_release(mali_mem_backend *mem_backend)
 {
 	ump_dd_handle ump_mem;
 	mali_mem_allocation *alloc;
@@ -152,3 +155,10 @@ void mali_mem_unbind_ump_buf(mali_mem_backend *mem_backend)
 	ump_dd_reference_release(ump_mem);
 }
 
+int mali_memory_unbind_ump_buf(mali_mem_backend *mem_backend)
+{
+	MALI_DEBUG_ASSERT_POINTER(mem_backend);
+	mali_mem_ump_release(mem_backend);
+	return _MALI_OSK_ERR_OK;
+}
+
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_ump.h b/drivers/gpu/arm/mali/linux/mali_memory_ump.h
old mode 100755
new mode 100644
index 7f03a49d..0f4aa198
--- a/drivers/gpu/arm/mali/linux/mali_memory_ump.h
+++ b/drivers/gpu/arm/mali/linux/mali_memory_ump.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -19,8 +19,9 @@ extern "C" {
 #include "mali_osk.h"
 #include "mali_memory.h"
 
-int mali_mem_bind_ump_buf(mali_mem_allocation *alloc, mali_mem_backend *mem_backend, u32  secure_id, u32 flags);
-void mali_mem_unbind_ump_buf(mali_mem_backend *mem_backend);
+int mali_memory_bind_ump_buf(mali_mem_allocation *alloc, mali_mem_backend *mem_backend, u32  secure_id, u32 flags);
+int mali_memory_unbind_ump_buf(mali_mem_backend *mem_backend);
+void mali_mem_ump_release(mali_mem_backend *mem_backend);
 
 #ifdef __cplusplus
 }
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_util.c b/drivers/gpu/arm/mali/linux/mali_memory_util.c
old mode 100755
new mode 100644
index 4fbb7579..5947cafd
--- a/drivers/gpu/arm/mali/linux/mali_memory_util.c
+++ b/drivers/gpu/arm/mali/linux/mali_memory_util.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -25,7 +25,6 @@
 #include "mali_memory_os_alloc.h"
 #if defined(CONFIG_DMA_SHARED_BUFFER)
 #include "mali_memory_dma_buf.h"
-#include "mali_memory_secure.h"
 #endif
 #if defined(CONFIG_MALI400_UMP)
 #include "mali_memory_ump.h"
@@ -33,19 +32,19 @@
 #include "mali_memory_external.h"
 #include "mali_memory_manager.h"
 #include "mali_memory_virtual.h"
-#include "mali_memory_cow.h"
 #include "mali_memory_block_alloc.h"
-#include "mali_memory_swap_alloc.h"
-
-
 
 /**
 *function @_mali_free_allocation_mem - free a memory allocation
+* support backend type:
+* MALI_MEM_OS
+* maybe COW later?
 */
-static u32 _mali_free_allocation_mem(mali_mem_allocation *mali_alloc)
+static void _mali_free_allocation_mem(struct kref *kref)
 {
 	mali_mem_backend *mem_bkend = NULL;
-	u32 free_pages_nr = 0;
+
+	mali_mem_allocation *mali_alloc = container_of(kref, struct mali_mem_allocation, ref);
 
 	struct mali_session_data *session = mali_alloc->session;
 	MALI_DEBUG_PRINT(4, (" _mali_free_allocation_mem, psize =0x%x! \n", mali_alloc->psize));
@@ -56,66 +55,39 @@ static u32 _mali_free_allocation_mem(mali_mem_allocation *mali_alloc)
 	mutex_lock(&mali_idr_mutex);
 	mem_bkend = idr_find(&mali_backend_idr, mali_alloc->backend_handle);
 	mutex_unlock(&mali_idr_mutex);
+
 	MALI_DEBUG_ASSERT(NULL != mem_bkend);
 
 	switch (mem_bkend->type) {
 	case MALI_MEM_OS:
-		free_pages_nr = mali_mem_os_release(mem_bkend);
-		atomic_sub(free_pages_nr, &session->mali_mem_allocated_pages);
+		mali_mem_os_release(mem_bkend);
 		break;
 	case MALI_MEM_UMP:
 #if defined(CONFIG_MALI400_UMP)
-		mali_mem_unbind_ump_buf(mem_bkend);
-		atomic_sub(mem_bkend->size / MALI_MMU_PAGE_SIZE, &session->mali_mem_array[mem_bkend->type]);
+		mali_mem_ump_release(mem_bkend);
 #else
-		MALI_DEBUG_PRINT(1, ("UMP not supported\n"));
+		MALI_DEBUG_PRINT(2, ("DMA not supported\n"));
 #endif
 		break;
 	case MALI_MEM_DMA_BUF:
 #if defined(CONFIG_DMA_SHARED_BUFFER)
-		mali_mem_unbind_dma_buf(mem_bkend);
-		atomic_sub(mem_bkend->size / MALI_MMU_PAGE_SIZE, &session->mali_mem_array[mem_bkend->type]);
+		mali_mem_dma_buf_release(mem_bkend);
 #else
-		MALI_DEBUG_PRINT(1, ("DMA not supported\n"));
+		MALI_DEBUG_PRINT(2, ("DMA not supported\n"));
 #endif
 		break;
 	case MALI_MEM_EXTERNAL:
-		mali_mem_unbind_ext_buf(mem_bkend);
-		atomic_sub(mem_bkend->size / MALI_MMU_PAGE_SIZE, &session->mali_mem_array[mem_bkend->type]);
+		mali_mem_external_release(mem_bkend);
 		break;
-
 	case MALI_MEM_BLOCK:
-		free_pages_nr = mali_mem_block_release(mem_bkend);
-		atomic_sub(free_pages_nr, &session->mali_mem_allocated_pages);
-		break;
-
-	case MALI_MEM_COW:
-		if (mem_bkend->flags & MALI_MEM_BACKEND_FLAG_SWAP_COWED) {
-			free_pages_nr = mali_mem_swap_release(mem_bkend, MALI_TRUE);
-		} else {
-			free_pages_nr = mali_mem_cow_release(mem_bkend, MALI_TRUE);
-		}
-		atomic_sub(free_pages_nr, &session->mali_mem_allocated_pages);
-		break;
-	case MALI_MEM_SWAP:
-		free_pages_nr = mali_mem_swap_release(mem_bkend, MALI_TRUE);
-		atomic_sub(free_pages_nr, &session->mali_mem_allocated_pages);
-		atomic_sub(free_pages_nr, &session->mali_mem_array[mem_bkend->type]);
-		break;
-	case MALI_MEM_SECURE:
-#if defined(CONFIG_DMA_SHARED_BUFFER)
-		free_pages_nr = mali_mem_secure_release(mem_bkend);
-		atomic_sub(free_pages_nr, &session->mali_mem_allocated_pages);
-#else
-		MALI_DEBUG_PRINT(1, ("DMA not supported for mali secure memory\n"));
-#endif
+		mali_mem_block_release(mem_bkend);
 		break;
 	default:
 		MALI_DEBUG_PRINT(1, ("mem type %d is not in the mali_mem_type enum.\n", mem_bkend->type));
 		break;
 	}
 
-	/*Remove backend memory idex */
+	/* remove backend memory idex */
 	mutex_lock(&mali_idr_mutex);
 	idr_remove(&mali_backend_idr, mali_alloc->backend_handle);
 	mutex_unlock(&mali_idr_mutex);
@@ -124,30 +96,29 @@ out:
 	/* remove memory allocation  */
 	mali_vma_offset_remove(&session->allocation_mgr, &mali_alloc->mali_vma_node);
 	mali_mem_allocation_struct_destory(mali_alloc);
-	return free_pages_nr;
+
 }
 
+
+
 /**
 *  ref_count for allocation
 */
-u32 mali_allocation_unref(struct mali_mem_allocation **alloc)
+void mali_allocation_unref(struct mali_mem_allocation **alloc)
 {
-	u32 free_pages_nr = 0;
 	mali_mem_allocation *mali_alloc = *alloc;
 	*alloc = NULL;
-	if (0 == _mali_osk_atomic_dec_return(&mali_alloc->mem_alloc_refcount)) {
-		free_pages_nr = _mali_free_allocation_mem(mali_alloc);
-	}
-	return free_pages_nr;
+	kref_put(&mali_alloc->ref, _mali_free_allocation_mem);
 }
 
 void mali_allocation_ref(struct mali_mem_allocation *alloc)
 {
-	_mali_osk_atomic_inc(&alloc->mem_alloc_refcount);
+	kref_get(&alloc->ref);
 }
 
 void mali_free_session_allocations(struct mali_session_data *session)
 {
+
 	struct mali_mem_allocation *entry, *next;
 
 	MALI_DEBUG_PRINT(4, (" mali_free_session_allocations! \n"));
@@ -156,3 +127,4 @@ void mali_free_session_allocations(struct mali_session_data *session)
 		mali_allocation_unref(&entry);
 	}
 }
+
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_util.h b/drivers/gpu/arm/mali/linux/mali_memory_util.h
old mode 100755
new mode 100644
index b3cc7e9e..419e05f0
--- a/drivers/gpu/arm/mali/linux/mali_memory_util.h
+++ b/drivers/gpu/arm/mali/linux/mali_memory_util.h
@@ -1,20 +1,17 @@
-/*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+/*
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#ifndef __MALI_MEMORY_UTIL_H__
-#define __MALI_MEMORY_UTIL_H__
-
-u32 mali_allocation_unref(struct mali_mem_allocation **alloc);
-
-void mali_allocation_ref(struct mali_mem_allocation *alloc);
-
-void mali_free_session_allocations(struct mali_session_data *session);
-
-#endif
+ */
+
+
+void mali_allocation_unref(struct mali_mem_allocation **alloc);
+
+void mali_allocation_ref(struct mali_mem_allocation *alloc);
+
+void mali_free_session_allocations(struct mali_session_data *session);
+
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_virtual.c b/drivers/gpu/arm/mali/linux/mali_memory_virtual.c
old mode 100755
new mode 100644
index cb85ca23..535feffb
--- a/drivers/gpu/arm/mali/linux/mali_memory_virtual.c
+++ b/drivers/gpu/arm/mali/linux/mali_memory_virtual.c
@@ -1,127 +1,128 @@
-/*
- * Copyright (C) 2013-2016 ARM Limited. All rights reserved.
- * 
+/*
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-#include <linux/list.h>
-#include <linux/mm.h>
-#include <linux/mm_types.h>
-#include <linux/fs.h>
-#include <linux/dma-mapping.h>
-#include <linux/slab.h>
-#include <linux/platform_device.h>
-
-#include "mali_osk.h"
-#include "mali_osk_mali.h"
-#include "mali_kernel_linux.h"
-#include "mali_scheduler.h"
-#include "mali_memory_os_alloc.h"
-#include "mali_memory_manager.h"
-#include "mali_memory_virtual.h"
-
-
-/**
-*internal helper to link node into the rb-tree
-*/
-static inline void _mali_vma_offset_add_rb(struct mali_allocation_manager *mgr,
-		struct mali_vma_node *node)
-{
-	struct rb_node **iter = &mgr->allocation_mgr_rb.rb_node;
-	struct rb_node *parent = NULL;
-	struct mali_vma_node *iter_node;
-
-	while (likely(*iter)) {
-		parent = *iter;
-		iter_node = rb_entry(*iter, struct mali_vma_node, vm_rb);
-
-		if (node->vm_node.start < iter_node->vm_node.start)
-			iter = &(*iter)->rb_left;
-		else if (node->vm_node.start > iter_node->vm_node.start)
-			iter = &(*iter)->rb_right;
-		else
-			MALI_DEBUG_ASSERT(0);
-	}
-
-	rb_link_node(&node->vm_rb, parent, iter);
-	rb_insert_color(&node->vm_rb, &mgr->allocation_mgr_rb);
-}
-
-/**
- * mali_vma_offset_add() - Add offset node to RB Tree
- */
-int mali_vma_offset_add(struct mali_allocation_manager *mgr,
-			struct mali_vma_node *node)
-{
-	int ret = 0;
-	write_lock(&mgr->vm_lock);
-
-	if (node->vm_node.allocated) {
-		goto out;
-	}
-
-	_mali_vma_offset_add_rb(mgr, node);
-	/* set to allocated */
-	node->vm_node.allocated = 1;
-
-out:
-	write_unlock(&mgr->vm_lock);
-	return ret;
-}
-
-/**
- * mali_vma_offset_remove() - Remove offset node from RB tree
- */
-void mali_vma_offset_remove(struct mali_allocation_manager *mgr,
-			    struct mali_vma_node *node)
-{
-	write_lock(&mgr->vm_lock);
-
-	if (node->vm_node.allocated) {
-		rb_erase(&node->vm_rb, &mgr->allocation_mgr_rb);
-		memset(&node->vm_node, 0, sizeof(node->vm_node));
-	}
-	write_unlock(&mgr->vm_lock);
-}
-
-/**
-* mali_vma_offset_search - Search the node in RB tree
-*/
-struct mali_vma_node *mali_vma_offset_search(struct mali_allocation_manager *mgr,
-		unsigned long start, unsigned long pages)
-{
-	struct mali_vma_node *node, *best;
-	struct rb_node *iter;
-	unsigned long offset;
-	read_lock(&mgr->vm_lock);
-
-	iter = mgr->allocation_mgr_rb.rb_node;
-	best = NULL;
-
-	while (likely(iter)) {
-		node = rb_entry(iter, struct mali_vma_node, vm_rb);
-		offset = node->vm_node.start;
-		if (start >= offset) {
-			iter = iter->rb_right;
-			best = node;
-			if (start == offset)
-				break;
-		} else {
-			iter = iter->rb_left;
-		}
-	}
-
-	if (best) {
-		offset = best->vm_node.start + best->vm_node.size;
-		if (offset <= start + pages)
-			best = NULL;
-	}
-	read_unlock(&mgr->vm_lock);
-
-	return best;
-}
-
+ */
+
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/mm_types.h>
+#include <linux/fs.h>
+#include <linux/dma-mapping.h>
+#include <linux/slab.h>
+#include <linux/platform_device.h>
+
+#include "mali_osk.h"
+#include "mali_osk_mali.h"
+#include "mali_kernel_linux.h"
+#include "mali_scheduler.h"
+#include "mali_memory_os_alloc.h"
+#include "mali_memory_manager.h"
+#include "mali_memory_virtual.h"
+
+
+/**
+*internal helper to link node into the rb-tree
+*/
+static inline void _mali_vma_offset_add_rb(struct mali_allocation_manager *mgr,
+		struct mali_vma_node *node)
+{
+	struct rb_node **iter = &mgr->allocation_mgr_rb.rb_node;
+	struct rb_node *parent = NULL;
+	struct mali_vma_node *iter_node;
+
+	while (likely(*iter)) {
+		parent = *iter;
+		iter_node = rb_entry(*iter, struct mali_vma_node, vm_rb);
+
+		if (node->vm_node.start < iter_node->vm_node.start)
+			iter = &(*iter)->rb_left;
+		else if (node->vm_node.start > iter_node->vm_node.start)
+			iter = &(*iter)->rb_right;
+		else
+			/* Not support yet */
+			MALI_DEBUG_ASSERT(0);
+	}
+
+	rb_link_node(&node->vm_rb, parent, iter);
+	rb_insert_color(&node->vm_rb, &mgr->allocation_mgr_rb);
+}
+
+/**
+ * mali_vma_offset_add() - Add offset node to RB Tree
+ */
+int mali_vma_offset_add(struct mali_allocation_manager *mgr,
+			struct mali_vma_node *node)
+{
+	int ret = 0;
+	write_lock(&mgr->vm_lock);
+
+	if (node->vm_node.allocated) {
+		goto out;
+	}
+
+	_mali_vma_offset_add_rb(mgr, node);
+	/* set to allocated */
+	node->vm_node.allocated = 1;
+
+out:
+	write_unlock(&mgr->vm_lock);
+	return ret;
+}
+
+/**
+ * mali_vma_offset_remove() - Remove offset node from RB tree
+ */
+void mali_vma_offset_remove(struct mali_allocation_manager *mgr,
+			    struct mali_vma_node *node)
+{
+	write_lock(&mgr->vm_lock);
+
+	if (node->vm_node.allocated) {
+		rb_erase(&node->vm_rb, &mgr->allocation_mgr_rb);
+		memset(&node->vm_node, 0, sizeof(node->vm_node));
+	}
+	write_unlock(&mgr->vm_lock);
+}
+
+/**
+* mali_vma_offset_search - Search the node in RB tree
+*/
+struct mali_vma_node *mali_vma_offset_search(struct mali_allocation_manager *mgr,
+		unsigned long start, unsigned long pages)
+{
+	struct mali_vma_node *node, *best;
+	struct rb_node *iter;
+	unsigned long offset;
+	read_lock(&mgr->vm_lock);
+
+	iter = mgr->allocation_mgr_rb.rb_node;
+	best = NULL;
+
+	while (likely(iter)) {
+		node = rb_entry(iter, struct mali_vma_node, vm_rb);
+		offset = node->vm_node.start;
+		if (start >= offset) {
+			iter = iter->rb_right;
+			best = node;
+			if (start == offset)
+				break;
+		} else {
+			iter = iter->rb_left;
+		}
+	}
+
+	if (best) {
+		offset = best->vm_node.start + best->vm_node.size;
+		if (offset <= start + pages)
+			best = NULL;
+	}
+	read_unlock(&mgr->vm_lock);
+
+	return best;
+}
+
diff --git a/drivers/gpu/arm/mali/linux/mali_memory_virtual.h b/drivers/gpu/arm/mali/linux/mali_memory_virtual.h
old mode 100755
new mode 100644
index 9815f28f..1f64c5e4
--- a/drivers/gpu/arm/mali/linux/mali_memory_virtual.h
+++ b/drivers/gpu/arm/mali/linux/mali_memory_virtual.h
@@ -1,35 +1,35 @@
-/*
- * Copyright (C) 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+/*
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-#ifndef __MALI_GPU_VMEM_H__
-#define __MALI_GPU_VMEM_H__
-
-#include "mali_osk.h"
-#include "mali_session.h"
-#include <linux/list.h>
-#include <linux/mm.h>
-#include <linux/rbtree.h>
-#include <linux/spinlock.h>
-#include <linux/types.h>
-#include "mali_memory_types.h"
-#include "mali_memory_os_alloc.h"
-#include "mali_memory_manager.h"
-
-
-
-int mali_vma_offset_add(struct mali_allocation_manager *mgr,
-			struct mali_vma_node *node);
-
-void mali_vma_offset_remove(struct mali_allocation_manager *mgr,
-			    struct mali_vma_node *node);
-
-struct mali_vma_node *mali_vma_offset_search(struct mali_allocation_manager *mgr,
-		unsigned long start,    unsigned long pages);
-
-#endif
+ */
+#ifndef __MALI_GPU_VMEM_H__
+#define __MALI_GPU_VMEM_H__
+
+#include "mali_osk.h"
+#include "mali_session.h"
+#include <linux/list.h>
+#include <linux/mm.h>
+#include <linux/rbtree.h>
+#include <linux/spinlock.h>
+#include <linux/types.h>
+#include "mali_memory_types.h"
+#include "mali_memory_os_alloc.h"
+#include "mali_memory_manager.h"
+
+
+
+int mali_vma_offset_add(struct mali_allocation_manager *mgr,
+			struct mali_vma_node *node);
+
+void mali_vma_offset_remove(struct mali_allocation_manager *mgr,
+			    struct mali_vma_node *node);
+
+struct mali_vma_node *mali_vma_offset_search(struct mali_allocation_manager *mgr,
+		unsigned long start,    unsigned long pages);
+
+#endif
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_atomics.c b/drivers/gpu/arm/mali/linux/mali_osk_atomics.c
old mode 100755
new mode 100644
index 03f4421e..d209699a
--- a/drivers/gpu/arm/mali/linux/mali_osk_atomics.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_atomics.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_bitmap.c b/drivers/gpu/arm/mali/linux/mali_osk_bitmap.c
deleted file mode 100755
index 67cc7e42..00000000
--- a/drivers/gpu/arm/mali/linux/mali_osk_bitmap.c
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * Copyright (C) 2010, 2013-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-/**
- * @file mali_osk_bitmap.c
- * Implementation of the OS abstraction layer for the kernel device driver
- */
-
-#include <linux/errno.h>
-#include <linux/slab.h>
-#include <linux/mm.h>
-#include <linux/bitmap.h>
-#include <linux/vmalloc.h>
-#include "common/mali_kernel_common.h"
-#include "mali_osk_types.h"
-#include "mali_osk.h"
-
-u32 _mali_osk_bitmap_alloc(struct _mali_osk_bitmap *bitmap)
-{
-	u32 obj;
-
-	MALI_DEBUG_ASSERT_POINTER(bitmap);
-
-	_mali_osk_spinlock_lock(bitmap->lock);
-
-	obj = find_next_zero_bit(bitmap->table, bitmap->max, bitmap->reserve);
-
-	if (obj < bitmap->max) {
-		set_bit(obj, bitmap->table);
-	} else {
-		obj = -1;
-	}
-
-	if (obj != -1)
-		--bitmap->avail;
-	_mali_osk_spinlock_unlock(bitmap->lock);
-
-	return obj;
-}
-
-void _mali_osk_bitmap_free(struct _mali_osk_bitmap *bitmap, u32 obj)
-{
-	MALI_DEBUG_ASSERT_POINTER(bitmap);
-
-	_mali_osk_bitmap_free_range(bitmap, obj, 1);
-}
-
-u32 _mali_osk_bitmap_alloc_range(struct _mali_osk_bitmap *bitmap, int cnt)
-{
-	u32 obj;
-
-	MALI_DEBUG_ASSERT_POINTER(bitmap);
-
-	if (0 >= cnt) {
-		return -1;
-	}
-
-	if (1 == cnt) {
-		return _mali_osk_bitmap_alloc(bitmap);
-	}
-
-	_mali_osk_spinlock_lock(bitmap->lock);
-	obj = bitmap_find_next_zero_area(bitmap->table, bitmap->max,
-					 bitmap->last, cnt, 0);
-
-	if (obj >= bitmap->max) {
-		obj = bitmap_find_next_zero_area(bitmap->table, bitmap->max,
-						 bitmap->reserve, cnt, 0);
-	}
-
-	if (obj < bitmap->max) {
-		bitmap_set(bitmap->table, obj, cnt);
-
-		bitmap->last = (obj + cnt);
-		if (bitmap->last >= bitmap->max) {
-			bitmap->last = bitmap->reserve;
-		}
-	} else {
-		obj = -1;
-	}
-
-	if (obj != -1) {
-		bitmap->avail -= cnt;
-	}
-
-	_mali_osk_spinlock_unlock(bitmap->lock);
-
-	return obj;
-}
-
-u32 _mali_osk_bitmap_avail(struct _mali_osk_bitmap *bitmap)
-{
-	MALI_DEBUG_ASSERT_POINTER(bitmap);
-
-	return bitmap->avail;
-}
-
-void _mali_osk_bitmap_free_range(struct _mali_osk_bitmap *bitmap, u32 obj, int cnt)
-{
-	MALI_DEBUG_ASSERT_POINTER(bitmap);
-
-	_mali_osk_spinlock_lock(bitmap->lock);
-	bitmap_clear(bitmap->table, obj, cnt);
-	bitmap->last = min(bitmap->last, obj);
-
-	bitmap->avail += cnt;
-	_mali_osk_spinlock_unlock(bitmap->lock);
-}
-
-int _mali_osk_bitmap_init(struct _mali_osk_bitmap *bitmap, u32 num, u32 reserve)
-{
-	MALI_DEBUG_ASSERT_POINTER(bitmap);
-	MALI_DEBUG_ASSERT(reserve <= num);
-
-	bitmap->reserve = reserve;
-	bitmap->last = reserve;
-	bitmap->max  = num;
-	bitmap->avail = num - reserve;
-	bitmap->lock = _mali_osk_spinlock_init(_MALI_OSK_LOCKFLAG_UNORDERED, _MALI_OSK_LOCK_ORDER_FIRST);
-	if (!bitmap->lock) {
-		return _MALI_OSK_ERR_NOMEM;
-	}
-	bitmap->table = kzalloc(BITS_TO_LONGS(bitmap->max) *
-				sizeof(long), GFP_KERNEL);
-	if (!bitmap->table) {
-		_mali_osk_spinlock_term(bitmap->lock);
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	return _MALI_OSK_ERR_OK;
-}
-
-void _mali_osk_bitmap_term(struct _mali_osk_bitmap *bitmap)
-{
-	MALI_DEBUG_ASSERT_POINTER(bitmap);
-
-	if (NULL != bitmap->lock) {
-		_mali_osk_spinlock_term(bitmap->lock);
-	}
-
-	if (NULL != bitmap->table) {
-		kfree(bitmap->table);
-	}
-}
-
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_irq.c b/drivers/gpu/arm/mali/linux/mali_osk_irq.c
old mode 100755
new mode 100644
index 4a75845a..0d19f74a
--- a/drivers/gpu/arm/mali/linux/mali_osk_irq.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_irq.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -13,7 +13,9 @@
  * Implementation of the OS abstraction layer for the kernel device driver
  */
 
-#include <linux/slab.h> /* For memory allocation */
+#include <linux/types.h>
+#include <mach/cpu.h>
+#include <linux/slab.h>	/* For memory allocation */
 #include <linux/interrupt.h>
 #include <linux/wait.h>
 #include <linux/sched.h>
@@ -30,6 +32,16 @@ typedef struct _mali_osk_irq_t_struct {
 typedef irqreturn_t (*irq_handler_func_t)(int, void *, struct pt_regs *);
 static irqreturn_t irq_handler_upper_half(int port_name, void *dev_id);   /* , struct pt_regs *regs*/
 
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+u32 get_irqnum(struct _mali_osk_irq_t_struct* irq)
+{
+	if (irq)
+		return irq->irqnum;
+	else
+		return 0;
+}
+#endif
+
 #if defined(DEBUG)
 
 struct test_interrupt_data {
@@ -153,7 +165,7 @@ _mali_osk_irq_t *_mali_osk_irq_init(u32 irqnum, _mali_osk_irq_uhandler_t uhandle
 #if defined(DEBUG)
 	/* Verify that the configured interrupt settings are working */
 	if (_MALI_OSK_ERR_OK != test_interrupt(irqnum, trigger_func, ack_func, probe_data, description)) {
-		MALI_DEBUG_PRINT(2, ("Test of IRQ(%d) handler for core '%s' failed\n", irqnum, description));
+		MALI_DEBUG_PRINT(2, ("Test of IRQ handler for core '%s' failed\n", description));
 		kfree(irq_object);
 		return NULL;
 	}
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_locks.c b/drivers/gpu/arm/mali/linux/mali_osk_locks.c
old mode 100755
new mode 100644
index 4fa93981..2a395a26
--- a/drivers/gpu/arm/mali/linux/mali_osk_locks.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_locks.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_locks.h b/drivers/gpu/arm/mali/linux/mali_osk_locks.h
old mode 100755
new mode 100644
index a05586f0..69b011f0
--- a/drivers/gpu/arm/mali/linux/mali_osk_locks.h
+++ b/drivers/gpu/arm/mali/linux/mali_osk_locks.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_low_level_mem.c b/drivers/gpu/arm/mali/linux/mali_osk_low_level_mem.c
old mode 100755
new mode 100644
index bc713a17..39329778
--- a/drivers/gpu/arm/mali/linux/mali_osk_low_level_mem.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_low_level_mem.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_mali.c b/drivers/gpu/arm/mali/linux/mali_osk_mali.c
old mode 100755
new mode 100644
index 272d1964..a1f96528
--- a/drivers/gpu/arm/mali/linux/mali_osk_mali.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_mali.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -24,15 +24,6 @@
 #include "mali_osk.h"           /* kernel side OS functions */
 #include "mali_kernel_linux.h"
 
-static mali_bool mali_secure_mode_enabled = MALI_FALSE;
-static mali_bool mali_secure_mode_supported = MALI_FALSE;
-
-/* Function that init the mali gpu secure mode */
-void (*mali_secure_mode_deinit)(void) = NULL;
-/* Function that reset GPU and enable the mali gpu secure mode */
-int (*mali_gpu_reset_and_secure_mode_enable)(void) = NULL;
-/* Function that reset GPU and disable the mali gpu secure mode */
-int (*mali_gpu_reset_and_secure_mode_disable)(void) = NULL;
 
 #ifdef CONFIG_MALI_DT
 
@@ -61,11 +52,6 @@ int (*mali_gpu_reset_and_secure_mode_disable)(void) = NULL;
 #define MALI_OSK_RESOURCE_L2_LOCATION_START 20
 #define MALI_OSK_RESOURCE_l2_LOCATION_END 22
 
-/**
- * DMA unit location.
- */
-#define MALI_OSK_RESOURCE_DMA_LOCATION 26
-
 static _mali_osk_resource_t mali_osk_resource_bank[MALI_OSK_MAX_RESOURCE_NUMBER] = {
 	{.description = "Mali_GP", .base = MALI_OFFSET_GP, .irq_name = "IRQGP",},
 	{.description = "Mali_GP_MMU", .base = MALI_OFFSET_GP_MMU, .irq_name = "IRQGPMMU",},
@@ -96,36 +82,20 @@ static _mali_osk_resource_t mali_osk_resource_bank[MALI_OSK_MAX_RESOURCE_NUMBER]
 	{.description = "Mali_DMA", .base = MALI_OFFSET_DMA,},
 };
 
-static int _mali_osk_get_compatible_name(const char **out_string)
-{
-	struct device_node *node = mali_platform_device->dev.of_node;
-
-	MALI_DEBUG_ASSERT(NULL != node);
-
-	return of_property_read_string(node, "compatible", out_string);
-}
-
 _mali_osk_errcode_t _mali_osk_resource_initialize(void)
 {
-	mali_bool mali_is_450 = MALI_FALSE, mali_is_470 = MALI_FALSE;
+	mali_bool mali_is_450 = MALI_FALSE;
 	int i, pp_core_num = 0, l2_core_num = 0;
 	struct resource *res;
-	const char *compatible_name = NULL;
-
-	if (0 == _mali_osk_get_compatible_name(&compatible_name)) {
-		if (0 == strncmp(compatible_name, "arm,mali-450", strlen("arm,mali-450"))) {
-			mali_is_450 = MALI_TRUE;
-			MALI_DEBUG_PRINT(2, ("mali-450 device tree detected."));
-		} else if (0 == strncmp(compatible_name, "arm,mali-470", strlen("arm,mali-470"))) {
-			mali_is_470 = MALI_TRUE;
-			MALI_DEBUG_PRINT(2, ("mali-470 device tree detected."));
-		}
-	}
 
 	for (i = 0; i < MALI_OSK_RESOURCE_WITH_IRQ_NUMBER; i++) {
 		res = platform_get_resource_byname(mali_platform_device, IORESOURCE_IRQ, mali_osk_resource_bank[i].irq_name);
 		if (res) {
 			mali_osk_resource_bank[i].irq = res->start;
+			if (0 == strncmp("Mali_PP_Broadcast", mali_osk_resource_bank[i].description,
+					 strlen(mali_osk_resource_bank[i].description))) {
+				mali_is_450 = MALI_TRUE;
+			}
 		} else {
 			mali_osk_resource_bank[i].base = MALI_OSK_INVALID_RESOURCE_ADDRESS;
 		}
@@ -147,15 +117,14 @@ _mali_osk_errcode_t _mali_osk_resource_initialize(void)
 
 	/**
 	 * we can caculate the number of l2 cache core according the number of pp core number
-	 * and device type(mali400/mali450/mali470).
+	 * and device type(mali400/mali450).
 	 */
-	l2_core_num = 1;
-	if (mali_is_450) {
-		if (pp_core_num > 4) {
-			l2_core_num = 3;
-		} else if (pp_core_num <= 4) {
-			l2_core_num = 2;
-		}
+	if (mali_is_450 && 4 < pp_core_num) {
+		l2_core_num = 3;
+	} else if (mali_is_450 && 4 >= pp_core_num) {
+		l2_core_num = 2;
+	} else {
+		l2_core_num = 1;
 	}
 
 	for (i = MALI_OSK_RESOURCE_l2_LOCATION_END; i > MALI_OSK_RESOURCE_L2_LOCATION_START + l2_core_num - 1; i--) {
@@ -163,15 +132,12 @@ _mali_osk_errcode_t _mali_osk_resource_initialize(void)
 	}
 
 	/* If device is not mali-450 type, we have to remove related resource from resource bank. */
-	if (!(mali_is_450 || mali_is_470)) {
+	if (!mali_is_450) {
 		for (i = MALI_OSK_RESOURCE_l2_LOCATION_END + 1; i < MALI_OSK_MAX_RESOURCE_NUMBER; i++) {
 			mali_osk_resource_bank[i].base = MALI_OSK_INVALID_RESOURCE_ADDRESS;
 		}
 	}
 
-	if (mali_is_470)
-		mali_osk_resource_bank[MALI_OSK_RESOURCE_DMA_LOCATION].base = MALI_OSK_INVALID_RESOURCE_ADDRESS;
-
 	return _MALI_OSK_ERR_OK;
 }
 
@@ -359,18 +325,22 @@ _mali_osk_errcode_t _mali_osk_device_data_get(_mali_osk_device_data *data)
 	return _MALI_OSK_ERR_ITEM_NOT_FOUND;
 }
 
-u32 _mali_osk_identify_gpu_resource(void)
+u32 _mali_osk_l2_resource_count(void)
 {
+	u32 l2_core_num = 0;
+
+	if (_MALI_OSK_ERR_OK == _mali_osk_resource_find(MALI_OFFSET_L2_RESOURCE0, NULL))
+		l2_core_num++;
+
 	if (_MALI_OSK_ERR_OK == _mali_osk_resource_find(MALI_OFFSET_L2_RESOURCE1, NULL))
-		/* Mali 450 */
-		return 0x450;
+		l2_core_num++;
+
+	if (_MALI_OSK_ERR_OK == _mali_osk_resource_find(MALI_OFFSET_L2_RESOURCE2, NULL))
+		l2_core_num++;
 
-	if (_MALI_OSK_ERR_OK == _mali_osk_resource_find(MALI_OFFSET_DLBU, NULL))
-		/* Mali 470 */
-		return 0x470;
+	MALI_DEBUG_ASSERT(0 < l2_core_num);
 
-	/* Mali 400 */
-	return 0x400;
+	return l2_core_num;
 }
 
 mali_bool _mali_osk_shared_interrupts(void)
@@ -397,95 +367,3 @@ mali_bool _mali_osk_shared_interrupts(void)
 
 	return MALI_FALSE;
 }
-
-_mali_osk_errcode_t _mali_osk_gpu_secure_mode_init(void)
-{
-	_mali_osk_device_data data = { 0, };
-
-	if (_MALI_OSK_ERR_OK ==  _mali_osk_device_data_get(&data)) {
-		if ((NULL != data.secure_mode_init) && (NULL != data.secure_mode_deinit)
-		    && (NULL != data.gpu_reset_and_secure_mode_enable) && (NULL != data.gpu_reset_and_secure_mode_disable)) {
-			int err = data.secure_mode_init();
-			if (err) {
-				MALI_DEBUG_PRINT(1, ("Failed to init gpu secure mode.\n"));
-				return _MALI_OSK_ERR_FAULT;
-			}
-
-			mali_secure_mode_deinit = data.secure_mode_deinit;
-			mali_gpu_reset_and_secure_mode_enable = data.gpu_reset_and_secure_mode_enable;
-			mali_gpu_reset_and_secure_mode_disable = data.gpu_reset_and_secure_mode_disable;
-
-			mali_secure_mode_supported = MALI_TRUE;
-			mali_secure_mode_enabled = MALI_FALSE;
-			return _MALI_OSK_ERR_OK;
-		}
-	}
-	MALI_DEBUG_PRINT(3, ("GPU secure mode not supported.\n"));
-	return _MALI_OSK_ERR_UNSUPPORTED;
-
-}
-
-_mali_osk_errcode_t _mali_osk_gpu_secure_mode_deinit(void)
-{
-	if (NULL !=  mali_secure_mode_deinit) {
-		mali_secure_mode_deinit();
-		mali_secure_mode_enabled = MALI_FALSE;
-		mali_secure_mode_supported = MALI_FALSE;
-		return _MALI_OSK_ERR_OK;
-	}
-	MALI_DEBUG_PRINT(3, ("GPU secure mode not supported.\n"));
-	return _MALI_OSK_ERR_UNSUPPORTED;
-
-}
-
-
-_mali_osk_errcode_t _mali_osk_gpu_reset_and_secure_mode_enable(void)
-{
-	/* the mali executor lock must be held before enter this function. */
-
-	MALI_DEBUG_ASSERT(MALI_FALSE == mali_secure_mode_enabled);
-
-	if (NULL !=  mali_gpu_reset_and_secure_mode_enable) {
-		if (mali_gpu_reset_and_secure_mode_enable()) {
-			MALI_DEBUG_PRINT(1, ("Failed to reset GPU or enable gpu secure mode.\n"));
-			return _MALI_OSK_ERR_FAULT;
-		}
-		mali_secure_mode_enabled = MALI_TRUE;
-		return _MALI_OSK_ERR_OK;
-	}
-	MALI_DEBUG_PRINT(1, ("GPU secure mode not supported.\n"));
-	return _MALI_OSK_ERR_UNSUPPORTED;
-}
-
-_mali_osk_errcode_t _mali_osk_gpu_reset_and_secure_mode_disable(void)
-{
-	/* the mali executor lock must be held before enter this function. */
-
-	MALI_DEBUG_ASSERT(MALI_TRUE == mali_secure_mode_enabled);
-
-	if (NULL != mali_gpu_reset_and_secure_mode_disable) {
-		if (mali_gpu_reset_and_secure_mode_disable()) {
-			MALI_DEBUG_PRINT(1, ("Failed to reset GPU or disable gpu secure mode.\n"));
-			return _MALI_OSK_ERR_FAULT;
-		}
-		mali_secure_mode_enabled = MALI_FALSE;
-
-		return _MALI_OSK_ERR_OK;
-
-	}
-	MALI_DEBUG_PRINT(1, ("GPU secure mode not supported.\n"));
-	return _MALI_OSK_ERR_UNSUPPORTED;
-
-}
-
-mali_bool _mali_osk_gpu_secure_mode_is_enabled(void)
-{
-	return mali_secure_mode_enabled;
-}
-
-mali_bool _mali_osk_gpu_secure_mode_is_supported(void)
-{
-	return mali_secure_mode_supported;
-}
-
-
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_math.c b/drivers/gpu/arm/mali/linux/mali_osk_math.c
old mode 100755
new mode 100644
index 3f06723a..a8716c41
--- a/drivers/gpu/arm/mali/linux/mali_osk_math.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_math.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_memory.c b/drivers/gpu/arm/mali/linux/mali_osk_memory.c
old mode 100755
new mode 100644
index ad5494d3..b9dd7555
--- a/drivers/gpu/arm/mali/linux/mali_osk_memory.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_memory.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2011, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_misc.c b/drivers/gpu/arm/mali/linux/mali_osk_misc.c
old mode 100755
new mode 100644
index 7dda2834..0600f309
--- a/drivers/gpu/arm/mali/linux/mali_osk_misc.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_misc.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -42,6 +42,17 @@ u32 _mali_osk_snprintf(char *buf, u32 size, const char *fmt, ...)
 	return res;
 }
 
+void _mali_osk_ctxprintf(_mali_osk_print_ctx *print_ctx, const char *fmt, ...)
+{
+	va_list args;
+	char buf[512];
+
+	va_start(args, fmt);
+	vscnprintf(buf, 512, fmt, args);
+	seq_printf(print_ctx, buf);
+	va_end(args);
+}
+
 void _mali_osk_abort(void)
 {
 	/* make a simple fault by dereferencing a NULL pointer */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_notification.c b/drivers/gpu/arm/mali/linux/mali_osk_notification.c
old mode 100755
new mode 100644
index 58678417..61462eec
--- a/drivers/gpu/arm/mali/linux/mali_osk_notification.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_notification.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_pm.c b/drivers/gpu/arm/mali/linux/mali_osk_pm.c
old mode 100755
new mode 100644
index 6a579ad3..50a237cc
--- a/drivers/gpu/arm/mali/linux/mali_osk_pm.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_pm.c
@@ -1,9 +1,9 @@
 /**
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -15,7 +15,6 @@
 
 #include <linux/sched.h>
 
-#include "mali_kernel_linux.h"
 #ifdef CONFIG_PM_RUNTIME
 #include <linux/pm_runtime.h>
 #endif /* CONFIG_PM_RUNTIME */
@@ -23,6 +22,7 @@
 #include <linux/version.h>
 #include "mali_osk.h"
 #include "mali_kernel_common.h"
+#include "mali_kernel_linux.h"
 
 /* Can NOT run in atomic context */
 _mali_osk_errcode_t _mali_osk_pm_dev_ref_get_sync(void)
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_profiling.c b/drivers/gpu/arm/mali/linux/mali_osk_profiling.c
old mode 100755
new mode 100644
index 35d1abcb..2c5a9dfd
--- a/drivers/gpu/arm/mali/linux/mali_osk_profiling.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_profiling.c
@@ -1,18 +1,14 @@
 /*
- * Copyright (C) 2012-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
-#include <linux/hrtimer.h>
+
 #include <linux/module.h>
-#include <linux/file.h>
-#include <linux/poll.h>
-#include <linux/anon_inodes.h>
-#include <linux/sched.h>
 
 #include <mali_profiling_gator_api.h>
 #include "mali_kernel_common.h"
@@ -26,770 +22,19 @@
 #include "mali_l2_cache.h"
 #include "mali_user_settings_db.h"
 #include "mali_executor.h"
-#include "mali_memory_manager.h"
-
-#define MALI_PROFILING_STREAM_DATA_DEFAULT_SIZE 100
-#define MALI_PROFILING_STREAM_HOLD_TIME 1000000         /*1 ms */
-
-#define MALI_PROFILING_STREAM_BUFFER_SIZE       (1 << 12)
-#define MALI_PROFILING_STREAM_BUFFER_NUM        100
-
-/**
- * Define the mali profiling stream struct.
- */
-typedef struct mali_profiling_stream {
-	u8 data[MALI_PROFILING_STREAM_BUFFER_SIZE];
-	u32 used_size;
-	struct list_head list;
-} mali_profiling_stream;
-
-typedef struct mali_profiling_stream_list {
-	spinlock_t spin_lock;
-	struct list_head free_list;
-	struct list_head queue_list;
-} mali_profiling_stream_list;
-
-static const char mali_name[] = "4xx";
-static const char utgard_setup_version[] = "ANNOTATE_SETUP 1\n";
-
-static u32 profiling_sample_rate = 0;
-static u32 first_sw_counter_index = 0;
-
-static mali_bool l2_cache_counter_if_enabled = MALI_FALSE;
-static u32 num_counters_enabled = 0;
-static u32 mem_counters_enabled = 0;
-
-static _mali_osk_atomic_t stream_fd_if_used;
-
-static wait_queue_head_t stream_fd_wait_queue;
-static mali_profiling_counter *global_mali_profiling_counters = NULL;
-static u32 num_global_mali_profiling_counters = 0;
-
-static mali_profiling_stream_list *global_mali_stream_list = NULL;
-static mali_profiling_stream *mali_counter_stream = NULL;
-static mali_profiling_stream *mali_core_activity_stream = NULL;
-static u64 mali_core_activity_stream_dequeue_time = 0;
-static spinlock_t mali_activity_lock;
-static u32 mali_activity_cores_num =  0;
-static struct hrtimer profiling_sampling_timer;
-
-const char *_mali_mem_counter_descriptions[] = _MALI_MEM_COUTNER_DESCRIPTIONS;
-const char *_mali_special_counter_descriptions[] = _MALI_SPCIAL_COUNTER_DESCRIPTIONS;
-
-static u32 current_profiling_pid = 0;
-
-static void _mali_profiling_stream_list_destory(mali_profiling_stream_list *profiling_stream_list)
-{
-	mali_profiling_stream *profiling_stream, *tmp_profiling_stream;
-	MALI_DEBUG_ASSERT_POINTER(profiling_stream_list);
-
-	list_for_each_entry_safe(profiling_stream, tmp_profiling_stream, &profiling_stream_list->free_list, list) {
-		list_del(&profiling_stream->list);
-		kfree(profiling_stream);
-	}
-
-	list_for_each_entry_safe(profiling_stream, tmp_profiling_stream, &profiling_stream_list->queue_list, list) {
-		list_del(&profiling_stream->list);
-		kfree(profiling_stream);
-	}
-
-	kfree(profiling_stream_list);
-}
-
-static void _mali_profiling_global_stream_list_free(void)
-{
-	mali_profiling_stream *profiling_stream, *tmp_profiling_stream;
-	unsigned long irq_flags;
-
-	MALI_DEBUG_ASSERT_POINTER(global_mali_stream_list);
-	spin_lock_irqsave(&global_mali_stream_list->spin_lock, irq_flags);
-	list_for_each_entry_safe(profiling_stream, tmp_profiling_stream, &global_mali_stream_list->queue_list, list) {
-		profiling_stream->used_size = 0;
-		list_move(&profiling_stream->list, &global_mali_stream_list->free_list);
-	}
-	spin_unlock_irqrestore(&global_mali_stream_list->spin_lock, irq_flags);
-}
-
-static _mali_osk_errcode_t _mali_profiling_global_stream_list_dequeue(struct list_head *stream_list, mali_profiling_stream **new_mali_profiling_stream)
-{
-	unsigned long irq_flags;
-	_mali_osk_errcode_t ret = _MALI_OSK_ERR_OK;
-	MALI_DEBUG_ASSERT_POINTER(global_mali_stream_list);
-	MALI_DEBUG_ASSERT_POINTER(stream_list);
-
-	spin_lock_irqsave(&global_mali_stream_list->spin_lock, irq_flags);
-
-	if (!list_empty(stream_list)) {
-		*new_mali_profiling_stream = list_entry(stream_list->next, mali_profiling_stream, list);
-		list_del_init(&(*new_mali_profiling_stream)->list);
-	} else {
-		ret = _MALI_OSK_ERR_NOMEM;
-	}
-
-	spin_unlock_irqrestore(&global_mali_stream_list->spin_lock, irq_flags);
-
-	return ret;
-}
-
-static void _mali_profiling_global_stream_list_queue(struct list_head *stream_list, mali_profiling_stream *current_mali_profiling_stream)
-{
-	unsigned long irq_flags;
-	MALI_DEBUG_ASSERT_POINTER(global_mali_stream_list);
-	MALI_DEBUG_ASSERT_POINTER(stream_list);
-
-	spin_lock_irqsave(&global_mali_stream_list->spin_lock, irq_flags);
-	list_add_tail(&current_mali_profiling_stream->list, stream_list);
-	spin_unlock_irqrestore(&global_mali_stream_list->spin_lock, irq_flags);
-}
-
-static mali_bool _mali_profiling_global_stream_queue_list_if_empty(void)
-{
-	MALI_DEBUG_ASSERT_POINTER(global_mali_stream_list);
-	return list_empty(&global_mali_stream_list->queue_list);
-}
-
-static u32 _mali_profiling_global_stream_queue_list_next_size(void)
-{
-	unsigned long irq_flags;
-	u32 size = 0;
-	MALI_DEBUG_ASSERT_POINTER(global_mali_stream_list);
-
-	spin_lock_irqsave(&global_mali_stream_list->spin_lock, irq_flags);
-	if (!list_empty(&global_mali_stream_list->queue_list)) {
-		mali_profiling_stream *next_mali_profiling_stream =
-			list_entry(global_mali_stream_list->queue_list.next, mali_profiling_stream, list);
-		size = next_mali_profiling_stream->used_size;
-	}
-	spin_unlock_irqrestore(&global_mali_stream_list->spin_lock, irq_flags);
-	return size;
-}
-
-/* The mali profiling stream file operations functions. */
-static ssize_t _mali_profiling_stream_read(
-	struct file *filp,
-	char __user *buffer,
-	size_t      size,
-	loff_t      *f_pos);
-
-static unsigned int  _mali_profiling_stream_poll(struct file *filp, poll_table *wait);
-
-static int  _mali_profiling_stream_release(struct inode *inode, struct file *filp);
-
-/* The timeline stream file operations structure. */
-static const struct file_operations mali_profiling_stream_fops = {
-	.release = _mali_profiling_stream_release,
-	.read    = _mali_profiling_stream_read,
-	.poll    = _mali_profiling_stream_poll,
-};
-
-static ssize_t _mali_profiling_stream_read(
-	struct file *filp,
-	char __user *buffer,
-	size_t      size,
-	loff_t      *f_pos)
-{
-	u32 copy_len = 0;
-	mali_profiling_stream *current_mali_profiling_stream;
-	u32 used_size;
-	MALI_DEBUG_ASSERT_POINTER(global_mali_stream_list);
-
-	while (!_mali_profiling_global_stream_queue_list_if_empty()) {
-		used_size = _mali_profiling_global_stream_queue_list_next_size();
-		if (used_size <= ((u32)size - copy_len)) {
-			current_mali_profiling_stream = NULL;
-			_mali_profiling_global_stream_list_dequeue(&global_mali_stream_list->queue_list,
-					&current_mali_profiling_stream);
-			MALI_DEBUG_ASSERT_POINTER(current_mali_profiling_stream);
-			if (copy_to_user(&buffer[copy_len], current_mali_profiling_stream->data, current_mali_profiling_stream->used_size)) {
-				current_mali_profiling_stream->used_size = 0;
-				_mali_profiling_global_stream_list_queue(&global_mali_stream_list->free_list, current_mali_profiling_stream);
-				return -EFAULT;
-			}
-			copy_len += current_mali_profiling_stream->used_size;
-			current_mali_profiling_stream->used_size = 0;
-			_mali_profiling_global_stream_list_queue(&global_mali_stream_list->free_list, current_mali_profiling_stream);
-		} else {
-			break;
-		}
-	}
-	return (ssize_t)copy_len;
-}
-
-static unsigned int  _mali_profiling_stream_poll(struct file *filp, poll_table *wait)
-{
-	poll_wait(filp, &stream_fd_wait_queue, wait);
-	if (!_mali_profiling_global_stream_queue_list_if_empty())
-		return POLLIN;
-	return 0;
-}
-
-static int  _mali_profiling_stream_release(struct inode *inode, struct file *filp)
-{
-	_mali_osk_atomic_init(&stream_fd_if_used, 0);
-	return 0;
-}
-
-/* The funs for control packet and stream data.*/
-static void _mali_profiling_set_packet_size(unsigned char *const buf, const u32 size)
-{
-	u32 i;
-
-	for (i = 0; i < sizeof(size); ++i)
-		buf[i] = (size >> 8 * i) & 0xFF;
-}
-
-static u32 _mali_profiling_get_packet_size(unsigned char *const buf)
-{
-	u32 i;
-	u32 size = 0;
-	for (i = 0; i < sizeof(size); ++i)
-		size |= (u32)buf[i] << 8 * i;
-	return size;
-}
-
-static u32 _mali_profiling_read_packet_int(unsigned char *const buf, u32 *const pos, u32 const packet_size)
-{
-	u64 int_value = 0;
-	u8 shift = 0;
-	u8 byte_value = ~0;
-
-	while ((byte_value & 0x80) != 0) {
-		if ((*pos) >= packet_size)
-			return -1;
-		byte_value = buf[*pos];
-		*pos += 1;
-		int_value |= (u32)(byte_value & 0x7f) << shift;
-		shift += 7;
-	}
-
-	if (shift < 8 * sizeof(int_value) && (byte_value & 0x40) != 0) {
-		int_value |= -(1 << shift);
-	}
-
-	return int_value;
-}
-
-static u32 _mali_profiling_pack_int(u8 *const buf, u32 const buf_size, u32 const pos, s32 value)
-{
-	u32 add_bytes = 0;
-	int more = 1;
-	while (more) {
-		/* low order 7 bits of val */
-		char byte_value = value & 0x7f;
-		value >>= 7;
-
-		if ((value == 0 && (byte_value & 0x40) == 0) || (value == -1 && (byte_value & 0x40) != 0)) {
-			more = 0;
-		} else {
-			byte_value |= 0x80;
-		}
-
-		if ((pos + add_bytes) >= buf_size)
-			return 0;
-		buf[pos + add_bytes] = byte_value;
-		add_bytes++;
-	}
-
-	return add_bytes;
-}
-
-static int _mali_profiling_pack_long(uint8_t *const buf, u32 const buf_size, u32 const pos, s64 val)
-{
-	int add_bytes = 0;
-	int more = 1;
-	while (more) {
-		/* low order 7 bits of x */
-		char byte_value = val & 0x7f;
-		val >>= 7;
-
-		if ((val == 0 && (byte_value & 0x40) == 0) || (val == -1 && (byte_value & 0x40) != 0)) {
-			more = 0;
-		} else {
-			byte_value |= 0x80;
-		}
-
-		MALI_DEBUG_ASSERT((pos + add_bytes) < buf_size);
-		buf[pos + add_bytes] = byte_value;
-		add_bytes++;
-	}
-
-	return add_bytes;
-}
-
-static void _mali_profiling_stream_add_counter(mali_profiling_stream *profiling_stream, s64 current_time, u32 key, u32 counter_value)
-{
-	u32 add_size = STREAM_HEADER_SIZE;
-	MALI_DEBUG_ASSERT_POINTER(profiling_stream);
-	MALI_DEBUG_ASSERT((profiling_stream->used_size) < MALI_PROFILING_STREAM_BUFFER_SIZE);
-
-	profiling_stream->data[profiling_stream->used_size] = STREAM_HEADER_COUNTER_VALUE;
-
-	add_size += _mali_profiling_pack_long(profiling_stream->data, MALI_PROFILING_STREAM_BUFFER_SIZE,
-					      profiling_stream->used_size + add_size, current_time);
-	add_size += _mali_profiling_pack_int(profiling_stream->data, MALI_PROFILING_STREAM_BUFFER_SIZE,
-					     profiling_stream->used_size + add_size, (s32)0);
-	add_size += _mali_profiling_pack_int(profiling_stream->data, MALI_PROFILING_STREAM_BUFFER_SIZE,
-					     profiling_stream->used_size + add_size, (s32)key);
-	add_size += _mali_profiling_pack_int(profiling_stream->data, MALI_PROFILING_STREAM_BUFFER_SIZE,
-					     profiling_stream->used_size + add_size, (s32)counter_value);
-
-	_mali_profiling_set_packet_size(profiling_stream->data + profiling_stream->used_size + 1,
-					add_size - STREAM_HEADER_SIZE);
-
-	profiling_stream->used_size += add_size;
-}
-
-/* The callback function for sampling timer.*/
-static enum hrtimer_restart  _mali_profiling_sampling_counters(struct hrtimer *timer)
-{
-	u32 counter_index;
-	s64 current_time;
-	MALI_DEBUG_ASSERT_POINTER(global_mali_profiling_counters);
-	MALI_DEBUG_ASSERT_POINTER(global_mali_stream_list);
-
-	MALI_DEBUG_ASSERT(NULL == mali_counter_stream);
-	if (_MALI_OSK_ERR_OK == _mali_profiling_global_stream_list_dequeue(
-		    &global_mali_stream_list->free_list, &mali_counter_stream)) {
-
-		MALI_DEBUG_ASSERT_POINTER(mali_counter_stream);
-		MALI_DEBUG_ASSERT(0 == mali_counter_stream->used_size);
-
-		/* Capture l2 cache counter values if enabled */
-		if (MALI_TRUE == l2_cache_counter_if_enabled) {
-			int i, j = 0;
-			_mali_profiling_l2_counter_values l2_counters_values;
-			_mali_profiling_get_l2_counters(&l2_counters_values);
-
-			for (i  = COUNTER_L2_0_C0; i <= COUNTER_L2_2_C1; i++) {
-				if (0 == (j % 2))
-					_mali_osk_profiling_record_global_counters(i, l2_counters_values.cores[j / 2].value0);
-				else
-					_mali_osk_profiling_record_global_counters(i, l2_counters_values.cores[j / 2].value1);
-				j++;
-			}
-		}
-
-		current_time = (s64)_mali_osk_boot_time_get_ns();
-
-		/* Add all enabled counter values into stream */
-		for (counter_index = 0; counter_index < num_global_mali_profiling_counters; counter_index++) {
-			/* No need to sample these couners here. */
-			if (global_mali_profiling_counters[counter_index].enabled) {
-				if ((global_mali_profiling_counters[counter_index].counter_id >= FIRST_MEM_COUNTER &&
-				     global_mali_profiling_counters[counter_index].counter_id <= LAST_MEM_COUNTER)
-				    || (global_mali_profiling_counters[counter_index].counter_id == COUNTER_VP_ACTIVITY)
-				    || (global_mali_profiling_counters[counter_index].counter_id == COUNTER_FP_ACTIVITY)
-				    || (global_mali_profiling_counters[counter_index].counter_id == COUNTER_FILMSTRIP)) {
-
-					continue;
-				}
-
-				if (global_mali_profiling_counters[counter_index].counter_id >= COUNTER_L2_0_C0 &&
-				    global_mali_profiling_counters[counter_index].counter_id <= COUNTER_L2_2_C1) {
-
-					u32 prev_val = global_mali_profiling_counters[counter_index].prev_counter_value;
-
-					_mali_profiling_stream_add_counter(mali_counter_stream, current_time, global_mali_profiling_counters[counter_index].key,
-									   global_mali_profiling_counters[counter_index].current_counter_value - prev_val);
-
-					prev_val = global_mali_profiling_counters[counter_index].current_counter_value;
-
-					global_mali_profiling_counters[counter_index].prev_counter_value = prev_val;
-				} else {
-
-					if (global_mali_profiling_counters[counter_index].counter_id == COUNTER_TOTAL_ALLOC_PAGES) {
-						u32 total_alloc_mem = _mali_ukk_report_memory_usage();
-						global_mali_profiling_counters[counter_index].current_counter_value = total_alloc_mem / _MALI_OSK_MALI_PAGE_SIZE;
-					}
-					_mali_profiling_stream_add_counter(mali_counter_stream, current_time, global_mali_profiling_counters[counter_index].key,
-									   global_mali_profiling_counters[counter_index].current_counter_value);
-					if (global_mali_profiling_counters[counter_index].counter_id < FIRST_SPECIAL_COUNTER)
-						global_mali_profiling_counters[counter_index].current_counter_value = 0;
-				}
-			}
-		}
-		_mali_profiling_global_stream_list_queue(&global_mali_stream_list->queue_list, mali_counter_stream);
-		mali_counter_stream = NULL;
-	} else {
-		MALI_DEBUG_PRINT(1, ("Not enough mali profiling stream buffer!\n"));
-	}
-
-	wake_up_interruptible(&stream_fd_wait_queue);
-
-	/*Enable the sampling timer again*/
-	if (0 != num_counters_enabled && 0 != profiling_sample_rate) {
-		hrtimer_forward_now(&profiling_sampling_timer, ns_to_ktime(profiling_sample_rate));
-		return HRTIMER_RESTART;
-	}
-	return HRTIMER_NORESTART;
-}
-
-static void _mali_profiling_sampling_core_activity_switch(int counter_id, int core, u32 activity, u32 pid)
-{
-	unsigned long irq_flags;
-
-	spin_lock_irqsave(&mali_activity_lock, irq_flags);
-	if (activity == 0)
-		mali_activity_cores_num--;
-	else
-		mali_activity_cores_num++;
-	spin_unlock_irqrestore(&mali_activity_lock, irq_flags);
-
-	if (NULL != global_mali_profiling_counters) {
-		int i ;
-		for (i = 0; i < num_global_mali_profiling_counters; i++) {
-			if (counter_id == global_mali_profiling_counters[i].counter_id && global_mali_profiling_counters[i].enabled) {
-				u64 current_time = _mali_osk_boot_time_get_ns();
-				u32 add_size = STREAM_HEADER_SIZE;
-
-				if (NULL != mali_core_activity_stream) {
-					if ((mali_core_activity_stream_dequeue_time +  MALI_PROFILING_STREAM_HOLD_TIME < current_time) ||
-					    (MALI_PROFILING_STREAM_DATA_DEFAULT_SIZE > MALI_PROFILING_STREAM_BUFFER_SIZE
-					     - mali_core_activity_stream->used_size)) {
-						_mali_profiling_global_stream_list_queue(&global_mali_stream_list->queue_list, mali_core_activity_stream);
-						mali_core_activity_stream = NULL;
-						wake_up_interruptible(&stream_fd_wait_queue);
-					}
-				}
-
-				if (NULL == mali_core_activity_stream) {
-					if (_MALI_OSK_ERR_OK == _mali_profiling_global_stream_list_dequeue(
-						    &global_mali_stream_list->free_list, &mali_core_activity_stream)) {
-						mali_core_activity_stream_dequeue_time = current_time;
-					} else {
-						MALI_DEBUG_PRINT(1, ("Not enough mali profiling stream buffer!\n"));
-						wake_up_interruptible(&stream_fd_wait_queue);
-						break;
-					}
-
-				}
-
-				mali_core_activity_stream->data[mali_core_activity_stream->used_size] = STREAM_HEADER_CORE_ACTIVITY;
-
-				add_size += _mali_profiling_pack_long(mali_core_activity_stream->data,
-								      MALI_PROFILING_STREAM_BUFFER_SIZE, mali_core_activity_stream->used_size + add_size, (s64)current_time);
-				add_size += _mali_profiling_pack_int(mali_core_activity_stream->data,
-								     MALI_PROFILING_STREAM_BUFFER_SIZE, mali_core_activity_stream->used_size + add_size, core);
-				add_size += _mali_profiling_pack_int(mali_core_activity_stream->data,
-								     MALI_PROFILING_STREAM_BUFFER_SIZE, mali_core_activity_stream->used_size + add_size, (s32)global_mali_profiling_counters[i].key);
-				add_size += _mali_profiling_pack_int(mali_core_activity_stream->data,
-								     MALI_PROFILING_STREAM_BUFFER_SIZE, mali_core_activity_stream->used_size + add_size, activity);
-				add_size += _mali_profiling_pack_int(mali_core_activity_stream->data,
-								     MALI_PROFILING_STREAM_BUFFER_SIZE, mali_core_activity_stream->used_size + add_size, pid);
-
-				_mali_profiling_set_packet_size(mali_core_activity_stream->data + mali_core_activity_stream->used_size + 1,
-								add_size - STREAM_HEADER_SIZE);
-
-				mali_core_activity_stream->used_size += add_size;
-
-				if (0 == mali_activity_cores_num) {
-					_mali_profiling_global_stream_list_queue(&global_mali_stream_list->queue_list, mali_core_activity_stream);
-					mali_core_activity_stream = NULL;
-					wake_up_interruptible(&stream_fd_wait_queue);
-				}
-
-				break;
-			}
-		}
-	}
-}
-
-static mali_bool _mali_profiling_global_counters_init(void)
-{
-	int core_id, counter_index, counter_number, counter_id;
-	u32 num_l2_cache_cores;
-	u32 num_pp_cores;
-	u32 num_gp_cores = 1;
-
-	MALI_DEBUG_ASSERT(NULL == global_mali_profiling_counters);
-	num_pp_cores = mali_pp_get_glob_num_pp_cores();
-	num_l2_cache_cores =    mali_l2_cache_core_get_glob_num_l2_cores();
-
-	num_global_mali_profiling_counters = 3 * (num_gp_cores + num_pp_cores) + 2 * num_l2_cache_cores
-					     + MALI_PROFILING_SW_COUNTERS_NUM
-					     + MALI_PROFILING_SPECIAL_COUNTERS_NUM
-					     + MALI_PROFILING_MEM_COUNTERS_NUM;
-	global_mali_profiling_counters = _mali_osk_calloc(num_global_mali_profiling_counters, sizeof(mali_profiling_counter));
-
-	if (NULL == global_mali_profiling_counters)
-		return MALI_FALSE;
-
-	counter_index = 0;
-	/*Vertex processor counters */
-	for (core_id = 0; core_id < num_gp_cores; core_id ++) {
-		global_mali_profiling_counters[counter_index].counter_id = ACTIVITY_VP_0 + core_id;
-		_mali_osk_snprintf(global_mali_profiling_counters[counter_index].counter_name,
-				   sizeof(global_mali_profiling_counters[counter_index].counter_name), "ARM_Mali-%s_VP_%d_active", mali_name, core_id);
-
-		for (counter_number = 0; counter_number < 2; counter_number++) {
-			counter_index++;
-			global_mali_profiling_counters[counter_index].counter_id = COUNTER_VP_0_C0 + (2 * core_id) + counter_number;
-			_mali_osk_snprintf(global_mali_profiling_counters[counter_index].counter_name,
-					   sizeof(global_mali_profiling_counters[counter_index].counter_name), "ARM_Mali-%s_VP_%d_cnt%d", mali_name, core_id, counter_number);
-		}
-	}
-
-	/* Fragment processors' counters */
-	for (core_id = 0; core_id < num_pp_cores; core_id++) {
-		counter_index++;
-		global_mali_profiling_counters[counter_index].counter_id = ACTIVITY_FP_0 + core_id;
-		_mali_osk_snprintf(global_mali_profiling_counters[counter_index].counter_name,
-				   sizeof(global_mali_profiling_counters[counter_index].counter_name), "ARM_Mali-%s_FP_%d_active", mali_name, core_id);
-
-		for (counter_number = 0; counter_number < 2; counter_number++) {
-			counter_index++;
-			global_mali_profiling_counters[counter_index].counter_id = COUNTER_FP_0_C0 + (2 * core_id) + counter_number;
-			_mali_osk_snprintf(global_mali_profiling_counters[counter_index].counter_name,
-					   sizeof(global_mali_profiling_counters[counter_index].counter_name), "ARM_Mali-%s_FP_%d_cnt%d", mali_name, core_id, counter_number);
-		}
-	}
-
-	/* L2 Cache counters */
-	for (core_id = 0; core_id < num_l2_cache_cores; core_id++) {
-		for (counter_number = 0; counter_number < 2; counter_number++) {
-			counter_index++;
-			global_mali_profiling_counters[counter_index].counter_id = COUNTER_L2_0_C0 + (2 * core_id) + counter_number;
-			_mali_osk_snprintf(global_mali_profiling_counters[counter_index].counter_name,
-					   sizeof(global_mali_profiling_counters[counter_index].counter_name), "ARM_Mali-%s_L2_%d_cnt%d", mali_name, core_id, counter_number);
-		}
-	}
-
-	/* Now set up the software counter entries */
-	for (counter_id = FIRST_SW_COUNTER; counter_id <= LAST_SW_COUNTER; counter_id++) {
-		counter_index++;
-
-		if (0 == first_sw_counter_index)
-			first_sw_counter_index = counter_index;
-
-		global_mali_profiling_counters[counter_index].counter_id = counter_id;
-		_mali_osk_snprintf(global_mali_profiling_counters[counter_index].counter_name,
-				   sizeof(global_mali_profiling_counters[counter_index].counter_name), "ARM_Mali-%s_SW_%d", mali_name, counter_id - FIRST_SW_COUNTER);
-	}
-
-	/* Now set up the special counter entries */
-	for (counter_id = FIRST_SPECIAL_COUNTER; counter_id <= LAST_SPECIAL_COUNTER; counter_id++) {
-
-		counter_index++;
-		_mali_osk_snprintf(global_mali_profiling_counters[counter_index].counter_name,
-				   sizeof(global_mali_profiling_counters[counter_index].counter_name), "ARM_Mali-%s_%s",
-				   mali_name, _mali_special_counter_descriptions[counter_id - FIRST_SPECIAL_COUNTER]);
-
-		global_mali_profiling_counters[counter_index].counter_id = counter_id;
-	}
-
-	/* Now set up the mem counter entries*/
-	for (counter_id = FIRST_MEM_COUNTER; counter_id <= LAST_MEM_COUNTER; counter_id++) {
-
-		counter_index++;
-		_mali_osk_snprintf(global_mali_profiling_counters[counter_index].counter_name,
-				   sizeof(global_mali_profiling_counters[counter_index].counter_name), "ARM_Mali-%s_%s",
-				   mali_name, _mali_mem_counter_descriptions[counter_id - FIRST_MEM_COUNTER]);
-
-		global_mali_profiling_counters[counter_index].counter_id = counter_id;
-	}
-
-	MALI_DEBUG_ASSERT((counter_index + 1) == num_global_mali_profiling_counters);
-
-	return MALI_TRUE;
-}
-
-void _mali_profiling_notification_mem_counter(struct mali_session_data *session, u32 counter_id, u32 key, int enable)
-{
-
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	if (NULL != session) {
-		_mali_osk_notification_t *notification;
-		_mali_osk_notification_queue_t *queue;
-
-		queue = session->ioctl_queue;
-		MALI_DEBUG_ASSERT(NULL != queue);
-
-		notification = _mali_osk_notification_create(_MALI_NOTIFICATION_ANNOTATE_PROFILING_MEM_COUNTER,
-				sizeof(_mali_uk_annotate_profiling_mem_counter_s));
-
-		if (NULL != notification) {
-			_mali_uk_annotate_profiling_mem_counter_s *data = notification->result_buffer;
-			data->counter_id = counter_id;
-			data->key = key;
-			data->enable = enable;
-
-			_mali_osk_notification_queue_send(queue, notification);
-		} else {
-			MALI_PRINT_ERROR(("Failed to create notification object!\n"));
-		}
-	} else {
-		MALI_PRINT_ERROR(("Failed to find the right session!\n"));
-	}
-}
-
-void _mali_profiling_notification_enable(struct mali_session_data *session, u32 sampling_rate, int enable)
-{
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	if (NULL != session) {
-		_mali_osk_notification_t *notification;
-		_mali_osk_notification_queue_t *queue;
-
-		queue = session->ioctl_queue;
-		MALI_DEBUG_ASSERT(NULL != queue);
-
-		notification = _mali_osk_notification_create(_MALI_NOTIFICATION_ANNOTATE_PROFILING_ENABLE,
-				sizeof(_mali_uk_annotate_profiling_enable_s));
-
-		if (NULL != notification) {
-			_mali_uk_annotate_profiling_enable_s *data = notification->result_buffer;
-			data->sampling_rate = sampling_rate;
-			data->enable = enable;
-
-			_mali_osk_notification_queue_send(queue, notification);
-		} else {
-			MALI_PRINT_ERROR(("Failed to create notification object!\n"));
-		}
-	} else {
-		MALI_PRINT_ERROR(("Failed to find the right session!\n"));
-	}
-}
-
 
 _mali_osk_errcode_t _mali_osk_profiling_init(mali_bool auto_start)
 {
-	int i;
-	mali_profiling_stream *new_mali_profiling_stream = NULL;
-	mali_profiling_stream_list *new_mali_profiling_stream_list = NULL;
 	if (MALI_TRUE == auto_start) {
 		mali_set_user_setting(_MALI_UK_USER_SETTING_SW_EVENTS_ENABLE, MALI_TRUE);
 	}
 
-	/*Init the global_mali_stream_list*/
-	MALI_DEBUG_ASSERT(NULL == global_mali_stream_list);
-	new_mali_profiling_stream_list = (mali_profiling_stream_list *)kmalloc(sizeof(mali_profiling_stream_list), GFP_KERNEL);
-
-	if (NULL == new_mali_profiling_stream_list) {
-		return _MALI_OSK_ERR_NOMEM;
-	}
-
-	spin_lock_init(&new_mali_profiling_stream_list->spin_lock);
-	INIT_LIST_HEAD(&new_mali_profiling_stream_list->free_list);
-	INIT_LIST_HEAD(&new_mali_profiling_stream_list->queue_list);
-
-	spin_lock_init(&mali_activity_lock);
-	mali_activity_cores_num =  0;
-
-	for (i = 0; i < MALI_PROFILING_STREAM_BUFFER_NUM; i++) {
-		new_mali_profiling_stream = (mali_profiling_stream *)kmalloc(sizeof(mali_profiling_stream), GFP_KERNEL);
-		if (NULL == new_mali_profiling_stream) {
-			_mali_profiling_stream_list_destory(new_mali_profiling_stream_list);
-			return _MALI_OSK_ERR_NOMEM;
-		}
-
-		INIT_LIST_HEAD(&new_mali_profiling_stream->list);
-		new_mali_profiling_stream->used_size = 0;
-		list_add_tail(&new_mali_profiling_stream->list, &new_mali_profiling_stream_list->free_list);
-
-	}
-
-	_mali_osk_atomic_init(&stream_fd_if_used, 0);
-	init_waitqueue_head(&stream_fd_wait_queue);
-
-	hrtimer_init(&profiling_sampling_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
-
-	profiling_sampling_timer.function = _mali_profiling_sampling_counters;
-
-	global_mali_stream_list = new_mali_profiling_stream_list;
-
 	return _MALI_OSK_ERR_OK;
 }
 
 void _mali_osk_profiling_term(void)
 {
-	if (0 != profiling_sample_rate) {
-		hrtimer_cancel(&profiling_sampling_timer);
-		profiling_sample_rate = 0;
-	}
-	_mali_osk_atomic_term(&stream_fd_if_used);
-
-	if (NULL != global_mali_profiling_counters) {
-		_mali_osk_free(global_mali_profiling_counters);
-		global_mali_profiling_counters = NULL;
-		num_global_mali_profiling_counters = 0;
-	}
-
-	if (NULL != global_mali_stream_list) {
-		_mali_profiling_stream_list_destory(global_mali_stream_list);
-		global_mali_stream_list = NULL;
-	}
-
-}
-
-void _mali_osk_profiling_stop_sampling(u32 pid)
-{
-	if (pid == current_profiling_pid) {
-
-		int i;
-		/* Reset all counter states when closing connection.*/
-		for (i = 0; i < num_global_mali_profiling_counters; ++i) {
-			_mali_profiling_set_event(global_mali_profiling_counters[i].counter_id, MALI_HW_CORE_NO_COUNTER);
-			global_mali_profiling_counters[i].enabled = 0;
-			global_mali_profiling_counters[i].prev_counter_value = 0;
-			global_mali_profiling_counters[i].current_counter_value = 0;
-		}
-		l2_cache_counter_if_enabled = MALI_FALSE;
-		num_counters_enabled = 0;
-		mem_counters_enabled = 0;
-		_mali_profiling_control(FBDUMP_CONTROL_ENABLE, 0);
-		_mali_profiling_control(SW_COUNTER_ENABLE, 0);
-		/* Delete sampling timer when closing connection. */
-		if (0 != profiling_sample_rate) {
-			hrtimer_cancel(&profiling_sampling_timer);
-			profiling_sample_rate = 0;
-		}
-		current_profiling_pid = 0;
-	}
-}
-
-void    _mali_osk_profiling_add_event(u32 event_id, u32 data0, u32 data1, u32 data2, u32 data3, u32 data4)
-{
-	/*Record the freq & volt to global_mali_profiling_counters here. */
-	if (0 != profiling_sample_rate) {
-		u32 channel;
-		u32 state;
-		channel = (event_id >> 16) & 0xFF;
-		state = ((event_id >> 24) & 0xF) << 24;
-
-		switch (state) {
-		case MALI_PROFILING_EVENT_TYPE_SINGLE:
-			if ((MALI_PROFILING_EVENT_CHANNEL_GPU >> 16) == channel) {
-				u32 reason = (event_id & 0xFFFF);
-				if (MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE == reason) {
-					_mali_osk_profiling_record_global_counters(COUNTER_FREQUENCY, data0);
-					_mali_osk_profiling_record_global_counters(COUNTER_VOLTAGE, data1);
-				}
-			}
-			break;
-		case MALI_PROFILING_EVENT_TYPE_START:
-			if ((MALI_PROFILING_EVENT_CHANNEL_GP0 >> 16) == channel) {
-				_mali_profiling_sampling_core_activity_switch(COUNTER_VP_ACTIVITY, 0, 1, data1);
-			} else if (channel >= (MALI_PROFILING_EVENT_CHANNEL_PP0 >> 16) &&
-				   (MALI_PROFILING_EVENT_CHANNEL_PP7 >> 16) >= channel) {
-				u32 core_id = channel - (MALI_PROFILING_EVENT_CHANNEL_PP0 >> 16);
-				_mali_profiling_sampling_core_activity_switch(COUNTER_FP_ACTIVITY, core_id, 1, data1);
-			}
-			break;
-		case MALI_PROFILING_EVENT_TYPE_STOP:
-			if ((MALI_PROFILING_EVENT_CHANNEL_GP0 >> 16) == channel) {
-				_mali_profiling_sampling_core_activity_switch(COUNTER_VP_ACTIVITY, 0, 0, 0);
-			} else if (channel >= (MALI_PROFILING_EVENT_CHANNEL_PP0 >> 16) &&
-				   (MALI_PROFILING_EVENT_CHANNEL_PP7 >> 16) >= channel) {
-				u32 core_id = channel - (MALI_PROFILING_EVENT_CHANNEL_PP0 >> 16);
-				_mali_profiling_sampling_core_activity_switch(COUNTER_FP_ACTIVITY, core_id, 0, 0);
-			}
-			break;
-		default:
-			break;
-		}
-	}
-	trace_mali_timeline_event(event_id, data0, data1, data2, data3, data4);
+	/* Nothing to do */
 }
 
 void _mali_osk_profiling_report_sw_counters(u32 *counters)
@@ -797,17 +42,9 @@ void _mali_osk_profiling_report_sw_counters(u32 *counters)
 	trace_mali_sw_counters(_mali_osk_get_pid(), _mali_osk_get_tid(), NULL, counters);
 }
 
-void _mali_osk_profiling_record_global_counters(int counter_id, u32 value)
+void _mali_osk_profiling_memory_usage_get(u32 *memory_usage)
 {
-	if (NULL != global_mali_profiling_counters) {
-		int i ;
-		for (i = 0; i < num_global_mali_profiling_counters; i++) {
-			if (counter_id == global_mali_profiling_counters[i].counter_id && global_mali_profiling_counters[i].enabled) {
-				global_mali_profiling_counters[i].current_counter_value = value;
-				break;
-			}
-		}
-	}
+	*memory_usage = _mali_ukk_report_memory_usage();
 }
 
 _mali_osk_errcode_t _mali_ukk_profiling_add_event(_mali_uk_profiling_add_event_s *args)
@@ -824,279 +61,12 @@ _mali_osk_errcode_t _mali_ukk_sw_counters_report(_mali_uk_sw_counters_report_s *
 
 	_mali_osk_profiling_report_sw_counters(counters);
 
-	if (NULL != global_mali_profiling_counters) {
-		int i;
-		for (i = 0; i < MALI_PROFILING_SW_COUNTERS_NUM; i ++) {
-			if (global_mali_profiling_counters[first_sw_counter_index + i].enabled) {
-				global_mali_profiling_counters[first_sw_counter_index + i].current_counter_value = *(counters + i);
-			}
-		}
-	}
-
 	return _MALI_OSK_ERR_OK;
 }
 
-_mali_osk_errcode_t _mali_ukk_profiling_stream_fd_get(_mali_uk_profiling_stream_fd_get_s *args)
+_mali_osk_errcode_t _mali_ukk_profiling_memory_usage_get(_mali_uk_profiling_memory_usage_get_s *args)
 {
-	struct  mali_session_data *session = (struct mali_session_data *)(uintptr_t)args->ctx;
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	if (1 == _mali_osk_atomic_inc_return(&stream_fd_if_used)) {
-
-		s32 fd = anon_inode_getfd("[mali_profiling_stream]", &mali_profiling_stream_fops,
-					  session,
-					  O_RDONLY | O_CLOEXEC);
-
-		args->stream_fd = fd;
-		if (0 > fd) {
-			_mali_osk_atomic_dec(&stream_fd_if_used);
-			return _MALI_OSK_ERR_FAULT;
-		}
-		args->stream_fd = fd;
-	} else {
-		_mali_osk_atomic_dec(&stream_fd_if_used);
-		args->stream_fd = -1;
-		return _MALI_OSK_ERR_BUSY;
-	}
-
-	return _MALI_OSK_ERR_OK;
-}
-
-_mali_osk_errcode_t _mali_ukk_profiling_control_set(_mali_uk_profiling_control_set_s *args)
-{
-	u32 control_packet_size;
-	u32 output_buffer_size;
-
-	struct  mali_session_data *session = (struct mali_session_data *)(uintptr_t)args->ctx;
-	MALI_DEBUG_ASSERT_POINTER(session);
-
-	if (NULL == global_mali_profiling_counters && MALI_FALSE == _mali_profiling_global_counters_init()) {
-		MALI_PRINT_ERROR(("Failed to create global_mali_profiling_counters.\n"));
-		return _MALI_OSK_ERR_FAULT;
-	}
-
-	control_packet_size = args->control_packet_size;
-	output_buffer_size = args->response_packet_size;
-
-	if (0 != control_packet_size) {
-		u8 control_type;
-		u8 *control_packet_data;
-		u8 *response_packet_data;
-		u32 version_length = sizeof(utgard_setup_version) - 1;
-
-		control_packet_data = (u8 *)(uintptr_t)args->control_packet_data;
-		MALI_DEBUG_ASSERT_POINTER(control_packet_data);
-		response_packet_data = (u8 *)(uintptr_t)args->response_packet_data;
-		MALI_DEBUG_ASSERT_POINTER(response_packet_data);
-
-		/*Decide if need to ignore Utgard setup version.*/
-		if (control_packet_size >= version_length) {
-			if (0 == memcmp(control_packet_data, utgard_setup_version, version_length)) {
-				if (control_packet_size == version_length) {
-					args->response_packet_size = 0;
-					return _MALI_OSK_ERR_OK;
-				} else {
-					control_packet_data += version_length;
-					control_packet_size -= version_length;
-				}
-			}
-		}
-
-		current_profiling_pid = _mali_osk_get_pid();
-
-		control_type = control_packet_data[0];
-		switch (control_type) {
-		case PACKET_HEADER_COUNTERS_REQUEST: {
-			int i;
-
-			if (PACKET_HEADER_SIZE > control_packet_size ||
-			    control_packet_size !=  _mali_profiling_get_packet_size(control_packet_data + 1)) {
-				MALI_PRINT_ERROR(("Wrong control packet  size, type 0x%x,size 0x%x.\n", control_packet_data[0], control_packet_size));
-				return _MALI_OSK_ERR_FAULT;
-			}
-
-			/* Send supported counters */
-			if (PACKET_HEADER_SIZE > output_buffer_size)
-				return _MALI_OSK_ERR_FAULT;
-
-			*response_packet_data = PACKET_HEADER_COUNTERS_ACK;
-			args->response_packet_size = PACKET_HEADER_SIZE;
-
-			for (i = 0; i < num_global_mali_profiling_counters; ++i) {
-				u32 name_size = strlen(global_mali_profiling_counters[i].counter_name);
-
-				if ((args->response_packet_size + name_size + 1) > output_buffer_size) {
-					MALI_PRINT_ERROR(("Response packet data is too large..\n"));
-					return _MALI_OSK_ERR_FAULT;
-				}
-
-				memcpy(response_packet_data + args->response_packet_size,
-				       global_mali_profiling_counters[i].counter_name, name_size + 1);
-
-				args->response_packet_size += (name_size + 1);
-
-				if (global_mali_profiling_counters[i].counter_id == COUNTER_VP_ACTIVITY) {
-					args->response_packet_size += _mali_profiling_pack_int(response_packet_data,
-								      output_buffer_size, args->response_packet_size, (s32)1);
-				} else if (global_mali_profiling_counters[i].counter_id == COUNTER_FP_ACTIVITY) {
-					args->response_packet_size += _mali_profiling_pack_int(response_packet_data,
-								      output_buffer_size, args->response_packet_size, (s32)mali_pp_get_glob_num_pp_cores());
-				} else {
-					args->response_packet_size += _mali_profiling_pack_int(response_packet_data,
-								      output_buffer_size, args->response_packet_size, (s32) - 1);
-				}
-			}
-
-			_mali_profiling_set_packet_size(response_packet_data + 1, args->response_packet_size);
-			break;
-		}
-
-		case PACKET_HEADER_COUNTERS_ENABLE: {
-			int i;
-			u32 request_pos = PACKET_HEADER_SIZE;
-			mali_bool sw_counter_if_enabled = MALI_FALSE;
-
-			if (PACKET_HEADER_SIZE > control_packet_size ||
-			    control_packet_size !=  _mali_profiling_get_packet_size(control_packet_data + 1)) {
-				MALI_PRINT_ERROR(("Wrong control packet  size , type 0x%x,size 0x%x.\n", control_packet_data[0], control_packet_size));
-				return _MALI_OSK_ERR_FAULT;
-			}
-
-			/* Init all counter states before enable requested counters.*/
-			for (i = 0; i < num_global_mali_profiling_counters; ++i) {
-				_mali_profiling_set_event(global_mali_profiling_counters[i].counter_id, MALI_HW_CORE_NO_COUNTER);
-				global_mali_profiling_counters[i].enabled = 0;
-				global_mali_profiling_counters[i].prev_counter_value = 0;
-				global_mali_profiling_counters[i].current_counter_value = 0;
-
-				if (global_mali_profiling_counters[i].counter_id >= FIRST_MEM_COUNTER &&
-				    global_mali_profiling_counters[i].counter_id <= LAST_MEM_COUNTER) {
-					_mali_profiling_notification_mem_counter(session, global_mali_profiling_counters[i].counter_id, 0, 0);
-				}
-			}
-
-			l2_cache_counter_if_enabled = MALI_FALSE;
-			num_counters_enabled = 0;
-			mem_counters_enabled = 0;
-			_mali_profiling_control(FBDUMP_CONTROL_ENABLE, 0);
-			_mali_profiling_control(SW_COUNTER_ENABLE, 0);
-			_mali_profiling_notification_enable(session, 0, 0);
-
-			/* Enable requested counters */
-			while (request_pos < control_packet_size) {
-				u32 begin = request_pos;
-				u32 event;
-				u32 key;
-
-				/* Check the counter name which should be ended with null */
-				while (request_pos < control_packet_size && control_packet_data[request_pos] != '\0') {
-					++request_pos;
-				}
-
-				if (request_pos >= control_packet_size)
-					return _MALI_OSK_ERR_FAULT;
-
-				++request_pos;
-				event = _mali_profiling_read_packet_int(control_packet_data, &request_pos, control_packet_size);
-				key = _mali_profiling_read_packet_int(control_packet_data, &request_pos, control_packet_size);
-
-				for (i = 0; i < num_global_mali_profiling_counters; ++i) {
-					u32 name_size = strlen((char *)(control_packet_data + begin));
-
-					if (strncmp(global_mali_profiling_counters[i].counter_name, (char *)(control_packet_data + begin), name_size) == 0) {
-						if (!sw_counter_if_enabled && (FIRST_SW_COUNTER <= global_mali_profiling_counters[i].counter_id
-									       && global_mali_profiling_counters[i].counter_id <= LAST_SW_COUNTER)) {
-							sw_counter_if_enabled = MALI_TRUE;
-							_mali_profiling_control(SW_COUNTER_ENABLE, 1);
-						}
-
-						if (COUNTER_FILMSTRIP == global_mali_profiling_counters[i].counter_id) {
-							_mali_profiling_control(FBDUMP_CONTROL_ENABLE, 1);
-							_mali_profiling_control(FBDUMP_CONTROL_RATE, event & 0xff);
-							_mali_profiling_control(FBDUMP_CONTROL_RESIZE_FACTOR, (event >> 8) & 0xff);
-						}
-
-						if (global_mali_profiling_counters[i].counter_id >= FIRST_MEM_COUNTER &&
-						    global_mali_profiling_counters[i].counter_id <= LAST_MEM_COUNTER) {
-							_mali_profiling_notification_mem_counter(session, global_mali_profiling_counters[i].counter_id,
-									key, 1);
-							mem_counters_enabled++;
-						}
-
-						global_mali_profiling_counters[i].counter_event = event;
-						global_mali_profiling_counters[i].key = key;
-						global_mali_profiling_counters[i].enabled = 1;
-
-						_mali_profiling_set_event(global_mali_profiling_counters[i].counter_id,
-									  global_mali_profiling_counters[i].counter_event);
-						num_counters_enabled++;
-						break;
-					}
-				}
-
-				if (i == num_global_mali_profiling_counters) {
-					MALI_PRINT_ERROR(("Counter name does not match for type %u.\n", control_type));
-					return _MALI_OSK_ERR_FAULT;
-				}
-			}
-
-			if (PACKET_HEADER_SIZE <= output_buffer_size) {
-				*response_packet_data = PACKET_HEADER_ACK;
-				_mali_profiling_set_packet_size(response_packet_data + 1, PACKET_HEADER_SIZE);
-				args->response_packet_size = PACKET_HEADER_SIZE;
-			} else {
-				return _MALI_OSK_ERR_FAULT;
-			}
-
-			break;
-		}
-
-		case PACKET_HEADER_START_CAPTURE_VALUE: {
-			u32 live_rate;
-			u32 request_pos = PACKET_HEADER_SIZE;
-
-			if (PACKET_HEADER_SIZE > control_packet_size ||
-			    control_packet_size !=  _mali_profiling_get_packet_size(control_packet_data + 1)) {
-				MALI_PRINT_ERROR(("Wrong control packet  size , type 0x%x,size 0x%x.\n", control_packet_data[0], control_packet_size));
-				return _MALI_OSK_ERR_FAULT;
-			}
-
-			/* Read samping rate in nanoseconds and live rate, start capture.*/
-			profiling_sample_rate =  _mali_profiling_read_packet_int(control_packet_data,
-						 &request_pos, control_packet_size);
-
-			live_rate = _mali_profiling_read_packet_int(control_packet_data, &request_pos, control_packet_size);
-
-			if (PACKET_HEADER_SIZE <= output_buffer_size) {
-				*response_packet_data = PACKET_HEADER_ACK;
-				_mali_profiling_set_packet_size(response_packet_data + 1, PACKET_HEADER_SIZE);
-				args->response_packet_size = PACKET_HEADER_SIZE;
-			} else {
-				return _MALI_OSK_ERR_FAULT;
-			}
-
-			if (0 != num_counters_enabled && 0 != profiling_sample_rate) {
-				_mali_profiling_global_stream_list_free();
-				if (mem_counters_enabled > 0) {
-					_mali_profiling_notification_enable(session, profiling_sample_rate, 1);
-				}
-				hrtimer_start(&profiling_sampling_timer,
-					      ktime_set(profiling_sample_rate / 1000000000, profiling_sample_rate % 1000000000),
-					      HRTIMER_MODE_REL_PINNED);
-			}
-
-			break;
-		}
-		default:
-			MALI_PRINT_ERROR(("Unsupported  profiling packet header type %u.\n", control_type));
-			args->response_packet_size  = 0;
-			return _MALI_OSK_ERR_FAULT;
-		}
-	} else {
-		_mali_osk_profiling_stop_sampling(current_profiling_pid);
-		_mali_profiling_notification_enable(session, 0, 0);
-	}
-
+	_mali_osk_profiling_memory_usage_get(&args->memory_usage);
 	return _MALI_OSK_ERR_OK;
 }
 
@@ -1187,7 +157,6 @@ int _mali_profiling_set_event(u32 counter_id, s32 event_id)
 			u32 counter_src = (counter_id - COUNTER_L2_0_C0) & 1;
 			mali_l2_cache_core_set_counter_src(l2_cache_core,
 							   counter_src, event_id);
-			l2_cache_counter_if_enabled = MALI_TRUE;
 		}
 	} else {
 		return 0; /* Failure, unknown event */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_specific.h b/drivers/gpu/arm/mali/linux/mali_osk_specific.h
old mode 100755
new mode 100644
index adcca293..99486ba5
--- a/drivers/gpu/arm/mali/linux/mali_osk_specific.h
+++ b/drivers/gpu/arm/mali/linux/mali_osk_specific.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_time.c b/drivers/gpu/arm/mali/linux/mali_osk_time.c
old mode 100755
new mode 100644
index 76876b61..741756e7
--- a/drivers/gpu/arm/mali/linux/mali_osk_time.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_time.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_timers.c b/drivers/gpu/arm/mali/linux/mali_osk_timers.c
old mode 100755
new mode 100644
index 8ada2da8..a2066f62
--- a/drivers/gpu/arm/mali/linux/mali_osk_timers.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_timers.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_wait_queue.c b/drivers/gpu/arm/mali/linux/mali_osk_wait_queue.c
old mode 100755
new mode 100644
index caa3abe1..9bc17ee5
--- a/drivers/gpu/arm/mali/linux/mali_osk_wait_queue.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_wait_queue.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_osk_wq.c b/drivers/gpu/arm/mali/linux/mali_osk_wq.c
old mode 100755
new mode 100644
index 06afa040..cf4a5ccc
--- a/drivers/gpu/arm/mali/linux/mali_osk_wq.c
+++ b/drivers/gpu/arm/mali/linux/mali_osk_wq.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_pmu_power_up_down.c b/drivers/gpu/arm/mali/linux/mali_pmu_power_up_down.c
old mode 100755
new mode 100644
index 48482a99..e833e655
--- a/drivers/gpu/arm/mali/linux/mali_pmu_power_up_down.c
+++ b/drivers/gpu/arm/mali/linux/mali_pmu_power_up_down.c
@@ -1,9 +1,9 @@
 /**
- * Copyright (C) 2010, 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -17,7 +17,11 @@
 
 int mali_perf_set_num_pp_cores(unsigned int num_cores)
 {
+#ifndef CONFIG_MALI_DVFS
+	return mali_executor_set_perf_level(num_cores, MALI_TRUE);
+#else
 	return mali_executor_set_perf_level(num_cores, MALI_FALSE);
+#endif
 }
 
 EXPORT_SYMBOL(mali_perf_set_num_pp_cores);
diff --git a/drivers/gpu/arm/mali/linux/mali_profiling_events.h b/drivers/gpu/arm/mali/linux/mali_profiling_events.h
old mode 100755
new mode 100644
index 5e510958..0a07f227
--- a/drivers/gpu/arm/mali/linux/mali_profiling_events.h
+++ b/drivers/gpu/arm/mali/linux/mali_profiling_events.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_profiling_gator_api.h b/drivers/gpu/arm/mali/linux/mali_profiling_gator_api.h
old mode 100755
new mode 100644
index e3719713..5290f6d3
--- a/drivers/gpu/arm/mali/linux/mali_profiling_gator_api.h
+++ b/drivers/gpu/arm/mali/linux/mali_profiling_gator_api.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_profiling_internal.c b/drivers/gpu/arm/mali/linux/mali_profiling_internal.c
old mode 100755
new mode 100644
index 918caa07..498525b4
--- a/drivers/gpu/arm/mali/linux/mali_profiling_internal.c
+++ b/drivers/gpu/arm/mali/linux/mali_profiling_internal.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -104,7 +104,6 @@ _mali_osk_errcode_t _mali_internal_profiling_start(u32 *limit)
 	new_profile_entries = _mali_osk_valloc(*limit * sizeof(mali_profiling_entry));
 
 	if (NULL == new_profile_entries) {
-		_mali_osk_mutex_signal(lock);
 		_mali_osk_vfree(new_profile_entries);
 		return _MALI_OSK_ERR_NOMEM;
 	}
diff --git a/drivers/gpu/arm/mali/linux/mali_profiling_internal.h b/drivers/gpu/arm/mali/linux/mali_profiling_internal.h
old mode 100755
new mode 100644
index 6e05ffdc..dc5a97fe
--- a/drivers/gpu/arm/mali/linux/mali_profiling_internal.h
+++ b/drivers/gpu/arm/mali/linux/mali_profiling_internal.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_sync.c b/drivers/gpu/arm/mali/linux/mali_sync.c
old mode 100755
new mode 100644
index c74553be..e38cfc16
--- a/drivers/gpu/arm/mali/linux/mali_sync.c
+++ b/drivers/gpu/arm/mali/linux/mali_sync.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -13,7 +13,6 @@
 #include "mali_osk.h"
 #include "mali_kernel_common.h"
 #include "mali_timeline.h"
-#include "mali_executor.h"
 
 #include <linux/file.h>
 #include <linux/seq_file.h>
@@ -60,6 +59,11 @@ static struct sync_pt *timeline_dup(struct sync_pt *pt)
 	struct mali_sync_pt *mpt, *new_mpt;
 	struct sync_pt *new_pt;
 
+	if (NULL == pt) {
+		dump_stack();
+		return NULL;
+	}
+
 	MALI_DEBUG_ASSERT_POINTER(pt);
 	mpt = to_mali_sync_pt(pt);
 
@@ -121,24 +125,6 @@ static void timeline_free_pt(struct sync_pt *pt)
 
 static void timeline_release(struct sync_timeline *sync_timeline)
 {
-	struct mali_sync_timeline_container *mali_sync_tl = NULL;
-	struct mali_timeline *mali_tl = NULL;
-
-	MALI_DEBUG_ASSERT_POINTER(sync_timeline);
-
-	mali_sync_tl = to_mali_sync_tl_container(sync_timeline);
-	MALI_DEBUG_ASSERT_POINTER(mali_sync_tl);
-
-	mali_tl = mali_sync_tl->timeline;
-
-	/* always signaled timeline didn't have mali container */
-	if (mali_tl) {
-		if (NULL != mali_tl->spinlock) {
-			mali_spinlock_reentrant_term(mali_tl->spinlock);
-		}
-		_mali_osk_free(mali_tl);
-	}
-
 	module_put(THIS_MODULE);
 }
 
@@ -162,42 +148,6 @@ static void timeline_print_pt(struct seq_file *s, struct sync_pt *sync_pt)
 	}
 }
 
-static void timeline_print_obj(struct seq_file *s, struct sync_timeline *sync_tl)
-{
-	struct mali_sync_timeline_container *mali_sync_tl = NULL;
-	struct mali_timeline *mali_tl = NULL;
-
-	MALI_DEBUG_ASSERT_POINTER(sync_tl);
-
-	mali_sync_tl = to_mali_sync_tl_container(sync_tl);
-	MALI_DEBUG_ASSERT_POINTER(mali_sync_tl);
-
-	mali_tl = mali_sync_tl->timeline;
-
-	if (NULL != mali_tl) {
-		seq_printf(s, "oldest (%u) ", mali_tl->point_oldest);
-		seq_printf(s, "next (%u)", mali_tl->point_next);
-		seq_printf(s, "\n");
-
-#if defined(MALI_TIMELINE_DEBUG_FUNCTIONS)
-		{
-			u32 tid = _mali_osk_get_tid();
-			struct mali_timeline_system *system = mali_tl->system;
-
-			mali_spinlock_reentrant_wait(mali_tl->spinlock, tid);
-			if (!mali_tl->destroyed) {
-				mali_spinlock_reentrant_wait(system->spinlock, tid);
-				mali_timeline_debug_print_timeline(mali_tl, s);
-				mali_spinlock_reentrant_signal(system->spinlock, tid);
-			}
-			mali_spinlock_reentrant_signal(mali_tl->spinlock, tid);
-
-			/* dump job queue status and group running status */
-			mali_executor_status_dump();
-		}
-#endif
-	}
-}
 #else
 static void timeline_pt_value_str(struct sync_pt *pt, char *str, int size)
 {
@@ -220,43 +170,22 @@ static void timeline_pt_value_str(struct sync_pt *pt, char *str, int size)
 
 static void timeline_value_str(struct sync_timeline *timeline, char *str, int size)
 {
-	struct mali_sync_timeline_container *mali_sync_tl = NULL;
-	struct mali_timeline *mali_tl = NULL;
+	struct mali_sync_timeline_container *mali_sync_tl;
 
 	MALI_DEBUG_ASSERT_POINTER(timeline);
+	MALI_DEBUG_ASSERT_POINTER(str);
 
 	mali_sync_tl = to_mali_sync_tl_container(timeline);
+
 	MALI_DEBUG_ASSERT_POINTER(mali_sync_tl);
 
-	mali_tl = mali_sync_tl->timeline;
-
-	if (NULL != mali_tl) {
-		_mali_osk_snprintf(str, size, "oldest (%u) ", mali_tl->point_oldest);
-		_mali_osk_snprintf(str, size, "next (%u)", mali_tl->point_next);
-		_mali_osk_snprintf(str, size, "\n");
-
-#if defined(MALI_TIMELINE_DEBUG_FUNCTIONS)
-		{
-			u32 tid = _mali_osk_get_tid();
-			struct mali_timeline_system *system = mali_tl->system;
-
-			mali_spinlock_reentrant_wait(mali_tl->spinlock, tid);
-			if (!mali_tl->destroyed) {
-				mali_spinlock_reentrant_wait(system->spinlock, tid);
-				mali_timeline_debug_direct_print_timeline(mali_tl);
-				mali_spinlock_reentrant_signal(system->spinlock, tid);
-			}
-			mali_spinlock_reentrant_signal(mali_tl->spinlock, tid);
-
-			/* dump job queue status and group running status */
-			mali_executor_status_dump();
-		}
-#endif
+	if (NULL != mali_sync_tl->timeline) {
+		_mali_osk_snprintf(str, size, "oldest (%u)  next (%u)\n", mali_sync_tl->timeline->point_oldest,
+				   mali_sync_tl->timeline->point_next);
 	}
 }
 #endif
 
-
 static struct sync_timeline_ops mali_timeline_ops = {
 	.driver_name    = "Mali",
 	.dup            = timeline_dup,
@@ -266,7 +195,6 @@ static struct sync_timeline_ops mali_timeline_ops = {
 	.release_obj    = timeline_release,
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 17, 0)
 	.print_pt       = timeline_print_pt,
-	.print_obj      = timeline_print_obj,
 #else
 	.pt_value_str = timeline_pt_value_str,
 	.timeline_value_str = timeline_value_str,
@@ -294,16 +222,17 @@ struct sync_timeline *mali_sync_timeline_create(struct mali_timeline *timeline,
 	return sync_tl;
 }
 
+mali_bool mali_sync_timeline_is_ours(struct sync_timeline *sync_tl)
+{
+	MALI_DEBUG_ASSERT_POINTER(sync_tl);
+	return (sync_tl->ops == &mali_timeline_ops) ? MALI_TRUE : MALI_FALSE;
+}
+
 s32 mali_sync_fence_fd_alloc(struct sync_fence *sync_fence)
 {
 	s32 fd = -1;
 
-#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)
 	fd = get_unused_fd();
-#else
-	fd = get_unused_fd_flags(0);
-#endif
-
 	if (fd < 0) {
 		sync_fence_put(sync_fence);
 		return -1;
diff --git a/drivers/gpu/arm/mali/linux/mali_sync.h b/drivers/gpu/arm/mali/linux/mali_sync.h
old mode 100755
new mode 100644
index 79efb8e6..2e36a96e
--- a/drivers/gpu/arm/mali/linux/mali_sync.h
+++ b/drivers/gpu/arm/mali/linux/mali_sync.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -41,6 +41,14 @@ struct mali_timeline;
  */
 struct sync_timeline *mali_sync_timeline_create(struct mali_timeline *timeline, const char *name);
 
+/**
+ * Check if sync timeline belongs to Mali.
+ *
+ * @param sync_tl Sync timeline to check.
+ * @return MALI_TRUE if sync timeline belongs to Mali, MALI_FALSE if not.
+ */
+mali_bool mali_sync_timeline_is_ours(struct sync_timeline *sync_tl);
+
 /**
  * Creates a file descriptor representing the sync fence.  Will release sync fence if allocation of
  * file descriptor fails.
diff --git a/drivers/gpu/arm/mali/linux/mali_uk_types.h b/drivers/gpu/arm/mali/linux/mali_uk_types.h
old mode 100755
new mode 100644
index 00ba28b1..d656e651
--- a/drivers/gpu/arm/mali/linux/mali_uk_types.h
+++ b/drivers/gpu/arm/mali/linux/mali_uk_types.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2012, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2012, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_ukk_core.c b/drivers/gpu/arm/mali/linux/mali_ukk_core.c
old mode 100755
new mode 100644
index a6c43b71..aee3e788
--- a/drivers/gpu/arm/mali/linux/mali_ukk_core.c
+++ b/drivers/gpu/arm/mali/linux/mali_ukk_core.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -130,17 +130,3 @@ int request_high_priority_wrapper(struct mali_session_data *session_data, _mali_
 
 	return map_errcode(err);
 }
-
-int pending_submit_wrapper(struct mali_session_data *session_data, _mali_uk_pending_submit_s __user *uargs)
-{
-	_mali_uk_pending_submit_s kargs;
-	_mali_osk_errcode_t err;
-
-	MALI_CHECK_NON_NULL(uargs, -EINVAL);
-
-	kargs.ctx = (uintptr_t)session_data;
-	err = _mali_ukk_pending_submit(&kargs);
-	if (_MALI_OSK_ERR_OK != err) return map_errcode(err);
-
-	return 0;
-}
diff --git a/drivers/gpu/arm/mali/linux/mali_ukk_gp.c b/drivers/gpu/arm/mali/linux/mali_ukk_gp.c
old mode 100755
new mode 100644
index d7c5d2f9..2c050c06
--- a/drivers/gpu/arm/mali/linux/mali_ukk_gp.c
+++ b/drivers/gpu/arm/mali/linux/mali_ukk_gp.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_ukk_mem.c b/drivers/gpu/arm/mali/linux/mali_ukk_mem.c
old mode 100755
new mode 100644
index 3dfe345f..4e376dcf
--- a/drivers/gpu/arm/mali/linux/mali_ukk_mem.c
+++ b/drivers/gpu/arm/mali/linux/mali_ukk_mem.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -61,10 +61,6 @@ int mem_free_wrapper(struct mali_session_data *session_data, _mali_uk_free_mem_s
 		return map_errcode(err);
 	}
 
-	if (0 != put_user(kargs.free_pages_nr, &uargs->free_pages_nr)) {
-		return -EFAULT;
-	}
-
 	return 0;
 }
 
@@ -113,80 +109,6 @@ int mem_unbind_wrapper(struct mali_session_data *session_data, _mali_uk_unbind_m
 }
 
 
-int mem_cow_wrapper(struct mali_session_data *session_data, _mali_uk_cow_mem_s __user *uargs)
-{
-	_mali_uk_cow_mem_s kargs;
-	_mali_osk_errcode_t err;
-
-	MALI_CHECK_NON_NULL(uargs, -EINVAL);
-	MALI_CHECK_NON_NULL(session_data, -EINVAL);
-
-	if (0 != copy_from_user(&kargs, uargs, sizeof(_mali_uk_cow_mem_s))) {
-		return -EFAULT;
-	}
-	kargs.ctx = (uintptr_t)session_data;
-
-	err = _mali_ukk_mem_cow(&kargs);
-
-	if (_MALI_OSK_ERR_OK != err) {
-		return map_errcode(err);
-	}
-
-	if (0 != put_user(kargs.backend_handle, &uargs->backend_handle)) {
-		return -EFAULT;
-	}
-
-	return 0;
-}
-
-int mem_cow_modify_range_wrapper(struct mali_session_data *session_data, _mali_uk_cow_modify_range_s __user *uargs)
-{
-	_mali_uk_cow_modify_range_s kargs;
-	_mali_osk_errcode_t err;
-
-	MALI_CHECK_NON_NULL(uargs, -EINVAL);
-	MALI_CHECK_NON_NULL(session_data, -EINVAL);
-
-	if (0 != copy_from_user(&kargs, uargs, sizeof(_mali_uk_cow_modify_range_s))) {
-		return -EFAULT;
-	}
-	kargs.ctx = (uintptr_t)session_data;
-
-	err = _mali_ukk_mem_cow_modify_range(&kargs);
-
-	if (_MALI_OSK_ERR_OK != err) {
-		return map_errcode(err);
-	}
-
-	if (0 != put_user(kargs.change_pages_nr, &uargs->change_pages_nr)) {
-		return -EFAULT;
-	}
-	return 0;
-}
-
-
-int mem_resize_mem_wrapper(struct mali_session_data *session_data, _mali_uk_mem_resize_s __user *uargs)
-{
-	_mali_uk_mem_resize_s kargs;
-	_mali_osk_errcode_t err;
-
-	MALI_CHECK_NON_NULL(uargs, -EINVAL);
-	MALI_CHECK_NON_NULL(session_data, -EINVAL);
-
-	if (0 != copy_from_user(&kargs, uargs, sizeof(_mali_uk_mem_resize_s))) {
-		return -EFAULT;
-	}
-	kargs.ctx = (uintptr_t)session_data;
-
-	err = _mali_ukk_mem_resize(&kargs);
-
-	if (_MALI_OSK_ERR_OK != err) {
-		return map_errcode(err);
-	}
-
-	return 0;
-}
-
 int mem_write_safe_wrapper(struct mali_session_data *session_data, _mali_uk_mem_write_safe_s __user *uargs)
 {
 	_mali_uk_mem_write_safe_s kargs;
@@ -304,30 +226,3 @@ err_exit:
 	if (buffer) _mali_osk_vfree(buffer);
 	return rc;
 }
-
-int mem_usage_get_wrapper(struct mali_session_data *session_data, _mali_uk_profiling_memory_usage_get_s __user *uargs)
-{
-	_mali_osk_errcode_t err;
-	_mali_uk_profiling_memory_usage_get_s kargs;
-
-	MALI_CHECK_NON_NULL(uargs, -EINVAL);
-	MALI_CHECK_NON_NULL(session_data, -EINVAL);
-
-	if (0 != copy_from_user(&kargs, uargs, sizeof(_mali_uk_profiling_memory_usage_get_s))) {
-		return -EFAULT;
-	}
-
-	kargs.ctx = (uintptr_t)session_data;
-	err = _mali_ukk_mem_usage_get(&kargs);
-	if (_MALI_OSK_ERR_OK != err) {
-		return map_errcode(err);
-	}
-
-	kargs.ctx = (uintptr_t)NULL; /* prevent kernel address to be returned to user space */
-	if (0 != copy_to_user(uargs, &kargs, sizeof(_mali_uk_profiling_memory_usage_get_s))) {
-		return -EFAULT;
-	}
-
-	return 0;
-}
-
diff --git a/drivers/gpu/arm/mali/linux/mali_ukk_pp.c b/drivers/gpu/arm/mali/linux/mali_ukk_pp.c
old mode 100755
new mode 100644
index 2c59bc72..7790f28a
--- a/drivers/gpu/arm/mali/linux/mali_ukk_pp.c
+++ b/drivers/gpu/arm/mali/linux/mali_ukk_pp.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_ukk_profiling.c b/drivers/gpu/arm/mali/linux/mali_ukk_profiling.c
old mode 100755
new mode 100644
index 35f916d7..931f6d2a
--- a/drivers/gpu/arm/mali/linux/mali_ukk_profiling.c
+++ b/drivers/gpu/arm/mali/linux/mali_ukk_profiling.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -37,6 +37,28 @@ int profiling_add_event_wrapper(struct mali_session_data *session_data, _mali_uk
 	return 0;
 }
 
+int profiling_memory_usage_get_wrapper(struct mali_session_data *session_data, _mali_uk_profiling_memory_usage_get_s __user *uargs)
+{
+	_mali_osk_errcode_t err;
+	_mali_uk_profiling_memory_usage_get_s kargs;
+
+	MALI_CHECK_NON_NULL(uargs, -EINVAL);
+	MALI_CHECK_NON_NULL(session_data, -EINVAL);
+
+	kargs.ctx = (uintptr_t)session_data;
+	err = _mali_ukk_profiling_memory_usage_get(&kargs);
+	if (_MALI_OSK_ERR_OK != err) {
+		return map_errcode(err);
+	}
+
+	kargs.ctx = (uintptr_t)NULL; /* prevent kernel address to be returned to user space */
+	if (0 != copy_to_user(uargs, &kargs, sizeof(_mali_uk_profiling_memory_usage_get_s))) {
+		return -EFAULT;
+	}
+
+	return 0;
+}
+
 int profiling_report_sw_counters_wrapper(struct mali_session_data *session_data, _mali_uk_sw_counters_report_s __user *uargs)
 {
 	_mali_uk_sw_counters_report_s kargs;
@@ -81,103 +103,3 @@ int profiling_report_sw_counters_wrapper(struct mali_session_data *session_data,
 
 	return 0;
 }
-
-int profiling_get_stream_fd_wrapper(struct mali_session_data *session_data, _mali_uk_profiling_stream_fd_get_s __user *uargs)
-{
-	_mali_uk_profiling_stream_fd_get_s kargs;
-	_mali_osk_errcode_t err;
-
-	MALI_CHECK_NON_NULL(uargs, -EINVAL);
-
-	if (0 != copy_from_user(&kargs, uargs, sizeof(_mali_uk_profiling_stream_fd_get_s))) {
-		return -EFAULT;
-	}
-
-	kargs.ctx = (uintptr_t)session_data;
-	err = _mali_ukk_profiling_stream_fd_get(&kargs);
-	if (_MALI_OSK_ERR_OK != err) {
-		return map_errcode(err);
-	}
-
-	if (0 != copy_to_user(uargs, &kargs, sizeof(_mali_uk_profiling_stream_fd_get_s))) {
-		return -EFAULT;
-	}
-
-	return 0;
-}
-
-int profiling_control_set_wrapper(struct mali_session_data *session_data, _mali_uk_profiling_control_set_s __user *uargs)
-{
-	_mali_uk_profiling_control_set_s kargs;
-	_mali_osk_errcode_t err;
-	u8 *kernel_control_data = NULL;
-	u8 *kernel_response_data = NULL;
-
-	MALI_CHECK_NON_NULL(uargs, -EINVAL);
-
-	if (0 != get_user(kargs.control_packet_size, &uargs->control_packet_size)) return -EFAULT;
-	if (0 != get_user(kargs.response_packet_size, &uargs->response_packet_size)) return -EFAULT;
-
-	kargs.ctx = (uintptr_t)session_data;
-
-
-	/* Sanity check about the size */
-	if (kargs.control_packet_size > PAGE_SIZE || kargs.response_packet_size > PAGE_SIZE)
-		return -EINVAL;
-
-	if (0 !=  kargs.control_packet_size) {
-
-		if (0 == kargs.response_packet_size)
-			return -EINVAL;
-
-		kernel_control_data = _mali_osk_calloc(1, kargs.control_packet_size);
-		if (NULL == kernel_control_data) {
-			return -ENOMEM;
-		}
-
-		kernel_response_data = _mali_osk_calloc(1, kargs.response_packet_size);
-		if (NULL == kernel_response_data) {
-			_mali_osk_free(kernel_control_data);
-			return -ENOMEM;
-		}
-
-		kargs.control_packet_data = (uintptr_t)kernel_control_data;
-		kargs.response_packet_data = (uintptr_t)kernel_response_data;
-
-		if (0 != copy_from_user((void *)(uintptr_t)kernel_control_data, (void *)(uintptr_t)uargs->control_packet_data, kargs.control_packet_size)) {
-			_mali_osk_free(kernel_control_data);
-			_mali_osk_free(kernel_response_data);
-			return -EFAULT;
-		}
-
-		err = _mali_ukk_profiling_control_set(&kargs);
-		if (_MALI_OSK_ERR_OK != err) {
-			_mali_osk_free(kernel_control_data);
-			_mali_osk_free(kernel_response_data);
-			return map_errcode(err);
-		}
-
-		if (0 != kargs.response_packet_size && 0 != copy_to_user(((void *)(uintptr_t)uargs->response_packet_data), ((void *)(uintptr_t)kargs.response_packet_data), kargs.response_packet_size)) {
-			_mali_osk_free(kernel_control_data);
-			_mali_osk_free(kernel_response_data);
-			return -EFAULT;
-		}
-
-		if (0 != put_user(kargs.response_packet_size, &uargs->response_packet_size)) {
-			_mali_osk_free(kernel_control_data);
-			_mali_osk_free(kernel_response_data);
-			return -EFAULT;
-		}
-
-		_mali_osk_free(kernel_control_data);
-		_mali_osk_free(kernel_response_data);
-	} else {
-
-		err = _mali_ukk_profiling_control_set(&kargs);
-		if (_MALI_OSK_ERR_OK != err) {
-			return map_errcode(err);
-		}
-
-	}
-	return 0;
-}
diff --git a/drivers/gpu/arm/mali/linux/mali_ukk_soft_job.c b/drivers/gpu/arm/mali/linux/mali_ukk_soft_job.c
old mode 100755
new mode 100644
index beeb7531..4ff60c43
--- a/drivers/gpu/arm/mali/linux/mali_ukk_soft_job.c
+++ b/drivers/gpu/arm/mali/linux/mali_ukk_soft_job.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_ukk_timeline.c b/drivers/gpu/arm/mali/linux/mali_ukk_timeline.c
old mode 100755
new mode 100644
index f32d8b0d..22b3f333
--- a/drivers/gpu/arm/mali/linux/mali_ukk_timeline.c
+++ b/drivers/gpu/arm/mali/linux/mali_ukk_timeline.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_ukk_vsync.c b/drivers/gpu/arm/mali/linux/mali_ukk_vsync.c
old mode 100755
new mode 100644
index 5b54fb98..2dfd3735
--- a/drivers/gpu/arm/mali/linux/mali_ukk_vsync.c
+++ b/drivers/gpu/arm/mali/linux/mali_ukk_vsync.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2011-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2011-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/linux/mali_ukk_wrappers.h b/drivers/gpu/arm/mali/linux/mali_ukk_wrappers.h
old mode 100755
new mode 100644
index 7e59346f..314cb042
--- a/drivers/gpu/arm/mali/linux/mali_ukk_wrappers.h
+++ b/drivers/gpu/arm/mali/linux/mali_ukk_wrappers.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -29,19 +29,15 @@ int get_api_version_v2_wrapper(struct mali_session_data *session_data, _mali_uk_
 int get_user_settings_wrapper(struct mali_session_data *session_data, _mali_uk_get_user_settings_s __user *uargs);
 int post_notification_wrapper(struct mali_session_data *session_data, _mali_uk_post_notification_s __user *uargs);
 int request_high_priority_wrapper(struct mali_session_data *session_data, _mali_uk_request_high_priority_s __user *uargs);
-int pending_submit_wrapper(struct mali_session_data *session_data, _mali_uk_pending_submit_s __user *uargs);
 
 int mem_alloc_wrapper(struct mali_session_data *session_data, _mali_uk_alloc_mem_s __user *uargs);
 int mem_free_wrapper(struct mali_session_data *session_data, _mali_uk_free_mem_s __user *uargs);
 int mem_bind_wrapper(struct mali_session_data *session_data, _mali_uk_bind_mem_s __user *uargs);
 int mem_unbind_wrapper(struct mali_session_data *session_data, _mali_uk_unbind_mem_s __user *uargs);
-int mem_cow_wrapper(struct mali_session_data *session_data, _mali_uk_cow_mem_s __user *uargs);
-int mem_cow_modify_range_wrapper(struct mali_session_data *session_data, _mali_uk_cow_modify_range_s __user *uargs);
-int mem_resize_mem_wrapper(struct mali_session_data *session_data, _mali_uk_mem_resize_s __user *uargs);
+
 int mem_write_safe_wrapper(struct mali_session_data *session_data, _mali_uk_mem_write_safe_s __user *uargs);
 int mem_query_mmu_page_table_dump_size_wrapper(struct mali_session_data *session_data, _mali_uk_query_mmu_page_table_dump_size_s __user *uargs);
 int mem_dump_mmu_page_table_wrapper(struct mali_session_data *session_data, _mali_uk_dump_mmu_page_table_s __user *uargs);
-int mem_usage_get_wrapper(struct mali_session_data *session_data, _mali_uk_profiling_memory_usage_get_s __user *uargs);
 
 int timeline_get_latest_point_wrapper(struct mali_session_data *session, _mali_uk_timeline_get_latest_point_s __user *uargs);
 int timeline_wait_wrapper(struct mali_session_data *session, _mali_uk_timeline_wait_s __user *uargs);
@@ -60,8 +56,7 @@ int gp_suspend_response_wrapper(struct mali_session_data *session_data, _mali_uk
 
 int profiling_add_event_wrapper(struct mali_session_data *session_data, _mali_uk_profiling_add_event_s __user *uargs);
 int profiling_report_sw_counters_wrapper(struct mali_session_data *session_data, _mali_uk_sw_counters_report_s __user *uargs);
-int profiling_get_stream_fd_wrapper(struct mali_session_data *session_data, _mali_uk_profiling_stream_fd_get_s __user *uargs);
-int profiling_control_set_wrapper(struct mali_session_data *session_data, _mali_uk_profiling_control_set_s __user *uargs);
+int profiling_memory_usage_get_wrapper(struct mali_session_data *session_data, _mali_uk_profiling_memory_usage_get_s __user *uargs);
 
 int vsync_event_report_wrapper(struct mali_session_data *session_data, _mali_uk_vsync_event_report_s __user *uargs);
 
diff --git a/drivers/gpu/arm/mali/platform/arm/arm.c b/drivers/gpu/arm/mali/platform/arm/arm.c
deleted file mode 100755
index a7ff1b22..00000000
--- a/drivers/gpu/arm/mali/platform/arm/arm.c
+++ /dev/null
@@ -1,623 +0,0 @@
-/*
- * Copyright (C) 2010, 2012-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-/**
- * @file mali_platform.c
- * Platform specific Mali driver functions for:
- * - Realview Versatile platforms with ARM11 Mpcore and virtex 5.
- * - Versatile Express platforms with ARM Cortex-A9 and virtex 6.
- */
-#include <linux/platform_device.h>
-#include <linux/version.h>
-#include <linux/pm.h>
-#include "mali_kernel_linux.h"
-#ifdef CONFIG_PM_RUNTIME
-#include <linux/pm_runtime.h>
-#endif
-#include <asm/io.h>
-#include <linux/mali/mali_utgard.h>
-#include "mali_kernel_common.h"
-#include <linux/dma-mapping.h>
-#include <linux/moduleparam.h>
-
-#include "arm_core_scaling.h"
-#include "mali_executor.h"
-
-#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_DEVFREQ_THERMAL)
-#include <linux/devfreq_cooling.h>
-#include <linux/thermal.h>
-#endif
-
-static int mali_core_scaling_enable = 0;
-
-void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data);
-static u32 mali_read_phys(u32 phys_addr);
-#if defined(CONFIG_ARCH_REALVIEW)
-static void mali_write_phys(u32 phys_addr, u32 value);
-#endif
-
-#if defined(CONFIG_ARCH_VEXPRESS) && defined(CONFIG_ARM64)
-
-#define SECURE_MODE_CONTROL_HANDLER     0x6F02006C
-void *secure_mode_mapped_addr = NULL;
-/**
- * Reset GPU and enable/disable Mali secure mode.
- * @Return value:
- * 0: success
- * non-0: failure.
- */
-
-static int mali_gpu_reset_and_secure_mode_enable_juno(void)
-{
-	u32 phys_offset    = SECURE_MODE_CONTROL_HANDLER & 0x00001FFF;
-	MALI_DEBUG_ASSERT(NULL != secure_mode_mapped_addr);
-
-	iowrite32(1, ((u8 *)secure_mode_mapped_addr) + phys_offset);
-
-	if (1 == (u32)ioread32(((u8 *)secure_mode_mapped_addr) + phys_offset)) {
-		MALI_DEBUG_PRINT(3, ("Mali reset GPU and enable secured mode successfully! \n"));
-		return 0;
-	}
-
-	MALI_PRINT_ERROR(("Failed to reset GPU and enable Mali secured mode !!! \n"));
-
-	return -1;
-
-}
-
-static int mali_gpu_reset_and_secure_mode_disable_juno(void)
-{
-	u32 phys_offset    = SECURE_MODE_CONTROL_HANDLER & 0x00001FFF;
-	MALI_DEBUG_ASSERT(NULL != secure_mode_mapped_addr);
-
-	iowrite32(0, ((u8 *)secure_mode_mapped_addr) + phys_offset);
-
-	if (0 == (u32)ioread32(((u8 *)secure_mode_mapped_addr) + phys_offset)) {
-		MALI_DEBUG_PRINT(3, ("Mali reset GPU and disable secured mode successfully! \n"));
-		return 0;
-	}
-
-	MALI_PRINT_ERROR(("Failed to reset GPU and disable mali secured mode !!! \n"));
-	return -1;
-}
-
-static int mali_secure_mode_init_juno(void)
-{
-	u32 phys_addr_page = SECURE_MODE_CONTROL_HANDLER & 0xFFFFE000;
-	u32 phys_offset    = SECURE_MODE_CONTROL_HANDLER & 0x00001FFF;
-	u32 map_size       = phys_offset + sizeof(u32);
-
-	MALI_DEBUG_ASSERT(NULL == secure_mode_mapped_addr);
-
-	secure_mode_mapped_addr = ioremap_nocache(phys_addr_page, map_size);
-	if (NULL != secure_mode_mapped_addr) {
-		return mali_gpu_reset_and_secure_mode_disable_juno();
-	}
-	MALI_DEBUG_PRINT(2, ("Failed to ioremap for Mali secured mode! \n"));
-	return -1;
-}
-
-static void mali_secure_mode_deinit_juno(void)
-{
-	if (NULL != secure_mode_mapped_addr) {
-		mali_gpu_reset_and_secure_mode_disable_juno();
-		iounmap(secure_mode_mapped_addr);
-		secure_mode_mapped_addr = NULL;
-	}
-}
-#endif
-
-#ifndef CONFIG_MALI_DT
-static void mali_platform_device_release(struct device *device);
-
-#if defined(CONFIG_ARCH_VEXPRESS)
-
-#if defined(CONFIG_ARM64)
-/* Juno + Mali-450 MP6 in V7 FPGA */
-static struct resource mali_gpu_resources_m450_mp6[] = {
-	MALI_GPU_RESOURCES_MALI450_MP6_PMU(0x6F040000, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200)
-};
-
-static struct resource mali_gpu_resources_m470_mp4[] = {
-	MALI_GPU_RESOURCES_MALI470_MP4_PMU(0x6F040000, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200)
-};
-
-static struct resource mali_gpu_resources_m470_mp3[] = {
-	MALI_GPU_RESOURCES_MALI470_MP3_PMU(0x6F040000, 200, 200, 200, 200, 200, 200, 200, 200, 200)
-};
-
-static struct resource mali_gpu_resources_m470_mp2[] = {
-	MALI_GPU_RESOURCES_MALI470_MP2_PMU(0x6F040000, 200, 200, 200, 200, 200, 200, 200)
-};
-
-static struct resource mali_gpu_resources_m470_mp1[] = {
-	MALI_GPU_RESOURCES_MALI470_MP1_PMU(0x6F040000, 200, 200, 200, 200, 200)
-};
-
-#else
-static struct resource mali_gpu_resources_m450_mp8[] = {
-	MALI_GPU_RESOURCES_MALI450_MP8_PMU(0xFC040000, -1, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 68)
-};
-
-static struct resource mali_gpu_resources_m450_mp6[] = {
-	MALI_GPU_RESOURCES_MALI450_MP6_PMU(0xFC040000, -1, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 70, 68)
-};
-
-static struct resource mali_gpu_resources_m450_mp4[] = {
-	MALI_GPU_RESOURCES_MALI450_MP4_PMU(0xFC040000, -1, 70, 70, 70, 70, 70, 70, 70, 70, 70, 68)
-};
-
-static struct resource mali_gpu_resources_m470_mp4[] = {
-	MALI_GPU_RESOURCES_MALI470_MP4_PMU(0xFC040000, -1, 70, 70, 70, 70, 70, 70, 70, 70, 70, 68)
-};
-#endif /* CONFIG_ARM64 */
-
-#elif defined(CONFIG_ARCH_REALVIEW)
-
-static struct resource mali_gpu_resources_m300[] = {
-	MALI_GPU_RESOURCES_MALI300_PMU(0xC0000000, -1, -1, -1, -1)
-};
-
-static struct resource mali_gpu_resources_m400_mp1[] = {
-	MALI_GPU_RESOURCES_MALI400_MP1_PMU(0xC0000000, -1, -1, -1, -1)
-};
-
-static struct resource mali_gpu_resources_m400_mp2[] = {
-	MALI_GPU_RESOURCES_MALI400_MP2_PMU(0xC0000000, -1, -1, -1, -1, -1, -1)
-};
-
-#endif
-#endif
-
-#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_DEVFREQ_THERMAL)
-
-#define FALLBACK_STATIC_TEMPERATURE 55000
-
-static struct thermal_zone_device *gpu_tz;
-
-/* Calculate gpu static power example for reference */
-static unsigned long arm_model_static_power(unsigned long voltage)
-{
-	int temperature, temp;
-	int temp_squared, temp_cubed, temp_scaling_factor;
-	const unsigned long coefficient = (410UL << 20) / (729000000UL >> 10);
-	const unsigned long voltage_cubed = (voltage * voltage * voltage) >> 10;
-	unsigned long static_power;
-
-	if (gpu_tz) {
-		int ret;
-
-		ret = gpu_tz->ops->get_temp(gpu_tz, &temperature);
-		if (ret) {
-			MALI_DEBUG_PRINT(2, ("Error reading temperature for gpu thermal zone: %d\n", ret));
-			temperature = FALLBACK_STATIC_TEMPERATURE;
-		}
-	} else {
-		temperature = FALLBACK_STATIC_TEMPERATURE;
-	}
-
-	/* Calculate the temperature scaling factor. To be applied to the
-	 * voltage scaled power.
-	 */
-	temp = temperature / 1000;
-	temp_squared = temp * temp;
-	temp_cubed = temp_squared * temp;
-	temp_scaling_factor =
-		(2 * temp_cubed)
-		- (80 * temp_squared)
-		+ (4700 * temp)
-		+ 32000;
-
-	static_power = (((coefficient * voltage_cubed) >> 20)
-			* temp_scaling_factor)
-		       / 1000000;
-
-	return static_power;
-}
-
-/* Calculate gpu dynamic power example for reference */
-static unsigned long arm_model_dynamic_power(unsigned long freq,
-		unsigned long voltage)
-{
-	/* The inputs: freq (f) is in Hz, and voltage (v) in mV.
-	 * The coefficient (c) is in mW/(MHz mV mV).
-	 *
-	 * This function calculates the dynamic power after this formula:
-	 * Pdyn (mW) = c (mW/(MHz*mV*mV)) * v (mV) * v (mV) * f (MHz)
-	 */
-	const unsigned long v2 = (voltage * voltage) / 1000; /* m*(V*V) */
-	const unsigned long f_mhz = freq / 1000000; /* MHz */
-	const unsigned long coefficient = 3600; /* mW/(MHz*mV*mV) */
-	unsigned long dynamic_power;
-
-	dynamic_power = (coefficient * v2 * f_mhz) / 1000000; /* mW */
-
-	return dynamic_power;
-}
-
-struct devfreq_cooling_power arm_cooling_ops = {
-	.get_static_power = arm_model_static_power,
-	.get_dynamic_power = arm_model_dynamic_power,
-};
-#endif
-
-static struct mali_gpu_device_data mali_gpu_data = {
-#ifndef CONFIG_MALI_DT
-	.pmu_switch_delay = 0xFF, /* do not have to be this high on FPGA, but it is good for testing to have a delay */
-#if defined(CONFIG_ARCH_VEXPRESS)
-	.shared_mem_size = 256 * 1024 * 1024, /* 256MB */
-#endif
-#endif
-	.max_job_runtime = 60000, /* 60 seconds */
-
-#if defined(CONFIG_ARCH_REALVIEW)
-	.dedicated_mem_start = 0x80000000, /* Physical start address (use 0xD0000000 for old indirect setup) */
-	.dedicated_mem_size = 0x10000000, /* 256MB */
-#endif
-#if defined(CONFIG_ARM64)
-	/* Some framebuffer drivers get the framebuffer dynamically, such as through GEM,
-	* in which the memory resource can't be predicted in advance.
-	*/
-	.fb_start = 0x0,
-	.fb_size = 0xFFFFF000,
-#else
-	.fb_start = 0xe0000000,
-	.fb_size = 0x01000000,
-#endif
-	.control_interval = 1000, /* 1000ms */
-	.utilization_callback = mali_gpu_utilization_callback,
-	.get_clock_info = NULL,
-	.get_freq = NULL,
-	.set_freq = NULL,
-#if defined(CONFIG_ARCH_VEXPRESS) && defined(CONFIG_ARM64)
-	.secure_mode_init = mali_secure_mode_init_juno,
-	.secure_mode_deinit = mali_secure_mode_deinit_juno,
-	.gpu_reset_and_secure_mode_enable = mali_gpu_reset_and_secure_mode_enable_juno,
-	.gpu_reset_and_secure_mode_disable = mali_gpu_reset_and_secure_mode_disable_juno,
-#else
-	.secure_mode_init = NULL,
-	.secure_mode_deinit = NULL,
-	.gpu_reset_and_secure_mode_enable = NULL,
-	.gpu_reset_and_secure_mode_disable = NULL,
-#endif
-#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_DEVFREQ_THERMAL)
-	.gpu_cooling_ops = &arm_cooling_ops,
-#endif
-};
-
-#ifndef CONFIG_MALI_DT
-static struct platform_device mali_gpu_device = {
-	.name = MALI_GPU_NAME_UTGARD,
-	.id = 0,
-	.dev.release = mali_platform_device_release,
-	.dev.dma_mask = &mali_gpu_device.dev.coherent_dma_mask,
-	.dev.coherent_dma_mask = DMA_BIT_MASK(32),
-
-	.dev.platform_data = &mali_gpu_data,
-};
-
-int mali_platform_device_register(void)
-{
-	int err = -1;
-	int num_pp_cores = 0;
-#if defined(CONFIG_ARCH_REALVIEW)
-	u32 m400_gp_version;
-#endif
-
-	MALI_DEBUG_PRINT(4, ("mali_platform_device_register() called\n"));
-
-	/* Detect present Mali GPU and connect the correct resources to the device */
-#if defined(CONFIG_ARCH_VEXPRESS)
-
-#if defined(CONFIG_ARM64)
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 4, 0)
-	mali_gpu_device.dev.archdata.dma_ops = &dummy_dma_ops;
-#else
-	mali_gpu_device.dev.archdata.dma_ops = dma_ops;
-#endif
-	if ((mali_read_phys(0x6F000000) & 0x00600450) == 0x00600450) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-450 MP6 device\n"));
-		num_pp_cores = 6;
-		mali_gpu_device.num_resources = ARRAY_SIZE(mali_gpu_resources_m450_mp6);
-		mali_gpu_device.resource = mali_gpu_resources_m450_mp6;
-	} else if ((mali_read_phys(0x6F000000) & 0x00F00430) == 0x00400430) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-470 MP4 device\n"));
-		num_pp_cores = 4;
-		mali_gpu_device.num_resources = ARRAY_SIZE(mali_gpu_resources_m470_mp4);
-		mali_gpu_device.resource = mali_gpu_resources_m470_mp4;
-	} else if ((mali_read_phys(0x6F000000) & 0x00F00430) == 0x00300430) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-470 MP3 device\n"));
-		num_pp_cores = 3;
-		mali_gpu_device.num_resources = ARRAY_SIZE(mali_gpu_resources_m470_mp3);
-		mali_gpu_device.resource = mali_gpu_resources_m470_mp3;
-	} else if ((mali_read_phys(0x6F000000) & 0x00F00430) == 0x00200430) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-470 MP2 device\n"));
-		num_pp_cores = 2;
-		mali_gpu_device.num_resources = ARRAY_SIZE(mali_gpu_resources_m470_mp2);
-		mali_gpu_device.resource = mali_gpu_resources_m470_mp2;
-	} else if ((mali_read_phys(0x6F000000) & 0x00F00430) == 0x00100430) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-470 MP1 device\n"));
-		num_pp_cores = 1;
-		mali_gpu_device.num_resources = ARRAY_SIZE(mali_gpu_resources_m470_mp1);
-		mali_gpu_device.resource = mali_gpu_resources_m470_mp1;
-	}
-#else
-	if (mali_read_phys(0xFC000000) == 0x00000450) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-450 MP8 device\n"));
-		num_pp_cores = 8;
-		mali_gpu_device.num_resources = ARRAY_SIZE(mali_gpu_resources_m450_mp8);
-		mali_gpu_device.resource = mali_gpu_resources_m450_mp8;
-	} else if (mali_read_phys(0xFC000000) == 0x40600450) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-450 MP6 device\n"));
-		num_pp_cores = 6;
-		mali_gpu_device.num_resources = ARRAY_SIZE(mali_gpu_resources_m450_mp6);
-		mali_gpu_device.resource = mali_gpu_resources_m450_mp6;
-	} else if (mali_read_phys(0xFC000000) == 0x40400450) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-450 MP4 device\n"));
-		num_pp_cores = 4;
-		mali_gpu_device.num_resources = ARRAY_SIZE(mali_gpu_resources_m450_mp4);
-		mali_gpu_device.resource = mali_gpu_resources_m450_mp4;
-	} else if (mali_read_phys(0xFC000000) == 0xFFFFFFFF) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-470 MP4 device\n"));
-		num_pp_cores = 4;
-		mali_gpu_device.num_resources = ARRAY_SIZE(mali_gpu_resources_m470_mp4);
-		mali_gpu_device.resource = mali_gpu_resources_m470_mp4;
-	}
-#endif /* CONFIG_ARM64 */
-
-#elif defined(CONFIG_ARCH_REALVIEW)
-
-	m400_gp_version = mali_read_phys(0xC000006C);
-	if ((m400_gp_version & 0xFFFF0000) == 0x0C070000) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-300 device\n"));
-		num_pp_cores = 1;
-		mali_gpu_device.num_resources = ARRAY_SIZE(mali_gpu_resources_m300);
-		mali_gpu_device.resource = mali_gpu_resources_m300;
-		mali_write_phys(0xC0010020, 0xA); /* Enable direct memory mapping for FPGA */
-	} else if ((m400_gp_version & 0xFFFF0000) == 0x0B070000) {
-		u32 fpga_fw_version = mali_read_phys(0xC0010000);
-		if (fpga_fw_version == 0x130C008F || fpga_fw_version == 0x110C008F) {
-			/* Mali-400 MP1 r1p0 or r1p1 */
-			MALI_DEBUG_PRINT(4, ("Registering Mali-400 MP1 device\n"));
-			num_pp_cores = 1;
-			mali_gpu_device.num_resources = ARRAY_SIZE(mali_gpu_resources_m400_mp1);
-			mali_gpu_device.resource = mali_gpu_resources_m400_mp1;
-			mali_write_phys(0xC0010020, 0xA); /* Enable direct memory mapping for FPGA */
-		} else if (fpga_fw_version == 0x130C000F) {
-			/* Mali-400 MP2 r1p1 */
-			MALI_DEBUG_PRINT(4, ("Registering Mali-400 MP2 device\n"));
-			num_pp_cores = 2;
-			mali_gpu_device.num_resources = ARRAY_SIZE(mali_gpu_resources_m400_mp2);
-			mali_gpu_device.resource = mali_gpu_resources_m400_mp2;
-			mali_write_phys(0xC0010020, 0xA); /* Enable direct memory mapping for FPGA */
-		}
-	}
-
-#endif
-	/* Register the platform device */
-	err = platform_device_register(&mali_gpu_device);
-	if (0 == err) {
-#ifdef CONFIG_PM_RUNTIME
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-		pm_runtime_set_autosuspend_delay(&(mali_gpu_device.dev), 1000);
-		pm_runtime_use_autosuspend(&(mali_gpu_device.dev));
-#endif
-		pm_runtime_enable(&(mali_gpu_device.dev));
-#endif
-		MALI_DEBUG_ASSERT(0 < num_pp_cores);
-		mali_core_scaling_init(num_pp_cores);
-
-		return 0;
-	}
-
-	return err;
-}
-
-void mali_platform_device_unregister(void)
-{
-	MALI_DEBUG_PRINT(4, ("mali_platform_device_unregister() called\n"));
-
-	mali_core_scaling_term();
-#ifdef CONFIG_PM_RUNTIME
-	pm_runtime_disable(&(mali_gpu_device.dev));
-#endif
-	platform_device_unregister(&mali_gpu_device);
-
-	platform_device_put(&mali_gpu_device);
-
-#if defined(CONFIG_ARCH_REALVIEW)
-	mali_write_phys(0xC0010020, 0x9); /* Restore default (legacy) memory mapping */
-#endif
-}
-
-static void mali_platform_device_release(struct device *device)
-{
-	MALI_DEBUG_PRINT(4, ("mali_platform_device_release() called\n"));
-}
-
-#else /* CONFIG_MALI_DT */
-int mali_platform_device_init(struct platform_device *device)
-{
-	int num_pp_cores = 0;
-	int err = -1;
-#if defined(CONFIG_ARCH_REALVIEW)
-	u32 m400_gp_version;
-#endif
-
-	/* Detect present Mali GPU and connect the correct resources to the device */
-#if defined(CONFIG_ARCH_VEXPRESS)
-
-#if defined(CONFIG_ARM64)
-	if ((mali_read_phys(0x6F000000) & 0x00600450) == 0x00600450) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-450 MP6 device\n"));
-		num_pp_cores = 6;
-	} else if ((mali_read_phys(0x6F000000) & 0x00F00430) == 0x00400430) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-470 MP4 device\n"));
-		num_pp_cores = 4;
-	} else if ((mali_read_phys(0x6F000000) & 0x00F00430) == 0x00300430) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-470 MP3 device\n"));
-		num_pp_cores = 3;
-	} else if ((mali_read_phys(0x6F000000) & 0x00F00430) == 0x00200430) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-470 MP2 device\n"));
-		num_pp_cores = 2;
-	} else if ((mali_read_phys(0x6F000000) & 0x00F00430) == 0x00100430) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-470 MP1 device\n"));
-		num_pp_cores = 1;
-	}
-#else
-	if (mali_read_phys(0xFC000000) == 0x00000450) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-450 MP8 device\n"));
-		num_pp_cores = 8;
-	} else if (mali_read_phys(0xFC000000) == 0x40400450) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-450 MP4 device\n"));
-		num_pp_cores = 4;
-	} else if (mali_read_phys(0xFC000000) == 0xFFFFFFFF) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-470 MP4 device\n"));
-		num_pp_cores = 4;
-	}
-#endif
-
-#elif defined(CONFIG_ARCH_REALVIEW)
-
-	m400_gp_version = mali_read_phys(0xC000006C);
-	if ((m400_gp_version & 0xFFFF0000) == 0x0C070000) {
-		MALI_DEBUG_PRINT(4, ("Registering Mali-300 device\n"));
-		num_pp_cores = 1;
-		mali_write_phys(0xC0010020, 0xA); /* Enable direct memory mapping for FPGA */
-	} else if ((m400_gp_version & 0xFFFF0000) == 0x0B070000) {
-		u32 fpga_fw_version = mali_read_phys(0xC0010000);
-		if (fpga_fw_version == 0x130C008F || fpga_fw_version == 0x110C008F) {
-			/* Mali-400 MP1 r1p0 or r1p1 */
-			MALI_DEBUG_PRINT(4, ("Registering Mali-400 MP1 device\n"));
-			num_pp_cores = 1;
-			mali_write_phys(0xC0010020, 0xA); /* Enable direct memory mapping for FPGA */
-		} else if (fpga_fw_version == 0x130C000F) {
-			/* Mali-400 MP2 r1p1 */
-			MALI_DEBUG_PRINT(4, ("Registering Mali-400 MP2 device\n"));
-			num_pp_cores = 2;
-			mali_write_phys(0xC0010020, 0xA); /* Enable direct memory mapping for FPGA */
-		}
-	}
-#endif
-
-	/* After kernel 3.15 device tree will default set dev
-	 * related parameters in of_platform_device_create_pdata.
-	 * But kernel changes from version to version,
-	 * For example 3.10 didn't include device->dev.dma_mask parameter setting,
-	 * if we didn't include here will cause dma_mapping error,
-	 * but in kernel 3.15 it include  device->dev.dma_mask parameter setting,
-	 * so it's better to set must need paramter by DDK itself.
-	 */
-	if (!device->dev.dma_mask)
-		device->dev.dma_mask = &device->dev.coherent_dma_mask;
-	device->dev.archdata.dma_ops = dma_ops;
-
-	err = platform_device_add_data(device, &mali_gpu_data, sizeof(mali_gpu_data));
-
-	if (0 == err) {
-#ifdef CONFIG_PM_RUNTIME
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2, 6, 37))
-		pm_runtime_set_autosuspend_delay(&(device->dev), 1000);
-		pm_runtime_use_autosuspend(&(device->dev));
-#endif
-		pm_runtime_enable(&(device->dev));
-#endif
-		MALI_DEBUG_ASSERT(0 < num_pp_cores);
-		mali_core_scaling_init(num_pp_cores);
-	}
-
-#if defined(CONFIG_MALI_DEVFREQ) && defined(CONFIG_DEVFREQ_THERMAL)
-	/* Get thermal zone */
-	gpu_tz = thermal_zone_get_zone_by_name("soc_thermal");
-	if (IS_ERR(gpu_tz)) {
-		MALI_DEBUG_PRINT(2, ("Error getting gpu thermal zone (%ld), not yet ready?\n",
-				     PTR_ERR(gpu_tz)));
-		gpu_tz = NULL;
-
-		err =  -EPROBE_DEFER;
-	}
-#endif
-
-	return err;
-}
-
-int mali_platform_device_deinit(struct platform_device *device)
-{
-	MALI_IGNORE(device);
-
-	MALI_DEBUG_PRINT(4, ("mali_platform_device_deinit() called\n"));
-
-	mali_core_scaling_term();
-#ifdef CONFIG_PM_RUNTIME
-	pm_runtime_disable(&(device->dev));
-#endif
-
-#if defined(CONFIG_ARCH_REALVIEW)
-	mali_write_phys(0xC0010020, 0x9); /* Restore default (legacy) memory mapping */
-#endif
-
-	return 0;
-}
-
-#endif /* CONFIG_MALI_DT */
-
-static u32 mali_read_phys(u32 phys_addr)
-{
-	u32 phys_addr_page = phys_addr & 0xFFFFE000;
-	u32 phys_offset    = phys_addr & 0x00001FFF;
-	u32 map_size       = phys_offset + sizeof(u32);
-	u32 ret = 0xDEADBEEF;
-	void *mem_mapped = ioremap_nocache(phys_addr_page, map_size);
-	if (NULL != mem_mapped) {
-		ret = (u32)ioread32(((u8 *)mem_mapped) + phys_offset);
-		iounmap(mem_mapped);
-	}
-
-	return ret;
-}
-
-#if defined(CONFIG_ARCH_REALVIEW)
-static void mali_write_phys(u32 phys_addr, u32 value)
-{
-	u32 phys_addr_page = phys_addr & 0xFFFFE000;
-	u32 phys_offset    = phys_addr & 0x00001FFF;
-	u32 map_size       = phys_offset + sizeof(u32);
-	void *mem_mapped = ioremap_nocache(phys_addr_page, map_size);
-	if (NULL != mem_mapped) {
-		iowrite32(value, ((u8 *)mem_mapped) + phys_offset);
-		iounmap(mem_mapped);
-	}
-}
-#endif
-
-static int param_set_core_scaling(const char *val, const struct kernel_param *kp)
-{
-	int ret = param_set_int(val, kp);
-
-	if (1 == mali_core_scaling_enable) {
-		mali_core_scaling_sync(mali_executor_get_num_cores_enabled());
-	}
-	return ret;
-}
-
-static struct kernel_param_ops param_ops_core_scaling = {
-	.set = param_set_core_scaling,
-	.get = param_get_int,
-};
-
-module_param_cb(mali_core_scaling_enable, &param_ops_core_scaling, &mali_core_scaling_enable, 0644);
-MODULE_PARM_DESC(mali_core_scaling_enable, "1 means to enable core scaling policy, 0 means to disable core scaling policy");
-
-void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data)
-{
-	if (1 == mali_core_scaling_enable) {
-		mali_core_scaling_update(data);
-	}
-}
diff --git a/drivers/gpu/arm/mali/platform/arm/arm_core_scaling.c b/drivers/gpu/arm/mali/platform/arm/arm_core_scaling.c
deleted file mode 100755
index 37ab2ebf..00000000
--- a/drivers/gpu/arm/mali/platform/arm/arm_core_scaling.c
+++ /dev/null
@@ -1,122 +0,0 @@
-/*
- * Copyright (C) 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-/**
- * @file arm_core_scaling.c
- * Example core scaling policy.
- */
-
-#include "arm_core_scaling.h"
-
-#include <linux/mali/mali_utgard.h>
-#include "mali_kernel_common.h"
-
-#include <linux/workqueue.h>
-
-static int num_cores_total;
-static int num_cores_enabled;
-
-static struct work_struct wq_work;
-
-static void set_num_cores(struct work_struct *work)
-{
-	int err = mali_perf_set_num_pp_cores(num_cores_enabled);
-	MALI_DEBUG_ASSERT(0 == err);
-	MALI_IGNORE(err);
-}
-
-static void enable_one_core(void)
-{
-	if (num_cores_enabled < num_cores_total) {
-		++num_cores_enabled;
-		schedule_work(&wq_work);
-		MALI_DEBUG_PRINT(3, ("Core scaling: Enabling one more core\n"));
-	}
-
-	MALI_DEBUG_ASSERT(1 <= num_cores_enabled);
-	MALI_DEBUG_ASSERT(num_cores_total >= num_cores_enabled);
-}
-
-static void disable_one_core(void)
-{
-	if (1 < num_cores_enabled) {
-		--num_cores_enabled;
-		schedule_work(&wq_work);
-		MALI_DEBUG_PRINT(3, ("Core scaling: Disabling one core\n"));
-	}
-
-	MALI_DEBUG_ASSERT(1 <= num_cores_enabled);
-	MALI_DEBUG_ASSERT(num_cores_total >= num_cores_enabled);
-}
-
-static void enable_max_num_cores(void)
-{
-	if (num_cores_enabled < num_cores_total) {
-		num_cores_enabled = num_cores_total;
-		schedule_work(&wq_work);
-		MALI_DEBUG_PRINT(3, ("Core scaling: Enabling maximum number of cores\n"));
-	}
-
-	MALI_DEBUG_ASSERT(num_cores_total == num_cores_enabled);
-}
-
-void mali_core_scaling_init(int num_pp_cores)
-{
-	INIT_WORK(&wq_work, set_num_cores);
-
-	num_cores_total   = num_pp_cores;
-	num_cores_enabled = num_pp_cores;
-
-	/* NOTE: Mali is not fully initialized at this point. */
-}
-
-void mali_core_scaling_sync(int num_cores)
-{
-	num_cores_enabled = num_cores;
-}
-
-void mali_core_scaling_term(void)
-{
-	flush_scheduled_work();
-}
-
-#define PERCENT_OF(percent, max) ((int) ((percent)*(max)/100.0 + 0.5))
-
-void mali_core_scaling_update(struct mali_gpu_utilization_data *data)
-{
-	/*
-	 * This function implements a very trivial PP core scaling algorithm.
-	 *
-	 * It is _NOT_ of production quality.
-	 * The only intention behind this algorithm is to exercise and test the
-	 * core scaling functionality of the driver.
-	 * It is _NOT_ tuned for neither power saving nor performance!
-	 *
-	 * Other metrics than PP utilization need to be considered as well
-	 * in order to make a good core scaling algorithm.
-	 */
-
-	MALI_DEBUG_PRINT(3, ("Utilization: (%3d, %3d, %3d), cores enabled: %d/%d\n", data->utilization_gpu, data->utilization_gp, data->utilization_pp, num_cores_enabled, num_cores_total));
-
-	/* NOTE: this function is normally called directly from the utilization callback which is in
-	 * timer context. */
-
-	if (PERCENT_OF(90, 256) < data->utilization_pp) {
-		enable_max_num_cores();
-	} else if (PERCENT_OF(50, 256) < data->utilization_pp) {
-		enable_one_core();
-	} else if (PERCENT_OF(40, 256) < data->utilization_pp) {
-		/* do nothing */
-	} else if (PERCENT_OF(0, 256) < data->utilization_pp) {
-		disable_one_core();
-	} else {
-		/* do nothing */
-	}
-}
diff --git a/drivers/gpu/arm/mali/platform/arm/arm_core_scaling.h b/drivers/gpu/arm/mali/platform/arm/arm_core_scaling.h
deleted file mode 100755
index b2ae3835..00000000
--- a/drivers/gpu/arm/mali/platform/arm/arm_core_scaling.h
+++ /dev/null
@@ -1,44 +0,0 @@
-/*
- * Copyright (C) 2013, 2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-/**
- * @file arm_core_scaling.h
- * Example core scaling policy.
- */
-
-#ifndef __ARM_CORE_SCALING_H__
-#define __ARM_CORE_SCALING_H__
-
-struct mali_gpu_utilization_data;
-
-/**
- * Initialize core scaling policy.
- *
- * @note The core scaling policy will assume that all PP cores are on initially.
- *
- * @param num_pp_cores Total number of PP cores.
- */
-void mali_core_scaling_init(int num_pp_cores);
-
-/**
- * Terminate core scaling policy.
- */
-void mali_core_scaling_term(void);
-
-/**
- * Update core scaling policy with new utilization data.
- *
- * @param data Utilization data.
- */
-void mali_core_scaling_update(struct mali_gpu_utilization_data *data);
-
-void mali_core_scaling_sync(int num_cores);
-
-#endif /* __ARM_CORE_SCALING_H__ */
diff --git a/drivers/gpu/arm/mali/platform/arm/juno_opp.c b/drivers/gpu/arm/mali/platform/arm/juno_opp.c
deleted file mode 100755
index 08be4e12..00000000
--- a/drivers/gpu/arm/mali/platform/arm/juno_opp.c
+++ /dev/null
@@ -1,127 +0,0 @@
-/*
- * Copyright (C) 2010, 2012-2016 ARM Limited. All rights reserved.
- * 
- * This program is free software and is provided to you under the terms of the GNU General Public License version 2
- * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
- * A copy of the licence is included with the program, and can also be obtained from Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- */
-
-/**
- * @file juno_opp.c
- * Example: Set up opp table
- * Using ARM64 juno specific SCPI_PROTOCOL get frequence inform
- * Customer need implement your own platform releated logic
- */
-#ifdef CONFIG_ARCH_VEXPRESS
-#ifdef CONFIG_MALI_DEVFREQ
-#ifdef CONFIG_ARM64
-#ifdef CONFIG_ARM_SCPI_PROTOCOL
-#include <linux/module.h>
-#include <linux/of_platform.h>
-#include <linux/platform_device.h>
-#include <linux/scpi_protocol.h>
-#include <linux/version.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 13, 0)
-#include <linux/pm_opp.h>
-#else /* Linux >= 3.13 */
-/* In 3.13 the OPP include header file, types, and functions were all
- * renamed. Use the old filename for the include, and define the new names to
- * the old, when an old kernel is detected.
- */
-#include <linux/opp.h>
-#define dev_pm_opp_add opp_add
-#define dev_pm_opp_remove opp_remove
-#endif /* Linux >= 3.13 */
-
-#include "mali_kernel_common.h"
-
-static int init_juno_opps_from_scpi(struct device *dev)
-{
-	struct scpi_dvfs_info *sinfo;
-	struct scpi_ops *sops;
-
-	int i;
-
-	sops = get_scpi_ops();
-	if (NULL == sops) {
-		MALI_DEBUG_PRINT(2, ("Mali didn't get any scpi ops \n"));
-		return -1;
-	}
-
-	/* Hard coded for Juno. 2 is GPU domain */
-	sinfo = sops->dvfs_get_info(2);
-	if (IS_ERR_OR_NULL(sinfo))
-		return PTR_ERR(sinfo);
-
-	for (i = 0; i < sinfo->count; i++) {
-		struct scpi_opp *e = &sinfo->opps[i];
-
-		MALI_DEBUG_PRINT(2, ("Mali OPP from SCPI: %u Hz @ %u mV\n", e->freq, e->m_volt));
-
-		dev_pm_opp_add(dev, e->freq, e->m_volt * 1000);
-	}
-
-	return 0;
-}
-
-int setup_opps(void)
-{
-	struct device_node *np;
-	struct platform_device *pdev;
-	int err;
-
-	np = of_find_node_by_name(NULL, "gpu");
-	if (!np) {
-		pr_err("Failed to find DT entry for Mali\n");
-		return -EFAULT;
-	}
-
-	pdev = of_find_device_by_node(np);
-	if (!pdev) {
-		pr_err("Failed to find device for Mali\n");
-		of_node_put(np);
-		return -EFAULT;
-	}
-
-	err = init_juno_opps_from_scpi(&pdev->dev);
-
-	of_node_put(np);
-
-	return err;
-}
-
-int term_opps(struct device *dev)
-{
-	struct scpi_dvfs_info *sinfo;
-	struct scpi_ops *sops;
-
-	int i;
-
-	sops = get_scpi_ops();
-	if (NULL == sops) {
-		MALI_DEBUG_PRINT(2, ("Mali didn't get any scpi ops \n"));
-		return -1;
-	}
-
-	/* Hard coded for Juno. 2 is GPU domain */
-	sinfo = sops->dvfs_get_info(2);
-	if (IS_ERR_OR_NULL(sinfo))
-		return PTR_ERR(sinfo);
-
-	for (i = 0; i < sinfo->count; i++) {
-		struct scpi_opp *e = &sinfo->opps[i];
-
-		MALI_DEBUG_PRINT(2, ("Mali Remove OPP: %u Hz \n", e->freq));
-
-		dev_pm_opp_remove(dev, e->freq);
-	}
-
-	return 0;
-
-}
-#endif
-#endif
-#endif
-#endif
diff --git a/drivers/gpu/arm/mali/platform/mali_clock.c b/drivers/gpu/arm/mali/platform/mali_clock.c
index a44db8dd..7b1d5f15 100644
--- a/drivers/gpu/arm/mali/platform/mali_clock.c
+++ b/drivers/gpu/arm/mali/platform/mali_clock.c
@@ -12,7 +12,6 @@
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TVD
 
 #define FCLK_MPLL2 (2 << 9)
-
 static DEFINE_SPINLOCK(lock);
 static mali_plat_info_t* pmali_plat = NULL;
 static u32 mali_extr_backup = 0;
@@ -98,7 +97,11 @@ void enable_clock(void)
 
 u32 get_mali_freq(u32 idx)
 {
+    if (!mali_pm_statue) {
 	return pmali_plat->clk_sample[idx];
+    } else {
+        return 0;
+    }
 }
 
 void set_str_src(u32 data)
diff --git a/drivers/gpu/arm/mali/platform/mali_platform.h b/drivers/gpu/arm/mali/platform/mali_platform.h
index d2cef163..41185d02 100644
--- a/drivers/gpu/arm/mali/platform/mali_platform.h
+++ b/drivers/gpu/arm/mali/platform/mali_platform.h
@@ -9,6 +9,7 @@
 #ifndef MALI_PLATFORM_H_
 #define MALI_PLATFORM_H_
 
-
+extern u32 mali_gp_reset_fail;
+extern u32 mali_core_timeout;
 
 #endif /* MALI_PLATFORM_H_ */
diff --git a/drivers/gpu/arm/mali/platform/mali_pm_device.c b/drivers/gpu/arm/mali/platform/mali_pm_device.c
index 0c33f66f..6d1b700c 100644
--- a/drivers/gpu/arm/mali/platform/mali_pm_device.c
+++ b/drivers/gpu/arm/mali/platform/mali_pm_device.c
@@ -12,6 +12,7 @@
 #include <common/mali_kernel_common.h>
 #include <common/mali_osk_profiling.h>
 #include <common/mali_pmu.h>
+#include <linux/mali/mali_utgard.h>
 
 static int mali_os_suspend(struct device *device)
 {
@@ -28,6 +29,7 @@ static int mali_os_resume(struct device *device)
 	int ret = 0;
 
 	MALI_DEBUG_PRINT(4, ("mali_os_resume() called\n"));
+
 	ret = mali_deep_resume(device);
 
 	return ret;
@@ -49,12 +51,34 @@ static int mali_os_freeze(struct device *device)
 
 	return ret;
 }
+//copy from r4p1 linux/mali_pmu_power_up_down.c
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+static int mali_pmu_powerup(void)
+{
+	struct mali_pmu_core *pmu = mali_pmu_get_global_pmu_core();
+
+	MALI_DEBUG_PRINT(5, ("Mali PMU: Power up\n"));
+
+	MALI_DEBUG_ASSERT_POINTER(pmu);
+	if (NULL == pmu) {
+		return -ENXIO;
+	}
+
+	mali_pmu_power_up_all(pmu);
+
+	return 0;
+}
+#endif
 
 static int mali_os_thaw(struct device *device)
 {
 	int ret = 0;
 
 	MALI_DEBUG_PRINT(4, ("mali_os_thaw() called\n"));
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	enable_clock();
+	mali_pmu_powerup();
+#endif
 
 	if (NULL != device->driver &&
 	    NULL != device->driver->pm &&
@@ -67,7 +91,17 @@ static int mali_os_thaw(struct device *device)
 	return ret;
 }
 
+static int mali_os_restore(struct device *device)
+{
+	MALI_DEBUG_PRINT(4, ("mali_os_thaw() called\n"));
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	mali_dev_restore();
+#endif
+	return mali_os_resume(device);
+}
+
 #ifdef CONFIG_PM_RUNTIME
+#if 0
 static int mali_runtime_suspend(struct device *device)
 {
 	int ret = 0;
@@ -109,6 +143,7 @@ static int mali_runtime_idle(struct device *device)
 	return 0;
 }
 #endif
+#endif
 
 static struct dev_pm_ops mali_gpu_device_type_pm_ops =
 {
@@ -116,7 +151,8 @@ static struct dev_pm_ops mali_gpu_device_type_pm_ops =
 	.resume = mali_os_resume,
 	.freeze = mali_os_freeze,
 	.thaw = mali_os_thaw,
-#ifdef CONFIG_PM_RUNTIME
+	.restore = mali_os_restore,
+#if 0//def CONFIG_PM_RUNTIME
 	.runtime_suspend = mali_runtime_suspend,
 	.runtime_resume = mali_runtime_resume,
 	.runtime_idle = mali_runtime_idle,
diff --git a/drivers/gpu/arm/mali/platform/mali_scaling.h b/drivers/gpu/arm/mali/platform/mali_scaling.h
index fbf759da..6421d544 100644
--- a/drivers/gpu/arm/mali/platform/mali_scaling.h
+++ b/drivers/gpu/arm/mali/platform/mali_scaling.h
@@ -1,9 +1,9 @@
 /*
  * Copyright (C) 2013 ARM Limited. All rights reserved.
- * 
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -106,6 +106,7 @@ void set_mali_schel_mode(u32 mode);
 
 /* for frequency reporter in DS-5 streamline. */
 u32 get_current_frequency(void);
+void mali_dev_restore(void);
 
 extern int mali_pm_statue;
 #endif /* __ARM_CORE_SCALING_H__ */
diff --git a/drivers/gpu/arm/mali/platform/meson_m400/mali_fix.c b/drivers/gpu/arm/mali/platform/meson_m400/mali_fix.c
new file mode 100644
index 00000000..121ada7f
--- /dev/null
+++ b/drivers/gpu/arm/mali/platform/meson_m400/mali_fix.c
@@ -0,0 +1,185 @@
+/*
+ * AMLOGIC Mali fix driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/timer.h>
+#include <asm/io.h>
+#include <linux/ioport.h>
+#include <linux/dma-mapping.h>
+
+#include <linux/module.h>
+
+#include <mach/am_regs.h>
+#include <mach/clock.h>
+#include <linux/io.h>
+#include <mach/io.h>
+#include <plat/io.h>
+#include <asm/io.h>
+
+#include "mali_kernel_common.h"
+#include "mali_osk.h"
+#include "mali_platform.h"
+#include "mali_fix.h"
+
+#define MALI_MM1_REG_ADDR 0xd0064000
+#define MALI_MMU_REGISTER_INT_STATUS     0x0008
+#define MALI_MM2_REG_ADDR 0xd0065000
+#define MALI_MMU_REGISTER_INT_STATUS     0x0008
+#define MALI_MM_REG_SIZE 0x1000
+
+#define READ_MALI_MMU1_REG(r) (ioread32(((u8*)mali_mm1_regs) + r))
+#define READ_MALI_MMU2_REG(r) (ioread32(((u8*)mali_mm2_regs) + r))
+
+extern int mali_PP0_int_cnt(void);
+extern int mali_PP1_int_cnt(void);
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+static ulong * mali_mm1_regs = NULL;
+static ulong * mali_mm2_regs = NULL;
+static struct timer_list timer;
+
+static u32 mali_pp1_int_count = 0;
+static u32 mali_pp2_int_count = 0;
+static u32 mali_pp1_mmu_int_count = 0;
+static u32 mali_pp2_mmu_int_count = 0;
+static u32 mali_mmu_int_process_state[2];
+
+static void timer_callback(ulong data)
+{
+	unsigned long mali_flags;
+
+	mali_pp1_int_count = mali_PP0_int_cnt();
+	mali_pp2_int_count = mali_PP1_int_cnt();
+
+	/* lock mali_clock_gating when access Mali registers */
+	mali_flags = mali_clock_gating_lock();
+
+	if (readl((u32 *)P_HHI_MALI_CLK_CNTL) & 0x100) {
+		/* polling for PP1 MMU interrupt */
+		if (mali_mmu_int_process_state[0] == MMU_INT_NONE) {
+			if (READ_MALI_MMU1_REG(MALI_MMU_REGISTER_INT_STATUS) != 0) {
+				mali_pp1_mmu_int_count++;
+				MALI_DEBUG_PRINT(3, ("Mali MMU: core0 page fault emit \n"));
+				mali_mmu_int_process_state[0] = MMU_INT_HIT;
+				__raw_writel(1, (volatile void *)P_ISA_TIMERC);
+			}
+		}
+
+		/* polling for PP2 MMU interrupt */
+		if (mali_mmu_int_process_state[1] == MMU_INT_NONE) {
+			if (READ_MALI_MMU2_REG(MALI_MMU_REGISTER_INT_STATUS) != 0) {
+				mali_pp2_mmu_int_count++;
+				MALI_DEBUG_PRINT(3, ("Mali MMU: core1 page fault emit \n"));
+				mali_mmu_int_process_state[1] = MMU_INT_HIT;
+				__raw_writel(1, (volatile void *)P_ISA_TIMERC);
+			}
+		}
+	}
+
+	mali_clock_gating_unlock(mali_flags);
+
+	timer.expires = jiffies + HZ/100;
+
+	add_timer(&timer);
+}
+
+void malifix_set_mmu_int_process_state(int index, int state)
+{
+	if (index < 2)
+		mali_mmu_int_process_state[index] = state;
+}
+
+int malifix_get_mmu_int_process_state(int index)
+{
+	if (index < 2)
+		return mali_mmu_int_process_state[index];
+	return 0;
+}
+#endif
+
+void malifix_init(void)
+{
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+	if (!mali_meson_is_revb())
+		return;
+
+	if ((mali_mm1_regs) && (mali_mm2_regs)) return;
+	mali_mmu_int_process_state[0] = 0;
+	mali_mmu_int_process_state[1] = 0;
+
+	/* set up Timer C as a 1uS one-shot timer */
+	aml_clr_reg32_mask(P_ISA_TIMER_MUX, (1<<18)|(1<<14)|(3<<4));
+	aml_set_reg32_mask(P_ISA_TIMER_MUX,	(1<<18)|(0<<14)|(0<<4));
+
+	setup_timer(&timer, timer_callback, 0);
+
+	mali_mm1_regs = (ulong *)ioremap_nocache(MALI_MM1_REG_ADDR, MALI_MM_REG_SIZE);
+	if (mali_mm1_regs)
+		printk("Mali pp1 MMU register mapped at %p...\n", mali_mm1_regs);
+
+	mali_mm2_regs = (ulong *)ioremap_nocache(MALI_MM2_REG_ADDR, MALI_MM_REG_SIZE);
+	if (mali_mm2_regs)
+		printk("Mali pp2 MMU register mapped at %p...\n", mali_mm2_regs);
+
+	if ((mali_mm1_regs != NULL) && (mali_mm2_regs != NULL))
+		mod_timer(&timer, jiffies + HZ/100);
+#endif
+}
+
+void malifix_exit(void)
+{
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+	if (!mali_meson_is_revb())
+		return;
+
+	del_timer(&timer);
+
+	if (mali_mm1_regs != NULL)
+		iounmap(mali_mm1_regs);
+	mali_mm1_regs = NULL;
+
+	if (mali_mm2_regs != NULL)
+		iounmap(mali_mm2_regs);
+	mali_mm2_regs = NULL;
+
+#endif
+	return;
+}
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+module_param(mali_pp1_int_count, uint, 0664);
+MODULE_PARM_DESC(mali_pp1_int_count, "Mali PP1 interrupt count\n");
+
+module_param(mali_pp2_int_count, uint, 0664);
+MODULE_PARM_DESC(mali_pp2_int_count, "Mali PP1 interrupt count\n");
+
+module_param(mali_pp1_mmu_int_count, uint, 0664);
+MODULE_PARM_DESC(mali_pp1_mmu_int_count, "Mali PP1 mmu interrupt count\n");
+
+module_param(mali_pp2_mmu_int_count, uint, 0664);
+MODULE_PARM_DESC(mali_pp2_mmu_int_count, "Mali PP2 mmu interrupt count\n");
+#endif
+
+MODULE_DESCRIPTION("AMLOGIC mali fix driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Tim Yao <timyao@amlogic.com>");
diff --git a/drivers/gpu/arm/mali/platform/meson_m400/mali_fix.h b/drivers/gpu/arm/mali/platform/meson_m400/mali_fix.h
new file mode 100644
index 00000000..3c291613
--- /dev/null
+++ b/drivers/gpu/arm/mali/platform/meson_m400/mali_fix.h
@@ -0,0 +1,14 @@
+#ifndef MALI_FIX_H
+#define MALI_FIX_H
+
+#define MMU_INT_NONE 0
+#define MMU_INT_HIT  1
+#define MMU_INT_TOP  2
+#define MMU_INT_BOT  3
+
+extern void malifix_init(void);
+extern void malifix_exit(void);
+extern void malifix_set_mmu_int_process_state(int, int);
+extern int  malifix_get_mmu_int_process_state(int);
+extern int mali_meson_is_revb(void);
+#endif /* MALI_FIX_H */
diff --git a/drivers/gpu/arm/mali/platform/meson_m400/mali_platform.c b/drivers/gpu/arm/mali/platform/meson_m400/mali_platform.c
new file mode 100644
index 00000000..f764a3a3
--- /dev/null
+++ b/drivers/gpu/arm/mali/platform/meson_m400/mali_platform.c
@@ -0,0 +1,311 @@
+/*
+ * This confidential and proprietary software may be used only as
+ * authorised by a licensing agreement from AMLOGIC, INC.
+ * (C) COPYRIGHT 2011 AMLOGIC, INC.
+ * ALL RIGHTS RESERVED
+ * The entire notice above must be reproduced on all authorised
+ * copies and copies may only be made to the extent permitted
+ * by a licensing agreement from AMLOGIC, INC.
+ */
+
+/**
+ * @file mali_platform.c
+ * Platform specific Mali driver functions for meson platform
+ */
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/dma-mapping.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <linux/delay.h>
+#include <linux/clk.h>
+#include <mach/am_regs.h>
+#include <mach/clock.h>
+
+#include "mali_kernel_common.h"
+#include "mali_osk.h"
+#include "mali_platform.h"
+#include "mali_poweron_reg.h"
+#include "mali_fix.h"
+#include "mali_platform.h"
+
+static int last_power_mode = -1;
+static int mali_init_flag = 0;
+static const u32 poweron_data[] =
+{
+/* commands */
+/* 000 */ 0x00000040, 0x20400000, 0x00000300, 0x30040000,
+/* 010 */ 0x00000400, 0x400a0000, 0x0f000033, 0x10000042,
+/* 020 */ 0x00300c00, 0x10000040, 0x4c000001, 0x00000000,
+/* 030 */ 0x00000000, 0x60000000, 0x00000000, 0x00000000,
+/* 040 */ 0x00004000, 0x00002000, 0x00000210, 0x0000203f,
+/* 050 */ 0x00000220, 0x0000203f, 0x00000230, 0x0000203f,
+/* 060 */ 0x00000240, 0x0000203f, 0x00000250, 0x0000203f,
+/* 070 */ 0x00000260, 0x0000203f, 0x00000270, 0x0000203f,
+/* 080 */ 0x00000280, 0x0000203f, 0x00000290, 0x0000203f,
+/* 090 */ 0x000002a0, 0x0000203f, 0x000002b0, 0x0000203f,
+/* 0a0 */ 0x000002c0, 0x0000203f, 0x000002d0, 0x0000203f,
+/* 0b0 */ 0x000002e0, 0x0000203f, 0x000002f0, 0x0000203f,
+/* 0c0 */ 0x00002000, 0x00002000, 0x00002010, 0x0000203f,
+/* 0d0 */ 0x00002020, 0x0000203f, 0x00002030, 0x0000203f,
+/* 0e0 */ 0x00002040, 0x0000203f, 0x00002050, 0x0000203f,
+/* 0f0 */ 0x00002060, 0x0000203f, 0x00002070, 0x0000203f,
+/* 100 */ 0x00002080, 0x0000203f, 0x00002090, 0x0000203f,
+/* 110 */ 0x000020a0, 0x0000203f, 0x000020b0, 0x0000203f,
+/* 120 */ 0x000020c0, 0x0000203f, 0x000020d0, 0x0000203f,
+/* 130 */ 0x000020e0, 0x0000203f, 0x000020f0, 0x0000203f,
+/* 140 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 150 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 160 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 170 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 180 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 190 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 1a0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 1b0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 1c0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 1d0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 1e0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 1f0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 200 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 210 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 220 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 230 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 240 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 250 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 260 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 270 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 280 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 290 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 2a0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 2b0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 2c0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 2d0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 2e0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 2f0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* const */
+/* 300 */ 0x3f2a6400, 0xbf317600, 0x3e8d8e00, 0x00000000,
+/* 310 */ 0x3f2f7000, 0x3f36e200, 0x3e10c500, 0x00000000,
+/* 320 */ 0xbe974e00, 0x3dc35300, 0x3f735800, 0x00000000,
+/* 330 */ 0x00000000, 0x00000000, 0x00000000, 0x3f800000,
+/* 340 */ 0x42b00000, 0x42dc0000, 0x3f800000, 0x3f800000,
+/* 350 */ 0x42b00000, 0x42dc0000, 0x00000000, 0x00000000,
+/* 360 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 370 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 380 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 390 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 3a0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 3b0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 3c0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 3d0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 3e0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* 3f0 */ 0x00000000, 0x00000000, 0x00000000, 0x00000000,
+/* inst */
+/* 400 */ 0xad4ad6b5, 0x438002b5, 0x0007ffe0, 0x00001e00,
+/* 410 */ 0xad4ad694, 0x038002b5, 0x0087ffe0, 0x00005030,
+/* 420 */ 0xad4bda56, 0x038002b5, 0x0007ffe0, 0x00001c10,
+/* 430 */ 0xad4ad6b5, 0x038002b5, 0x4007fee0, 0x00001c00
+};
+
+static struct clk *mali_clk = NULL;
+
+#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6
+
+#define OFFSET_MMU_DTE          0
+#define OFFSET_MMU_PTE          4096
+#define OFFSET_MMU_VIRTUAL_ZERO 8192
+
+#define INT_MALI_GP_BITS     (1<<16)
+#define INT_MALI_PP_BITS     (1<<18)
+#define INT_MALI_PP_MMU_BITS (1<<19)
+#define INT_ALL              (0xffffffff)
+
+#define INT_MALI_PP_MMU_PAGE_FAULT (1<<0)
+
+#define MMU_FLAG_DTE_PRESENT            0x01
+#define MMU_FLAG_PTE_PAGE_PRESENT       0x01
+#define MMU_FLAG_PTE_RD_PERMISSION      0x02
+#define MMU_FLAG_PTE_WR_PERMISSION      0x04
+
+//static int mali_revb_flag = -1;
+static DEFINE_SPINLOCK(lock);
+extern int mali_revb_flag;
+int mali_meson_is_revb(void)
+{
+	printk("mail version=%d\n",mali_revb_flag);
+	if (mali_revb_flag == -1)
+		mali_revb_flag = 1;
+	else if (mali_revb_flag == 0)
+	    panic("rev-a! you should neet earlier version of mali_driver.!\n");
+
+    return mali_revb_flag;
+}
+
+static void mali_meson_poweron(int first_poweron)
+{
+	unsigned long flags;
+	u32 p, p_aligned;
+	dma_addr_t p_phy;
+	int i;
+	unsigned int_mask;
+
+	if(!first_poweron) {
+		if ((last_power_mode != -1) && (last_power_mode != MALI_POWER_MODE_DEEP_SLEEP)) {
+			 MALI_DEBUG_PRINT(3, ("Maybe your system not deep sleep now.......\n"));
+			//printk("Maybe your system not deep sleep now.......\n");
+			return;
+		}
+	}
+
+	MALI_DEBUG_PRINT(2, ("mali_meson_poweron: Mali APB bus accessing\n"));
+	if (READ_MALI_REG(MALI_PP_PP_VERSION) != MALI_PP_PP_VERSION_MAGIC) {
+	MALI_DEBUG_PRINT(3, ("mali_meson_poweron: Mali APB bus access failed\n"));
+	//printk("mali_meson_poweron: Mali APB bus access failed.");
+	return;
+	}
+	MALI_DEBUG_PRINT(2, ("..........accessing done.\n"));
+	if (READ_MALI_REG(MALI_MMU_DTE_ADDR) != 0) {
+		MALI_DEBUG_PRINT(3, ("mali_meson_poweron: Mali is not really powered off\n"));
+		//printk("mali_meson_poweron: Mali is not really powered off.");
+		return;
+	}
+
+	p = (u32)kcalloc(4096 * 4, 1, GFP_KERNEL);
+	if (!p) {
+		printk("mali_meson_poweron: NOMEM in meson_poweron\n");
+		return;
+	}
+
+	p_aligned = __ALIGN_MASK(p, 4096);
+
+	/* DTE */
+	*(u32 *)(p_aligned) = (virt_to_phys((void *)p_aligned) + OFFSET_MMU_PTE) | MMU_FLAG_DTE_PRESENT;
+	/* PTE */
+	for (i=0; i<1024; i++) {
+		*(u32 *)(p_aligned + OFFSET_MMU_PTE + i*4) =
+		    (virt_to_phys((void *)p_aligned) + OFFSET_MMU_VIRTUAL_ZERO + 4096 * i) |
+		    MMU_FLAG_PTE_PAGE_PRESENT |
+		    MMU_FLAG_PTE_RD_PERMISSION;
+	}
+
+	/* command & data */
+	memcpy((void *)(p_aligned + OFFSET_MMU_VIRTUAL_ZERO), poweron_data, 4096);
+
+	p_phy = dma_map_single(NULL, (void *)p_aligned, 4096 * 3, DMA_TO_DEVICE);
+
+	/* Set up Mali GP MMU */
+	WRITE_MALI_REG(MALI_MMU_DTE_ADDR, p_phy);
+	WRITE_MALI_REG(MALI_MMU_CMD, 0);
+
+	if ((READ_MALI_REG(MALI_MMU_STATUS) & 1) != 1)
+		printk("mali_meson_poweron: MMU enabling failed.\n");
+
+	/* Set up Mali command registers */
+	WRITE_MALI_REG(MALI_APB_GP_VSCL_START, 0);
+	WRITE_MALI_REG(MALI_APB_GP_VSCL_END, 0x38);
+
+	spin_lock_irqsave(&lock, flags);
+
+	int_mask = READ_MALI_REG(MALI_APB_GP_INT_MASK);
+	WRITE_MALI_REG(MALI_APB_GP_INT_CLEAR, 0x707bff);
+	WRITE_MALI_REG(MALI_APB_GP_INT_MASK, 0);
+
+	/* Start GP */
+	WRITE_MALI_REG(MALI_APB_GP_CMD, 1);
+
+	for (i = 0; i<100; i++)
+		udelay(500);
+
+	/* check Mali GP interrupt */
+	if (READ_MALI_REG(MALI_APB_GP_INT_RAWSTAT) & 0x707bff)
+		printk("mali_meson_poweron: Interrupt received.\n");
+	else
+		printk("mali_meson_poweron: No interrupt received.\n");
+
+	/* force reset GP */
+	WRITE_MALI_REG(MALI_APB_GP_CMD, 1 << 5);
+
+	/* stop MMU paging and reset */
+	WRITE_MALI_REG(MALI_MMU_CMD, 1);
+	WRITE_MALI_REG(MALI_MMU_CMD, 6);
+
+	for (i = 0; i<100; i++)
+		udelay(500);
+
+	WRITE_MALI_REG(MALI_APB_GP_INT_CLEAR, 0x3ff);
+	WRITE_MALI_REG(MALI_MMU_INT_CLEAR, INT_ALL);
+	WRITE_MALI_REG(MALI_MMU_INT_MASK, 0);
+
+	WRITE_MALI_REG(MALI_APB_GP_INT_CLEAR, 0x707bff);
+	WRITE_MALI_REG(MALI_APB_GP_INT_MASK, int_mask);
+
+	spin_unlock_irqrestore(&lock, flags);
+
+	dma_unmap_single(NULL, p_phy, 4096 * 3, DMA_TO_DEVICE);
+
+	kfree((void *)p);
+
+	/* Mali revision detection */
+	if (last_power_mode == -1)
+		mali_revb_flag = mali_meson_is_revb();
+}
+#else
+static void mali_meson_poweron(int first_poweron) {
+	return;
+}
+#endif /*MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6 */
+
+_mali_osk_errcode_t mali_platform_init(void)
+{
+	mali_clk = clk_get_sys("mali", "pll_fixed");
+
+	if (mali_clk ) {
+		if (!mali_init_flag) {
+			clk_set_rate(mali_clk, 333000000);
+			mali_clk->enable(mali_clk);
+			malifix_init();
+			mali_meson_poweron(1);
+			mali_init_flag = 1;
+		}
+		MALI_SUCCESS;
+	} else
+		panic("linux kernel should > 3.0\n");
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+    MALI_PRINT_ERROR(("Failed to lookup mali clock"));
+	MALI_ERROR(_MALI_OSK_ERR_FAULT);
+#else
+	MALI_SUCCESS;
+#endif /* CONFIG_ARCH_MESON6 */
+}
+
+_mali_osk_errcode_t mali_platform_deinit(void)
+{
+	mali_init_flag =0;
+	printk("MALI:mali_platform_deinit\n");
+	malifix_exit();
+
+	MALI_SUCCESS;
+}
+
+_mali_osk_errcode_t mali_platform_power_mode_change(mali_power_mode power_mode)
+{
+	MALI_DEBUG_PRINT(3, ( "mali_platform_power_mode_change power_mode=%d\n", power_mode));
+
+	switch (power_mode) {
+	case MALI_POWER_MODE_LIGHT_SLEEP:
+	case MALI_POWER_MODE_DEEP_SLEEP:
+		/* Turn off mali clock gating */
+		mali_clk->disable(mali_clk);
+		break;
+
+        case MALI_POWER_MODE_ON:
+		/* Turn on MALI clock gating */
+		mali_clk->enable(mali_clk);
+		mali_meson_poweron(0);
+		break;
+	}
+	last_power_mode = power_mode;
+	MALI_SUCCESS;
+}
+
diff --git a/drivers/gpu/arm/mali/platform/meson_m400/mali_platform.h b/drivers/gpu/arm/mali/platform/meson_m400/mali_platform.h
new file mode 100644
index 00000000..63f61187
--- /dev/null
+++ b/drivers/gpu/arm/mali/platform/meson_m400/mali_platform.h
@@ -0,0 +1,73 @@
+/*
+ * Copyright (C) 2010-2012 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained from Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/**
+ * @file mali_platform.h
+ * Platform specific Mali driver functions
+ */
+
+#ifndef __MALI_PLATFORM_H__
+#define __MALI_PLATFORM_H__
+
+#include "mali_osk.h"
+
+/** @brief description of power change reasons
+ */
+typedef enum mali_power_mode_tag
+{
+	MALI_POWER_MODE_ON,           /**< Power Mali on */
+	MALI_POWER_MODE_LIGHT_SLEEP,  /**< Mali has been idle for a short time, or runtime PM suspend */
+	MALI_POWER_MODE_DEEP_SLEEP,   /**< Mali has been idle for a long time, or OS suspend */
+} mali_power_mode;
+
+/** @brief Platform specific setup and initialisation of MALI
+ *
+ * This is called from the entrypoint of the driver to initialize the platform
+ *
+ * @return _MALI_OSK_ERR_OK on success otherwise, a suitable _mali_osk_errcode_t error.
+ */
+_mali_osk_errcode_t mali_platform_init(void);
+
+/** @brief Platform specific deinitialisation of MALI
+ *
+ * This is called on the exit of the driver to terminate the platform
+ *
+ * @return _MALI_OSK_ERR_OK on success otherwise, a suitable _mali_osk_errcode_t error.
+ */
+_mali_osk_errcode_t mali_platform_deinit(void);
+
+/** @brief Platform specific powerdown sequence of MALI
+ *
+ * Notification from the Mali device driver stating the new desired power mode.
+ * MALI_POWER_MODE_ON must be obeyed, while the other modes are optional.
+ * @param power_mode defines the power modes
+ * @return _MALI_OSK_ERR_OK on success otherwise, a suitable _mali_osk_errcode_t error.
+ */
+_mali_osk_errcode_t mali_platform_power_mode_change(mali_power_mode power_mode);
+
+
+/** @brief Platform specific handling of GPU utilization data
+ *
+ * When GPU utilization data is enabled, this function will be
+ * periodically called.
+ *
+ * @param utilization The workload utilization of the Mali GPU. 0 = no utilization, 256 = full utilization.
+ */
+void mali_gpu_utilization_handler(u32 utilization);
+
+/** @brief Setting the power domain of MALI
+ *
+ * This function sets the power domain of MALI if Linux run time power management is enabled
+ *
+ * @param dev Reference to struct platform_device (defined in linux) used by MALI GPU
+ */
+void set_mali_parent_power_domain(void* dev);
+
+#endif
diff --git a/drivers/gpu/arm/mali/platform/meson_m400/mali_poweron_reg.h b/drivers/gpu/arm/mali/platform/meson_m400/mali_poweron_reg.h
new file mode 100644
index 00000000..aeadd9fc
--- /dev/null
+++ b/drivers/gpu/arm/mali/platform/meson_m400/mali_poweron_reg.h
@@ -0,0 +1,68 @@
+/*
+ * This confidential and proprietary software may be used only as
+ * authorised by a licensing agreement from AMLOGIC, INC.
+ * (C) COPYRIGHT 2011 AMLOGIC, INC.
+ * ALL RIGHTS RESERVED
+ * The entire notice above must be reproduced on all authorised
+ * copies and copies may only be made to the extent permitted
+ * by a licensing agreement from AMLOGIC, INC.
+ */
+
+#ifndef MALI_POWERON_REG_H
+#define MALI_POWERON_REG_H
+
+#define MALI_PP_PP_VERSION_MAGIC      0xCD070100UL
+
+#if defined(IO_APB2_BUS_PHY_BASE)
+#define WRITE_MALI_REG(reg, val) \
+    __raw_writel(val, (volatile void *)(reg - IO_APB2_BUS_PHY_BASE + IO_APB2_BUS_BASE))
+#define READ_MALI_REG(reg) \
+    __raw_readl((volatile void *)(reg - IO_APB2_BUS_PHY_BASE + IO_APB2_BUS_BASE))
+#else
+#define WRITE_MALI_REG(reg, val) \
+    __raw_writel(val, (volatile void *)(reg - IO_APB_BUS_PHY_BASE + IO_APB_BUS_BASE))
+#define READ_MALI_REG(reg) \
+    __raw_readl((volatile void *)(reg - IO_APB_BUS_PHY_BASE + IO_APB_BUS_BASE))
+#endif
+
+#define MALI_APB_GP_VSCL_START        0xd0060000
+#define MALI_APB_GP_VSCL_END          0xd0060004
+#define MALI_APB_GP_CMD               0xd0060020
+#define MALI_APB_GP_INT_RAWSTAT       0xd0060024
+#define MALI_APB_GP_INT_CLEAR         0xd0060028
+#define MALI_APB_GP_INT_MASK          0xd006002c
+#define MALI_APB_GP_INT_STAT          0xd0060030
+
+#define MALI_MMU_DTE_ADDR             0xd0063000
+#define MALI_MMU_STATUS               0xd0063004
+#define MALI_MMU_CMD                  0xd0063008
+#define MALI_MMU_RAW_STATUS           0xd0064014
+#define MALI_MMU_INT_CLEAR            0xd0064018
+#define MALI_MMU_INT_MASK             0xd006401c
+#define MALI_MMU_INT_STATUS           0xd0064020
+
+#define MALI_PP_MMU_DTE_ADDR          0xd0064000
+#define MALI_PP_MMU_STATUS            0xd0064004
+#define MALI_PP_MMU_CMD               0xd0064008
+#define MALI_PP_MMU_RAW_STATUS        0xd0064014
+#define MALI_PP_MMU_INT_CLEAR         0xd0064018
+#define MALI_PP_MMU_INT_MASK          0xd006401c
+#define MALI_PP_MMU_INT_STATUS        0xd0064020
+
+#define MALI_APB_PP_REND_LIST_ADDR    0xd0068000
+#define MALI_APB_PP_REND_RSW_BASE     0xd0068004
+#define MALI_APB_PP_REND_VERTEX_BASE  0xd0068008
+#define MALI_APB_PPSUBPIXEL_SPECIFIER 0xd0068048
+#define MALI_APB_WB0_SOURCE_SELECT    0xd0068100
+#define MALI_APB_WB0_TARGET_ADDR      0xd0068104
+#define MALI_APB_WB0_TARGET_SCANLINE_LENGTH 0xd0068114
+
+#define MALI_PP_PP_VERSION            0xd0069000
+#define MALI_PP_STATUS                0xd0069008
+#define MALI_PP_CTRL_MGMT             0xd006900C
+#define MALI_PP_INT_RAWSTAT           0xd0069020
+#define MALI_PP_INT_CLEAR             0xd0069024
+#define MALI_PP_INT_MASK              0xd0069028
+#define MALI_PP_INT_STAT              0xd006902C
+
+#endif /* MALI_POWERON_REG_H */
diff --git a/drivers/gpu/arm/mali/platform/meson_m400/platform_mx.c b/drivers/gpu/arm/mali/platform/meson_m400/platform_mx.c
new file mode 100644
index 00000000..bd24a278
--- /dev/null
+++ b/drivers/gpu/arm/mali/platform/meson_m400/platform_mx.c
@@ -0,0 +1,235 @@
+/*
+ * platform.c
+ *
+ * clock source setting and resource config
+ *
+ *  Created on: Dec 4, 2013
+ *      Author: amlogic
+ */
+
+#include <linux/platform_device.h>
+#include <linux/version.h>
+#include <linux/pm.h>
+#include <linux/of.h>
+#include <linux/module.h>
+#include <linux/ioport.h>
+#include <linux/slab.h>
+#include <mach/register.h>
+#include <mach/irqs.h>
+#include <mach/io.h>
+#include <asm/io.h>
+#include <linux/mali/mali_utgard.h>
+
+#include <common/mali_kernel_common.h>
+#include <common/mali_osk_profiling.h>
+#include <common/mali_pmu.h>
+
+#include "meson_main.h"
+#include "mali_fix.h"
+#include "mali_platform.h"
+
+/**
+ *    For Meson 6tvd.
+ *
+ */
+
+#if MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6TV
+
+u32 mali_dvfs_clk[1];
+u32 mali_dvfs_clk_sample[1];
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TV
+#undef INT_MALI_GP
+#undef INT_MALI_GP_MMU
+#undef INT_MALI_PP
+#undef INT_MALI_PP2
+#undef INT_MALI_PP3
+#undef INT_MALI_PP4
+#undef INT_MALI_PP_MMU
+#undef INT_MALI_PP2_MMU
+#undef INT_MALI_PP3_MMU
+#undef INT_MALI_PP4_MMU
+
+#define INT_MALI_GP      (48+32)
+#define INT_MALI_GP_MMU  (49+32)
+#define INT_MALI_PP      (50+32)
+#define INT_MALI_PP2     (58+32)
+#define INT_MALI_PP3     (60+32)
+#define INT_MALI_PP4     (62+32)
+#define INT_MALI_PP_MMU  (51+32)
+#define INT_MALI_PP2_MMU (59+32)
+#define INT_MALI_PP3_MMU (61+32)
+#define INT_MALI_PP4_MMU (63+32)
+
+#ifndef CONFIG_MALI400_4_PP
+static struct resource meson_mali_resources[] =
+{
+	MALI_GPU_RESOURCES_MALI400_MP2(0xd0060000,
+			INT_MALI_GP, INT_MALI_GP_MMU,
+			INT_MALI_PP, INT_MALI_PP_MMU,
+			INT_MALI_PP2, INT_MALI_PP2_MMU)
+};
+#else
+static struct resource meson_mali_resources[] =
+{
+	MALI_GPU_RESOURCES_MALI400_MP4(0xd0060000,
+			INT_MALI_GP, INT_MALI_GP_MMU,
+			INT_MALI_PP, INT_MALI_PP_MMU,
+			INT_MALI_PP2, INT_MALI_PP2_MMU,
+			INT_MALI_PP3, INT_MALI_PP3_MMU,
+			INT_MALI_PP4, INT_MALI_PP4_MMU
+			)
+};
+#endif
+
+#elif MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+
+#undef INT_MALI_GP
+#undef INT_MALI_GP_MMU
+#undef INT_MALI_PP
+#undef INT_MALI_PP2
+#undef INT_MALI_PP_MMU
+#undef INT_MALI_PP2_MMU
+
+#define INT_MALI_GP      (48+32)
+#define INT_MALI_GP_MMU  (49+32)
+#define INT_MALI_PP      (50+32)
+#define INT_MALI_PP_MMU  (51+32)
+#define INT_MALI_PP2_MMU ( 6+32)
+
+static struct resource meson_mali_resources[] =
+{
+	MALI_GPU_RESOURCES_MALI400_MP2(0xd0060000,
+			INT_MALI_GP, INT_MALI_GP_MMU,
+			INT_MALI_PP, INT_MALI_PP2_MMU,
+			INT_MALI_PP_MMU, INT_MALI_PP2_MMU)
+};
+
+#else  /* MESON_CPU_TYPE == MESON_CPU_TYPE_MESON3 */
+
+#undef INT_MALI_GP
+#undef INT_MALI_GP_MMU
+#undef INT_MALI_PP
+#undef INT_MALI_PP_MMU
+
+#define INT_MALI_GP	48
+#define INT_MALI_GP_MMU 49
+#define INT_MALI_PP	50
+#define INT_MALI_PP_MMU 51
+
+static struct resource meson_mali_resources[] =
+{
+	MALI_GPU_RESOURCES_MALI400_MP1(0xd0060000,
+			INT_MALI_GP, INT_MALI_GP_MMU, INT_MALI_PP, INT_MALI_PP_MMU)
+};
+#endif /* MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6TV */
+
+void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data)
+{
+
+}
+
+mali_plat_info_t mali_plat_data = {
+
+};
+
+int mali_meson_init_start(struct platform_device* ptr_plt_dev)
+{
+	/* for mali platform data. */
+	struct mali_gpu_device_data* pdev = ptr_plt_dev->dev.platform_data;
+
+	pdev->control_interval = 1000;
+	pdev->utilization_callback = mali_gpu_utilization_callback;
+
+	/* for resource data. */
+	ptr_plt_dev->num_resources = ARRAY_SIZE(meson_mali_resources);
+	ptr_plt_dev->resource = meson_mali_resources;
+	return 0;
+}
+
+int mali_meson_init_finish(struct platform_device* ptr_plt_dev)
+{
+	mali_platform_init();
+	return 0;
+}
+
+int mali_meson_uninit(struct platform_device* ptr_plt_dev)
+{
+	mali_platform_deinit();
+	return 0;
+}
+
+int mali_light_suspend(struct device *device)
+{
+	int ret = 0;
+
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->runtime_suspend)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->runtime_suspend(device);
+	}
+
+	mali_platform_power_mode_change(MALI_POWER_MODE_LIGHT_SLEEP);
+	return ret;
+}
+
+int mali_light_resume(struct device *device)
+{
+	int ret = 0;
+
+	mali_platform_power_mode_change(MALI_POWER_MODE_ON);
+
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->runtime_resume)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->runtime_resume(device);
+	}
+	return ret;
+}
+
+int mali_deep_suspend(struct device *device)
+{
+	int ret = 0;
+
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->suspend)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->suspend(device);
+	}
+
+	mali_platform_power_mode_change(MALI_POWER_MODE_DEEP_SLEEP);
+	return ret;
+}
+
+int mali_deep_resume(struct device *device)
+{
+	int ret = 0;
+
+	mali_platform_power_mode_change(MALI_POWER_MODE_ON);
+
+	if (NULL != device->driver &&
+	    NULL != device->driver->pm &&
+	    NULL != device->driver->pm->resume)
+	{
+		/* Need to notify Mali driver about this event */
+		ret = device->driver->pm->resume(device);
+	}
+	return ret;
+
+}
+
+void mali_core_scaling_term(void)
+{
+
+}
+
+void mali_post_init(void)
+{
+}
+#endif /* MESON_CPU_TYPE <= MESON_CPU_TYPE_MESON6 */
diff --git a/drivers/gpu/arm/mali/platform/meson_m450/platform_g9tv.c b/drivers/gpu/arm/mali/platform/meson_m450/platform_g9tv.c
deleted file mode 100644
index 5346b014..00000000
--- a/drivers/gpu/arm/mali/platform/meson_m450/platform_g9tv.c
+++ /dev/null
@@ -1,417 +0,0 @@
-/*
- * platform.c
- *
- * clock source setting and resource config
- *
- *  Created on: Dec 4, 2013
- *      Author: amlogic
- */
-
-#include <linux/platform_device.h>
-#include <linux/version.h>
-#include <linux/pm.h>
-#include <linux/of.h>
-#include <linux/module.h>            /* kernel module definitions */
-#include <linux/ioport.h>            /* request_mem_region */
-#include <linux/slab.h>
-#include <mach/register.h>
-#include <mach/irqs.h>
-#include <mach/io.h>
-#include <asm/io.h>
-#include <linux/mali/mali_utgard.h>
-#include <linux/gpu_cooling.h>
-#include <linux/gpucore_cooling.h>
-#include <common/mali_kernel_common.h>
-#include <common/mali_osk_profiling.h>
-#include <common/mali_pmu.h>
-
-#include "meson_main.h"
-
-/*
- *    For Meson 8 M2.
- *
- */
-
-#define CFG_PP 6
-#define CFG_CLOCK 3
-#define CFG_MIN_PP 1
-#define CFG_MIN_CLOCK 0
-
-/* fclk is 2550Mhz. */
-#define FCLK_DEV3 (6 << 9)		/*	850   Mhz  */
-#define FCLK_DEV4 (5 << 9)		/*	637.5 Mhz  */
-#define FCLK_DEV5 (7 << 9)		/*	510   Mhz  */
-#define FCLK_DEV7 (4 << 9)		/*	364.3 Mhz  */
-
-static u32 mali_dvfs_clk[] = {
-	FCLK_DEV7 | 1,     /* 182.1 Mhz */
-	FCLK_DEV4 | 1,     /* 318.7 Mhz */
-	FCLK_DEV3 | 1,     /* 425 Mhz */
-	FCLK_DEV5 | 0,     /* 510 Mhz */
-	FCLK_DEV4 | 0,     /* 637.5 Mhz */
-};
-
-static u32 mali_dvfs_clk_sample[] = {
-	182,     /* 182.1 Mhz */
-	319,     /* 318.7 Mhz */
-	425,     /* 425 Mhz */
-	510,     /* 510 Mhz */
-	637,     /* 637.5 Mhz */
-};
-
-static mali_dvfs_threshold_table mali_dvfs_table[]={
-		{ 0, 0, 3,  70, 180}, /* for 182.1  */
-		{ 1, 1, 3, 108, 205}, /* for 318.7  */
-		{ 2, 2, 3, 150, 215}, /* for 425.0  */
-		{ 3, 3, 3, 170, 253}, /* for 510.0  */
-		{ 4, 4, 3, 230, 256},  /* for 637.5  */
-		{ 0, 0, 3,   0,   0}
-};
-
-static void mali_plat_preheat(void);
-static mali_plat_info_t mali_plat_data = {
-	.cfg_pp = CFG_PP,  /* number of pp. */
-	.cfg_min_pp = CFG_MIN_PP,
-	.turbo_clock = 4, /* reserved clock src. */
-	.def_clock = 2, /* gpu clock used most of time.*/
-	.cfg_clock = CFG_CLOCK, /* max gpu clock. */
-	.cfg_min_clock = CFG_MIN_CLOCK,
-
-	.sc_mpp = 3, /* number of pp used most of time.*/
-	.bst_gpu = 210, /* threshold for boosting gpu. */
-	.bst_pp = 160, /* threshold for boosting PP. */
-
-	.clk = mali_dvfs_clk, /* clock source table. */
-	.clk_sample = mali_dvfs_clk_sample, /* freqency table for show. */
-	.clk_len = sizeof(mali_dvfs_clk) / sizeof(mali_dvfs_clk[0]),
-	.have_switch = 1,
-
-	.dvfs_table = mali_dvfs_table, /* DVFS table. */
-	.dvfs_table_size = sizeof(mali_dvfs_table) / sizeof(mali_dvfs_threshold_table),
-
-	.scale_info = {
-		CFG_MIN_PP, /* minpp */
-		CFG_PP, /* maxpp, should be same as cfg_pp */
-		CFG_MIN_CLOCK, /* minclk */
-		CFG_CLOCK, /* maxclk should be same as cfg_clock */
-	},
-
-	.limit_on = 1,
-	.plat_preheat = mali_plat_preheat,
-};
-
-static void mali_plat_preheat(void)
-{
-	u32 pre_fs;
-	u32 clk, pp;
-
-	if (get_mali_schel_mode() != MALI_PP_FS_SCALING)
-		return;
-
-	get_mali_rt_clkpp(&clk, &pp);
-	pre_fs = mali_plat_data.def_clock + 1;
-	if (clk < pre_fs)
-		clk = pre_fs;
-	if (pp < mali_plat_data.sc_mpp)
-		pp = mali_plat_data.sc_mpp;
-	set_mali_rt_clkpp(clk, pp, 1);
-}
-
-mali_plat_info_t* get_mali_plat_data(void) {
-	return &mali_plat_data;
-}
-
-int get_mali_freq_level(int freq)
-{
-	int i = 0, level = -1;
-	int mali_freq_num;
-
-	if(freq < 0)
-		return level;
-	mali_freq_num = mali_plat_data.dvfs_table_size - 1;
-	if(freq <= mali_plat_data.clk_sample[0])
-		level = mali_freq_num-1;
-	if(freq >= mali_plat_data.clk_sample[mali_freq_num - 1])
-		level = 0;
-	for(i=0; i<mali_freq_num - 1 ;i++) {
-		if(freq >= mali_plat_data.clk_sample[i] && freq<=mali_plat_data.clk_sample[i + 1]) {
-			level = i;
-			level = mali_freq_num-level - 1;
-		}
-	}
-	return level;
-}
-
-unsigned int get_mali_max_level(void)
-{
-	return mali_plat_data.dvfs_table_size - 1;
-}
-
-static struct resource mali_gpu_resources[] =
-{
-	MALI_GPU_RESOURCES_MALI450_MP6_PMU(IO_MALI_APB_PHY_BASE, INT_MALI_GP, INT_MALI_GP_MMU,
-				INT_MALI_PP0, INT_MALI_PP0_MMU,
-				INT_MALI_PP1, INT_MALI_PP1_MMU,
-				INT_MALI_PP2, INT_MALI_PP2_MMU,
-				INT_MALI_PP4, INT_MALI_PP4_MMU,
-				INT_MALI_PP5, INT_MALI_PP5_MMU,
-				INT_MALI_PP6, INT_MALI_PP6_MMU,
-				INT_MALI_PP)
-};
-
-static void set_limit_mali_freq(u32 idx)
-{
-	if (mali_plat_data.limit_on == 0)
-		return;
-	if (idx > mali_plat_data.turbo_clock || idx < mali_plat_data.scale_info.minclk)
-		return;
-	mali_plat_data.scale_info.maxclk= idx;
-	revise_mali_rt();
-}
-
-static u32 get_limit_mali_freq(void)
-{
-	return mali_plat_data.scale_info.maxclk;
-}
-
-static u32 set_limit_pp_num(u32 num)
-{
-	u32 ret = -1;
-	if (mali_plat_data.limit_on == 0)
-		goto quit;
-	if (num > mali_plat_data.cfg_pp ||
-				num < mali_plat_data.scale_info.minpp)
-		goto quit;
-	mali_plat_data.scale_info.maxpp = num;
-	revise_mali_rt();
-	ret = 0;
-quit:
-	return ret;
-}
-
-#ifdef CONFIG_AM_VDEC_H264_4K2K
-static u32 grd_pp_bk = CFG_PP;
-static void mali_4k2k_enter(void)
-{
-	if (mali_plat_data.limit_on == 0)
-		return;
-	grd_pp_bk = mali_plat_data.scale_info.maxpp;
-	set_limit_pp_num(mali_plat_data.scale_info.minpp);
-}
-
-static void mali_4k2k_exit(void)
-{
-	if (mali_plat_data.limit_on == 0)
-		return;
-	set_limit_pp_num(grd_pp_bk);
-}
-
-void vh264_4k2k_register_module_callback(void(*enter_func)(void), void(*remove_func)(void));
-#endif /* CONFIG_AM_VDEC_H264_4K2K */
-
-void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data);
-int mali_meson_init_start(struct platform_device* ptr_plt_dev)
-{
-	struct mali_gpu_device_data* pdev = ptr_plt_dev->dev.platform_data;
-
-	/* for mali platform data. */
-	pdev->utilization_interval = 300,
-	pdev->utilization_callback = mali_gpu_utilization_callback,
-
-	/* for resource data. */
-	ptr_plt_dev->num_resources = ARRAY_SIZE(mali_gpu_resources);
-	ptr_plt_dev->resource = mali_gpu_resources;
-	return mali_clock_init(&mali_plat_data);
-}
-
-int mali_meson_init_finish(struct platform_device* ptr_plt_dev)
-{
-#ifdef CONFIG_GPU_THERMAL
-	int err;
-	struct gpufreq_cooling_device *gcdev = NULL;
-	struct gpucore_cooling_device *gccdev = NULL;
-#endif
-	if (mali_core_scaling_init(&mali_plat_data) < 0)
-		return -1;
-
-#ifdef CONFIG_GPU_THERMAL
-	gcdev = gpufreq_cooling_alloc();
-	register_gpu_freq_info(get_current_frequency);
-	if(IS_ERR(gcdev))
-		printk("malloc gpu cooling buffer error!!\n");
-	else if(!gcdev)
-		printk("system does not enable thermal driver\n");
-	else {
-		gcdev->get_gpu_freq_level = get_mali_freq_level;
-		gcdev->get_gpu_max_level = get_mali_max_level;
-		gcdev->set_gpu_freq_idx = set_limit_mali_freq;
-		gcdev->get_gpu_current_max_level = get_limit_mali_freq;
-		err = gpufreq_cooling_register(gcdev);
-		if(err < 0)
-			printk("register GPU  cooling error\n");
-		printk("gpu cooling register okay with err=%d\n",err);
-	}
-
-	gccdev=gpucore_cooling_alloc();
-	if(IS_ERR(gccdev))
-		printk("malloc gpu core cooling buffer error!!\n");
-	else if(!gccdev)
-		printk("system does not enable thermal driver\n");
-	else {
-		gccdev->max_gpu_core_num=mali_plat_data.cfg_pp;
-		gccdev->set_max_pp_num=set_limit_pp_num;
-		err = (int)gpucore_cooling_register(gccdev);
-		if(err < 0)
-			printk("register GPU  cooling error\n");
-		printk("gpu core cooling register okay with err=%d\n",err);
-	}
-#endif
-#ifdef CONFIG_AM_VDEC_H264_4K2K
-	vh264_4k2k_register_module_callback(mali_4k2k_enter, mali_4k2k_exit);
-#endif /* CONFIG_AM_VDEC_H264_4K2K */
-	return 0;
-}
-
-int mali_meson_uninit(struct platform_device* ptr_plt_dev)
-{
-	return 0;
-}
-
-static int mali_cri_light_suspend(size_t param)
-{
-	int ret;
-	struct device *device;
-	struct mali_pmu_core *pmu;
-
-	ret = 0;
-	device = (struct device *)param;
-	pmu = mali_pmu_get_global_pmu_core();
-
-	if (NULL != device->driver &&
-	    NULL != device->driver->pm &&
-	    NULL != device->driver->pm->runtime_suspend)
-	{
-		/* Need to notify Mali driver about this event */
-		ret = device->driver->pm->runtime_suspend(device);
-	}
-	mali_pmu_power_down_all(pmu);
-	return ret;
-}
-
-static int mali_cri_light_resume(size_t param)
-{
-	int ret;
-	struct device *device;
-	struct mali_pmu_core *pmu;
-
-	ret = 0;
-	device = (struct device *)param;
-	pmu = mali_pmu_get_global_pmu_core();
-
-	mali_pmu_power_up_all(pmu);
-	if (NULL != device->driver &&
-	    NULL != device->driver->pm &&
-	    NULL != device->driver->pm->runtime_resume)
-	{
-		/* Need to notify Mali driver about this event */
-		ret = device->driver->pm->runtime_resume(device);
-	}
-	return ret;
-}
-
-static int mali_cri_deep_suspend(size_t param)
-{
-	int ret;
-	struct device *device;
-	struct mali_pmu_core *pmu;
-
-	ret = 0;
-	device = (struct device *)param;
-	pmu = mali_pmu_get_global_pmu_core();
-
-	if (NULL != device->driver &&
-	    NULL != device->driver->pm &&
-	    NULL != device->driver->pm->suspend)
-	{
-		/* Need to notify Mali driver about this event */
-		ret = device->driver->pm->suspend(device);
-	}
-	mali_pmu_power_down_all(pmu);
-	return ret;
-}
-
-static int mali_cri_deep_resume(size_t param)
-{
-	int ret;
-	struct device *device;
-	struct mali_pmu_core *pmu;
-
-	ret = 0;
-	device = (struct device *)param;
-	pmu = mali_pmu_get_global_pmu_core();
-
-	mali_pmu_power_up_all(pmu);
-	if (NULL != device->driver &&
-	    NULL != device->driver->pm &&
-	    NULL != device->driver->pm->resume)
-	{
-		/* Need to notify Mali driver about this event */
-		ret = device->driver->pm->resume(device);
-	}
-	return ret;
-
-}
-
-int mali_light_suspend(struct device *device)
-{
-	int ret = 0;
-#ifdef CONFIG_MALI400_PROFILING
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-					MALI_PROFILING_EVENT_CHANNEL_GPU |
-					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-					0, 0,	0,	0,	0);
-#endif
-
-	/* clock scaling. Kasin..*/
-	ret = mali_clock_critical(mali_cri_light_suspend, (size_t)device);
-
-	return ret;
-}
-
-int mali_light_resume(struct device *device)
-{
-	int ret = 0;
-
-	ret = mali_clock_critical(mali_cri_light_resume, (size_t)device);
-#ifdef CONFIG_MALI400_PROFILING
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-					MALI_PROFILING_EVENT_CHANNEL_GPU |
-					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-					get_current_frequency(), 0,	0,	0,	0);
-#endif
-	return ret;
-}
-
-int mali_deep_suspend(struct device *device)
-{
-	int ret = 0;
-	enable_clock();
-	flush_scaling_job();
-
-	/* clock scaling off. Kasin... */
-	ret = mali_clock_critical(mali_cri_deep_suspend, (size_t)device);
-	disable_clock();
-	return ret;
-}
-
-int mali_deep_resume(struct device *device)
-{
-	int ret = 0;
-
-	/* clock scaling up. Kasin.. */
-	enable_clock();
-	ret = mali_clock_critical(mali_cri_deep_resume, (size_t)device);
-	return ret;
-
-}
-
diff --git a/drivers/gpu/arm/mali/platform/meson_m450/platform_m6tvd.c b/drivers/gpu/arm/mali/platform/meson_m450/platform_m6tvd.c
index bfd67910..58b30900 100644
--- a/drivers/gpu/arm/mali/platform/meson_m450/platform_m6tvd.c
+++ b/drivers/gpu/arm/mali/platform/meson_m450/platform_m6tvd.c
@@ -192,3 +192,6 @@ int mali_deep_resume(struct device *device)
 
 }
 
+void mali_post_init(void)
+{
+}
diff --git a/drivers/gpu/arm/mali/platform/meson_m450/platform_m8.c b/drivers/gpu/arm/mali/platform/meson_m450/platform_m8.c
index a7ee6bbf..62f2aada 100644
--- a/drivers/gpu/arm/mali/platform/meson_m450/platform_m8.c
+++ b/drivers/gpu/arm/mali/platform/meson_m450/platform_m8.c
@@ -38,391 +38,441 @@
 #define CFG_MIN_CLOCK 0
 
 /* fclk is 2550Mhz. */
-#define FCLK_DEV3 (6 << 9)		/*	850   Mhz  */
-#define FCLK_DEV4 (5 << 9)		/*	637.5 Mhz  */
-#define FCLK_DEV5 (7 << 9)		/*	510   Mhz  */
-#define FCLK_DEV7 (4 << 9)		/*	364.3 Mhz  */
+#define FCLK_DEV3 (6 << 9)      /*  850   Mhz  */
+#define FCLK_DEV4 (5 << 9)      /*  637.5 Mhz  */
+#define FCLK_DEV5 (7 << 9)      /*  510   Mhz  */
+#define FCLK_DEV7 (4 << 9)      /*  364.3 Mhz  */
 
 static u32 mali_dvfs_clk[] = {
-	FCLK_DEV7 | 1,     /* 182.1 Mhz */
-	FCLK_DEV4 | 1,     /* 318.7 Mhz */
-	FCLK_DEV3 | 1,     /* 425 Mhz */
-	FCLK_DEV5 | 0,     /* 510 Mhz */
-	FCLK_DEV4 | 0,     /* 637.5 Mhz */
+    FCLK_DEV7 | 1,     /* 182.1 Mhz */
+    FCLK_DEV4 | 1,     /* 318.7 Mhz */
+    FCLK_DEV3 | 1,     /* 425 Mhz */
+    FCLK_DEV5 | 0,     /* 510 Mhz */
+    FCLK_DEV4 | 0,     /* 637.5 Mhz */
 };
 
 static u32 mali_dvfs_clk_sample[] = {
-	182,     /* 182.1 Mhz */
-	319,     /* 318.7 Mhz */
-	425,     /* 425 Mhz */
-	510,     /* 510 Mhz */
-	637,     /* 637.5 Mhz */
+    182,     /* 182.1 Mhz */
+    319,     /* 318.7 Mhz */
+    425,     /* 425 Mhz */
+    510,     /* 510 Mhz */
+    637,     /* 637.5 Mhz */
 };
-
+//////////////////////////////////////
+//for dvfs
+struct mali_gpu_clk_item  meson_gpu_clk[]  = {
+    {182,  1150},   /* 182.1 Mhz, 1150mV */
+    {319,  1150},   /* 318.7 Mhz */
+    {425,  1150},   /* 425 Mhz */
+    {510,  1150},   /* 510 Mhz */
+    {637,  1150},   /* 637.5 Mhz */
+};
+struct mali_gpu_clock meson_gpu_clk_info = {
+    .item = meson_gpu_clk,
+    .num_of_steps = ARRAY_SIZE(meson_gpu_clk),
+};
+static int cur_gpu_clk_index = 0;
+//////////////////////////////////////
 static mali_dvfs_threshold_table mali_dvfs_table[]={
-		{ 0, 0, 3,  70, 180}, /* for 182.1  */
-		{ 1, 1, 3, 108, 205}, /* for 318.7  */
-		{ 2, 2, 3, 150, 215}, /* for 425.0  */
-		{ 3, 3, 3, 170, 253}, /* for 510.0  */
-		{ 4, 4, 3, 230, 256},  /* for 637.5  */
-		{ 0, 0, 3,   0,   0}
+    { 0, 0, 3,  30,  80}, /* for 182.1  */
+    { 1, 1, 3,  40, 205}, /* for 318.7  */
+    { 2, 2, 3, 150, 215}, /* for 425.0  */
+    { 3, 3, 3, 170, 253}, /* for 510.0  */
+    { 4, 4, 3, 230, 255},  /* for 637.5  */
+    { 0, 0, 3,   0,   0}
 };
 
 static void mali_plat_preheat(void);
 static mali_plat_info_t mali_plat_data = {
-	.cfg_pp = CFG_PP,  /* number of pp. */
-	.cfg_min_pp = CFG_MIN_PP,
-	.turbo_clock = 4, /* reserved clock src. */
-	.def_clock = 2, /* gpu clock used most of time.*/
-	.cfg_clock = CFG_CLOCK, /* max gpu clock. */
-	.cfg_clock_bkup = CFG_CLOCK,
-	.cfg_min_clock = CFG_MIN_CLOCK,
-
-	.sc_mpp = 3, /* number of pp used most of time.*/
-	.bst_gpu = 210, /* threshold for boosting gpu. */
-	.bst_pp = 160, /* threshold for boosting PP. */
-
-	.clk = mali_dvfs_clk, /* clock source table. */
-	.clk_sample = mali_dvfs_clk_sample, /* freqency table for show. */
-	.clk_len = sizeof(mali_dvfs_clk) / sizeof(mali_dvfs_clk[0]),
-	.have_switch = 1,
-
-	.dvfs_table = mali_dvfs_table, /* DVFS table. */
-	.dvfs_table_size = sizeof(mali_dvfs_table) / sizeof(mali_dvfs_threshold_table),
-
-	.scale_info = {
-		CFG_MIN_PP, /* minpp */
-		CFG_PP, /* maxpp, should be same as cfg_pp */
-		CFG_MIN_CLOCK, /* minclk */
-		CFG_CLOCK, /* maxclk should be same as cfg_clock */
-	},
-
-	.limit_on = 1,
-	.plat_preheat = mali_plat_preheat,
+    .cfg_pp = CFG_PP,  /* number of pp. */
+    .cfg_min_pp = CFG_MIN_PP,
+    .turbo_clock = 4, /* reserved clock src. */
+    .def_clock = 2, /* gpu clock used most of time.*/
+    .cfg_clock = CFG_CLOCK, /* max gpu clock. */
+    .cfg_clock_bkup = CFG_CLOCK,
+    .cfg_min_clock = CFG_MIN_CLOCK,
+
+    .sc_mpp = 3, /* number of pp used most of time.*/
+    .bst_gpu = 210, /* threshold for boosting gpu. */
+    .bst_pp = 160, /* threshold for boosting PP. */
+
+    .clk = mali_dvfs_clk, /* clock source table. */
+    .clk_sample = mali_dvfs_clk_sample, /* freqency table for show. */
+    .clk_len = sizeof(mali_dvfs_clk) / sizeof(mali_dvfs_clk[0]),
+    .have_switch = 1,
+
+    .dvfs_table = mali_dvfs_table, /* DVFS table. */
+    .dvfs_table_size = sizeof(mali_dvfs_table) / sizeof(mali_dvfs_threshold_table),
+
+    .scale_info = {
+        CFG_MIN_PP, /* minpp */
+        CFG_PP, /* maxpp, should be same as cfg_pp */
+        CFG_MIN_CLOCK, /* minclk */
+        CFG_CLOCK, /* maxclk should be same as cfg_clock */
+    },
+
+    .limit_on = 1,
+    .plat_preheat = mali_plat_preheat,
 };
 
 static void mali_plat_preheat(void)
 {
-	u32 pre_fs;
-	u32 clk, pp;
-
-	if (get_mali_schel_mode() != MALI_PP_FS_SCALING)
-		return;
-
-	get_mali_rt_clkpp(&clk, &pp);
-	pre_fs = mali_plat_data.def_clock + 1;
-	if (clk < pre_fs)
-		clk = pre_fs;
-	if (pp < mali_plat_data.sc_mpp)
-		pp = mali_plat_data.sc_mpp;
-	set_mali_rt_clkpp(clk, pp, 1);
+#ifndef CONFIG_MALI_DVFS
+    u32 pre_fs;
+    u32 clk, pp;
+
+    if (get_mali_schel_mode() != MALI_PP_FS_SCALING)
+        return;
+
+    get_mali_rt_clkpp(&clk, &pp);
+    pre_fs = mali_plat_data.def_clock + 1;
+    if (clk < pre_fs)
+        clk = pre_fs;
+    if (pp < mali_plat_data.sc_mpp)
+        pp = mali_plat_data.sc_mpp;
+    set_mali_rt_clkpp(clk, pp, 1);
+#endif
 }
 
 mali_plat_info_t* get_mali_plat_data(void) {
-	return &mali_plat_data;
+    return &mali_plat_data;
 }
 
 int get_mali_freq_level(int freq)
 {
-	int i = 0, level = -1;
-	int mali_freq_num;
-
-	if(freq < 0)
-		return level;
-	mali_freq_num = mali_plat_data.dvfs_table_size - 1;
-	if(freq <= mali_plat_data.clk_sample[0])
-		level = mali_freq_num-1;
-	if(freq >= mali_plat_data.clk_sample[mali_freq_num - 1])
-		level = 0;
-	for(i=0; i<mali_freq_num - 1 ;i++) {
-		if(freq >= mali_plat_data.clk_sample[i] && freq<=mali_plat_data.clk_sample[i + 1]) {
-			level = i;
-			level = mali_freq_num-level - 1;
-		}
-	}
-	return level;
+    int i = 0, level = -1;
+    int mali_freq_num;
+
+    if (freq < 0)
+        return level;
+
+    mali_freq_num = mali_plat_data.dvfs_table_size - 1;
+    if (freq <= mali_plat_data.clk_sample[0])
+        level = mali_freq_num-1;
+    if (freq >= mali_plat_data.clk_sample[mali_freq_num - 1])
+        level = 0;
+    for (i=0; i<mali_freq_num - 1 ;i++) {
+        if (freq >= mali_plat_data.clk_sample[i] && freq <= mali_plat_data.clk_sample[i + 1]) {
+            level = i;
+            level = mali_freq_num-level - 1;
+        }
+    }
+    return level;
 }
 
 unsigned int get_mali_max_level(void)
 {
-	return mali_plat_data.dvfs_table_size - 1;
+    return mali_plat_data.dvfs_table_size - 1;
 }
 
 static struct resource mali_gpu_resources[] =
 {
-	MALI_GPU_RESOURCES_MALI450_MP6_PMU(IO_MALI_APB_PHY_BASE, INT_MALI_GP, INT_MALI_GP_MMU,
-				INT_MALI_PP0, INT_MALI_PP0_MMU,
-				INT_MALI_PP1, INT_MALI_PP1_MMU,
-				INT_MALI_PP2, INT_MALI_PP2_MMU,
-				INT_MALI_PP4, INT_MALI_PP4_MMU,
-				INT_MALI_PP5, INT_MALI_PP5_MMU,
-				INT_MALI_PP6, INT_MALI_PP6_MMU,
-				INT_MALI_PP)
+    MALI_GPU_RESOURCES_MALI450_MP6_PMU(IO_MALI_APB_PHY_BASE, INT_MALI_GP, INT_MALI_GP_MMU,
+            INT_MALI_PP0, INT_MALI_PP0_MMU,
+            INT_MALI_PP1, INT_MALI_PP1_MMU,
+            INT_MALI_PP2, INT_MALI_PP2_MMU,
+            INT_MALI_PP4, INT_MALI_PP4_MMU,
+            INT_MALI_PP5, INT_MALI_PP5_MMU,
+            INT_MALI_PP6, INT_MALI_PP6_MMU,
+            INT_MALI_PP)
 };
 
 static void set_limit_mali_freq(u32 idx)
 {
-	if (mali_plat_data.limit_on == 0)
-		return;
-	if (idx > mali_plat_data.turbo_clock || idx < mali_plat_data.scale_info.minclk)
-		return;
-	mali_plat_data.scale_info.maxclk= idx;
-	revise_mali_rt();
+    if (mali_plat_data.limit_on == 0)
+        return;
+    if (idx > mali_plat_data.turbo_clock || idx < mali_plat_data.scale_info.minclk)
+        return;
+    mali_plat_data.scale_info.maxclk= idx;
+    revise_mali_rt();
 }
 
 static u32 get_limit_mali_freq(void)
 {
-	return mali_plat_data.scale_info.maxclk;
+    return mali_plat_data.scale_info.maxclk;
 }
 
 static u32 set_limit_pp_num(u32 num)
 {
-	u32 ret = -1;
-	if (mali_plat_data.limit_on == 0)
-		goto quit;
-	if (num > mali_plat_data.cfg_pp ||
-				num < mali_plat_data.scale_info.minpp)
-		goto quit;
-	mali_plat_data.scale_info.maxpp = num;
-	revise_mali_rt();
-	ret = 0;
+    u32 ret = -1;
+    if (mali_plat_data.limit_on == 0)
+        goto quit;
+    if (num > mali_plat_data.cfg_pp ||
+            num < mali_plat_data.scale_info.minpp)
+        goto quit;
+    mali_plat_data.scale_info.maxpp = num;
+    revise_mali_rt();
+    ret = 0;
 quit:
-	return ret;
+    return ret;
 }
 
-#ifdef CONFIG_AM_VDEC_H264_4K2K
-static u32 grd_pp_bk = CFG_PP;
-static void mali_4k2k_enter(void)
-{
-	if (mali_plat_data.limit_on == 0)
-		return;
-	grd_pp_bk = mali_plat_data.scale_info.maxpp;
-	set_limit_pp_num(mali_plat_data.scale_info.minpp);
+void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data);
+
+#if 0
+struct mali_gpu_clk_item {
+    unsigned int clock; /* unit(MHz) */
+    unsigned int vol;
+};
+
+struct mali_gpu_clock {
+    struct mali_gpu_clk_item *item;
+    unsigned int num_of_steps;
+};
+#endif
+
+/* Function that platfrom report it's clock info which driver can set, needed when CONFIG_MALI_DVFS enabled */
+void meson_platform_get_clock_info(struct mali_gpu_clock **data) {
+    *data = &meson_gpu_clk_info;
 }
 
-static void mali_4k2k_exit(void)
-{
-	if (mali_plat_data.limit_on == 0)
-		return;
-	set_limit_pp_num(grd_pp_bk);
+/* Function that get the current clock info, needed when CONFIG_MALI_DVFS enabled */
+int meson_platform_get_freq(void) {
+    printk("get cur_gpu_clk_index =%d\n", cur_gpu_clk_index);
+    return  cur_gpu_clk_index;
 }
 
-void vh264_4k2k_register_module_callback(void(*enter_func)(void), void(*remove_func)(void));
-#endif /* CONFIG_AM_VDEC_H264_4K2K */
+/* Fuction that platform callback for freq setting, needed when CONFIG_MALI_DVFS enabled */
+int meson_platform_set_freq(int setting_clock_step) {
+
+    if (cur_gpu_clk_index == setting_clock_step) {
+        return 0;
+    }
+
+    mali_clock_set(setting_clock_step);
+
+    cur_gpu_clk_index = setting_clock_step;
+    printk("set cur_gpu_clk_index =%d\n", cur_gpu_clk_index);
+
+    return 0;
+}
 
-void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data);
 int mali_meson_init_start(struct platform_device* ptr_plt_dev)
 {
-	struct mali_gpu_device_data* pdev = ptr_plt_dev->dev.platform_data;
-
-	/* chip mark detect. */
+    struct mali_gpu_device_data* pdev = ptr_plt_dev->dev.platform_data;
 
+    /* chip mark detect. */
 #ifdef IS_MESON_M8_CPU
-	if(IS_MESON_M8_CPU) {
-		mali_plat_data.have_switch = 0;
-	}
+    if (IS_MESON_M8_CPU) {
+        mali_plat_data.have_switch = 0;
+    }
 #endif
 
-	/* for mali platform data. */
-	pdev->utilization_interval = 300,
-	pdev->utilization_callback = mali_gpu_utilization_callback,
+    /* for resource data. */
+    ptr_plt_dev->num_resources = ARRAY_SIZE(mali_gpu_resources);
+    ptr_plt_dev->resource = mali_gpu_resources;
+
+    /*for dvfs*/
+#ifndef CONFIG_MALI_DVFS
+    /* for mali platform data. */
+    pdev->control_interval = 300;
+    pdev->utilization_callback = mali_gpu_utilization_callback;
+#else
+    pdev->get_clock_info = meson_platform_get_clock_info;
+    pdev->get_freq = meson_platform_get_freq;
+    pdev->set_freq = meson_platform_set_freq;
+#endif
 
-	/* for resource data. */
-	ptr_plt_dev->num_resources = ARRAY_SIZE(mali_gpu_resources);
-	ptr_plt_dev->resource = mali_gpu_resources;
-	return mali_clock_init(&mali_plat_data);
+    return mali_clock_init(&mali_plat_data);
 }
 
 int mali_meson_init_finish(struct platform_device* ptr_plt_dev)
 {
-#ifdef CONFIG_GPU_THERMAL
-	int err;
-	struct gpufreq_cooling_device *gcdev = NULL;
-	struct gpucore_cooling_device *gccdev = NULL;
-#endif
-	if (mali_core_scaling_init(&mali_plat_data) < 0)
-		return -1;
-
-#ifdef CONFIG_GPU_THERMAL
-	gcdev = gpufreq_cooling_alloc();
-	register_gpu_freq_info(get_current_frequency);
-	if(IS_ERR(gcdev))
-		printk("malloc gpu cooling buffer error!!\n");
-	else if(!gcdev)
-		printk("system does not enable thermal driver\n");
-	else {
-		gcdev->get_gpu_freq_level = get_mali_freq_level;
-		gcdev->get_gpu_max_level = get_mali_max_level;
-		gcdev->set_gpu_freq_idx = set_limit_mali_freq;
-		gcdev->get_gpu_current_max_level = get_limit_mali_freq;
-		err = gpufreq_cooling_register(gcdev);
-		if(err < 0)
-			printk("register GPU  cooling error\n");
-		printk("gpu cooling register okay with err=%d\n",err);
-	}
-
-	gccdev=gpucore_cooling_alloc();
-	if(IS_ERR(gccdev))
-		printk("malloc gpu core cooling buffer error!!\n");
-	else if(!gccdev)
-		printk("system does not enable thermal driver\n");
-	else {
-		gccdev->max_gpu_core_num=mali_plat_data.cfg_pp;
-		gccdev->set_max_pp_num=set_limit_pp_num;
-		err = (int)gpucore_cooling_register(gccdev);
-		if(err < 0)
-			printk("register GPU  cooling error\n");
-		printk("gpu core cooling register okay with err=%d\n",err);
-	}
+#ifndef CONFIG_MALI_DVFS
+    if (mali_core_scaling_init(&mali_plat_data) < 0)
+        return -1;
+#else
+    printk("disable meson own dvfs\n");
 #endif
-#ifdef CONFIG_AM_VDEC_H264_4K2K
-	vh264_4k2k_register_module_callback(mali_4k2k_enter, mali_4k2k_exit);
-#endif /* CONFIG_AM_VDEC_H264_4K2K */
-	return 0;
+    return 0;
 }
 
 int mali_meson_uninit(struct platform_device* ptr_plt_dev)
 {
-	return 0;
+    return 0;
 }
 
 static int mali_cri_light_suspend(size_t param)
 {
-	int ret;
-	struct device *device;
-	struct mali_pmu_core *pmu;
-
-	ret = 0;
-	mali_pm_statue = 0;
-	device = (struct device *)param;
-	pmu = mali_pmu_get_global_pmu_core();
-
-	if (NULL != device->driver &&
-	    NULL != device->driver->pm &&
-	    NULL != device->driver->pm->runtime_suspend)
-	{
-		/* Need to notify Mali driver about this event */
-		ret = device->driver->pm->runtime_suspend(device);
-	}
-	mali_pmu_power_down_all(pmu);
-	return ret;
+    int ret;
+    struct device *device;
+    struct mali_pmu_core *pmu;
+
+    ret = 0;
+    mali_pm_statue = 1;
+    device = (struct device *)param;
+    pmu = mali_pmu_get_global_pmu_core();
+
+    if (NULL != device->driver &&
+            NULL != device->driver->pm &&
+            NULL != device->driver->pm->runtime_suspend)
+    {
+        /* Need to notify Mali driver about this event */
+        ret = device->driver->pm->runtime_suspend(device);
+    }
+    mali_pmu_power_down_all(pmu);
+    return ret;
 }
 
 static int mali_cri_light_resume(size_t param)
 {
-	int ret;
-	struct device *device;
-	struct mali_pmu_core *pmu;
-
-	ret = 0;
-	device = (struct device *)param;
-	pmu = mali_pmu_get_global_pmu_core();
-
-	mali_pmu_power_up_all(pmu);
-	if (NULL != device->driver &&
-	    NULL != device->driver->pm &&
-	    NULL != device->driver->pm->runtime_resume)
-	{
-		/* Need to notify Mali driver about this event */
-		ret = device->driver->pm->runtime_resume(device);
-	}
-	mali_pm_statue = 1;
-	return ret;
+    int ret;
+    struct device *device;
+    struct mali_pmu_core *pmu;
+
+    ret = 0;
+    device = (struct device *)param;
+    pmu = mali_pmu_get_global_pmu_core();
+
+    mali_pmu_power_up_all(pmu);
+    if (NULL != device->driver &&
+            NULL != device->driver->pm &&
+            NULL != device->driver->pm->runtime_resume)
+    {
+        /* Need to notify Mali driver about this event */
+        ret = device->driver->pm->runtime_resume(device);
+    }
+    mali_pm_statue = 0;
+    return ret;
 }
 
 static int mali_cri_deep_suspend(size_t param)
 {
-	int ret;
-	struct device *device;
-	struct mali_pmu_core *pmu;
-
-	ret = 0;
-	device = (struct device *)param;
-	pmu = mali_pmu_get_global_pmu_core();
-
-	if (NULL != device->driver &&
-	    NULL != device->driver->pm &&
-	    NULL != device->driver->pm->suspend)
-	{
-		/* Need to notify Mali driver about this event */
-		ret = device->driver->pm->suspend(device);
-	}
-	mali_pmu_power_down_all(pmu);
-	return ret;
+    int ret;
+    struct device *device;
+    struct mali_pmu_core *pmu;
+
+    ret = 0;
+    device = (struct device *)param;
+    pmu = mali_pmu_get_global_pmu_core();
+
+    if (NULL != device->driver &&
+            NULL != device->driver->pm &&
+            NULL != device->driver->pm->suspend)
+    {
+        /* Need to notify Mali driver about this event */
+        ret = device->driver->pm->suspend(device);
+    }
+    mali_pmu_power_down_all(pmu);
+    return ret;
 }
 
 static int mali_cri_deep_resume(size_t param)
 {
-	int ret;
-	struct device *device;
-	struct mali_pmu_core *pmu;
-
-	ret = 0;
-	device = (struct device *)param;
-	pmu = mali_pmu_get_global_pmu_core();
-
-	mali_pmu_power_up_all(pmu);
-	if (NULL != device->driver &&
-	    NULL != device->driver->pm &&
-	    NULL != device->driver->pm->resume)
-	{
-		/* Need to notify Mali driver about this event */
-		ret = device->driver->pm->resume(device);
-	}
-	return ret;
+    int ret;
+    struct device *device;
+    struct mali_pmu_core *pmu;
+
+    ret = 0;
+    device = (struct device *)param;
+    pmu = mali_pmu_get_global_pmu_core();
+
+    mali_pmu_power_up_all(pmu);
+    if (NULL != device->driver &&
+            NULL != device->driver->pm &&
+            NULL != device->driver->pm->resume)
+    {
+        /* Need to notify Mali driver about this event */
+        ret = device->driver->pm->resume(device);
+    }
+    return ret;
 
 }
 
 int mali_light_suspend(struct device *device)
 {
-	int ret = 0;
+    int ret = 0;
 #ifdef CONFIG_MALI400_PROFILING
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-					MALI_PROFILING_EVENT_CHANNEL_GPU |
-					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-					0, 0,	0,	0,	0);
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+            MALI_PROFILING_EVENT_CHANNEL_GPU |
+            MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+            0, 0, 0, 0, 0);
 #endif
 
-	/* clock scaling. Kasin..*/
-	ret = mali_clock_critical(mali_cri_light_suspend, (size_t)device);
-	disable_clock();
-	return ret;
+    /* clock scaling. Kasin..*/
+    ret = mali_clock_critical(mali_cri_light_suspend, (size_t)device);
+    disable_clock();
+    return ret;
 }
 
 int mali_light_resume(struct device *device)
 {
-	int ret = 0;
-	enable_clock();
-	ret = mali_clock_critical(mali_cri_light_resume, (size_t)device);
+    int ret = 0;
+    enable_clock();
+    ret = mali_clock_critical(mali_cri_light_resume, (size_t)device);
 #ifdef CONFIG_MALI400_PROFILING
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-					MALI_PROFILING_EVENT_CHANNEL_GPU |
-					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-					get_current_frequency(), 0,	0,	0,	0);
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+            MALI_PROFILING_EVENT_CHANNEL_GPU |
+            MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+            get_current_frequency(), 0, 0, 0, 0);
 #endif
-	return ret;
+    return ret;
 }
 
 int mali_deep_suspend(struct device *device)
 {
-	int ret = 0;
-	enable_clock();
-	flush_scaling_job();
-
-	/* clock scaling off. Kasin... */
-	ret = mali_clock_critical(mali_cri_deep_suspend, (size_t)device);
-	disable_clock();
-	return ret;
+    int ret = 0;
+
+    mali_pm_statue = 1;
+    enable_clock();
+#ifndef CONFIG_MALI_DVFS
+    flush_scaling_job();
+#endif
+
+    /* clock scaling off. Kasin... */
+    ret = mali_clock_critical(mali_cri_deep_suspend, (size_t)device);
+    disable_clock();
+    return ret;
 }
 
 int mali_deep_resume(struct device *device)
 {
-	int ret = 0;
+    int ret = 0;
 
-	/* clock scaling up. Kasin.. */
-	enable_clock();
-	ret = mali_clock_critical(mali_cri_deep_resume, (size_t)device);
-	return ret;
+    /* clock scaling up. Kasin.. */
+    enable_clock();
+    ret = mali_clock_critical(mali_cri_deep_resume, (size_t)device);
+    mali_pm_statue = 0;
+    return ret;
 
 }
 
+void mali_post_init(void)
+{
+#ifdef CONFIG_GPU_THERMAL
+    int err;
+    struct gpufreq_cooling_device *gcdev = NULL;
+    struct gpucore_cooling_device *gccdev = NULL;
+
+    gcdev = gpufreq_cooling_alloc();
+    register_gpu_freq_info(get_current_frequency);
+    if (IS_ERR(gcdev))
+        printk("malloc gpu cooling buffer error!!\n");
+    else if (!gcdev)
+        printk("system does not enable thermal driver\n");
+    else {
+        gcdev->get_gpu_freq_level = get_mali_freq_level;
+        gcdev->get_gpu_max_level = get_mali_max_level;
+        gcdev->set_gpu_freq_idx = set_limit_mali_freq;
+        gcdev->get_gpu_current_max_level = get_limit_mali_freq;
+        err = gpufreq_cooling_register(gcdev);
+        if (err < 0)
+            printk("register GPU  cooling error\n");
+        printk("gpu cooling register okay with err=%d\n",err);
+    }
+
+    gccdev = gpucore_cooling_alloc();
+    if (IS_ERR(gccdev))
+        printk("malloc gpu core cooling buffer error!!\n");
+    else if (!gccdev)
+        printk("system does not enable thermal driver\n");
+    else {
+        gccdev->max_gpu_core_num=mali_plat_data.cfg_pp;
+        gccdev->set_max_pp_num=set_limit_pp_num;
+        err = (int)gpucore_cooling_register(gccdev);
+        if (err < 0)
+            printk("register GPU  cooling error\n");
+        printk("gpu core cooling register okay with err=%d\n",err);
+    }
+#endif
+}
diff --git a/drivers/gpu/arm/mali/platform/meson_m450/platform_m8b.c b/drivers/gpu/arm/mali/platform/meson_m450/platform_m8b.c
index ceb5e2be..7ab17d26 100644
--- a/drivers/gpu/arm/mali/platform/meson_m450/platform_m8b.c
+++ b/drivers/gpu/arm/mali/platform/meson_m450/platform_m8b.c
@@ -35,328 +35,434 @@
 #define CFG_PP 2
 #define CFG_CLOCK 4
 #define CFG_MIN_PP 2
-#define CFG_MIN_CLOCK 4
+
 
 /* fclk is 2550Mhz. */
-#define FCLK_DEV3 (6 << 9)		/*	850   Mhz  */
-#define FCLK_DEV4 (5 << 9)		/*	637.5 Mhz  */
-#define FCLK_DEV5 (7 << 9)		/*	510   Mhz  */
-#define FCLK_DEV7 (4 << 9)		/*	364.3 Mhz  */
+#define FCLK_DEV3 (6 << 9)      /*  850   Mhz  */
+#define FCLK_DEV4 (5 << 9)      /*  637.5 Mhz  */
+#define FCLK_DEV5 (7 << 9)      /*  510   Mhz  */
+#define FCLK_DEV7 (4 << 9)      /*  364.3 Mhz  */
 
 static u32 mali_dvfs_clk[] = {
-	FCLK_DEV5 | 1,     /* 255 Mhz */
-	FCLK_DEV7 | 0,     /* 364 Mhz */
-	FCLK_DEV3 | 1,     /* 425 Mhz */
-	FCLK_DEV5 | 0,     /* 510 Mhz */
-	FCLK_DEV4 | 0,     /* 637.5 Mhz */
+    FCLK_DEV5 | 1,     /* 255 Mhz */
+    FCLK_DEV7 | 0,     /* 364 Mhz */
+    FCLK_DEV3 | 1,     /* 425 Mhz */
+    FCLK_DEV5 | 0,     /* 510 Mhz */
+    FCLK_DEV4 | 0,     /* 637.5 Mhz */
 };
 
 static u32 mali_dvfs_clk_sample[] = {
-	255,     /* 182.1 Mhz */
-	364,     /* 318.7 Mhz */
-	425,     /* 425 Mhz */
-	510,     /* 510 Mhz */
-	637,     /* 637.5 Mhz */
+    255,     /* 182.1 Mhz */
+    364,     /* 318.7 Mhz */
+    425,     /* 425 Mhz */
+    510,     /* 510 Mhz */
+    637,     /* 637.5 Mhz */
 };
 
+//////////////////////////////////////
+//for dvfs
+struct mali_gpu_clk_item  meson_gpu_clk[]  = {
+    {255,  1150},   /* 182.1 Mhz, 1150mV */
+    {364,  1150},   /* 318.7 Mhz */
+    {425,  1150},   /* 425 Mhz */
+    {510,  1150},   /* 510 Mhz */
+    {637,  1150},   /* 637.5 Mhz */
+};
+struct mali_gpu_clock meson_gpu_clk_info = {
+    .item = meson_gpu_clk,
+    .num_of_steps = ARRAY_SIZE(meson_gpu_clk),
+};
+static int cur_gpu_clk_index = 0;
+//////////////////////////////////////
+
 static mali_dvfs_threshold_table mali_dvfs_table[]={
-		{ 0, 0, 5, 0  , 180}, /* for 255  */
-		{ 1, 1, 5, 152, 205}, /* for 364  */
-		{ 2, 2, 5, 180, 212}, /* for 425  */
-		{ 3, 3, 5, 205, 236}, /* for 510  */
-		{ 4, 4, 5, 230, 256}, /* for 637  */
-		{ 0, 0, 5,   0,   0}
+    { 0, 0, 5, 30 , 180}, /* for 255  */
+    { 1, 1, 5, 152, 205}, /* for 364  */
+    { 2, 2, 5, 180, 212}, /* for 425  */
+    { 3, 3, 5, 205, 236}, /* for 510  */
+    { 4, 4, 5, 230, 255}, /* for 637  */
+    { 0, 0, 5,   0,   0}
 };
 
 static void mali_plat_preheat(void);
 static mali_plat_info_t mali_plat_data = {
-	.cfg_pp = CFG_PP,  /* number of pp. */
-	.cfg_min_pp = CFG_MIN_PP,
-	.turbo_clock = 4, /* reserved clock src. */
-	.def_clock = 2, /* gpu clock used most of time.*/
-	.cfg_clock = CFG_CLOCK, /* max gpu clock. */
-	.cfg_clock_bkup = CFG_CLOCK,
-	.cfg_min_clock = CFG_MIN_CLOCK,
-
-	.sc_mpp = 2, /* number of pp used most of time.*/
-	.bst_gpu = 1, /* threshold for boosting gpu. */
-	.bst_pp = 1, /* threshold for boosting PP. */
-
-	.clk = mali_dvfs_clk, /* clock source table. */
-	.clk_sample = mali_dvfs_clk_sample, /* freqency table for show. */
-	.clk_len = sizeof(mali_dvfs_clk) / sizeof(mali_dvfs_clk[0]),
-	.have_switch = 1,
-
-	.dvfs_table = mali_dvfs_table, /* DVFS table. */
-	.dvfs_table_size = sizeof(mali_dvfs_table) / sizeof(mali_dvfs_threshold_table),
-
-	.scale_info = {
-		CFG_MIN_PP, /* minpp */
-		CFG_PP, /* maxpp, should be same as cfg_pp */
-		CFG_MIN_CLOCK, /* minclk */
-		CFG_CLOCK, /* maxclk should be same as cfg_clock */
-	},
-
-	.limit_on = 0,
-	.plat_preheat = mali_plat_preheat,
+    .cfg_pp = CFG_PP,  /* number of pp. */
+    .cfg_min_pp = CFG_MIN_PP,
+    .turbo_clock = CFG_CLOCK, /* reserved clock src. */
+    .def_clock = CFG_CLOCK, /* gpu clock used most of time.*/
+    .cfg_clock = CFG_CLOCK, /* max gpu clock. */
+    .cfg_clock_bkup = CFG_CLOCK,
+    .cfg_min_clock = CFG_CLOCK,
+
+    .sc_mpp = 2, /* number of pp used most of time.*/
+    .bst_gpu = 210, /* threshold for boosting gpu. */
+    .bst_pp = 160, /* threshold for boosting PP. */
+
+    .clk = mali_dvfs_clk, /* clock source table. */
+    .clk_sample = mali_dvfs_clk_sample, /* freqency table for show. */
+    .clk_len = sizeof(mali_dvfs_clk) / sizeof(mali_dvfs_clk[0]),
+    .have_switch = 1,
+
+    .dvfs_table = mali_dvfs_table, /* DVFS table. */
+    .dvfs_table_size = sizeof(mali_dvfs_table) / sizeof(mali_dvfs_threshold_table),
+
+    .scale_info = {
+        CFG_MIN_PP, /* minpp */
+        CFG_PP, /* maxpp, should be same as cfg_pp */
+        CFG_CLOCK, /* minclk */
+        CFG_CLOCK, /* maxclk should be same as cfg_clock */
+    },
+
+    .limit_on = 1,
+    .plat_preheat = mali_plat_preheat,
 };
 
 static void mali_plat_preheat(void)
 {
-	u32 pre_fs;
-	u32 clk, pp;
-
-	if (get_mali_schel_mode() != MALI_PP_FS_SCALING)
-		return;
-
-	get_mali_rt_clkpp(&clk, &pp);
-	pre_fs = mali_plat_data.def_clock + 1;
-	if (clk < pre_fs)
-		clk = pre_fs;
-	if (pp < mali_plat_data.sc_mpp)
-		pp = mali_plat_data.sc_mpp;
-	set_mali_rt_clkpp(clk, pp, 1);
+#ifndef CONFIG_MALI_DVFS
+    u32 pre_fs;
+    u32 clk, pp;
+
+    if (get_mali_schel_mode() != MALI_PP_FS_SCALING)
+        return;
+
+    get_mali_rt_clkpp(&clk, &pp);
+    pre_fs = mali_plat_data.def_clock + 1;
+    if (clk < pre_fs)
+        clk = pre_fs;
+    if (pp < mali_plat_data.sc_mpp)
+        pp = mali_plat_data.sc_mpp;
+    set_mali_rt_clkpp(clk, pp, 1);
+#endif
 }
 
 mali_plat_info_t* get_mali_plat_data(void) {
-	return &mali_plat_data;
+    return &mali_plat_data;
 }
 
 int get_mali_freq_level(int freq)
 {
-	int i = 0, level = -1;
-	int mali_freq_num;
-
-	if(freq < 0)
-		return level;
-	mali_freq_num = mali_plat_data.dvfs_table_size - 1;
-	if(freq <= mali_plat_data.clk_sample[0])
-		level = mali_freq_num-1;
-	if(freq >= mali_plat_data.clk_sample[mali_freq_num - 1])
-		level = 0;
-	for(i=0; i<mali_freq_num - 1 ;i++) {
-		if(freq >= mali_plat_data.clk_sample[i] && freq<=mali_plat_data.clk_sample[i + 1]) {
-			level = i;
-			level = mali_freq_num-level - 1;
-		}
-	}
-	return level;
+    int i = 0, level = -1;
+    int mali_freq_num;
+
+    if (freq < 0)
+        return level;
+    mali_freq_num = mali_plat_data.dvfs_table_size - 1;
+    if (freq <= mali_plat_data.clk_sample[0])
+        level = mali_freq_num-1;
+    if (freq >= mali_plat_data.clk_sample[mali_freq_num - 1])
+        level = 0;
+    for (i=0; i<mali_freq_num - 1 ;i++) {
+        if (freq >= mali_plat_data.clk_sample[i] && freq <= mali_plat_data.clk_sample[i + 1]) {
+            level = i;
+            level = mali_freq_num-level - 1;
+        }
+    }
+    return level;
 }
 
 unsigned int get_mali_max_level(void)
 {
-	return mali_plat_data.dvfs_table_size - 1;
+    return mali_plat_data.dvfs_table_size - 1;
 }
 
 static struct resource mali_gpu_resources[] =
 {
-	MALI_GPU_RESOURCES_MALI450_MP2_PMU(IO_MALI_APB_PHY_BASE, INT_MALI_GP, INT_MALI_GP_MMU, 
-				INT_MALI_PP0, INT_MALI_PP0_MMU,
-				INT_MALI_PP1, INT_MALI_PP1_MMU,
-				INT_MALI_PP)
+    MALI_GPU_RESOURCES_MALI450_MP2_PMU(IO_MALI_APB_PHY_BASE, INT_MALI_GP, INT_MALI_GP_MMU,
+            INT_MALI_PP0, INT_MALI_PP0_MMU,
+            INT_MALI_PP1, INT_MALI_PP1_MMU,
+            INT_MALI_PP)
 };
 
 static void set_limit_mali_freq(u32 idx)
 {
-	if (mali_plat_data.limit_on == 0)
-		return;
-	if (idx > mali_plat_data.turbo_clock || idx < mali_plat_data.scale_info.minclk)
-		return;
-	mali_plat_data.scale_info.maxclk= idx;
-	revise_mali_rt();
+    if (mali_plat_data.limit_on == 0)
+        return;
+    if (idx > mali_plat_data.turbo_clock || idx < mali_plat_data.scale_info.minclk)
+        return;
+    mali_plat_data.scale_info.maxclk= idx;
+
+    revise_mali_rt();
 }
 
 static u32 get_limit_mali_freq(void)
 {
-	return mali_plat_data.scale_info.maxclk;
+    return mali_plat_data.scale_info.maxclk;
 }
 
-void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data);
-int mali_meson_init_start(struct platform_device* ptr_plt_dev)
+static u32 set_limit_pp_num(u32 num)
 {
-	struct mali_gpu_device_data* pdev = ptr_plt_dev->dev.platform_data;
+    u32 ret = -1;
+    if (mali_plat_data.limit_on == 0)
+        goto quit;
+    if (num > mali_plat_data.cfg_pp ||
+            num < mali_plat_data.scale_info.minpp)
+        goto quit;
+    mali_plat_data.scale_info.maxpp = num;
+    revise_mali_rt();
+    ret = 0;
+quit:
+    return ret;
+}
 
-	/* for mali platform data. */
-	pdev->utilization_callback = mali_gpu_utilization_callback,
+void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data);
+
+#if 0
+struct mali_gpu_clk_item {
+    unsigned int clock; /* unit(MHz) */
+    unsigned int vol;
+};
 
-	/* for resource data. */
-	ptr_plt_dev->num_resources = ARRAY_SIZE(mali_gpu_resources);
-	ptr_plt_dev->resource = mali_gpu_resources;
-	return mali_clock_init(&mali_plat_data);
+struct mali_gpu_clock {
+    struct mali_gpu_clk_item *item;
+    unsigned int num_of_steps;
+};
+#endif
+
+/* Function that platfrom report it's clock info which driver can set, needed when CONFIG_MALI_DVFS enabled */
+void meson_platform_get_clock_info(struct mali_gpu_clock **data) {
+    *data = &meson_gpu_clk_info;
 }
 
-int mali_meson_init_finish(struct platform_device* ptr_plt_dev)
+/* Function that get the current clock info, needed when CONFIG_MALI_DVFS enabled */
+int meson_platform_get_freq(void) {
+    printk("get cur_gpu_clk_index =%d\n", cur_gpu_clk_index);
+    return  cur_gpu_clk_index;
+}
+
+/* Fuction that platform callback for freq setting, needed when CONFIG_MALI_DVFS enabled */
+int meson_platform_set_freq(int setting_clock_step) {
+
+    if (cur_gpu_clk_index == setting_clock_step) {
+        return 0;
+    }
+
+    mali_clock_set(setting_clock_step);
+
+    cur_gpu_clk_index = setting_clock_step;
+    printk("set cur_gpu_clk_index =%d\n", cur_gpu_clk_index);
+
+    return 0;
+}
+int mali_meson_init_start(struct platform_device* ptr_plt_dev)
 {
-#ifdef CONFIG_GPU_THERMAL
-	int err;
-	struct gpufreq_cooling_device *gcdev = NULL;
+    struct mali_gpu_device_data* pdev = ptr_plt_dev->dev.platform_data;
+
+
+    /* for resource data. */
+    ptr_plt_dev->num_resources = ARRAY_SIZE(mali_gpu_resources);
+    ptr_plt_dev->resource = mali_gpu_resources;
+
+    /*for dvfs*/
+#ifndef CONFIG_MALI_DVFS
+    /* for mali platform data. */
+    pdev->control_interval = 200;
+    pdev->utilization_callback = mali_gpu_utilization_callback;
+#else
+    pdev->get_clock_info = meson_platform_get_clock_info;
+    pdev->get_freq = meson_platform_get_freq;
+    pdev->set_freq = meson_platform_set_freq;
 #endif
-	if (mali_core_scaling_init(&mali_plat_data) < 0)
-		return -1;
 
-#ifdef CONFIG_GPU_THERMAL
-	gcdev = gpufreq_cooling_alloc();
-	if(IS_ERR(gcdev))
-		printk("malloc gpu cooling buffer error!!\n");
-	else if(!gcdev)
-		printk("system does not enable thermal driver\n");
-	else {
-		gcdev->get_gpu_freq_level = get_mali_freq_level;
-		gcdev->get_gpu_max_level = get_mali_max_level;
-		gcdev->set_gpu_freq_idx = set_limit_mali_freq;
-		gcdev->get_gpu_current_max_level = get_limit_mali_freq;
-		err = gpufreq_cooling_register(gcdev);
-		if(err < 0)
-			printk("register GPU  cooling error\n");
-		printk("gpu cooling register okay with err=%d\n",err);
-	}
+    return mali_clock_init(&mali_plat_data);
+}
 
+int mali_meson_init_finish(struct platform_device* ptr_plt_dev)
+{
+#ifndef CONFIG_MALI_DVFS
+    if (mali_core_scaling_init(&mali_plat_data) < 0)
+        return -1;
 #endif
-	return 0;
+    return 0;
 }
 
 int mali_meson_uninit(struct platform_device* ptr_plt_dev)
 {
-	return 0;
+    return 0;
 }
 
 static int mali_cri_light_suspend(size_t param)
 {
-	int ret;
-	struct device *device;
-	struct mali_pmu_core *pmu;
-
-	ret = 0;
-	mali_pm_statue = 0;
-	device = (struct device *)param;
-	pmu = mali_pmu_get_global_pmu_core();
-
-	if (NULL != device->driver &&
-	    NULL != device->driver->pm &&
-	    NULL != device->driver->pm->runtime_suspend)
-	{
-		/* Need to notify Mali driver about this event */
-		ret = device->driver->pm->runtime_suspend(device);
-	}
-	//mali_pmu_power_down_all(pmu);
-	return ret;
+    int ret;
+    struct device *device;
+    struct mali_pmu_core *pmu;
+
+    ret = 0;
+    mali_pm_statue = 1;
+    device = (struct device *)param;
+    pmu = mali_pmu_get_global_pmu_core();
+
+    if (NULL != device->driver &&
+            NULL != device->driver->pm &&
+            NULL != device->driver->pm->runtime_suspend)
+    {
+        /* Need to notify Mali driver about this event */
+        ret = device->driver->pm->runtime_suspend(device);
+    }
+    mali_pmu_power_down_all(pmu);
+    return ret;
 }
 
 static int mali_cri_light_resume(size_t param)
 {
-	int ret;
-	struct device *device;
-	struct mali_pmu_core *pmu;
-
-	ret = 0;
-	device = (struct device *)param;
-	pmu = mali_pmu_get_global_pmu_core();
-
-	//mali_pmu_power_up_all(pmu);
-	if (NULL != device->driver &&
-	    NULL != device->driver->pm &&
-	    NULL != device->driver->pm->runtime_resume)
-	{
-		/* Need to notify Mali driver about this event */
-		ret = device->driver->pm->runtime_resume(device);
-	}
-	mali_pm_statue = 1;
-	return ret;
+    int ret;
+    struct device *device;
+    struct mali_pmu_core *pmu;
+
+    ret = 0;
+    device = (struct device *)param;
+    pmu = mali_pmu_get_global_pmu_core();
+
+    mali_pmu_power_up_all(pmu);
+    if (NULL != device->driver &&
+            NULL != device->driver->pm &&
+            NULL != device->driver->pm->runtime_resume)
+    {
+        /* Need to notify Mali driver about this event */
+        ret = device->driver->pm->runtime_resume(device);
+    }
+    mali_pm_statue = 0;
+    return ret;
 }
 
 static int mali_cri_deep_suspend(size_t param)
 {
-	int ret;
-	struct device *device;
-	struct mali_pmu_core *pmu;
-
-	ret = 0;
-	device = (struct device *)param;
-	pmu = mali_pmu_get_global_pmu_core();
-
-	if (NULL != device->driver &&
-	    NULL != device->driver->pm &&
-	    NULL != device->driver->pm->suspend)
-	{
-		/* Need to notify Mali driver about this event */
-		ret = device->driver->pm->suspend(device);
-	}
-	mali_pmu_power_down_all(pmu);
-	return ret;
+    int ret;
+    struct device *device;
+    struct mali_pmu_core *pmu;
+
+    ret = 0;
+    device = (struct device *)param;
+    pmu = mali_pmu_get_global_pmu_core();
+
+    if (NULL != device->driver &&
+            NULL != device->driver->pm &&
+            NULL != device->driver->pm->suspend)
+    {
+        /* Need to notify Mali driver about this event */
+        ret = device->driver->pm->suspend(device);
+    }
+    mali_pmu_power_down_all(pmu);
+    return ret;
 }
 
 static int mali_cri_deep_resume(size_t param)
 {
-	int ret;
-	struct device *device;
-	struct mali_pmu_core *pmu;
-
-	ret = 0;
-	device = (struct device *)param;
-	pmu = mali_pmu_get_global_pmu_core();
-
-	mali_pmu_power_up_all(pmu);
-	if (NULL != device->driver &&
-	    NULL != device->driver->pm &&
-	    NULL != device->driver->pm->resume)
-	{
-		/* Need to notify Mali driver about this event */
-		ret = device->driver->pm->resume(device);
-	}
-	return ret;
+    int ret;
+    struct device *device;
+    struct mali_pmu_core *pmu;
+
+    ret = 0;
+    device = (struct device *)param;
+    pmu = mali_pmu_get_global_pmu_core();
+
+    mali_pmu_power_up_all(pmu);
+    if (NULL != device->driver &&
+            NULL != device->driver->pm &&
+            NULL != device->driver->pm->resume)
+    {
+        /* Need to notify Mali driver about this event */
+        ret = device->driver->pm->resume(device);
+    }
+    return ret;
 
 }
 
 int mali_light_suspend(struct device *device)
 {
-	int ret = 0;
+    int ret = 0;
 #ifdef CONFIG_MALI400_PROFILING
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-					MALI_PROFILING_EVENT_CHANNEL_GPU |
-					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-					0, 0,	0,	0,	0);
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+            MALI_PROFILING_EVENT_CHANNEL_GPU |
+            MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+            0, 0, 0, 0, 0);
 #endif
 
-	/* clock scaling. Kasin..*/
-	ret = mali_clock_critical(mali_cri_light_suspend, (size_t)device);
-	disable_clock();
-	return ret;
+    /* clock scaling. Kasin..*/
+    ret = mali_clock_critical(mali_cri_light_suspend, (size_t)device);
+    disable_clock();
+    return ret;
 }
 
 int mali_light_resume(struct device *device)
 {
-	int ret = 0;
-	enable_clock();
-	ret = mali_clock_critical(mali_cri_light_resume, (size_t)device);
+    int ret = 0;
+    enable_clock();
+    ret = mali_clock_critical(mali_cri_light_resume, (size_t)device);
 #ifdef CONFIG_MALI400_PROFILING
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-					MALI_PROFILING_EVENT_CHANNEL_GPU |
-					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-					get_current_frequency(), 0,	0,	0,	0);
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+            MALI_PROFILING_EVENT_CHANNEL_GPU |
+            MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+            get_current_frequency(), 0, 0, 0, 0);
 #endif
-	return ret;
+    return ret;
 }
 
 int mali_deep_suspend(struct device *device)
 {
-	int ret = 0;
-	enable_clock();
-	flush_scaling_job();
-
-	/* clock scaling off. Kasin... */
-	ret = mali_clock_critical(mali_cri_deep_suspend, (size_t)device);
-	disable_clock();
-	return ret;
+    int ret = 0;
+    struct mali_pmu_core *pmu;
+
+    mali_pm_statue = 1;
+    pmu = mali_pmu_get_global_pmu_core();
+    enable_clock();
+#ifndef CONFIG_MALI_DVFS
+    flush_scaling_job();
+#endif
+
+    /* clock scaling off. Kasin... */
+    ret = mali_clock_critical(mali_cri_deep_suspend, (size_t)device);
+    disable_clock();
+    return ret;
 }
 
 int mali_deep_resume(struct device *device)
 {
-	int ret = 0;
-
-	/* clock scaling up. Kasin.. */
-	enable_clock();
-	ret = mali_clock_critical(mali_cri_deep_resume, (size_t)device);
-	return ret;
+    int ret = 0;
 
+    /* clock scaling up. Kasin.. */
+    enable_clock();
+    ret = mali_clock_critical(mali_cri_deep_resume, (size_t)device);
+    mali_pm_statue = 0;
+    return ret;
 }
 
+void mali_post_init(void)
+{
+#ifdef CONFIG_GPU_THERMAL
+    int err;
+    struct gpufreq_cooling_device *gcdev = NULL;
+    struct gpucore_cooling_device *gccdev = NULL;
+
+    gcdev = gpufreq_cooling_alloc();
+    register_gpu_freq_info(get_current_frequency);
+    if (IS_ERR(gcdev))
+        printk("malloc gpu cooling buffer error!!\n");
+    else if (!gcdev)
+        printk("system does not enable thermal driver\n");
+    else {
+        gcdev->get_gpu_freq_level = get_mali_freq_level;
+        gcdev->get_gpu_max_level = get_mali_max_level;
+        gcdev->set_gpu_freq_idx = set_limit_mali_freq;
+        gcdev->get_gpu_current_max_level = get_limit_mali_freq;
+        err = gpufreq_cooling_register(gcdev);
+        if (err < 0)
+            printk("register GPU  cooling error\n");
+        printk("gpu cooling register okay with err=%d\n",err);
+    }
+
+    gccdev = gpucore_cooling_alloc();
+    if (IS_ERR(gccdev))
+        printk("malloc gpu core cooling buffer error!!\n");
+    else if (!gccdev)
+        printk("system does not enable thermal driver\n");
+    else {
+        gccdev->max_gpu_core_num=mali_plat_data.cfg_pp;
+        gccdev->set_max_pp_num=set_limit_pp_num;
+        err = (int)gpucore_cooling_register(gccdev);
+        if (err < 0)
+            printk("register GPU  cooling error\n");
+        printk("gpu core cooling register okay with err=%d\n",err);
+    }
+#endif
+}
diff --git a/drivers/gpu/arm/mali/platform/meson_m450/scaling.c b/drivers/gpu/arm/mali/platform/meson_m450/scaling.c
index 6129f5e4..d81a88db 100644
--- a/drivers/gpu/arm/mali/platform/meson_m450/scaling.c
+++ b/drivers/gpu/arm/mali/platform/meson_m450/scaling.c
@@ -1,9 +1,9 @@
 /*
  * Copyright (C) 2013 ARM Limited. All rights reserved.
- * 
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -17,372 +17,439 @@
 #include <linux/module.h>
 #include <linux/workqueue.h>
 #include <linux/mali/mali_utgard.h>
-#include "mali_kernel_common.h"
-#include "common/mali_osk_profiling.h"
-#include "common/mali_kernel_utilization.h"
-#include "common/mali_pp_scheduler.h"
+#include <mali_kernel_common.h>
+#include <mali_osk_profiling.h>
 
 #include <meson_main.h>
 
 #define LOG_MALI_SCALING 0
 
-static int num_cores_enabled;
+
 static int currentStep;
+#ifndef CONFIG_MALI_DVFS
+static int num_cores_enabled;
 static int lastStep;
 static struct work_struct wq_work;
 static mali_plat_info_t* pmali_plat = NULL;
-static int  scaling_mode = MALI_PP_FS_SCALING;
+#endif
+static int  scaling_mode = MALI_TURBO_MODE;
+
 
+static unsigned scaling_dbg_level = 0;
+module_param(scaling_dbg_level, uint, 0644);
+MODULE_PARM_DESC(scaling_dbg_level , "scaling debug level");
+
+#define scalingdbg(level, fmt, arg...)                      \
+    do {                                                    \
+        if (scaling_dbg_level >= (level))                   \
+        printk(fmt , ## arg);                           \
+    } while (0)
+
+#ifndef CONFIG_MALI_DVFS
 static void do_scaling(struct work_struct *work)
 {
-	mali_dvfs_threshold_table * pdvfs = pmali_plat->dvfs_table;
-	int err = mali_perf_set_num_pp_cores(num_cores_enabled);
-	MALI_DEBUG_ASSERT(0 == err);
-	MALI_IGNORE(err);
-	if (pdvfs[currentStep].freq_index != pdvfs[lastStep].freq_index) {
-		mali_dev_pause();
-		mali_clock_set(pdvfs[currentStep].freq_index);
-		mali_dev_resume();
-		lastStep = currentStep;
-	}
+    mali_dvfs_threshold_table * pdvfs = pmali_plat->dvfs_table;
+    int err = mali_perf_set_num_pp_cores(num_cores_enabled);
+    scalingdbg(1, "set pp cores to %d\n", num_cores_enabled);
+    MALI_DEBUG_ASSERT(0 == err);
+    MALI_IGNORE(err);
+    if (pdvfs[currentStep].freq_index != pdvfs[lastStep].freq_index) {
+        mali_dev_pause();
+        mali_clock_set(pdvfs[currentStep].freq_index);
+        mali_dev_resume();
+        lastStep = currentStep;
+    }
 #ifdef CONFIG_MALI400_PROFILING
-	_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-					MALI_PROFILING_EVENT_CHANNEL_GPU |
-					MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-					get_current_frequency(),
-					0,	0,	0,	0);
+    _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+            MALI_PROFILING_EVENT_CHANNEL_GPU |
+            MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+            get_current_frequency(),
+            0,	0,	0,	0);
 #endif
 }
+#endif
 
 u32 revise_set_clk(u32 val, u32 flush)
 {
-	mali_scale_info_t* pinfo;
-	u32 ret = 0;
-
-	pinfo = &pmali_plat->scale_info;
-
-	if (val < pinfo->minclk)
-		val = pinfo->minclk;
-	else if (val >  pinfo->maxclk)
-		val =  pinfo->maxclk;
-
-	if (val != currentStep) {
-		currentStep = val;
-		if (flush)
-			schedule_work(&wq_work);
-		else
-			ret = 1;
-	}
-
-	return ret;
+    u32 ret = 0;
+#ifndef CONFIG_MALI_DVFS
+    mali_scale_info_t* pinfo;
+
+    pinfo = &pmali_plat->scale_info;
+
+    if (val < pinfo->minclk)
+        val = pinfo->minclk;
+    else if (val >  pinfo->maxclk)
+        val =  pinfo->maxclk;
+
+    if (val != currentStep) {
+        currentStep = val;
+        if (flush)
+            schedule_work(&wq_work);
+        else
+            ret = 1;
+    }
+#endif
+    return ret;
 }
 
 void get_mali_rt_clkpp(u32* clk, u32* pp)
 {
-	*clk = currentStep;
-	*pp = num_cores_enabled;
+#ifndef CONFIG_MALI_DVFS
+    *clk = currentStep;
+    *pp = num_cores_enabled;
+#endif
 }
 
 u32 set_mali_rt_clkpp(u32 clk, u32 pp, u32 flush)
 {
-	mali_scale_info_t* pinfo;
-	u32 ret = 0;
-	u32 flush_work = 0;
-
-	pinfo = &pmali_plat->scale_info;
-	if (clk < pinfo->minclk)
-		clk = pinfo->minclk;
-	else if (clk >  pinfo->maxclk)
-		clk =  pinfo->maxclk;
-
-	if (clk != currentStep) {
-		currentStep = clk;
-		if (flush)
-			flush_work++;
-		else
-			ret = 1;
-	}
-	if (pp < pinfo->minpp)
-		pp = pinfo->minpp;
-	else if (pp > pinfo->maxpp)
-		pp = pinfo->maxpp;
-
-	if (pp != num_cores_enabled) {
-		num_cores_enabled = pp;
-		if (flush)
-			flush_work++;
-		else
-			ret = 1;
-	}
-
-	if (flush_work)
-		schedule_work(&wq_work);
-	return ret;
+    u32 ret = 0;
+#ifndef CONFIG_MALI_DVFS
+    mali_scale_info_t* pinfo;
+    u32 flush_work = 0;
+
+    pinfo = &pmali_plat->scale_info;
+    if (clk < pinfo->minclk)
+        clk = pinfo->minclk;
+    else if (clk >  pinfo->maxclk)
+        clk =  pinfo->maxclk;
+
+    if (clk != currentStep) {
+        currentStep = clk;
+        if (flush)
+            flush_work++;
+        else
+            ret = 1;
+    }
+    if (pp < pinfo->minpp)
+        pp = pinfo->minpp;
+    else if (pp > pinfo->maxpp)
+        pp = pinfo->maxpp;
+
+    if (pp != num_cores_enabled) {
+        num_cores_enabled = pp;
+        if (flush)
+            flush_work++;
+        else
+            ret = 1;
+    }
+
+    if (flush_work)
+        schedule_work(&wq_work);
+#endif
+    return ret;
 }
 
 void revise_mali_rt(void)
 {
-	set_mali_rt_clkpp(currentStep, num_cores_enabled, 1);
+#ifndef CONFIG_MALI_DVFS
+    set_mali_rt_clkpp(currentStep, num_cores_enabled, 1);
+#endif
 }
 
 void flush_scaling_job(void)
 {
-	cancel_work_sync(&wq_work);
+#ifndef CONFIG_MALI_DVFS
+    cancel_work_sync(&wq_work);
+#endif
 }
 
+#ifndef CONFIG_MALI_DVFS
 static u32 enable_one_core(void)
 {
-	return set_mali_rt_clkpp(currentStep, num_cores_enabled + 1, 0);
+    scalingdbg(2, "meson:     one more pp, curent has %d pp cores\n",  num_cores_enabled + 1);
+    return set_mali_rt_clkpp(currentStep, num_cores_enabled + 1, 0);
 }
 
 static u32 disable_one_core(void)
 {
-	return set_mali_rt_clkpp(currentStep, num_cores_enabled - 1, 0);
+    scalingdbg(2, "meson: disable one pp, current has %d pp cores\n",  num_cores_enabled - 1);
+    return set_mali_rt_clkpp(currentStep, num_cores_enabled - 1, 0);
 }
 
 static u32 enable_max_num_cores(void)
 {
-	return set_mali_rt_clkpp(currentStep, pmali_plat->scale_info.maxpp, 0);
+    return set_mali_rt_clkpp(currentStep, pmali_plat->scale_info.maxpp, 0);
 }
 
 static u32 enable_pp_cores(u32 val)
 {
-	return set_mali_rt_clkpp(currentStep, val, 0);
+    scalingdbg(2, "meson: enable %d pp cores\n", val);
+    return set_mali_rt_clkpp(currentStep, val, 0);
 }
+#endif
 
 int mali_core_scaling_init(mali_plat_info_t *mali_plat)
 {
-	if (mali_plat == NULL) {
-		printk(" Mali platform data is NULL!!!\n");
-		return -1;
-	}
-
-	pmali_plat = mali_plat;
-	num_cores_enabled = pmali_plat->sc_mpp;
-
-	currentStep = pmali_plat->def_clock;
-	lastStep = currentStep;
-	INIT_WORK(&wq_work, do_scaling);
-
-	return 0;
-	/* NOTE: Mali is not fully initialized at this point. */
+#ifndef CONFIG_MALI_DVFS
+    if (mali_plat == NULL) {
+        scalingdbg(2, " Mali platform data is NULL!!!\n");
+        return -1;
+    }
+
+    pmali_plat = mali_plat;
+    num_cores_enabled = pmali_plat->sc_mpp;
+
+    currentStep = pmali_plat->def_clock;
+    lastStep = currentStep;
+    INIT_WORK(&wq_work, do_scaling);
+#endif
+    return 0;
+    /* NOTE: Mali is not fully initialized at this point. */
 }
 
 void mali_core_scaling_term(void)
 {
-	flush_scheduled_work();
+#ifndef CONFIG_MALI_DVFS
+    flush_scheduled_work();
+#endif
 }
 
+#ifndef CONFIG_MALI_DVFS
 static u32 mali_threshold [] = {
-	102, /* 40% */
-	128, /* 50% */
-	230, /* 90% */
+    102, /* 40% */
+    128, /* 50% */
+    230, /* 90% */
 };
+#endif
 
 void mali_pp_scaling_update(struct mali_gpu_utilization_data *data)
 {
-	int ret = 0;
-
-	if (mali_threshold[2] < data->utilization_pp)
-		ret = enable_max_num_cores();
-	else if (mali_threshold[1]< data->utilization_pp)
-		ret = enable_one_core();
-	else if (0 < data->utilization_pp)
-		ret = disable_one_core();
-	if (ret == 1)
-		schedule_work(&wq_work);
+#ifndef CONFIG_MALI_DVFS
+    int ret = 0;
+
+    if (mali_threshold[2] < data->utilization_pp)
+        ret = enable_max_num_cores();
+    else if (mali_threshold[1]< data->utilization_pp)
+        ret = enable_one_core();
+    else if (0 < data->utilization_pp)
+        ret = disable_one_core();
+    if (ret == 1)
+        schedule_work(&wq_work);
+#endif
 }
 
 #if LOG_MALI_SCALING
 void trace_utilization(struct mali_gpu_utilization_data *data, u32 current_idx, u32 next,
-	u32 current_pp, u32 next_pp)
+        u32 current_pp, u32 next_pp)
 {
-	char direction;
-	if (next > current_idx)
-		direction = '>';
-	else if ((current_idx > pmali_plat->scale_info.minpp) && (next < current_idx))
-		direction = '<';
-	else
-		direction = '~';
-
-	printk("[SCALING]%c (%3d-->%3d)@%3d{%3d - %3d}. pp:(%d-->%d)\n",
-				direction,
-				get_mali_freq(current_idx),
-				get_mali_freq(next),
-				data->utilization_gpu,
-				pmali_plat->dvfs_table[current_idx].downthreshold,
-				pmali_plat->dvfs_table[current_idx].upthreshold,
-				current_pp, next_pp);
+    char direction;
+    if (next > current_idx)
+        direction = '>';
+    else if ((current_idx > pmali_plat->scale_info.minpp) && (next < current_idx))
+        direction = '<';
+    else
+        direction = '~';
+
+    scalingdbg(2, "[SCALING]%c (%3d-->%3d)@%3d{%3d - %3d}. pp:(%d-->%d)\n",
+            direction,
+            get_mali_freq(current_idx),
+            get_mali_freq(next),
+            data->utilization_gpu,
+            pmali_plat->dvfs_table[current_idx].downthreshold,
+            pmali_plat->dvfs_table[current_idx].upthreshold,
+            current_pp, next_pp);
 }
 #endif
 
+#ifndef CONFIG_MALI_DVFS
 static int mali_stay_count = 0;
 static void mali_decide_next_status(struct mali_gpu_utilization_data *data, int* next_fs_idx,
-								int* pp_change_flag)
+        int* pp_change_flag)
 {
-	u32 utilization, mali_up_limit, decided_fs_idx;
-	u32 ld_left, ld_right;
-	u32 ld_up, ld_down;
-	char change_mode;
-
-	*pp_change_flag = 0;
-	change_mode = 0;
-	utilization = 255;
-
-	mali_up_limit = (scaling_mode ==  MALI_TURBO_MODE) ?
-				pmali_plat->turbo_clock : pmali_plat->scale_info.maxclk;
-	decided_fs_idx = currentStep;
-
-	ld_up = pmali_plat->dvfs_table[currentStep].upthreshold;
-	ld_down = pmali_plat->dvfs_table[currentStep].downthreshold;
-	if (utilization >= ld_up) { /* go up */
-		if (currentStep < mali_up_limit) {
-			change_mode = 1;
-			if ((currentStep < pmali_plat->def_clock) && (utilization > pmali_plat->bst_gpu))
-				decided_fs_idx = pmali_plat->def_clock;
-			else
-				decided_fs_idx++;
-		}
-		if ((data->utilization_pp > ld_up) &&
-				(num_cores_enabled < pmali_plat->scale_info.maxpp)) {
-			if ((num_cores_enabled < pmali_plat->sc_mpp) && (data->utilization_pp >= pmali_plat->bst_pp)) {
-				*pp_change_flag = 1;
-				change_mode = 1;
-			} else if (change_mode == 0) {
-				*pp_change_flag = 2;
-				change_mode = 1;
-			}
-		}
-	} else if (utilization <= ld_down) { /* go down */
-		if (mali_stay_count > 0) {
-			*next_fs_idx = decided_fs_idx;
-			mali_stay_count--;
-			return;
-		}
-
-		if (num_cores_enabled > pmali_plat->sc_mpp) {
-			change_mode = 1;
-			if (data->utilization_pp <= ld_down) {
-				ld_left = data->utilization_pp * num_cores_enabled;
-				ld_right = (pmali_plat->dvfs_table[currentStep].upthreshold) *
-								(num_cores_enabled - 1);
-				if (ld_left < ld_right) {
-					change_mode = 2;
-				}
-			}
-		} else if (currentStep > pmali_plat->scale_info.minpp) {
-			change_mode = 1;
-		} else if (num_cores_enabled > 1) { /* decrease PPS */
-			if (data->utilization_pp <= ld_down) {
-				ld_left = data->utilization_pp * num_cores_enabled;
-				ld_right = (pmali_plat->dvfs_table[currentStep].upthreshold) *
-								(num_cores_enabled - 1);
-				if (ld_left < ld_right) {
-					change_mode = 2;
-				}
-			}
-		}
-
-		if (change_mode == 1) {
-			decided_fs_idx--;
-		} else if (change_mode == 2) { /* decrease PPS */
-			*pp_change_flag = -1;
-		}
-	}
-	if (change_mode)
-		mali_stay_count = pmali_plat->dvfs_table[decided_fs_idx].keep_count;
-	*next_fs_idx = decided_fs_idx;
+    u32 utilization, mali_up_limit, decided_fs_idx;
+    u32 ld_left, ld_right;
+    u32 ld_up, ld_down;
+    u32 change_mode;
+
+    *pp_change_flag = 0;
+    change_mode = 0;
+    utilization = data->utilization_gpu;
+
+    mali_up_limit = (scaling_mode ==  MALI_TURBO_MODE) ?
+        pmali_plat->turbo_clock : pmali_plat->scale_info.maxclk;
+    decided_fs_idx = currentStep;
+
+    ld_up = pmali_plat->dvfs_table[currentStep].upthreshold;
+    ld_down = pmali_plat->dvfs_table[currentStep].downthreshold;
+
+    scalingdbg(2, "utilization=%d,  ld_up=%d\n ", utilization,  ld_up);
+    if (utilization >= ld_up) { /* go up */
+
+        scalingdbg(2, "currentStep=%d,  mali_up_limit=%d\n ", currentStep, mali_up_limit);
+        if (currentStep < mali_up_limit) {
+            change_mode = 1;
+            if ((currentStep < pmali_plat->def_clock) && (utilization > pmali_plat->bst_gpu))
+                decided_fs_idx = pmali_plat->def_clock;
+            else
+                decided_fs_idx++;
+        }
+        if ((data->utilization_pp >= ld_up) &&
+                (num_cores_enabled < pmali_plat->scale_info.maxpp)) {
+            if ((num_cores_enabled < pmali_plat->sc_mpp) && (data->utilization_pp >= pmali_plat->bst_pp)) {
+                *pp_change_flag = 1;
+                change_mode = 1;
+            } else if (change_mode == 0) {
+                *pp_change_flag = 2;
+                change_mode = 1;
+            }
+        }
+#if LOG_MALI_SCALING
+        scalingdbg(2, "[nexting..] [LD:%d]-> FS[CRNT:%d LMT:%d NEXT:%d] PP[NUM:%d LMT:%d MD:%d][F:%d]\n",
+                data->utilization_pp, currentStep, mali_up_limit, decided_fs_idx,
+                num_cores_enabled, pmali_plat->scale_info.maxpp, *pp_change_flag, change_mode);
+#endif
+    } else if (utilization <= ld_down) { /* go down */
+        if (mali_stay_count > 0) {
+            *next_fs_idx = decided_fs_idx;
+            mali_stay_count--;
+            return;
+        }
+
+        if (num_cores_enabled > pmali_plat->sc_mpp) {
+            change_mode = 1;
+            if (data->utilization_pp <= ld_down) {
+                ld_left = data->utilization_pp * num_cores_enabled;
+                ld_right = (pmali_plat->dvfs_table[currentStep].upthreshold) *
+                    (num_cores_enabled - 1);
+                if (ld_left < ld_right) {
+                    change_mode = 2;
+                }
+            }
+        } else if (currentStep > pmali_plat->scale_info.minclk) {
+            change_mode = 1;
+        } else if (num_cores_enabled > 1) { /* decrease PPS */
+            if (data->utilization_pp <= ld_down) {
+                ld_left = data->utilization_pp * num_cores_enabled;
+                ld_right = (pmali_plat->dvfs_table[currentStep].upthreshold) *
+                    (num_cores_enabled - 1);
+                scalingdbg(2, "ld_left=%d, ld_right=%d\n", ld_left, ld_right);
+                if (ld_left < ld_right) {
+                    change_mode = 2;
+                }
+            }
+        }
+
+        if (change_mode == 1) {
+            decided_fs_idx--;
+        } else if (change_mode == 2) { /* decrease PPS */
+            *pp_change_flag = -1;
+        }
+    }
+    if (change_mode)
+        mali_stay_count = pmali_plat->dvfs_table[decided_fs_idx].keep_count;
+    *next_fs_idx = decided_fs_idx;
 }
+#endif
 
 void mali_pp_fs_scaling_update(struct mali_gpu_utilization_data *data)
 {
-	int ret = 0;
-	int pp_change_flag = 0;
-	u32 next_idx = 0;
-	
+#ifndef CONFIG_MALI_DVFS
+    int ret = 0;
+    int pp_change_flag = 0;
+    u32 next_idx = 0;
+
 #if LOG_MALI_SCALING
-	u32 last_pp = num_cores_enabled;
+    u32 last_pp = num_cores_enabled;
 #endif
-	mali_decide_next_status(data, &next_idx, &pp_change_flag);
+    mali_decide_next_status(data, &next_idx, &pp_change_flag);
 
-	if (pp_change_flag == 1)
-		ret = enable_pp_cores(pmali_plat->sc_mpp);
-	else if (pp_change_flag == 2)
-		ret = enable_one_core();
-	else if (pp_change_flag == -1) {
-		ret = disable_one_core();
-	}
+    if (pp_change_flag == 1)
+        ret = enable_pp_cores(pmali_plat->sc_mpp);
+    else if (pp_change_flag == 2)
+        ret = enable_one_core();
+    else if (pp_change_flag == -1) {
+        ret = disable_one_core();
+    }
 
 #if LOG_MALI_SCALING
-	if (pp_change_flag || (next_idx != currentStep))
-		trace_utilization(data, currentStep, next_idx, last_pp, num_cores_enabled);
+    if (pp_change_flag || (next_idx != currentStep))
+        trace_utilization(data, currentStep, next_idx, last_pp, num_cores_enabled);
 #endif
 
-	if (next_idx != currentStep) {
-		ret = 1;
-		currentStep = next_idx;
-	}
+    if (next_idx != currentStep) {
+        ret = 1;
+        currentStep = next_idx;
+    }
 
-	if (ret == 1)
-		schedule_work(&wq_work);
+    if (ret == 1)
+        schedule_work(&wq_work);
 #ifdef CONFIG_MALI400_PROFILING
-	else
-		_mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
-						MALI_PROFILING_EVENT_CHANNEL_GPU |
-						MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
-						get_current_frequency(),
-						0,	0,	0,	0);
+    else
+        _mali_osk_profiling_add_event(MALI_PROFILING_EVENT_TYPE_SINGLE |
+                MALI_PROFILING_EVENT_CHANNEL_GPU |
+                MALI_PROFILING_EVENT_REASON_SINGLE_GPU_FREQ_VOLT_CHANGE,
+                get_current_frequency(),
+                0,	0,	0,	0);
+#endif
 #endif
 }
 
 u32 get_mali_schel_mode(void)
 {
-	return scaling_mode;
+    return scaling_mode;
 }
 
 void set_mali_schel_mode(u32 mode)
 {
-	MALI_DEBUG_ASSERT(mode < MALI_SCALING_MODE_MAX);
-	if (mode >= MALI_SCALING_MODE_MAX)
-		return;
-	scaling_mode = MALI_TURBO_MODE;
-
-	/* set default performance range. */
-	pmali_plat->scale_info.minclk = pmali_plat->cfg_min_clock;
-	pmali_plat->scale_info.maxclk = pmali_plat->cfg_clock;
-	pmali_plat->scale_info.minpp = pmali_plat->cfg_min_pp;
-	pmali_plat->scale_info.maxpp = pmali_plat->cfg_pp;
-
-	/* set current status and tune max freq */
-	if (scaling_mode == MALI_PP_FS_SCALING) {
-		pmali_plat->scale_info.maxclk = pmali_plat->cfg_clock;
-		enable_pp_cores(pmali_plat->sc_mpp);
-	} else if (scaling_mode == MALI_SCALING_DISABLE) {
-		pmali_plat->scale_info.maxclk = pmali_plat->cfg_clock;
-		enable_max_num_cores();
-	} else if (scaling_mode == MALI_TURBO_MODE) {
-		pmali_plat->scale_info.maxclk = pmali_plat->turbo_clock;
-		enable_max_num_cores();
-	}
-	currentStep = pmali_plat->scale_info.maxclk;
-	schedule_work(&wq_work);
+#ifndef CONFIG_MALI_DVFS
+    MALI_DEBUG_ASSERT(mode < MALI_SCALING_MODE_MAX);
+    if (mode >= MALI_SCALING_MODE_MAX)
+        return;
+    scaling_mode = mode;
+
+    /* set default performance range. */
+    pmali_plat->scale_info.minclk = pmali_plat->cfg_min_clock;
+    pmali_plat->scale_info.maxclk = pmali_plat->cfg_clock;
+    pmali_plat->scale_info.minpp = pmali_plat->cfg_min_pp;
+    pmali_plat->scale_info.maxpp = pmali_plat->cfg_pp;
+
+    /* set current status and tune max freq */
+    if (scaling_mode == MALI_PP_FS_SCALING) {
+        pmali_plat->scale_info.maxclk = pmali_plat->cfg_clock;
+        enable_pp_cores(pmali_plat->sc_mpp);
+    } else if (scaling_mode == MALI_SCALING_DISABLE) {
+        pmali_plat->scale_info.maxclk = pmali_plat->cfg_clock;
+        enable_max_num_cores();
+    } else if (scaling_mode == MALI_TURBO_MODE) {
+        pmali_plat->scale_info.maxclk = pmali_plat->turbo_clock;
+        enable_max_num_cores();
+    }
+    currentStep = pmali_plat->scale_info.maxclk;
+    schedule_work(&wq_work);
+#endif
 }
 
 u32 get_current_frequency(void)
 {
-	return get_mali_freq(currentStep);
+    return get_mali_freq(currentStep);
 }
 
 void mali_gpu_utilization_callback(struct mali_gpu_utilization_data *data)
 {
-	switch (scaling_mode) {
-	case MALI_PP_FS_SCALING:
-		mali_pp_fs_scaling_update(data);
-		break;
-	case MALI_PP_SCALING:
-		mali_pp_scaling_update(data);
-		break;
-	default:
-		break;
-	}
+#ifndef CONFIG_MALI_DVFS
+    if (mali_pm_statue)
+        return;
+
+    switch (scaling_mode) {
+        case MALI_PP_FS_SCALING:
+            mali_pp_fs_scaling_update(data);
+            break;
+        case MALI_PP_SCALING:
+            mali_pp_scaling_update(data);
+            break;
+        default:
+            break;
+    }
+#endif
+}
+
+void mali_dev_restore(void)
+{
+#ifndef CONFIG_MALI_DVFS
+    mali_dvfs_threshold_table * pdvfs = pmali_plat->dvfs_table;
+
+    //mali_perf_set_num_pp_cores(num_cores_enabled);
+    mali_clock_set(pdvfs[currentStep].freq_index);
+#endif
 }
diff --git a/drivers/gpu/arm/mali/platform/meson_main.c b/drivers/gpu/arm/mali/platform/meson_main.c
index 295ae79b..27a5f711 100644
--- a/drivers/gpu/arm/mali/platform/meson_main.c
+++ b/drivers/gpu/arm/mali/platform/meson_main.c
@@ -1,9 +1,9 @@
 /*
  * Copyright (C) 2010, 2012-2013 ARM Limited. All rights reserved.
- * 
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -27,16 +27,28 @@
 #include "common/mali_pmu.h"
 #include "common/mali_osk_profiling.h"
 
-int mali_pm_statue = 1;
+int mali_pm_statue = 0;
+u32 mali_gp_reset_fail = 0;
+module_param(mali_gp_reset_fail, int, S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH); /* rw-rw-r-- */
+MODULE_PARM_DESC(mali_gp_reset_fail, "times of failed to reset GP");
+u32 mali_core_timeout = 0;
+module_param(mali_core_timeout, int, S_IRUSR | S_IWUSR | S_IWGRP | S_IRGRP | S_IROTH); /* rw-rw-r-- */
+MODULE_PARM_DESC(mali_core_timeout, "times of failed to reset GP");
 
 static struct mali_gpu_device_data mali_gpu_data =
 {
 	.shared_mem_size = 1024 * 1024 * 1024,
-	.fb_start = 0x06100000,
-	.fb_size = 0x01800000,
 	.max_job_runtime = 60000, /* 60 seconds */
 	.pmu_switch_delay = 0xFFFF, /* do not have to be this high on FPGA, but it is good for testing to have a delay */
-	.pmu_domain_config = {0x1, 0x2, 0x4, 0x4, 0x4, 0x8, 0x8, 0x8, 0x8, 0x1, 0x2, 0x8},
+#if defined(CONFIG_ARCH_MESON8B)||defined(CONFIG_ARCH_MESONG9BB)
+	.pmu_domain_config = {0x1, 0x2, 0x4, 0x0,
+						  0x0, 0x0, 0x0, 0x0,
+						  0x0, 0x1, 0x2, 0x0},
+#else
+	.pmu_domain_config = {0x1, 0x2, 0x4, 0x4,
+                          0x0, 0x8, 0x8, 0x8,
+                          0x0, 0x1, 0x2, 0x8},
+#endif
 };
 
 static void mali_platform_device_release(struct device *device);
@@ -62,6 +74,8 @@ int mali_pdev_pre_init(struct platform_device* ptr_plt_dev)
 
 void mali_pdev_post_init(struct platform_device* pdev)
 {
+	mali_gp_reset_fail = 0;
+	mali_core_timeout = 0;
 #ifdef CONFIG_PM_RUNTIME
 #if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,37))
 	pm_runtime_set_autosuspend_delay(&(pdev->dev), 1000);
@@ -118,3 +132,4 @@ static void mali_platform_device_release(struct device *device)
 	MALI_DEBUG_PRINT(4, ("mali_platform_device_release() called\n"));
 }
 
+
diff --git a/drivers/gpu/arm/mali/platform/meson_main.h b/drivers/gpu/arm/mali/platform/meson_main.h
index b30cfc78..44c31c4b 100644
--- a/drivers/gpu/arm/mali/platform/meson_main.h
+++ b/drivers/gpu/arm/mali/platform/meson_main.h
@@ -18,6 +18,7 @@
 #include "mali_clock.h"
 
 extern struct device_type mali_pm_device;
+extern int mali_pm_statue;
 
 u32 set_max_mali_freq(u32 idx);
 u32 get_max_mali_freq(void);
diff --git a/drivers/gpu/arm/mali/platform/mpgpu.c b/drivers/gpu/arm/mali/platform/mpgpu.c
index 8c63c33c..d3021bf6 100644
--- a/drivers/gpu/arm/mali/platform/mpgpu.c
+++ b/drivers/gpu/arm/mali/platform/mpgpu.c
@@ -29,19 +29,16 @@
 #include <common/mali_pmu.h>
 #include "meson_main.h"
 
-static ssize_t domain_stat_read(struct class *class, 
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+static ssize_t domain_stat_read(struct class *class,
 			struct class_attribute *attr, char *buf)
 {
 	unsigned int val;
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+
 	val = readl((u32 *)(IO_AOBUS_BASE + 0xf0)) & 0xff;
-#else
-	val = 0xffffffff;
-#endif
 	return sprintf(buf, "%x\n", val>>4);
 }
 
-#if MESON_CPU_TYPE > MESON_CPU_TYPE_MESON6TVD
 #define PREHEAT_CMD "preheat"
 #define PLL2_CMD "mpl2"  /* mpl2 [11] or [0xxxxxxx] */
 #define SCMPP_CMD "scmpp"  /* scmpp [number of pp your want in most of time]. */
@@ -101,7 +98,7 @@ static ssize_t mpgpu_write(struct class *class,
 	} else if (!strncmp(pstart, LIMIT_CMD, MAX_TOKEN)) {
 		if ((kstrtouint(cprt, 10, &val) <0) || pmali_plat == NULL)
 			goto quit;
-		
+
 		if (val < 2) {
 			pmali_plat->limit_on = val;
 			if (val == 0) {
@@ -304,11 +301,7 @@ static ssize_t current_pp_write(struct class *class,
 	return count;
 }
 
-#endif
-
-
 static struct class_attribute mali_class_attrs[] = {
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 	__ATTR(domain_stat,	0644, domain_stat_read, NULL),
 	__ATTR(mpgpucmd,	0644, NULL,		mpgpu_write),
 	__ATTR(scale_mode,	0644, scale_mode_read,  scale_mode_write),
@@ -318,19 +311,20 @@ static struct class_attribute mali_class_attrs[] = {
 	__ATTR(max_pp,		0644, max_pp_read,	max_pp_write),
 	__ATTR(cur_freq,	0644, freq_read,	freq_write),
 	__ATTR(cur_pp,		0644, current_pp_read,	current_pp_write),
-#endif
 };
 
 static struct class mpgpu_class = {
 	.name = "mpgpu",
 };
+#endif
 
 int mpgpu_class_init(void)
 {
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 	int ret = 0;
 	int i;
 	int attr_num =  ARRAY_SIZE(mali_class_attrs);
-	
+
 	ret = class_register(&mpgpu_class);
 	if (ret) {
 		printk(KERN_ERR "%s: class_register failed\n", __func__);
@@ -343,10 +337,15 @@ int mpgpu_class_init(void)
 		}
 	}
 	return ret;
+#else
+        return 0;
+#endif
 }
 
 void  mpgpu_class_exit(void)
 {
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 	class_unregister(&mpgpu_class);
+#endif
 }
 
diff --git a/drivers/gpu/arm/mali/readme.txt b/drivers/gpu/arm/mali/readme.txt
old mode 100755
new mode 100644
diff --git a/drivers/gpu/arm/mali/regs/mali_200_regs.h b/drivers/gpu/arm/mali/regs/mali_200_regs.h
old mode 100755
new mode 100644
index c904ad23..3e9ef53e
--- a/drivers/gpu/arm/mali/regs/mali_200_regs.h
+++ b/drivers/gpu/arm/mali/regs/mali_200_regs.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2012-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -25,11 +25,12 @@ enum mali200_mgmt_reg {
 	MALI200_REG_ADDR_MGMT_INT_MASK                             = 0x1028,
 	MALI200_REG_ADDR_MGMT_INT_STATUS                           = 0x102c,
 
+	MALI200_REG_ADDR_MGMT_WRITE_BOUNDARY_LOW                   = 0x1044,
+
 	MALI200_REG_ADDR_MGMT_BUS_ERROR_STATUS                     = 0x1050,
 
 	MALI200_REG_ADDR_MGMT_PERF_CNT_0_ENABLE                    = 0x1080,
 	MALI200_REG_ADDR_MGMT_PERF_CNT_0_SRC                       = 0x1084,
-	MALI200_REG_ADDR_MGMT_PERF_CNT_0_LIMIT                     = 0x1088,
 	MALI200_REG_ADDR_MGMT_PERF_CNT_0_VALUE                     = 0x108c,
 
 	MALI200_REG_ADDR_MGMT_PERF_CNT_1_ENABLE                    = 0x10a0,
@@ -124,8 +125,6 @@ enum mali200_wb_unit_regs {
 #define MALI300_PP_PRODUCT_ID 0xCE07
 #define MALI400_PP_PRODUCT_ID 0xCD07
 #define MALI450_PP_PRODUCT_ID 0xCF07
-#define MALI470_PP_PRODUCT_ID 0xCF08
-
 
 
 #endif /* _MALI200_REGS_H_ */
diff --git a/drivers/gpu/arm/mali/regs/mali_gp_regs.h b/drivers/gpu/arm/mali/regs/mali_gp_regs.h
old mode 100755
new mode 100644
index 435953d4..624776bd
--- a/drivers/gpu/arm/mali/regs/mali_gp_regs.h
+++ b/drivers/gpu/arm/mali/regs/mali_gp_regs.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2012-2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -31,13 +31,13 @@ typedef enum {
 	MALIGP2_REG_ADDR_MGMT_INT_CLEAR                 = 0x28,
 	MALIGP2_REG_ADDR_MGMT_INT_MASK                  = 0x2C,
 	MALIGP2_REG_ADDR_MGMT_INT_STAT                  = 0x30,
+	MALIGP2_REG_ADDR_MGMT_WRITE_BOUND_LOW           = 0x34,
 	MALIGP2_REG_ADDR_MGMT_PERF_CNT_0_ENABLE         = 0x3C,
 	MALIGP2_REG_ADDR_MGMT_PERF_CNT_1_ENABLE         = 0x40,
 	MALIGP2_REG_ADDR_MGMT_PERF_CNT_0_SRC            = 0x44,
 	MALIGP2_REG_ADDR_MGMT_PERF_CNT_1_SRC            = 0x48,
 	MALIGP2_REG_ADDR_MGMT_PERF_CNT_0_VALUE          = 0x4C,
 	MALIGP2_REG_ADDR_MGMT_PERF_CNT_1_VALUE          = 0x50,
-	MALIGP2_REG_ADDR_MGMT_PERF_CNT_0_LIMIT          = 0x54,
 	MALIGP2_REG_ADDR_MGMT_STATUS                    = 0x68,
 	MALIGP2_REG_ADDR_MGMT_VERSION                   = 0x6C,
 	MALIGP2_REG_ADDR_MGMT_VSCL_START_ADDR_READ      = 0x80,
diff --git a/drivers/gpu/arm/mali/timestamp-arm11-cc/mali_timestamp.c b/drivers/gpu/arm/mali/timestamp-arm11-cc/mali_timestamp.c
old mode 100755
new mode 100644
index f7f7baf4..3e74343b
--- a/drivers/gpu/arm/mali/timestamp-arm11-cc/mali_timestamp.c
+++ b/drivers/gpu/arm/mali/timestamp-arm11-cc/mali_timestamp.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2011, 2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2011, 2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/timestamp-arm11-cc/mali_timestamp.h b/drivers/gpu/arm/mali/timestamp-arm11-cc/mali_timestamp.h
old mode 100755
new mode 100644
index 757f6433..410910b9
--- a/drivers/gpu/arm/mali/timestamp-arm11-cc/mali_timestamp.h
+++ b/drivers/gpu/arm/mali/timestamp-arm11-cc/mali_timestamp.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2011, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/timestamp-default/mali_timestamp.c b/drivers/gpu/arm/mali/timestamp-default/mali_timestamp.c
old mode 100755
new mode 100644
index f7f7baf4..3e74343b
--- a/drivers/gpu/arm/mali/timestamp-default/mali_timestamp.c
+++ b/drivers/gpu/arm/mali/timestamp-default/mali_timestamp.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2011, 2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2011, 2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/mali/timestamp-default/mali_timestamp.h b/drivers/gpu/arm/mali/timestamp-default/mali_timestamp.h
old mode 100755
new mode 100644
index 21700fe3..49f9746c
--- a/drivers/gpu/arm/mali/timestamp-default/mali_timestamp.h
+++ b/drivers/gpu/arm/mali/timestamp-default/mali_timestamp.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2011, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/Kbuild b/drivers/gpu/arm/ump/Kbuild
old mode 100755
new mode 100644
index bac9cdc0..20ab2fe9
--- a/drivers/gpu/arm/ump/Kbuild
+++ b/drivers/gpu/arm/ump/Kbuild
@@ -1,16 +1,18 @@
 #
 # Copyright (C) 2010-2012 ARM Limited. All rights reserved.
-# 
+#
 # This program is free software and is provided to you under the terms of the GNU General Public License version 2
 # as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
-# 
+#
 # A copy of the licence is included with the program, and can also be obtained from Free Software
 # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 #
 
 # Set default configuration to use, if Makefile didn't provide one.
 # Change this to use a different config.h
-CONFIG ?= default
+TARGET_PLATFORM ?= aml-meson
+CONFIG ?= aml-meson-m400-1
+
 
 # Validate selected config
 ifneq ($(shell [ -d $(src)/arch-$(CONFIG) ] && [ -f  $(src)/arch-$(CONFIG)/config.h ] && echo "OK"), OK)
@@ -35,7 +37,6 @@ DRIVER_REV := $(MALI_RELEASE_NAME)-r$(SVN_REV)
 CHANGE_DATE := $(shell $(SVN_INFO) | grep '^Last Changed Date: ' | cut -d: -f2- | cut -b2-)
 CHANGED_REVISION := $(shell $(SVN_INFO) | grep '^Last Changed Rev: ' | cut -d: -f2- | cut -b2-)
 REPO_URL := $(shell $(SVN_INFO) | grep '^URL: ' | cut -d: -f2- | cut -b2-)
-
 else # SVN
 GIT_REV := $(shell cd $(src); git describe --always 2>/dev/null)
 ifneq ($(GIT_REV),)
@@ -44,7 +45,6 @@ DRIVER_REV := $(MALI_RELEASE_NAME)-$(GIT_REV)
 CHANGE_DATE := $(shell cd $(src); git log -1 --format="%ci")
 CHANGED_REVISION := $(GIT_REV)
 REPO_URL := $(shell cd $(src); git describe --all --always 2>/dev/null)
-
 else # Git
 # No Git or SVN detected
 DRIVER_REV := $(MALI_RELEASE_NAME)
@@ -52,11 +52,10 @@ CHANGE_DATE := $(MALI_RELEASE_NAME)
 CHANGED_REVISION := $(MALI_RELEASE_NAME)
 endif
 endif
-
 ccflags-y += -DSVN_REV=$(SVN_REV)
 ccflags-y += -DSVN_REV_STRING=\"$(DRIVER_REV)\"
 
-ccflags-y += -I$(src) -I$(src)/common -I$(src)/linux -I$(src)/../mali/common -I$(src)/../mali/linux -I$(src)/include -I$(src)/../../ump/include/ump
+ccflags-y += -I$(src) -I$(src)/common -I$(src)/linux -I$(src)/../mali/common -I$(src)/../mali/linux -I$(src)/../ump/include/ump
 ccflags-y += -DMALI_STATE_TRACKING=0
 ccflags-y += -DMALI_ENABLE_CPU_CYCLES=0
 ccflags-$(CONFIG_UMP_DEBUG) += -DDEBUG
@@ -71,6 +70,8 @@ else
 ccflags-y += -I$(src)/linux/license/gpl -I$(src)/../mali/linux/license/gpl
 endif
 
+
+
 ump-y = common/ump_kernel_common.o \
 	common/ump_kernel_descriptor_mapping.o \
 	common/ump_kernel_api.o \
@@ -86,13 +87,7 @@ ump-y = common/ump_kernel_common.o \
 	linux/ump_osk_misc.o \
 	linux/ump_kernel_random_mapping.o
 
-ifneq ($(CONFIG_MALI400),y)	
-ump-y += $(UDD_FILE_PREFIX)linux/mali_osk_atomics.o \
-	 $(UDD_FILE_PREFIX)linux/mali_osk_locks.o \
-	 $(UDD_FILE_PREFIX)linux/mali_osk_memory.o \
-	 $(UDD_FILE_PREFIX)linux/mali_osk_math.o \
-	 $(UDD_FILE_PREFIX)linux/mali_osk_misc.o
-endif
+
 
 obj-$(CONFIG_UMP) := ump.o
 
diff --git a/drivers/gpu/arm/ump/Kconfig b/drivers/gpu/arm/ump/Kconfig
old mode 100755
new mode 100644
index 3ae316c9..8a75854c
--- a/drivers/gpu/arm/ump/Kconfig
+++ b/drivers/gpu/arm/ump/Kconfig
@@ -1,6 +1,8 @@
+menu "Mali 400 UMP device driver"
 config UMP
 	tristate "UMP support"
 	depends on ARM
+	default n
 	---help---
 	  This enables support for the UMP memory allocation and sharing API.
 
@@ -10,7 +12,8 @@ config UMP
 config UMP_DEBUG
 	bool "Enable extra debug in UMP"
 	depends on UMP
-	default y
+	default n
 	---help---
 	  This enabled extra debug checks and messages in UMP.
 
+endmenu
diff --git a/drivers/gpu/arm/ump/Makefile b/drivers/gpu/arm/ump/Makefile
old mode 100755
new mode 100644
index 4d4f02b0..2ae2925a
--- a/drivers/gpu/arm/ump/Makefile
+++ b/drivers/gpu/arm/ump/Makefile
@@ -1,13 +1,19 @@
 #
-# Copyright (C) 2010-2012, 2014, 2016 ARM Limited. All rights reserved.
-# 
+# Copyright (C) 2010-2012, 2014-2015 ARM Limited. All rights reserved.
+#
 # This program is free software and is provided to you under the terms of the GNU General Public License version 2
 # as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
-# 
+#
 # A copy of the licence is included with the program, and can also be obtained from Free Software
 # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 #
 
+# Skip this Makefile when included from modpost
+ifeq ($(KBUILD_EXTMOD),)
+
+TARGET_PLATFORM ?= aml-meson
+CONFIG ?= aml-meson-m400-1
+
 # For each arch check: CROSS_COMPILE , KDIR , CFLAGS += -DARCH
 
 export ARCH ?= arm
@@ -36,7 +42,7 @@ endif
 KDIR-$(shell uname -m):=/lib/modules/$(shell uname -r)/build
 
 ifeq ($(ARCH), arm)
-# when compiling for ARM we're cross compiling
+	# when compiling for ARM we're cross compiling
 export CROSS_COMPILE ?= $(call check_cc2, arm-linux-gnueabi-gcc, arm-linux-gnueabi-, arm-none-linux-gnueabi-)
 endif
 
@@ -65,3 +71,5 @@ kernelrelease:
 clean:
 	$(MAKE) -C $(KDIR) M=$(CURDIR) clean
 	$(MAKE) -C $(KDIR) M=$(CURDIR)/../mali clean
+
+endif
diff --git a/drivers/gpu/arm/ump/Makefile.common b/drivers/gpu/arm/ump/Makefile.common
old mode 100755
new mode 100644
index 00153ded..87b824b3
--- a/drivers/gpu/arm/ump/Makefile.common
+++ b/drivers/gpu/arm/ump/Makefile.common
@@ -1,9 +1,9 @@
 #
-# Copyright (C) 2010-2011, 2013, 2016 ARM Limited. All rights reserved.
-# 
+# Copyright (C) 2010-2011, 2013, 2015 ARM Limited. All rights reserved.
+#
 # This program is free software and is provided to you under the terms of the GNU General Public License version 2
 # as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
-# 
+#
 # A copy of the licence is included with the program, and can also be obtained from Free Software
 # Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 #
diff --git a/drivers/gpu/arm/ump/arch b/drivers/gpu/arm/ump/arch
index f2976917..b2d568a2 120000
--- a/drivers/gpu/arm/ump/arch
+++ b/drivers/gpu/arm/ump/arch
@@ -1 +1 @@
-arch-default
\ No newline at end of file
+arch-aml-meson-m400-1
\ No newline at end of file
diff --git a/drivers/gpu/arm/ump/arch-default/config.h b/drivers/gpu/arm/ump/arch-aml-meson-m400-1/config.h
old mode 100755
new mode 100644
similarity index 64%
rename from drivers/gpu/arm/ump/arch-default/config.h
rename to drivers/gpu/arm/ump/arch-aml-meson-m400-1/config.h
index ddecfbb9..541bb52a
--- a/drivers/gpu/arm/ump/arch-default/config.h
+++ b/drivers/gpu/arm/ump/arch-aml-meson-m400-1/config.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2012, 2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -11,14 +11,8 @@
 #ifndef __ARCH_CONFIG_H__
 #define __ARCH_CONFIG_H__
 
-/* Use OS memory. */
 #define ARCH_UMP_BACKEND_DEFAULT          1
-
-/* OS memory won't need a base address. */
-#define ARCH_UMP_MEMORY_ADDRESS_DEFAULT   0x00000000
-
-/* 512 MB maximum limit for UMP allocations. */
-#define ARCH_UMP_MEMORY_SIZE_DEFAULT 512UL * 1024UL * 1024UL
-
+#define ARCH_UMP_MEMORY_ADDRESS_DEFAULT   0
+#define ARCH_UMP_MEMORY_SIZE_DEFAULT 256UL * 1024UL * 1024UL
 
 #endif /* __ARCH_CONFIG_H__ */
diff --git a/drivers/gpu/arm/ump/arch-pb-virtex5/config.h b/drivers/gpu/arm/ump/arch-pb-virtex5/config.h
old mode 100755
new mode 100644
index 9160ce1c..5d7f5ffe
--- a/drivers/gpu/arm/ump/arch-pb-virtex5/config.h
+++ b/drivers/gpu/arm/ump/arch-pb-virtex5/config.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2014 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/common/ump_kernel_api.c b/drivers/gpu/arm/ump/common/ump_kernel_api.c
old mode 100755
new mode 100644
index a347dfa1..7aa5b543
--- a/drivers/gpu/arm/ump/common/ump_kernel_api.c
+++ b/drivers/gpu/arm/ump/common/ump_kernel_api.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -12,7 +12,7 @@
 #include "mali_osk_list.h"
 #include "ump_osk.h"
 #include "ump_uk_types.h"
-#include <ump/ump_kernel_interface.h>
+#include "ump_kernel_interface.h"
 #include "ump_kernel_common.h"
 #include "ump_kernel_random_mapping.h"
 
diff --git a/drivers/gpu/arm/ump/common/ump_kernel_common.c b/drivers/gpu/arm/ump/common/ump_kernel_common.c
old mode 100755
new mode 100644
index 1f5ba471..8b20df0e
--- a/drivers/gpu/arm/ump/common/ump_kernel_common.c
+++ b/drivers/gpu/arm/ump/common/ump_kernel_common.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/common/ump_kernel_common.h b/drivers/gpu/arm/ump/common/ump_kernel_common.h
old mode 100755
new mode 100644
index 8703c6f7..6770d025
--- a/drivers/gpu/arm/ump/common/ump_kernel_common.h
+++ b/drivers/gpu/arm/ump/common/ump_kernel_common.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -12,7 +12,7 @@
 #define __UMP_KERNEL_COMMON_H__
 
 #include "ump_kernel_types.h"
-#include <ump/ump_kernel_interface.h>
+#include "ump_kernel_interface.h"
 #include "ump_kernel_descriptor_mapping.h"
 #include "ump_kernel_random_mapping.h"
 #include "ump_kernel_memory_backend.h"
@@ -110,7 +110,7 @@ extern struct ump_dev device;
 
 _mali_osk_errcode_t ump_kernel_constructor(void);
 void ump_kernel_destructor(void);
-int ump_map_errcode(_mali_osk_errcode_t err);
+int map_errcode(_mali_osk_errcode_t err);
 
 /**
  * variables from user space cannot be dereferenced from kernel space; tagging them
diff --git a/drivers/gpu/arm/ump/common/ump_kernel_descriptor_mapping.c b/drivers/gpu/arm/ump/common/ump_kernel_descriptor_mapping.c
old mode 100755
new mode 100644
index d22c049f..95514010
--- a/drivers/gpu/arm/ump/common/ump_kernel_descriptor_mapping.c
+++ b/drivers/gpu/arm/ump/common/ump_kernel_descriptor_mapping.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2011, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/common/ump_kernel_descriptor_mapping.h b/drivers/gpu/arm/ump/common/ump_kernel_descriptor_mapping.h
old mode 100755
new mode 100644
index bad215ab..7d02f508
--- a/drivers/gpu/arm/ump/common/ump_kernel_descriptor_mapping.h
+++ b/drivers/gpu/arm/ump/common/ump_kernel_descriptor_mapping.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2011, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/common/ump_kernel_memory_backend.h b/drivers/gpu/arm/ump/common/ump_kernel_memory_backend.h
old mode 100755
new mode 100644
index e21528b0..19c31077
--- a/drivers/gpu/arm/ump/common/ump_kernel_memory_backend.h
+++ b/drivers/gpu/arm/ump/common/ump_kernel_memory_backend.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2011, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -15,7 +15,7 @@
 #ifndef __UMP_KERNEL_MEMORY_BACKEND_H__
 #define __UMP_KERNEL_MEMORY_BACKEND_H__
 
-#include <ump/ump_kernel_interface.h>
+#include "ump_kernel_interface.h"
 #include "ump_kernel_types.h"
 
 
diff --git a/drivers/gpu/arm/ump/common/ump_kernel_ref_drv.c b/drivers/gpu/arm/ump/common/ump_kernel_ref_drv.c
old mode 100755
new mode 100644
index 76bd9eed..830a483b
--- a/drivers/gpu/arm/ump/common/ump_kernel_ref_drv.c
+++ b/drivers/gpu/arm/ump/common/ump_kernel_ref_drv.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -13,7 +13,7 @@
 #include "ump_osk.h"
 #include "ump_uk_types.h"
 
-#include <ump/ump_kernel_interface_ref_drv.h>
+#include "ump_kernel_interface_ref_drv.h"
 #include "ump_kernel_common.h"
 #include "ump_kernel_descriptor_mapping.h"
 
diff --git a/drivers/gpu/arm/ump/common/ump_kernel_types.h b/drivers/gpu/arm/ump/common/ump_kernel_types.h
old mode 100755
new mode 100644
index f7bcd659..be0ce5de
--- a/drivers/gpu/arm/ump/common/ump_kernel_types.h
+++ b/drivers/gpu/arm/ump/common/ump_kernel_types.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -11,13 +11,10 @@
 #ifndef __UMP_KERNEL_TYPES_H__
 #define __UMP_KERNEL_TYPES_H__
 
-#include <ump/ump_kernel_interface.h>
+#include "ump_kernel_interface.h"
 #include "mali_osk.h"
 
 #include <linux/rbtree.h>
-#ifdef CONFIG_DMA_SHARED_BUFFER
-#include <linux/dma-buf.h>
-#endif
 
 typedef enum {
 	UMP_USED_BY_CPU = 0,
@@ -47,10 +44,6 @@ typedef struct ump_dd_mem {
 	int is_cached;
 	ump_hw_usage hw_device;
 	ump_lock_usage lock_usage;
-#ifdef CONFIG_DMA_SHARED_BUFFER
-	struct dma_buf_attachment *import_attach;
-	struct sg_table *sgt;
-#endif
 } ump_dd_mem;
 
 
diff --git a/drivers/gpu/arm/ump/common/ump_osk.h b/drivers/gpu/arm/ump/common/ump_osk.h
old mode 100755
new mode 100644
index bd1aef5a..2829f01a
--- a/drivers/gpu/arm/ump/common/ump_osk.h
+++ b/drivers/gpu/arm/ump/common/ump_osk.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/common/ump_uk_types.h b/drivers/gpu/arm/ump/common/ump_uk_types.h
old mode 100755
new mode 100644
index 0e42a89d..13e1e996
--- a/drivers/gpu/arm/ump/common/ump_uk_types.h
+++ b/drivers/gpu/arm/ump/common/ump_uk_types.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -48,7 +48,6 @@ typedef enum
 	_UMP_IOC_SWITCH_HW_USAGE,
 	_UMP_IOC_LOCK,
 	_UMP_IOC_UNLOCK,
-	_UMP_IOC_DMABUF_IMPORT,
 } _ump_uk_functions;
 
 typedef enum
@@ -187,14 +186,6 @@ typedef struct _ump_uk_unlock_s
 	u32 secure_id;        /**< [in] secure_id that identifies the ump buffer */
 } _ump_uk_unlock_s;
 
-typedef struct _ump_uk_dmabuf_s
-{
-	void *ctx;            /**< [in,out] user-kernel context (trashed on output) */
-	int fd;               /**< [in] dmabuf_fd that identifies the dmabuf buffer */
-	size_t size;          /**< [in] size of the buffer */
-	u32 secure_id;        /**< [out] secure_id that identifies the ump buffer */
-} _ump_uk_dmabuf_s;
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/drivers/gpu/arm/ump/common/ump_ukk.h b/drivers/gpu/arm/ump/common/ump_ukk.h
old mode 100755
new mode 100644
index b8b1624b..7bc33bc5
--- a/drivers/gpu/arm/ump/common/ump_ukk.h
+++ b/drivers/gpu/arm/ump/common/ump_ukk.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/include/ump/ump_kernel_interface.h b/drivers/gpu/arm/ump/include/ump/ump_kernel_interface.h
new file mode 100644
index 00000000..8480cc2f
--- /dev/null
+++ b/drivers/gpu/arm/ump/include/ump/ump_kernel_interface.h
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2010, 2013-2014 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained from Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/**
+ * @file ump_kernel_interface.h
+ *
+ * This file contains the kernel space part of the UMP API.
+ */
+
+#ifndef __UMP_KERNEL_INTERFACE_H__
+#define __UMP_KERNEL_INTERFACE_H__
+
+
+/** @defgroup ump_kernel_space_api UMP Kernel Space API
+ * @{ */
+
+
+#include "ump_kernel_platform.h"
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/**
+ * External representation of a UMP handle in kernel space.
+ */
+typedef void *ump_dd_handle;
+
+/**
+ * Typedef for a secure ID, a system wide identificator for UMP memory buffers.
+ */
+typedef unsigned int ump_secure_id;
+
+
+/**
+ * Value to indicate an invalid UMP memory handle.
+ */
+#define UMP_DD_HANDLE_INVALID ((ump_dd_handle)0)
+
+
+/**
+ * Value to indicate an invalid secure Id.
+ */
+#define UMP_INVALID_SECURE_ID ((ump_secure_id)-1)
+
+
+/**
+ * UMP error codes for kernel space.
+ */
+typedef enum
+{
+	UMP_DD_SUCCESS, /**< indicates success */
+	UMP_DD_INVALID, /**< indicates failure */
+} ump_dd_status_code;
+
+
+/**
+ * Struct used to describe a physical block used by UMP memory
+ */
+typedef struct ump_dd_physical_block
+{
+	unsigned long addr; /**< The physical address of the block */
+	unsigned long size; /**< The length of the block, typically page aligned */
+} ump_dd_physical_block;
+
+
+/**
+ * Retrieves the secure ID for the specified UMP memory.
+ *
+ * This identificator is unique across the entire system, and uniquely identifies
+ * the specified UMP memory. This identificator can later be used through the
+ * @ref ump_dd_handle_create_from_secure_id "ump_dd_handle_create_from_secure_id" or
+ * @ref ump_handle_create_from_secure_id "ump_handle_create_from_secure_id"
+ * functions in order to access this UMP memory, for instance from another process.
+ *
+ * @note There is a user space equivalent function called @ref ump_secure_id_get "ump_secure_id_get"
+ *
+ * @see ump_dd_handle_create_from_secure_id
+ * @see ump_handle_create_from_secure_id
+ * @see ump_secure_id_get
+ *
+ * @param mem Handle to UMP memory.
+ *
+ * @return Returns the secure ID for the specified UMP memory.
+ */
+UMP_KERNEL_API_EXPORT ump_secure_id ump_dd_secure_id_get(ump_dd_handle mem);
+
+
+/**
+ * Retrieves a handle to allocated UMP memory.
+ *
+ * The usage of UMP memory is reference counted, so this will increment the reference
+ * count by one for the specified UMP memory.
+ * Use @ref ump_dd_reference_release "ump_dd_reference_release" when there is no longer any
+ * use for the retrieved handle.
+ *
+ * @note There is a user space equivalent function called @ref ump_handle_create_from_secure_id "ump_handle_create_from_secure_id"
+ *
+ * @see ump_dd_reference_release
+ * @see ump_handle_create_from_secure_id
+ *
+ * @param secure_id The secure ID of the UMP memory to open, that can be retrieved using the @ref ump_secure_id_get "ump_secure_id_get " function.
+ *
+ * @return UMP_INVALID_MEMORY_HANDLE indicates failure, otherwise a valid handle is returned.
+ */
+UMP_KERNEL_API_EXPORT ump_dd_handle ump_dd_handle_create_from_secure_id(ump_secure_id secure_id);
+
+
+/**
+ * Retrieves the number of physical blocks used by the specified UMP memory.
+ *
+ * This function retrieves the number of @ref ump_dd_physical_block "ump_dd_physical_block" structs needed
+ * to describe the physical memory layout of the given UMP memory. This can later be used when calling
+ * the functions @ref ump_dd_phys_blocks_get "ump_dd_phys_blocks_get" and
+ * @ref ump_dd_phys_block_get "ump_dd_phys_block_get".
+ *
+ * @see ump_dd_phys_blocks_get
+ * @see ump_dd_phys_block_get
+ *
+ * @param mem Handle to UMP memory.
+ *
+ * @return The number of ump_dd_physical_block structs required to describe the physical memory layout of the specified UMP memory.
+ */
+UMP_KERNEL_API_EXPORT unsigned long ump_dd_phys_block_count_get(ump_dd_handle mem);
+
+
+/**
+ * Retrieves all physical memory block information for specified UMP memory.
+ *
+ * This function can be used by other device drivers in order to create MMU tables.
+ *
+ * @note This function will fail if the num_blocks parameter is either to large or to small.
+ *
+ * @see ump_dd_phys_block_get
+ *
+ * @param mem Handle to UMP memory.
+ * @param blocks An array of @ref ump_dd_physical_block "ump_dd_physical_block" structs that will receive the physical description.
+ * @param num_blocks The number of blocks to return in the blocks array. Use the function
+ *                   @ref ump_dd_phys_block_count_get "ump_dd_phys_block_count_get" first to determine the number of blocks required.
+ *
+ * @return UMP_DD_SUCCESS indicates success, UMP_DD_INVALID indicates failure.
+ */
+UMP_KERNEL_API_EXPORT ump_dd_status_code ump_dd_phys_blocks_get(ump_dd_handle mem, ump_dd_physical_block *blocks, unsigned long num_blocks);
+
+
+/**
+ * Retrieves the physical memory block information for specified block for the specified UMP memory.
+ *
+ * This function can be used by other device drivers in order to create MMU tables.
+ *
+ * @note This function will return UMP_DD_INVALID if the specified index is out of range.
+ *
+ * @see ump_dd_phys_blocks_get
+ *
+ * @param mem Handle to UMP memory.
+ * @param index Which physical info block to retrieve.
+ * @param block Pointer to a @ref ump_dd_physical_block "ump_dd_physical_block" struct which will receive the requested information.
+ *
+ * @return UMP_DD_SUCCESS indicates success, UMP_DD_INVALID indicates failure.
+ */
+UMP_KERNEL_API_EXPORT ump_dd_status_code ump_dd_phys_block_get(ump_dd_handle mem, unsigned long index, ump_dd_physical_block *block);
+
+
+/**
+ * Retrieves the actual size of the specified UMP memory.
+ *
+ * The size is reported in bytes, and is typically page aligned.
+ *
+ * @note There is a user space equivalent function called @ref ump_size_get "ump_size_get"
+ *
+ * @see ump_size_get
+ *
+ * @param mem Handle to UMP memory.
+ *
+ * @return Returns the allocated size of the specified UMP memory, in bytes.
+ */
+UMP_KERNEL_API_EXPORT unsigned long ump_dd_size_get(ump_dd_handle mem);
+
+
+/**
+ * Adds an extra reference to the specified UMP memory.
+ *
+ * This function adds an extra reference to the specified UMP memory. This function should
+ * be used every time a UMP memory handle is duplicated, that is, assigned to another ump_dd_handle
+ * variable. The function @ref ump_dd_reference_release "ump_dd_reference_release" must then be used
+ * to release each copy of the UMP memory handle.
+ *
+ * @note You are not required to call @ref ump_dd_reference_add "ump_dd_reference_add"
+ * for UMP handles returned from
+ * @ref ump_dd_handle_create_from_secure_id "ump_dd_handle_create_from_secure_id",
+ * because these handles are already reference counted by this function.
+ *
+ * @note There is a user space equivalent function called @ref ump_reference_add "ump_reference_add"
+ *
+ * @see ump_reference_add
+ *
+ * @param mem Handle to UMP memory.
+ */
+UMP_KERNEL_API_EXPORT void ump_dd_reference_add(ump_dd_handle mem);
+
+
+/**
+ * Releases a reference from the specified UMP memory.
+ *
+ * This function should be called once for every reference to the UMP memory handle.
+ * When the last reference is released, all resources associated with this UMP memory
+ * handle are freed.
+ *
+ * @note There is a user space equivalent function called @ref ump_reference_release "ump_reference_release"
+ *
+ * @see ump_reference_release
+ *
+ * @param mem Handle to UMP memory.
+ */
+UMP_KERNEL_API_EXPORT void ump_dd_reference_release(ump_dd_handle mem);
+
+
+#ifdef __cplusplus
+}
+#endif
+
+
+/** @} */ /* end group ump_kernel_space_api */
+
+
+#endif  /* __UMP_KERNEL_INTERFACE_H__ */
diff --git a/drivers/gpu/arm/ump/include/ump/ump_kernel_interface_ref_drv.h b/drivers/gpu/arm/ump/include/ump/ump_kernel_interface_ref_drv.h
new file mode 100644
index 00000000..d7651b61
--- /dev/null
+++ b/drivers/gpu/arm/ump/include/ump/ump_kernel_interface_ref_drv.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2010, 2013-2014 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained from Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/**
+ * @file ump_kernel_interface.h
+ */
+
+#ifndef __UMP_KERNEL_INTERFACE_REF_DRV_H__
+#define __UMP_KERNEL_INTERFACE_REF_DRV_H__
+
+#include "ump_kernel_interface.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Turn specified physical memory into UMP memory. */
+UMP_KERNEL_API_EXPORT ump_dd_handle ump_dd_handle_create_from_phys_blocks(ump_dd_physical_block *blocks, unsigned long num_blocks);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif  /* __UMP_KERNEL_INTERFACE_REF_DRV_H__ */
diff --git a/drivers/gpu/arm/ump/include/ump/ump_kernel_platform.h b/drivers/gpu/arm/ump/include/ump/ump_kernel_platform.h
new file mode 100644
index 00000000..217a9a18
--- /dev/null
+++ b/drivers/gpu/arm/ump/include/ump/ump_kernel_platform.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2010, 2014 ARM Limited. All rights reserved.
+ *
+ * This program is free software and is provided to you under the terms of the GNU General Public License version 2
+ * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
+ *
+ * A copy of the licence is included with the program, and can also be obtained from Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
+ */
+
+/**
+ * @file ump_kernel_platform.h
+ *
+ * This file should define UMP_KERNEL_API_EXPORT,
+ * which dictates how the UMP kernel API should be exported/imported.
+ * Modify this file, if needed, to match your platform setup.
+ */
+
+#ifndef __UMP_KERNEL_PLATFORM_H__
+#define __UMP_KERNEL_PLATFORM_H__
+
+/** @addtogroup ump_kernel_space_api
+ * @{ */
+
+/**
+ * A define which controls how UMP kernel space API functions are imported and exported.
+ * This define should be set by the implementor of the UMP API.
+ */
+
+#if defined(_WIN32)
+
+#if defined(UMP_BUILDING_UMP_LIBRARY)
+#define UMP_KERNEL_API_EXPORT __declspec(dllexport)
+#else
+#define UMP_KERNEL_API_EXPORT __declspec(dllimport)
+#endif
+
+#else
+
+#define UMP_KERNEL_API_EXPORT
+
+#endif
+
+
+/** @} */ /* end group ump_kernel_space_api */
+
+
+#endif /* __UMP_KERNEL_PLATFORM_H__ */
diff --git a/drivers/gpu/arm/ump/linux/license/gpl/ump_kernel_license.h b/drivers/gpu/arm/ump/linux/license/gpl/ump_kernel_license.h
old mode 100755
new mode 100644
index c0a1b838..62fde182
--- a/drivers/gpu/arm/ump/linux/license/gpl/ump_kernel_license.h
+++ b/drivers/gpu/arm/ump/linux/license/gpl/ump_kernel_license.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2013-2014 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/linux/ump_ioctl.h b/drivers/gpu/arm/ump/linux/ump_ioctl.h
old mode 100755
new mode 100644
index b3fe7d36..9129332d
--- a/drivers/gpu/arm/ump/linux/ump_ioctl.h
+++ b/drivers/gpu/arm/ump/linux/ump_ioctl.h
@@ -1,21 +1,11 @@
 /*
- * Copyright (C) 2010-2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
- 
- * Class Path Exception
- * Linking this library statically or dynamically with other modules is making a combined work based on this library. 
- * Thus, the terms and conditions of the GNU General Public License cover the whole combination.
- * As a special exception, the copyright holders of this library give you permission to link this library with independent modules 
- * to produce an executable, regardless of the license terms of these independent modules, and to copy and distribute the resulting 
- * executable under terms of your choice, provided that you also meet, for each linked independent module, the terms and conditions 
- * of the license of that module. An independent module is a module which is not derived from or based on this library. If you modify 
- * this library, you may extend this exception to your version of the library, but you are not obligated to do so. 
- * If you do not wish to do so, delete this exception statement from your version.
  */
 
 #ifndef __UMP_IOCTL_H__
@@ -55,7 +45,6 @@ extern "C" {
 #define UMP_IOC_LOCK          _IOW(UMP_IOCTL_NR,  _UMP_IOC_LOCK, _ump_uk_lock_s)
 #define UMP_IOC_UNLOCK        _IOW(UMP_IOCTL_NR,  _UMP_IOC_UNLOCK, _ump_uk_unlock_s)
 
-#define UMP_IOC_DMABUF_IMPORT  _IOW(UMP_IOCTL_NR,  _UMP_IOC_DMABUF_IMPORT, _ump_uk_dmabuf_s)
 
 #ifdef __cplusplus
 }
diff --git a/drivers/gpu/arm/ump/linux/ump_kernel_linux.c b/drivers/gpu/arm/ump/linux/ump_kernel_linux.c
old mode 100755
new mode 100644
index e5e22105..833b91c2
--- a/drivers/gpu/arm/ump/linux/ump_kernel_linux.c
+++ b/drivers/gpu/arm/ump/linux/ump_kernel_linux.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -21,8 +21,8 @@
 #include "arch/config.h"             /* Configuration for current platform. The symlinc for arch is set by Makefile */
 #include "ump_ioctl.h"
 #include "ump_kernel_common.h"
-#include <ump/ump_kernel_interface.h>
-#include <ump/ump_kernel_interface_ref_drv.h>
+#include "ump_kernel_interface.h"
+#include "ump_kernel_interface_ref_drv.h"
 #include "ump_kernel_descriptor_mapping.h"
 #include "ump_kernel_memory_backend.h"
 #include "ump_kernel_memory_backend_os.h"
@@ -73,7 +73,7 @@ struct ump_device {
 
 /* The global variable containing the global device data */
 static struct ump_device ump_device;
-struct device *ump_global_mdev = NULL;
+
 
 /* Forward declare static functions */
 static int ump_file_open(struct inode *inode, struct file *filp);
@@ -112,7 +112,7 @@ static int ump_initialize_module(void)
 	err = ump_kernel_constructor();
 	if (_MALI_OSK_ERR_OK != err) {
 		MSG_ERR(("UMP device driver init failed\n"));
-		return ump_map_errcode(err);
+		return map_errcode(err);
 	}
 
 	MSG(("UMP device driver %s loaded\n", SVN_REV_STRING));
@@ -192,12 +192,13 @@ int ump_kernel_device_initialize(void)
 			if (IS_ERR(ump_device.ump_class)) {
 				err = PTR_ERR(ump_device.ump_class);
 			} else {
-				ump_global_mdev = device_create(ump_device.ump_class, NULL, dev, NULL, ump_dev_name);
-				if (!IS_ERR(ump_global_mdev)) {
+				struct device *mdev;
+				mdev = device_create(ump_device.ump_class, NULL, dev, NULL, ump_dev_name);
+				if (!IS_ERR(mdev)) {
 					return 0;
 				}
 
-				err = PTR_ERR(ump_global_mdev);
+				err = PTR_ERR(mdev);
 			}
 			cdev_del(&ump_device.cdev);
 #else
@@ -255,7 +256,7 @@ static int ump_file_open(struct inode *inode, struct file *filp)
 	err = _ump_ukk_open((void **) &session_data);
 	if (_MALI_OSK_ERR_OK != err) {
 		MSG_ERR(("Ump failed to open a new session\n"));
-		return ump_map_errcode(err);
+		return map_errcode(err);
 	}
 
 	filp->private_data = (void *)session_data;
@@ -275,7 +276,7 @@ static int ump_file_release(struct inode *inode, struct file *filp)
 
 	err = _ump_ukk_close((void **) &filp->private_data);
 	if (_MALI_OSK_ERR_OK != err) {
-		return ump_map_errcode(err);
+		return map_errcode(err);
 	}
 
 	return 0;  /* success */
@@ -346,15 +347,6 @@ static int ump_file_ioctl(struct inode *inode, struct file *filp, unsigned int c
 		err = ump_unlock_wrapper((u32 __user *)argument, session_data);
 		break;
 
-	case UMP_IOC_DMABUF_IMPORT:
-#ifdef CONFIG_DMA_SHARED_BUFFER
-		err = ump_dmabuf_import_wrapper((u32 __user *)argument, session_data);
-#else
-		err = -EFAULT;
-		DBG_MSG(1, ("User space use dmabuf API, but kernel don't support DMA BUF\n"));
-#endif
-		break;
-
 	default:
 		DBG_MSG(1, ("No handler for IOCTL. cmd: 0x%08x, arg: 0x%08lx\n", cmd, arg));
 		err = -EFAULT;
@@ -364,30 +356,6 @@ static int ump_file_ioctl(struct inode *inode, struct file *filp, unsigned int c
 	return err;
 }
 
-int ump_map_errcode(_mali_osk_errcode_t err)
-{
-	switch (err) {
-	case _MALI_OSK_ERR_OK :
-		return 0;
-	case _MALI_OSK_ERR_FAULT:
-		return -EFAULT;
-	case _MALI_OSK_ERR_INVALID_FUNC:
-		return -ENOTTY;
-	case _MALI_OSK_ERR_INVALID_ARGS:
-		return -EINVAL;
-	case _MALI_OSK_ERR_NOMEM:
-		return -ENOMEM;
-	case _MALI_OSK_ERR_TIMEOUT:
-		return -ETIMEDOUT;
-	case _MALI_OSK_ERR_RESTARTSYSCALL:
-		return -ERESTARTSYS;
-	case _MALI_OSK_ERR_ITEM_NOT_FOUND:
-		return -ENOENT;
-	default:
-		return -EFAULT;
-	}
-}
-
 /*
  * Handle from OS to map specified virtual memory to specified UMP memory.
  */
@@ -426,7 +394,7 @@ static int ump_file_mmap(struct file *filp, struct vm_area_struct *vma)
 	err = _ump_ukk_map_mem(&args);
 	if (_MALI_OSK_ERR_OK != err) {
 		MSG_ERR(("_ump_ukk_map_mem() failed in function ump_file_mmap()"));
-		return ump_map_errcode(err);
+		return map_errcode(err);
 	}
 
 	return 0; /* success */
diff --git a/drivers/gpu/arm/ump/linux/ump_kernel_linux.h b/drivers/gpu/arm/ump/linux/ump_kernel_linux.h
old mode 100755
new mode 100644
index f7c0a96b..481d23ba
--- a/drivers/gpu/arm/ump/linux/ump_kernel_linux.h
+++ b/drivers/gpu/arm/ump/linux/ump_kernel_linux.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2013, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2013, 2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_dedicated.c b/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_dedicated.c
old mode 100755
new mode 100644
index 517b46bb..dc22c050
--- a/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_dedicated.c
+++ b/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_dedicated.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2011, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_dedicated.h b/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_dedicated.h
old mode 100755
new mode 100644
index 8c1ea1e7..319c18da
--- a/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_dedicated.h
+++ b/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_dedicated.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2014-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_os.c b/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_os.c
old mode 100755
new mode 100644
index f7791b0c..c134af21
--- a/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_os.c
+++ b/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_os.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2011, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_os.h b/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_os.h
old mode 100755
new mode 100644
index 2d62f4dd..eccd89c3
--- a/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_os.h
+++ b/drivers/gpu/arm/ump/linux/ump_kernel_memory_backend_os.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2014-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/linux/ump_kernel_random_mapping.c b/drivers/gpu/arm/ump/linux/ump_kernel_random_mapping.c
old mode 100755
new mode 100644
index f5848789..9c2eb347
--- a/drivers/gpu/arm/ump/linux/ump_kernel_random_mapping.c
+++ b/drivers/gpu/arm/ump/linux/ump_kernel_random_mapping.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2011, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -186,21 +186,6 @@ void ump_random_mapping_put(ump_dd_mem *mem)
 	if (0 == new_ref) {
 		DBG_MSG(3, ("Final release of memory. ID: %u\n", mem->secure_id));
 
-#ifdef CONFIG_DMA_SHARED_BUFFER
-		if (mem->import_attach) {
-			struct dma_buf_attachment *attach = mem->import_attach;
-			struct dma_buf *dma_buf;
-
-			if (mem->sgt)
-				dma_buf_unmap_attachment(attach, mem->sgt,
-							 DMA_BIDIRECTIONAL);
-
-			dma_buf = attach->dmabuf;
-			dma_buf_detach(attach->dmabuf, attach);
-			dma_buf_put(dma_buf);
-
-		}
-#endif
 		ump_random_mapping_remove_internal(device.secure_id_map, mem->secure_id);
 
 		mem->release_func(mem->ctx, mem);
diff --git a/drivers/gpu/arm/ump/linux/ump_kernel_random_mapping.h b/drivers/gpu/arm/ump/linux/ump_kernel_random_mapping.h
old mode 100755
new mode 100644
index 67d4a864..30482c93
--- a/drivers/gpu/arm/ump/linux/ump_kernel_random_mapping.h
+++ b/drivers/gpu/arm/ump/linux/ump_kernel_random_mapping.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2011, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2011, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/linux/ump_memory_backend.c b/drivers/gpu/arm/ump/linux/ump_memory_backend.c
old mode 100755
new mode 100644
index 87b14190..793feca4
--- a/drivers/gpu/arm/ump/linux/ump_memory_backend.c
+++ b/drivers/gpu/arm/ump/linux/ump_memory_backend.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/linux/ump_osk_atomics.c b/drivers/gpu/arm/ump/linux/ump_osk_atomics.c
old mode 100755
new mode 100644
index f9fc1943..2136d8a0
--- a/drivers/gpu/arm/ump/linux/ump_osk_atomics.c
+++ b/drivers/gpu/arm/ump/linux/ump_osk_atomics.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2014-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/linux/ump_osk_low_level_mem.c b/drivers/gpu/arm/ump/linux/ump_osk_low_level_mem.c
old mode 100755
new mode 100644
index ef35052f..8e5e7e29
--- a/drivers/gpu/arm/ump/linux/ump_osk_low_level_mem.c
+++ b/drivers/gpu/arm/ump/linux/ump_osk_low_level_mem.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/linux/ump_osk_misc.c b/drivers/gpu/arm/ump/linux/ump_osk_misc.c
old mode 100755
new mode 100644
index ce0ab06f..1ba5efb9
--- a/drivers/gpu/arm/ump/linux/ump_osk_misc.c
+++ b/drivers/gpu/arm/ump/linux/ump_osk_misc.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/linux/ump_ukk_ref_wrappers.c b/drivers/gpu/arm/ump/linux/ump_ukk_ref_wrappers.c
old mode 100755
new mode 100644
index 6fb2b04d..10f76dd2
--- a/drivers/gpu/arm/ump/linux/ump_ukk_ref_wrappers.c
+++ b/drivers/gpu/arm/ump/linux/ump_ukk_ref_wrappers.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -20,11 +20,6 @@
 #include "ump_uk_types.h"
 #include "ump_ukk.h"
 #include "ump_kernel_common.h"
-#include <linux/scatterlist.h>
-#include <ump/ump_kernel_interface_ref_drv.h>
-#include "mali_osk_list.h"
-
-extern struct device *ump_global_mdev;
 
 /*
  * IOCTL operation; Allocate UMP memory
@@ -51,7 +46,7 @@ int ump_allocate_wrapper(u32 __user *argument, struct ump_session_data   *sessio
 	err = _ump_ukk_allocate(&user_interaction);
 	if (_MALI_OSK_ERR_OK != err) {
 		DBG_MSG(1, ("_ump_ukk_allocate() failed in ump_ioctl_allocate()\n"));
-		return ump_map_errcode(err);
+		return map_errcode(err);
 	}
 	user_interaction.ctx = NULL;
 
@@ -74,157 +69,3 @@ int ump_allocate_wrapper(u32 __user *argument, struct ump_session_data   *sessio
 
 	return 0; /* success */
 }
-
-#ifdef CONFIG_DMA_SHARED_BUFFER
-static ump_dd_handle get_ump_handle_from_dmabuf(struct ump_session_data *session_data,
-		struct dma_buf *dmabuf)
-{
-	ump_session_memory_list_element *session_mem, *tmp;
-	struct dma_buf_attachment *attach;
-	ump_dd_handle ump_handle;
-
-	DEBUG_ASSERT_POINTER(session_data);
-
-	_mali_osk_mutex_wait(session_data->lock);
-
-	_MALI_OSK_LIST_FOREACHENTRY(session_mem, tmp,
-				    &session_data->list_head_session_memory_list,
-				    ump_session_memory_list_element, list) {
-		if (session_mem->mem->import_attach) {
-			attach = session_mem->mem->import_attach;
-			if (attach->dmabuf == dmabuf) {
-				_mali_osk_mutex_signal(session_data->lock);
-				ump_handle = (ump_dd_handle)session_mem->mem;
-				ump_random_mapping_get(device.secure_id_map, ump_dd_secure_id_get(ump_handle));
-				return ump_handle;
-			}
-		}
-	}
-
-	_mali_osk_mutex_signal(session_data->lock);
-
-	return NULL;
-}
-
-int ump_dmabuf_import_wrapper(u32 __user *argument,
-			      struct ump_session_data  *session_data)
-{
-	ump_session_memory_list_element *session = NULL;
-	_ump_uk_dmabuf_s ump_dmabuf;
-	ump_dd_handle ump_handle;
-	ump_dd_physical_block *blocks = NULL;
-	struct dma_buf_attachment *attach = NULL;
-	struct dma_buf *dma_buf;
-	struct sg_table *sgt = NULL;
-	struct scatterlist *sgl;
-	unsigned int i = 0;
-	int ret = 0;
-
-	/* Sanity check input parameters */
-	if (!argument || !session_data) {
-		MSG_ERR(("NULL parameter.\n"));
-		return -EINVAL;
-	}
-
-	if (copy_from_user(&ump_dmabuf, argument,
-			   sizeof(_ump_uk_dmabuf_s))) {
-		MSG_ERR(("copy_from_user() failed.\n"));
-		return -EFAULT;
-	}
-
-	dma_buf = dma_buf_get(ump_dmabuf.fd);
-	if (IS_ERR(dma_buf))
-		return PTR_ERR(dma_buf);
-
-	/*
-	 * if already imported then increase a refcount to the ump descriptor
-	 * and call dma_buf_put() and then go to found to return previous
-	 * ump secure id.
-	 */
-	ump_handle = get_ump_handle_from_dmabuf(session_data, dma_buf);
-	if (ump_handle) {
-		dma_buf_put(dma_buf);
-		goto found;
-	}
-
-	attach = dma_buf_attach(dma_buf, ump_global_mdev);
-	if (IS_ERR(attach)) {
-		ret = PTR_ERR(attach);
-		goto err_dma_buf_put;
-	}
-
-	sgt = dma_buf_map_attachment(attach, DMA_BIDIRECTIONAL);
-	if (IS_ERR(sgt)) {
-		ret = PTR_ERR(sgt);
-		goto err_dma_buf_detach;
-	}
-
-	blocks = (ump_dd_physical_block *)_mali_osk_malloc(sizeof(ump_dd_physical_block) * sgt->nents);
-	if (!blocks) {
-		DBG_MSG(1, ("Failed to allocate blocks.\n"));
-		ret = -EFAULT;
-		goto err_dma_buf_unmap;
-	}
-	for_each_sg(sgt->sgl, sgl, sgt->nents, i) {
-		blocks[i].addr = sg_phys(sgl);
-		blocks[i].size = sg_dma_len(sgl);
-	}
-
-	/*
-	 * Initialize the session memory list element, and add it
-	 * to the session object
-	 */
-	session = _mali_osk_calloc(1, sizeof(*session));
-	if (!session) {
-		DBG_MSG(1, ("Failed to allocate session.\n"));
-		ret = -EFAULT;
-		goto err_free_block;
-	}
-
-	ump_handle = ump_dd_handle_create_from_phys_blocks(blocks, i);
-	if (UMP_DD_HANDLE_INVALID == ump_handle) {
-		DBG_MSG(1, ("Failed to create ump handle.\n"));
-		ret = -EFAULT;
-		goto err_free_session;
-	}
-
-	session->mem = (ump_dd_mem *)ump_handle;
-	session->mem->import_attach = attach;
-	session->mem->sgt = sgt;
-
-	_mali_osk_mutex_wait(session_data->lock);
-	_mali_osk_list_add(&(session->list),
-			   &(session_data->list_head_session_memory_list));
-	_mali_osk_mutex_signal(session_data->lock);
-
-	_mali_osk_free(blocks);
-
-found:
-	ump_dmabuf.ctx = (void *)session_data;
-	ump_dmabuf.secure_id = ump_dd_secure_id_get(ump_handle);
-	ump_dmabuf.size = ump_dd_size_get(ump_handle);
-
-	if (copy_to_user(argument, &ump_dmabuf,
-			 sizeof(_ump_uk_dmabuf_s))) {
-		MSG_ERR(("copy_to_user() failed.\n"));
-		ret =  -EFAULT;
-		goto err_release_ump_handle;
-	}
-
-	return ret;
-
-err_release_ump_handle:
-	ump_dd_reference_release(ump_handle);
-err_free_session:
-	_mali_osk_free(session);
-err_free_block:
-	_mali_osk_free(blocks);
-err_dma_buf_unmap:
-	dma_buf_unmap_attachment(attach, sgt, DMA_BIDIRECTIONAL);
-err_dma_buf_detach:
-	dma_buf_detach(dma_buf, attach);
-err_dma_buf_put:
-	dma_buf_put(dma_buf);
-	return ret;
-}
-#endif
diff --git a/drivers/gpu/arm/ump/linux/ump_ukk_ref_wrappers.h b/drivers/gpu/arm/ump/linux/ump_ukk_ref_wrappers.h
old mode 100755
new mode 100644
index b8b2ccef..569d941f
--- a/drivers/gpu/arm/ump/linux/ump_ukk_ref_wrappers.h
+++ b/drivers/gpu/arm/ump/linux/ump_ukk_ref_wrappers.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2013-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2013-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -25,9 +25,7 @@ extern "C" {
 
 
 int ump_allocate_wrapper(u32 __user *argument, struct ump_session_data   *session_data);
-#ifdef CONFIG_DMA_SHARED_BUFFER
-int ump_dmabuf_import_wrapper(u32 __user *argument, struct ump_session_data  *session_data);
-#endif
+
 
 #ifdef __cplusplus
 }
diff --git a/drivers/gpu/arm/ump/linux/ump_ukk_wrappers.c b/drivers/gpu/arm/ump/linux/ump_ukk_wrappers.c
old mode 100755
new mode 100644
index 2a88f50b..7774930d
--- a/drivers/gpu/arm/ump/linux/ump_ukk_wrappers.c
+++ b/drivers/gpu/arm/ump/linux/ump_ukk_wrappers.c
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
@@ -44,7 +44,7 @@ int ump_get_api_version_wrapper(u32 __user *argument, struct ump_session_data *s
 	err = _ump_uku_get_api_version(&version_info);
 	if (_MALI_OSK_ERR_OK != err) {
 		MSG_ERR(("_ump_uku_get_api_version() failed in ump_ioctl_get_api_version()\n"));
-		return ump_map_errcode(err);
+		return map_errcode(err);
 	}
 
 	version_info.ctx = NULL;
@@ -83,7 +83,7 @@ int ump_release_wrapper(u32 __user *argument, struct ump_session_data   *session
 	err = _ump_ukk_release(&release_args);
 	if (_MALI_OSK_ERR_OK != err) {
 		MSG_ERR(("_ump_ukk_release() failed in ump_ioctl_release()\n"));
-		return ump_map_errcode(err);
+		return map_errcode(err);
 	}
 
 
@@ -113,7 +113,7 @@ int ump_size_get_wrapper(u32 __user *argument, struct ump_session_data   *sessio
 	err = _ump_ukk_size_get(&user_interaction);
 	if (_MALI_OSK_ERR_OK != err) {
 		MSG_ERR(("_ump_ukk_size_get() failed in ump_ioctl_size_get()\n"));
-		return ump_map_errcode(err);
+		return map_errcode(err);
 	}
 
 	user_interaction.ctx = NULL;
diff --git a/drivers/gpu/arm/ump/linux/ump_ukk_wrappers.h b/drivers/gpu/arm/ump/linux/ump_ukk_wrappers.h
old mode 100755
new mode 100644
index 1adad5b7..51f43137
--- a/drivers/gpu/arm/ump/linux/ump_ukk_wrappers.h
+++ b/drivers/gpu/arm/ump/linux/ump_ukk_wrappers.h
@@ -1,9 +1,9 @@
 /*
- * Copyright (C) 2010, 2012-2014, 2016 ARM Limited. All rights reserved.
- * 
+ * Copyright (C) 2010, 2012-2015 ARM Limited. All rights reserved.
+ *
  * This program is free software and is provided to you under the terms of the GNU General Public License version 2
  * as published by the Free Software Foundation, and any use by you of this program is subject to the terms of such GNU licence.
- * 
+ *
  * A copy of the licence is included with the program, and can also be obtained from Free Software
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
  */
diff --git a/drivers/gpu/arm/ump/readme.txt b/drivers/gpu/arm/ump/readme.txt
old mode 100755
new mode 100644
