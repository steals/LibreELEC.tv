diff --git a/drivers/amlogic/hdmi/Kconfig b/drivers/amlogic/hdmi/Kconfig
index 84d38a0b..1bfc2899 100755
--- a/drivers/amlogic/hdmi/Kconfig
+++ b/drivers/amlogic/hdmi/Kconfig
@@ -1,31 +1,34 @@
 menu "HDMI TX Support"
 
+config AML_HDMI_TX_20
+        bool "HDMI 2.0 Output Enable"
+        default n
+        select SWITCH
+        select AM_DISPLAY_MODULE
+        help  
+                hdmi 2.0 output enable. It should be enalbe if board have hdmi 2.0 out interface
+
 config AML_HDMI_TX
-        bool "HDMI Output Enable"
+        bool "HDMI 1.4 Output Enable"
         default y
         select SWITCH
         select AM_DISPLAY_MODULE
-        help  
-                hdmi output enable,It should be enalbe if board have hdmi out interface
+        help
+                hdmi 1.4 output enable, It should be enalbe if board have hdmi 1.4 out interface
 
-if AML_HDMI_TX
+if AML_HDMI_TX || AML_HDMI_TX_20
 config AML_HDMI_TX_HDCP
         bool "HDMI HDCP Enable"
         default n
         help
                 hdmitx hdcp enable, it should be enalbe if board burned hdmitx hdcp keys
+endif
 
-config AML_HDMI_TX_CTS_DVI
-        bool "HDMI DVI mode Output Enable"
+if AML_HDMI_TX
+config AML_HDMI_TX_NEW_CEC_DRIVER
+        bool "HDMI new CEC driver"
         default n
         help
-                HDMI DVI output enable. By default, Tx will output HDMI mode signal, not DVI.
-                If you want to pass HDMI official CTS or compliance DVI device, enable it.
-
-config AML_HDMI_TX_NEW_CEC_DRIVER                                                                                                                 
-        bool "HDMI new CEC driver"                                                                                                                
-        default n                                                                                                                                 
-        help                                                                                                                                      
                 hdmitx uses new CEC driver
 endif
 
diff --git a/drivers/amlogic/hdmi/Makefile b/drivers/amlogic/hdmi/Makefile
index cb5f878b..8c66238a 100755
--- a/drivers/amlogic/hdmi/Makefile
+++ b/drivers/amlogic/hdmi/Makefile
@@ -1 +1,6 @@
 obj-$(CONFIG_AML_HDMI_TX)  +=  hdmi_tx/
+obj-$(CONFIG_AML_HDMI_TX_20)  +=  hdmi_tx_2/
+
+ifdef CONFIG_AML_HDMI_TX_20
+obj-y	+= hdmi_common/
+endif
diff --git a/drivers/amlogic/hdmi/hdmi_common/Makefile b/drivers/amlogic/hdmi/hdmi_common/Makefile
new file mode 100644
index 00000000..6964e1c3
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_common/Makefile
@@ -0,0 +1,3 @@
+obj-y		+= hdmi_common.o
+
+hdmi_common-objs := hdmi_parameters.o
diff --git a/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c b/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c
new file mode 100644
index 00000000..1e7d1828
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_common/hdmi_parameters.c
@@ -0,0 +1,771 @@
+#include <linux/kernel.h>
+#include <linux/amlogic/hdmi_tx/hdmi_common.h>
+
+static struct hdmi_format_para fmt_para_1920x1080p60_16x9 = {
+    .vic = HDMI_1920x1080p60_16x9,
+    .name = "1920x1080p60hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 148500,
+    .timing = {
+        .pixel_freq = 148500,
+        .h_freq = 67500,
+        .v_freq = 60000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1920,
+        .h_total = 2200,
+        .h_blank = 280,
+        .h_front = 88,
+        .h_sync = 44,
+        .h_back = 148,
+        .v_active = 1080,
+        .v_total = 1125,
+        .v_blank = 45,
+        .v_front = 4,
+        .v_sync = 5,
+        .v_back = 36,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_1920x1080p50_16x9 = {
+    .vic = HDMI_1920x1080p50_16x9,
+    .name = "1920x1080p50hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 148500,
+    .timing = {
+        .pixel_freq = 148500,
+        .h_freq = 56250,
+        .v_freq = 50000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1920,
+        .h_total = 2640,
+        .h_blank = 720,
+        .h_front = 528,
+        .h_sync = 44,
+        .h_back = 148,
+        .v_active = 1080,
+        .v_total = 1125,
+        .v_blank = 45,
+        .v_front = 4,
+        .v_sync = 5,
+        .v_back = 36,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_1920x1080p24_16x9 = {
+    .vic = HDMI_1920x1080p24_16x9,
+    .name = "1920x1080p24hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 74250,
+    .timing = {
+        .pixel_freq = 74250,
+        .h_freq = 27000,
+        .v_freq = 24000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1920,
+        .h_total = 2750,
+        .h_blank = 830,
+        .h_front = 638,
+        .h_sync = 44,
+        .h_back = 148,
+        .v_active = 1080,
+        .v_total = 1125,
+        .v_blank = 45,
+        .v_front = 4,
+        .v_sync = 5,
+        .v_back = 36,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p30_16x9 = {
+    .vic = HDMI_3840x2160p30_16x9,
+    .name = "3840x2160p30hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 297000,
+    .timing = {
+        .pixel_freq = 297000,
+        .h_freq = 67500,
+        .v_freq = 30000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 4400,
+        .h_blank = 560,
+        .h_front = 176,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 2160,
+        .v_total = 2250,
+        .v_blank = 90,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p60_16x9 = {
+    .vic = HDMI_3840x2160p60_16x9,
+    .name = "3840x2160p60hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 1,
+    .tmds_clk_div40 = 1,
+    .tmds_clk = 594000,
+    .timing = {
+        .pixel_freq = 594000,
+        .h_freq = 135000,
+        .v_freq = 60000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 4400,
+        .h_blank = 560,
+        .h_front = 176,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 2160,
+        .v_total = 2250,
+        .v_blank = 90,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p50_16x9 = {
+    .vic = HDMI_3840x2160p50_16x9,
+    .name = "3840x2160p50hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 1,
+    .tmds_clk_div40 = 1,
+    .tmds_clk = 594000,
+    .timing = {
+        .pixel_freq = 594000,
+        .h_freq = 112500,
+        .v_freq = 50000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 5280,
+        .h_blank = 1440,
+        .h_front = 1056,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 2160,
+        .v_total = 2250,
+        .v_blank = 90,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p25_16x9 = {
+    .vic = HDMI_3840x2160p25_16x9,
+    .name = "3840x2160p25hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 297000,
+    .timing = {
+        .pixel_freq = 297000,
+        .h_freq = 56250,
+        .v_freq = 25000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 5280,
+        .h_blank = 1440,
+        .h_front = 1056,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 2160,
+        .v_total = 2250,
+        .v_blank = 90,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x2160p24_16x9 = {
+    .vic = HDMI_3840x2160p24_16x9,
+    .name = "3840x2160p24hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 297000,
+    .timing = {
+        .pixel_freq = 297000,
+        .h_freq = 54000,
+        .v_freq = 24000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 5500,
+        .h_blank = 1660,
+        .h_front = 1276,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 2160,
+        .v_total = 2250,
+        .v_blank = 90,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_4096x2160p24_256x135 = {
+    .vic = HDMI_4096x2160p24_256x135,
+    .name = "4096x2160p24hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 297000,
+    .timing = {
+        .pixel_freq = 297000,
+        .h_freq = 54000,
+        .v_freq = 24000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 4096,
+        .h_total = 5500,
+        .h_blank = 1404,
+        .h_front = 1020,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 2160,
+        .v_total = 2250,
+        .v_blank = 90,
+        .v_front = 8,
+        .v_sync = 10,
+        .v_back = 72,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_1920x1080i60_16x9 = {
+    .vic = HDMI_1920x1080i60_16x9,
+    .name = "1920x1080i60hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 0,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 74250,
+    .timing = {
+        .pixel_freq = 74250,
+        .h_freq = 33750,
+        .v_freq = 60000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1920,
+        .h_total = 2200,
+        .h_blank = 280,
+        .h_front = 88,
+        .h_sync = 44,
+        .h_back = 148,
+        .v_active = 1080/2,
+        .v_total = 1125,
+        .v_blank = 45/2,
+        .v_front = 2,
+        .v_sync = 5,
+        .v_back = 15,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_1920x1080i50_16x9 = {
+    .vic = HDMI_1920x1080i50_16x9,
+    .name = "1920x1080i50hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 0,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 74250,
+    .timing = {
+        .pixel_freq = 74250,
+        .h_freq = 28125,
+        .v_freq = 50000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1920,
+        .h_total = 2640,
+        .h_blank = 720,
+        .h_front = 528,
+        .h_sync = 44,
+        .h_back = 148,
+        .v_active = 1080/2,
+        .v_total = 1125,
+        .v_blank = 45/2,
+        .v_front = 2,
+        .v_sync = 5,
+        .v_back = 15,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_1280x720p60_16x9 = {
+    .vic = HDMI_1280x720p60_16x9,
+    .name = "1280x720p60hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 74250,
+    .timing = {
+        .pixel_freq = 74250,
+        .h_freq = 45000,
+        .v_freq = 60000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1280,
+        .h_total = 1650,
+        .h_blank = 370,
+        .h_front = 110,
+        .h_sync = 40,
+        .h_back = 220,
+        .v_active = 720,
+        .v_total = 750,
+        .v_blank = 30,
+        .v_front = 5,
+        .v_sync = 5,
+        .v_back = 20,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_1280x720p50_16x9 = {
+    .vic = HDMI_1280x720p50_16x9,
+    .name = "1280x720p50hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 74250,
+    .timing = {
+        .pixel_freq = 74250,
+        .h_freq = 37500,
+        .v_freq = 50000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 1280,
+        .h_total = 1980,
+        .h_blank = 700,
+        .h_front = 440,
+        .h_sync = 40,
+        .h_back = 220,
+        .v_active = 720,
+        .v_total = 750,
+        .v_blank = 30,
+        .v_front = 5,
+        .v_sync = 5,
+        .v_back = 20,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_720x480p60_16x9 = {
+    .vic = HDMI_720x480p60_16x9,
+    .name = "720x480p60hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 27000,
+    .timing = {
+        .pixel_freq = 27000,
+        .h_freq = 31469,
+        .v_freq = 59940,
+        .vsync_polarity = 0,
+        .hsync_polarity = 0,
+        .h_active = 720,
+        .h_total = 858,
+        .h_blank = 138,
+        .h_front = 16,
+        .h_sync = 62,
+        .h_back = 60,
+        .v_active = 480,
+        .v_total = 525,
+        .v_blank = 45,
+        .v_front = 9,
+        .v_sync = 6,
+        .v_back = 30,
+        .v_sync_ln = 7,
+    },
+};
+
+static struct hdmi_format_para fmt_para_720x480i60_16x9 = {
+    .vic = HDMI_720x480i60_16x9,
+    .name = "720x480i60hz",
+    .pixel_repetition_factor = 1,
+    .progress_mode = 0,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 27000,
+    .timing = {
+        .pixel_freq = 27000,
+        .h_freq = 15734,
+        .v_freq = 59940,
+        .vsync_polarity = 0,
+        .hsync_polarity = 0,
+        .h_active = 1440,
+        .h_total = 1716,
+        .h_blank = 276,
+        .h_front = 38,
+        .h_sync = 124,
+        .h_back = 114,
+        .v_active = 480/2,
+        .v_total = 525,
+        .v_blank = 45/2,
+        .v_front = 4,
+        .v_sync = 3,
+        .v_back = 15,
+        .v_sync_ln = 4,
+    },
+};
+
+static struct hdmi_format_para fmt_para_720x576p50_16x9 = {
+    .vic = HDMI_720x576p50_16x9,
+    .name = "720x576p50hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 27000,
+    .timing = {
+        .pixel_freq = 27000,
+        .h_freq = 31250,
+        .v_freq = 50000,
+        .vsync_polarity = 0,
+        .hsync_polarity = 0,
+        .h_active = 720,
+        .h_total = 864,
+        .h_blank = 144,
+        .h_front = 12,
+        .h_sync = 64,
+        .h_back = 68,
+        .v_active = 576,
+        .v_total = 625,
+        .v_blank = 49,
+        .v_front = 5,
+        .v_sync = 5,
+        .v_back = 39,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_720x576i50_16x9 = {
+    .vic = HDMI_720x576i50_16x9,
+    .name = "720x576i50hz",
+    .pixel_repetition_factor = 1,
+    .progress_mode = 0,
+    .scrambler_en = 0,
+    .tmds_clk_div40 = 0,
+    .tmds_clk = 27000,
+    .timing = {
+        .pixel_freq = 27000,
+        .h_freq = 15625,
+        .v_freq = 50000,
+        .vsync_polarity = 0,
+        .hsync_polarity = 0,
+        .h_active = 1440,
+        .h_total = 1728,
+        .h_blank = 288,
+        .h_front = 24,
+        .h_sync = 126,
+        .h_back = 138,
+        .v_active = 576/2,
+        .v_total = 625,
+        .v_blank = 49/2,
+        .v_front = 2,
+        .v_sync = 3,
+        .v_back = 19,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x1080p120_16x9 = {
+    .vic = HDMI_3840x1080p120hz,
+    .name = "3840x1080p120hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 1,
+    .tmds_clk_div40 = 1,
+    .tmds_clk = 594000,
+    .timing = {
+        .pixel_freq = 594000,
+        .h_freq = 135000,
+        .v_freq = 120000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 4400,
+        .h_blank = 560,
+        .h_front = 176,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 1080,
+        .v_total = 1125,
+        .v_blank = 45,
+        .v_front = 4,
+        .v_sync = 5,
+        .v_back = 36,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x1080p100_16x9 = {
+    .vic = HDMI_3840x1080p100hz,
+    .name = "3840x1080p100hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 1,
+    .tmds_clk_div40 = 1,
+    .tmds_clk = 594000,
+    .timing = {
+        .pixel_freq = 594000,
+        .h_freq = 112500,
+        .v_freq = 50000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 5280,
+        .h_blank = 1440,
+        .h_front = 1056,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 1080,
+        .v_total = 1125,
+        .v_blank = 45,
+        .v_front = 4,
+        .v_sync = 5,
+        .v_back = 36,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x540p240_16x9 = {
+    .vic = HDMI_3840x540p240hz,
+    .name = "3840x540p240hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 1,
+    .tmds_clk_div40 = 1,
+    .tmds_clk = 594000,
+    .timing = {
+        .pixel_freq = 594000,
+        .h_freq = 135000,
+        .v_freq = 120000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 4400,
+        .h_blank = 560,
+        .h_front = 176,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 540,
+        .v_total = 562,
+        .v_blank = 22,
+        .v_front = 2,
+        .v_sync = 2,
+        .v_back = 18,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para fmt_para_3840x540p200_16x9 = {
+    .vic = HDMI_3840x1080p100hz,
+    .name = "3840x1080p200hz",
+    .pixel_repetition_factor = 0,
+    .progress_mode = 1,
+    .scrambler_en = 1,
+    .tmds_clk_div40 = 1,
+    .tmds_clk = 594000,
+    .timing = {
+        .pixel_freq = 594000,
+        .h_freq = 112500,
+        .v_freq = 50000,
+        .vsync_polarity = 1,
+        .hsync_polarity = 1,
+        .h_active = 3840,
+        .h_total = 5280,
+        .h_blank = 1440,
+        .h_front = 1056,
+        .h_sync = 88,
+        .h_back = 296,
+        .v_active = 540,
+        .v_total = 562,
+        .v_blank = 22,
+        .v_front = 2,
+        .v_sync = 2,
+        .v_back = 18,
+        .v_sync_ln = 1,
+    },
+};
+
+static struct hdmi_format_para *all_fmt_paras[] = {
+    &fmt_para_3840x2160p60_16x9,
+    &fmt_para_3840x2160p50_16x9,
+    &fmt_para_3840x2160p30_16x9,
+    &fmt_para_3840x2160p25_16x9,
+    &fmt_para_3840x2160p24_16x9,
+    &fmt_para_4096x2160p24_256x135,
+    &fmt_para_1920x1080p50_16x9,
+    &fmt_para_1920x1080p60_16x9,
+    &fmt_para_1920x1080p24_16x9,
+    &fmt_para_1920x1080i60_16x9,
+    &fmt_para_1920x1080i50_16x9,
+    &fmt_para_1280x720p60_16x9,
+    &fmt_para_1280x720p50_16x9,
+    &fmt_para_720x480p60_16x9,
+    &fmt_para_720x480i60_16x9,
+    &fmt_para_720x576p50_16x9,
+    &fmt_para_720x576i50_16x9,
+    &fmt_para_3840x1080p100_16x9,
+    &fmt_para_3840x1080p120_16x9,
+    &fmt_para_3840x540p200_16x9,
+    &fmt_para_3840x540p240_16x9,
+};
+
+struct hdmi_format_para * hdmi_get_fmt_paras(HDMI_Video_Codes_t vic)
+{
+    int i;
+    for(i = 0; i < sizeof(all_fmt_paras) / sizeof(struct hdmi_format_para*); i++) {
+        if(vic == all_fmt_paras[i]->vic)
+            return all_fmt_paras[i];
+    }
+    return NULL;
+}
+
+// For check all format parameters only
+void check_detail_fmt(void)
+{
+    int i;
+    struct hdmi_format_para * p;
+    struct hdmi_cea_timing * t;
+    printk("VIC Hactive Vactive I/P Htotal Hblank Vtotal Vblank Hfreq Vfreq Pfreq\n");
+    for(i = 0; i < sizeof(all_fmt_paras) / sizeof(struct hdmi_format_para*); i++) {
+        p = all_fmt_paras[i];
+        t = &p->timing;
+        printk("%s[%d] %d %d %c %d %d %d %d %d %d %d\n", all_fmt_paras[i]->name, all_fmt_paras[i]->vic,
+                t->h_active, t->v_active, (p->progress_mode) ? 'P' : 'I',
+                t->h_total, t->h_blank, t->v_total, t->v_blank,
+                t->h_freq, t->v_freq, t->pixel_freq);
+    }
+
+    printk("\nVIC Hfront Hsync Hback Hpol Vfront Vsync Vback Vpol Ln\n");
+    for(i = 0; i < sizeof(all_fmt_paras) / sizeof(struct hdmi_format_para*); i++) {
+        p = all_fmt_paras[i];
+        t = &p->timing;
+        printk("%s[%d] %d %d %d %c %d %d %d %c %d\n", all_fmt_paras[i]->name, all_fmt_paras[i]->vic,
+                t->h_front, t->h_sync, t->h_back, (t->hsync_polarity) ? 'P' : 'N',
+                t->v_front, t->v_sync, t->v_back, (t->vsync_polarity) ? 'P' : 'N',
+                t->v_sync_ln);
+    }
+
+    printk("\nCheck Horizon parameter\n");
+    for(i = 0; i < sizeof(all_fmt_paras) / sizeof(struct hdmi_format_para*); i++) {
+        p = all_fmt_paras[i];
+        t = &p->timing;
+        if(t->h_total != (t->h_active + t->h_blank))
+            printk("VIC[%d] Ht[%d] != (Ha[%d] + Hb[%d])\n", all_fmt_paras[i]->vic,
+                   t->h_total, t->h_active, t->h_blank);
+        if(t->h_blank != (t->h_front + t->h_sync + t->h_back))
+            printk("VIC[%d] Hb[%d] != (Hf[%d] + Hs[%d] + Hb[%d])\n", all_fmt_paras[i]->vic, t->h_blank,
+                    t->h_front, t->h_sync, t->h_back);
+    }
+
+    printk("\nCheck Vertical parameter\n");
+    for(i = 0; i < sizeof(all_fmt_paras) / sizeof(struct hdmi_format_para*); i++) {
+        p = all_fmt_paras[i];
+        t = &p->timing;
+        if(t->v_total != (t->v_active + t->v_blank))
+            printk("VIC[%d] Vt[%d] != (Va[%d] + Vb[%d]\n", all_fmt_paras[i]->vic,
+                   t->v_total, t->v_active, t->v_blank);
+        if((t->v_blank != (t->v_front + t->v_sync + t->v_back)) & (p->progress_mode == 1))
+            printk("VIC[%d] Vb[%d] != (Vf[%d] + Vs[%d] + Vb[%d])\n", all_fmt_paras[i]->vic, t->v_blank,
+                    t->v_front, t->v_sync, t->v_back);
+        if((t->v_blank/2 != (t->v_front + t->v_sync + t->v_back)) & (p->progress_mode == 0))
+            printk("VIC[%d] Vb[%d] != (Vf[%d] + Vs[%d] + Vb[%d])\n", all_fmt_paras[i]->vic, t->v_blank,
+                    t->v_front, t->v_sync, t->v_back);
+    }
+}
+
+struct hdmi_audio_fs_fmt_n_cts aud_32k_para = {
+    .array[0] = {
+        .tmds_clk = 25174,
+        .n = 4576,
+        .cts = 28125,
+    },
+    .array[1] = {
+        .tmds_clk = 74176,
+        .n = 11648,
+        .cts = 210937,
+    },
+    .array[2] = {
+        .tmds_clk = 148352,
+        .n = 11648,
+        .cts = 421875,
+    },
+    .array[3] = {
+        .tmds_clk = 296703,
+        .n = 5824,
+        .cts = 421875,
+    },
+    .array[4] = {
+        .tmds_clk = 297000,
+        .n = 3072,
+        .cts = 222750,
+    },
+    .def_n = 4096,
+};
+
+static struct hdmi_audio_fs_fmt_n_cts *all_aud_paras [] = {
+    NULL,
+    &aud_32k_para,
+};
+
+unsigned int hdmi_get_aud_n_paras(audio_fs_t fs, unsigned int tmds_clk)
+{
+    struct hdmi_audio_fs_fmt_n_cts *p = NULL;
+    unsigned int i;
+
+    p = all_aud_paras[fs];
+    for(i = 0; i < AUDIO_PARA_MAX_NUM; i++) {
+        if(tmds_clk == p->array[i].tmds_clk)
+            break;
+    }
+
+    if((i < AUDIO_PARA_MAX_NUM) && (p->array[i].n))
+        return p->array[i].n;
+    else
+        return p->def_n;
+}
diff --git a/drivers/amlogic/hdmi/hdmi_tx/Makefile b/drivers/amlogic/hdmi/hdmi_tx/Makefile
index 45b2d142..f74ec1f1 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/Makefile
+++ b/drivers/amlogic/hdmi/hdmi_tx/Makefile
@@ -1,6 +1,6 @@
 obj-$(CONFIG_AML_HDMI_TX)		+= hdmitx.o
 
-hdmitx-objs := hdmi_tx.o hdmi_tx_video.o hdmi_tx_audio.o hdmi_tx_edid.o hdmi_tx_audio.o hdmi_tx_hdcp.o
+hdmitx-objs := hdmi_tx.o hdmi_tx_video.o hdmi_tx_audio.o hdmi_tx_edid.o hdmi_tx_audio.o hdmi_tx_hdcp.o hdmi_tx_compliance.o
 
 ifdef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
   hdmitx-objs += amlogic_cec.o
diff --git a/drivers/amlogic/hdmi/hdmi_tx/aml.dtd b/drivers/amlogic/hdmi/hdmi_tx/aml.dtd
index 30182fe0..dde8ce10 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/aml.dtd
+++ b/drivers/amlogic/hdmi/hdmi_tx/aml.dtd
@@ -15,20 +15,20 @@
 				 74  0x16  0x40    /* 720p 1080i */
 				 148  0x16  0x40   /* 1080p */
 				>;
-#endif        
-        
+#endif
+
 //$$ MATCH "HDMI_vend-data_match" = <&vend_data>
 //$$ L2 PROP_STR = "vendor_name"
 //$$ L2 PROP_U32 = "vendor_id"
 //$$ L2 PROP_STR = "product_desc"
-//$$ L2 PROP_STR = "cec_osd_string"        
+//$$ L2 PROP_STR = "cec_osd_string"
         vend_data: vend_data{
             vendor_name = "Amlogic";           /* Max Chars: 8     */
             vendor_id = <0x000000>;                 /* Refer to http://standards.ieee.org/develop/regauth/oui/oui.txt   */
             product_desc = "M8 MBox SKTv1";        /* Max Chars: 16    */
             cec_osd_string = "Amlogic MBox";        /* Max Chars: 14    */
         };
-        
+
 //$$ MATCH "HDMI_pwr-ctrl_match" = <&pwr_ctrl>
 //$$ L2 PROP_STR = "pwr_5v_on"
 //$$ L2 PROP_STR = "pwr_5v_off"
diff --git a/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c b/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c
index c1f7d63c..10961c31 100644
--- a/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/amlogic_cec.c
@@ -39,20 +39,21 @@
 
 #define CONFIG_TV_DEBUG // for verbose output
 //#undef CONFIG_TV_DEBUG
-unsigned long amlogic_cec_debug_flag = 1;
 
 MODULE_AUTHOR("Gerald Dachs");
 MODULE_DESCRIPTION("Amlogic CEC driver");
 MODULE_LICENSE("GPL");
 
-//unused, only left to satisfy the linker
-bool cec_msg_dbg_en = 1;
+bool cec_msg_dbg_en = 0;
+
+MODULE_PARM_DESC(cec_msg_dbg_en, "\n cec_msg_dbg_en\n");
+module_param(cec_msg_dbg_en, bool, 0664);
 
 #define DRV_NAME "amlogic_cec"
 #ifndef amlogic_cec_log_dbg
 #define amlogic_cec_log_dbg(fmt, ...) \
-    if (amlogic_cec_debug_flag)       \
-	printk(KERN_INFO "[%s] %s(): " fmt, DRV_NAME, __func__, ##__VA_ARGS__)
+    if (cec_msg_dbg_en)       \
+        printk(KERN_INFO "[%s] %s(): " fmt, DRV_NAME, __func__, ##__VA_ARGS__)
 #endif
 
 #define CEC_IOC_MAGIC        'c'
@@ -60,7 +61,7 @@ bool cec_msg_dbg_en = 1;
 #define CEC_IOC_GETPADDR     _IO(CEC_IOC_MAGIC, 1)
 
 #define VERSION   "0.0.1" /* Driver version number */
-#define CEC_MINOR 243	/* Major 10, Minor 242, /dev/cec */
+#define CEC_MINOR 243        /* Major 10, Minor 242, /dev/cec */
 
 /* CEC Rx buffer size */
 #define CEC_RX_BUFF_SIZE            16
@@ -70,29 +71,29 @@ bool cec_msg_dbg_en = 1;
 static DEFINE_SEMAPHORE(init_mutex);
 
 struct cec_rx_list {
-	u8 buffer[CEC_RX_BUFF_SIZE];
-	unsigned char size;
-	struct list_head list;
+        u8 buffer[CEC_RX_BUFF_SIZE];
+        unsigned char size;
+        struct list_head list;
 };
 
 struct cec_rx_struct {
-	spinlock_t lock;
-	wait_queue_head_t waitq;
-	atomic_t state;
-	struct list_head list;
+        spinlock_t lock;
+        wait_queue_head_t waitq;
+        atomic_t state;
+        struct list_head list;
 };
 
 struct cec_tx_struct {
-	spinlock_t lock;
-	wait_queue_head_t waitq;
-	atomic_t state;
+        spinlock_t lock;
+        wait_queue_head_t waitq;
+        atomic_t state;
 };
 
 enum cec_state {
-	STATE_RX,
-	STATE_TX,
-	STATE_DONE,
-	STATE_ERROR
+        STATE_RX,
+        STATE_TX,
+        STATE_DONE,
+        STATE_ERROR
 };
 
 static char banner[] __initdata =
@@ -102,6 +103,8 @@ static struct cec_rx_struct cec_rx_struct;
 
 static struct cec_tx_struct cec_tx_struct;
 
+static struct hrtimer cec_late_timer;
+
 static atomic_t hdmi_on = ATOMIC_INIT(0);
 
 cec_global_info_t cec_global_info;
@@ -118,26 +121,6 @@ static void amlogic_cec_set_tx_state(enum cec_state state)
     atomic_set(&cec_tx_struct.state, state);
 }
 
-static void amlogic_cec_msg_dump(char * msg_tag, const unsigned char *data, unsigned char count)
-{
-  int i;
-  int pos;
-  unsigned char msg_log_buf[128] = { 0 };
-
-  if (amlogic_cec_debug_flag == 1)
-  {
-      pos = 0;
-      pos += sprintf(msg_log_buf + pos, "msg %s len: %d   dat: ", msg_tag, count);
-      for (i = 0; i < count; ++i)
-      {
-          pos += sprintf(msg_log_buf + pos, "%02x ", data[i]);
-      }
-      pos += sprintf(msg_log_buf + pos, "\n");
-      msg_log_buf[pos] = '\0';
-      hdmi_print(INF, "[amlogic_cec] dump: %s", msg_log_buf);
-  }
-}
-
 static unsigned int amlogic_cec_read_reg(unsigned int reg)
 {
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
@@ -158,169 +141,126 @@ static void amlogic_cec_write_reg(unsigned int reg, unsigned int value)
 #endif
 }
 
-static int amlogic_cec_read_hw(unsigned char *data, unsigned char *count)
+static int amlogic_cec_read_hw()
 {
-    int ret = -1;
-    int valid_msg;
-    int rx_msg_status;
-    int rx_num_msg;
-
-    rx_msg_status = amlogic_cec_read_reg(CEC_RX_MSG_STATUS);
-    rx_num_msg = amlogic_cec_read_reg(CEC_RX_NUM_MSG);
-
-    amlogic_cec_log_dbg("rx_msg_status: %d, rx_num_msg: %d\n", rx_msg_status, rx_num_msg);
-
-    valid_msg = (RX_DONE == rx_msg_status) && (1 == rx_num_msg);
+    int retval = 0;
+    unsigned long spin_flags;
+    struct cec_rx_list *entry;
 
-    if (valid_msg)
+    if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
     {
-      int i;
-
-      *count = amlogic_cec_read_reg(CEC_RX_MSG_LENGTH) + 1;
-      for (i = 0; i < (*count) && i < CEC_RX_BUFF_SIZE; ++i)
-      {
-          data[i]= amlogic_cec_read_reg(CEC_RX_MSG_0_HEADER + i);
-      }
-
-      amlogic_cec_msg_dump("RX", data, *count);
+        amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
+        retval = -1;
+    }
 
-      ret = RX_DONE;
+    if ((-1) == cec_ll_rx(entry->buffer, &entry->size))
+    {
+        kfree(entry);
+        cec_rx_buf_clear();
     }
+    else
+    {
+        INIT_LIST_HEAD(&entry->list);
+        spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+        list_add_tail(&entry->list, &cec_rx_struct.list);
+        amlogic_cec_set_rx_state(STATE_DONE);
+        spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    aml_write_reg32(P_AO_CEC_INTR_CLR, aml_read_reg32(P_AO_CEC_INTR_CLR) | (1 << 2));
-#endif
-    amlogic_cec_write_reg(CEC_RX_MSG_CMD, valid_msg ? RX_ACK_NEXT : RX_ACK_CURRENT);
-    amlogic_cec_write_reg(CEC_RX_MSG_CMD, RX_NO_OP);
+        wake_up_interruptible(&cec_rx_struct.waitq);
+    }
 
-    return ret;
+    return retval;
 }
 
-
-static void amlogic_cec_write_hw(const char *data, size_t count)
+static void amlogic_cec_set_logical_addr(unsigned int logical_addr)
 {
-  int i;
-
-  for (i = 0; i < count; ++i)
-  {
-      amlogic_cec_write_reg(CEC_TX_MSG_0_HEADER + i, data[i]);
-  }
-  amlogic_cec_write_reg(CEC_TX_MSG_LENGTH, count - 1);
-  amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_REQ_CURRENT);
-
-  amlogic_cec_msg_dump("TX", data, count);
+    amlogic_cec_write_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | logical_addr);
+    cec_global_info.my_node_index = logical_addr;
 }
 
 unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
 {
-// unused, just to satisfy the linker
-  return log_addr;
+    // unused, just to satisfy the linker
+    return log_addr;
 }
 
-void cec_node_init(hdmitx_dev_t* hdmitx_device)
+static enum hrtimer_restart cec_late_check_rx_buffer(struct hrtimer *timer)
 {
-    unsigned long cec_phy_addr;
-    unsigned long spin_flags;
-    struct cec_rx_list *entry;
-
-    cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12)
-                 | (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)
-                 | (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)
-                 | (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
-
-    // If VSDB is not valid,use last or default physical address.
-    if (hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0)
+    if (cec_rx_buf_check())
     {
-	amlogic_cec_log_dbg("no valid cec physical address\n");
-	if (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)
-	{
-	    amlogic_cec_log_dbg("use last physical address\n");
-	}
-	else
-	{
-	    aml_write_reg32(P_AO_DEBUG_REG1, (aml_read_reg32(P_AO_DEBUG_REG1) & (0xf << 16)) | 0x1000);
-	    amlogic_cec_log_dbg("use default physical address\n");
-	}
+        /*
+         * start another check if rx buffer is full
+         */
+        if ((-1) == amlogic_cec_read_hw())
+        {
+            return HRTIMER_NORESTART;
+        }
     }
-    else
+    if (atomic_read(&hdmi_on))
     {
-	if (cec_global_info.my_node_index)
-	{
-	    // prevent write operations
-	    if (down_interruptible(&init_mutex))
-	    {
-		printk(KERN_ERR "[amlogic] ##### cec node init interrupted! #####\n");
-		return;
-	    }
-	    hdmitx_device->cec_init_ready = 0;
-            spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
-
-	    amlogic_cec_log_dbg("start reset\n");
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-	    aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)|(1<<16));
-	    hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_CTRL0, 0xc); //[3]cec_creg_sw_rst [2]cec_sys_sw_rst
-
-#if 0
-	    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_CLEAR_BUF, 0x1);
-	    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_RX_CLEAR_BUF, 0x1);
+        hrtimer_start(&cec_late_timer, ktime_set(0, 384*1000*1000), HRTIMER_MODE_REL);
+    }
 
-	    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_TX_CLEAR_BUF, 0x0);
-	    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_RX_CLEAR_BUF, 0x0);
-#endif
+    return HRTIMER_NORESTART;
+}
 
-	    hdmi_wr_reg(OTHER_BASE_ADDR+HDMI_OTHER_CTRL0, 0x0);
-	    aml_write_reg32(P_HDMI_CTRL_PORT, aml_read_reg32(P_HDMI_CTRL_PORT)&(~(1<<16)));
-	    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
-	    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
+void cec_node_init(hdmitx_dev_t* hdmitx_device)
+{
+    unsigned long cec_phy_addr;
 
+    if (atomic_read(&hdmi_on) && (0 == hdmitx_device->cec_init_ready))
+    {
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+        cec_gpi_init();
+        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1);
+        // Clear CEC Int. state and set CEC Int. mask
+        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
+        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
 #endif
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	    // regain rx interrupts
-	    cec_enable_irq();
+        // GPIOAO_12
+        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 0, 14, 1);       // bit[14]: AO_PWM_C pinmux                  //0xc8100014
+        aml_set_reg32_bits(P_AO_RTI_PULL_UP_REG, 1, 12, 1);       // bit[12]: enable AO_12 internal pull-up   //0xc810002c
+        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 17, 1);       // bit[17]: AO_CEC pinmux                    //0xc8100014
+        ao_cec_init();
+        cec_arbit_bit_time_set(3, 0x118, 0);
+        cec_arbit_bit_time_set(5, 0x000, 0);
+        cec_arbit_bit_time_set(7, 0x2aa, 0);
 #endif
-            spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
-
-            hdmitx_device->cec_init_ready = 1;
-
-	    up(&init_mutex);
-	    amlogic_cec_log_dbg("stop reset\n");
-	}
-
-	if ((aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff) != cec_phy_addr)
-	{
-	    aml_write_reg32(P_AO_DEBUG_REG1, (aml_read_reg32(P_AO_DEBUG_REG1) & (0xf << 16)) | cec_phy_addr);
-	    amlogic_cec_log_dbg("physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff);
-
-	    if ((hdmitx_device->cec_init_ready != 0) && (hdmitx_device->hpd_state != 0))
-	    {
-		if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
-		{
-		    amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
-		}
-		else
-		{
-		    // let the libCEC ask for new physical Address
-		    entry->buffer[0] = 0xff;
-		    entry->size = 1;
-		    INIT_LIST_HEAD(&entry->list);
-
-		    spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
-		    list_add_tail(&entry->list, &cec_rx_struct.list);
-		    amlogic_cec_set_rx_state(STATE_DONE);
-		    spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
-
-		    amlogic_cec_log_dbg("trigger libCEC\n");
-		    wake_up_interruptible(&cec_rx_struct.waitq);
-		}
-	    }
-	}
+        cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12)
+                     | (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)
+                     | (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)
+                     | (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
+
+        // If VSDB is not valid,use last or default physical address.
+        if (hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0)
+        {
+            amlogic_cec_log_dbg("no valid cec physical address\n");
+            if (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)
+            {
+                amlogic_cec_log_dbg("use last physical address\n");
+            }
+            else
+            {
+                aml_write_reg32(P_AO_DEBUG_REG1, (aml_read_reg32(P_AO_DEBUG_REG1) & (0xf << 16)) | 0x1000);
+                amlogic_cec_log_dbg("use default physical address\n");
+            }
+        }
+        else
+        {
+            if ((aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff) != cec_phy_addr)
+            {
+                aml_write_reg32(P_AO_DEBUG_REG1, (aml_read_reg32(P_AO_DEBUG_REG1) & (0xf << 16)) | cec_phy_addr);
+                amlogic_cec_log_dbg("physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff);
+            }
+        }
+
+        hdmitx_device->cec_init_ready = 1;
     }
 }
 
 static irqreturn_t amlogic_cec_irq_handler(int irq, void *dummy)
 {
-    unsigned long spin_flags;
-    struct cec_rx_list *entry;
     unsigned int tx_msg_state;
     unsigned int rx_msg_state;
 
@@ -335,45 +275,28 @@ static irqreturn_t amlogic_cec_irq_handler(int irq, void *dummy)
 
     if ((tx_msg_state == TX_DONE) || (tx_msg_state == TX_ERROR))
     {
-	amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-
-	switch (tx_msg_state) {
-	  case TX_ERROR :
-	    amlogic_cec_set_tx_state(STATE_ERROR);
-	    break;
-	  case TX_DONE :
-	    amlogic_cec_set_tx_state(STATE_DONE);
-	    break;
-	}
-	wake_up_interruptible(&cec_tx_struct.waitq);
+        switch (tx_msg_state) {
+          case TX_ERROR :
+            amlogic_cec_set_tx_state(STATE_ERROR);
+            break;
+          case TX_DONE :
+            amlogic_cec_set_tx_state(STATE_DONE);
+            break;
+        }
+        wake_up_interruptible(&cec_tx_struct.waitq);
+    }
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    if (aml_read_reg32(P_AO_CEC_INTR_STAT) & (1<<1))
+    {   // aocec tx intr
+        tx_irq_handle();
+        return IRQ_HANDLED;
     }
+#endif
 
     if (rx_msg_state == RX_DONE)
     {
-
-	if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
-	{
-	    amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
-	    return IRQ_HANDLED;
-	}
-
-	INIT_LIST_HEAD(&entry->list);
-
-	spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
-
-	if ((-1) == amlogic_cec_read_hw(entry->buffer, &entry->size))
-	{
-	    kfree(entry);
-	    amlogic_cec_log_dbg("amlogic_cec_irq_handler: nothing to read\n");
-            spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
-	    return IRQ_HANDLED;
-	}
-
-	list_add_tail(&entry->list, &cec_rx_struct.list);
-	amlogic_cec_set_rx_state(STATE_DONE);
-	spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
-
-	wake_up_interruptible(&cec_rx_struct.waitq);
+        amlogic_cec_read_hw();
     }
 
     return IRQ_HANDLED;
@@ -382,71 +305,66 @@ static irqreturn_t amlogic_cec_irq_handler(int irq, void *dummy)
 static int amlogic_cec_open(struct inode *inode, struct file *file)
 {
     int ret = 0;
+    unsigned long spin_flags;
+    struct cec_rx_list* entry = NULL;
 
     if (atomic_read(&hdmi_on))
     {
-	amlogic_cec_log_dbg("do not allow multiple open for tvout cec\n");
-	ret = -EBUSY;
+        amlogic_cec_log_dbg("do not allow multiple open for tvout cec\n");
+        ret = -EBUSY;
     }
     else
     {
-	atomic_inc(&hdmi_on);
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-        if (request_irq(INT_HDMI_CEC, &amlogic_cec_irq_handler,
-        IRQF_SHARED, "amhdmitx-cec",(void *)hdmitx_device))
-        {
-    	    amlogic_cec_log_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
-            return -EFAULT;
-        }
-#endif
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-        if (request_irq(INT_AO_CEC, &amlogic_cec_irq_handler,
-        IRQF_SHARED, "amhdmitx-aocec",(void *)hdmitx_device))
+        atomic_inc(&hdmi_on);
+
+        spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+        while(!list_empty(&cec_rx_struct.list))
         {
-    	    amlogic_cec_log_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
-            return -EFAULT;
+            entry = list_first_entry(&cec_rx_struct.list, struct cec_rx_list, list);
+            list_del(&entry->list);
+            kfree(entry);
         }
-#endif
+        spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
 
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-        cec_gpi_init();
-#endif
+        cec_node_init(hdmitx_device);
 
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-        aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1);
-        // Clear CEC Int. state and set CEC Int. mask
-        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
-        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
-#endif
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-// GPIOAO_12
-        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 0, 14, 1);       // bit[14]: AO_PWM_C pinmux                  //0xc8100014
-        aml_set_reg32_bits(P_AO_RTI_PULL_UP_REG, 1, 12, 1);       // bit[12]: enable AO_12 internal pull-up   //0xc810002c
-        aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 17, 1);       // bit[17]: AO_CEC pinmux                    //0xc8100014
-        ao_cec_init();
-        cec_arbit_bit_time_set(3, 0x118, 0);
-        cec_arbit_bit_time_set(5, 0x000, 0);
-        cec_arbit_bit_time_set(7, 0x2aa, 0);
-#endif
-        amlogic_cec_write_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+        cec_enable_irq();
 
-        hdmitx_device->cec_init_ready = 1;
+        amlogic_cec_set_logical_addr(0xf);
 
+        if (hdmitx_device->hpd_state != 0)
+        {
+            if ((entry = kmalloc(sizeof(struct cec_rx_list), GFP_ATOMIC)) == NULL)
+            {
+                amlogic_cec_log_dbg("can't alloc cec_rx_list\n");
+            }
+            else
+            {
+                // let the libCEC ask for new physical Address
+                entry->buffer[0] = 0xff;
+                entry->size = 1;
+                INIT_LIST_HEAD(&entry->list);
+
+                spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
+                list_add_tail(&entry->list, &cec_rx_struct.list);
+                amlogic_cec_set_rx_state(STATE_DONE);
+                spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
+
+                amlogic_cec_log_dbg("trigger libCEC\n");
+                wake_up_interruptible(&cec_rx_struct.waitq);
+            }
+        }
+
+        hrtimer_start(&cec_late_timer, ktime_set(0, 384*1000*1000), HRTIMER_MODE_REL);
     }
     return ret;
 }
 
 static int amlogic_cec_release(struct inode *inode, struct file *file)
 {
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
-    free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
-#endif
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    free_irq(INT_AO_CEC, (void *)hdmitx_device);
-#endif
+    amlogic_cec_set_logical_addr(0xf);
 
-    amlogic_cec_write_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+    cec_disable_irq();
 
     atomic_dec(&hdmi_on);
 
@@ -454,17 +372,17 @@ static int amlogic_cec_release(struct inode *inode, struct file *file)
 }
 
 static ssize_t amlogic_cec_read(struct file *file, char __user *buffer,
-				size_t count, loff_t *ppos)
+                                size_t count, loff_t *ppos)
 {
     ssize_t retval;
     unsigned long spin_flags;
     struct cec_rx_list* entry = NULL;
 
     if (wait_event_interruptible(cec_rx_struct.waitq,
-				 atomic_read(&cec_rx_struct.state) == STATE_DONE))
+                                 atomic_read(&cec_rx_struct.state) == STATE_DONE))
     {
-	amlogic_cec_log_dbg("error during wait on state change\n");
-	return -ERESTARTSYS;
+        amlogic_cec_log_dbg("error during wait on state change\n");
+        return -ERESTARTSYS;
     }
 
     spin_lock_irqsave(&cec_rx_struct.lock, spin_flags);
@@ -473,17 +391,17 @@ static ssize_t amlogic_cec_read(struct file *file, char __user *buffer,
 
     if (entry == NULL || entry->size > count)
     {
-	amlogic_cec_log_dbg("entry is NULL, or empty\n");
-	retval = -1;
-	goto error_exit;
+        amlogic_cec_log_dbg("entry is NULL, or empty\n");
+        retval = -1;
+        goto error_exit;
     }
 
     if (copy_to_user(buffer, entry->buffer, entry->size))
     {
-	printk(KERN_ERR " copy_to_user() failed!\n");
+        printk(KERN_ERR " copy_to_user() failed!\n");
 
-	retval = -EFAULT;
-	goto error_exit;
+        retval = -EFAULT;
+        goto error_exit2;
     }
 
     retval = entry->size;
@@ -491,34 +409,35 @@ static ssize_t amlogic_cec_read(struct file *file, char __user *buffer,
 error_exit:
     if (entry != NULL)
     {
-    	list_del(&entry->list);
-    	kfree(entry);
+            list_del(&entry->list);
+            kfree(entry);
     }
 
     if (list_empty(&cec_rx_struct.list))
     {
-        amlogic_cec_set_rx_state(STATE_RX);
+            amlogic_cec_set_rx_state(STATE_RX);
     }
 
+error_exit2:
     spin_unlock_irqrestore(&cec_rx_struct.lock, spin_flags);
 
     return retval;
 }
 
 static ssize_t amlogic_cec_write(struct file *file, const char __user *buffer,
-			size_t count, loff_t *ppos)
+                        size_t count, loff_t *ppos)
 {
     int retval = count;
     char data[CEC_TX_BUFF_SIZE];
 
     /* check data size */
     if (count > CEC_TX_BUFF_SIZE || count == 0)
-	return -1;
+        return -1;
 
     if (copy_from_user(data, buffer, count))
     {
-	printk(KERN_ERR " copy_from_user() failed!\n");
-	return -EFAULT;
+        printk(KERN_ERR " copy_from_user() failed!\n");
+        return -EFAULT;
     }
 
     amlogic_cec_set_tx_state(STATE_TX);
@@ -526,28 +445,25 @@ static ssize_t amlogic_cec_write(struct file *file, const char __user *buffer,
     // don't write if cec_node_init() is in progress
     if (down_interruptible(&init_mutex))
     {
-	amlogic_cec_log_dbg("error during wait on state change\n");
-	printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
-	return -ERESTARTSYS;
+        amlogic_cec_log_dbg("error during wait on state change\n");
+        return -ERESTARTSYS;
     }
 
-    amlogic_cec_write_hw(data, count);
+    cec_ll_tx(data, count);
 
     if (wait_event_interruptible_timeout(cec_tx_struct.waitq,
         atomic_read(&cec_tx_struct.state) != STATE_TX, 2 * HZ) <= 0)
     {
-	amlogic_cec_log_dbg("error during wait on state change, resetting\n");
-	printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
-	amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_ABORT); // stop cec tx for hw retry.
-	amlogic_cec_write_reg(CEC_TX_MSG_CMD, TX_NO_OP);
-	retval = -ERESTARTSYS;
-	goto error_exit;
+        amlogic_cec_log_dbg("error during wait on state change, resetting\n");
+        cec_hw_reset();
+        retval = -ERESTARTSYS;
+        goto error_exit;
     }
 
     if (atomic_read(&cec_tx_struct.state) != STATE_DONE)
     {
-	printk(KERN_ERR "[amlogic] ##### cec write error! #####\n");
-	retval = -1;
+        amlogic_cec_log_dbg("##### cec write error! #####\n");
+        retval = -1;
     }
 
 error_exit:
@@ -557,7 +473,7 @@ error_exit:
 }
 
 static long amlogic_cec_ioctl(struct file *file, unsigned int cmd,
-						unsigned long arg)
+                                                unsigned long arg)
 {
     unsigned char logical_addr;
     unsigned int reg;
@@ -570,8 +486,7 @@ static long amlogic_cec_ioctl(struct file *file, unsigned int cmd,
             return -EFAULT;
         }
 
-        amlogic_cec_write_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | logical_addr);
-        cec_global_info.my_node_index = logical_addr;
+        amlogic_cec_set_logical_addr(logical_addr);
         /*
          * use DEBUG_REG1 bit 16 ~ 31 to save logic address.
          * So uboot can use this logic address directly
@@ -585,7 +500,7 @@ static long amlogic_cec_ioctl(struct file *file, unsigned int cmd,
 
     case CEC_IOC_GETPADDR:
         amlogic_cec_log_dbg("amlogic_cec_ioctl: return physical address 0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff);
-    	return aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff;
+            return aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff;
     }
 
     return -EINVAL;
@@ -593,13 +508,16 @@ static long amlogic_cec_ioctl(struct file *file, unsigned int cmd,
 
 static u32 amlogic_cec_poll(struct file *file, poll_table *wait)
 {
-    if (atomic_read(&cec_rx_struct.state) != STATE_DONE)
+    if (atomic_read(&cec_rx_struct.state) == STATE_DONE)
     {
-        poll_wait(file, &cec_rx_struct.waitq, wait);
+        return POLLIN | POLLRDNORM;
     }
+
+    poll_wait(file, &cec_rx_struct.waitq, wait);
+
     if (atomic_read(&cec_rx_struct.state) == STATE_DONE)
     {
-	return POLLIN | POLLRDNORM;
+        return POLLIN | POLLRDNORM;
     }
     return 0;
 }
@@ -627,7 +545,7 @@ static int amlogic_cec_init(void)
 
     if (down_interruptible(&init_mutex))
     {
-      return -ERESTARTSYS;
+        return -ERESTARTSYS;
     }
 
     INIT_LIST_HEAD(&cec_rx_struct.list);
@@ -637,7 +555,7 @@ static int amlogic_cec_init(void)
     hdmitx_device = get_hdmitx_device();
     amlogic_cec_log_dbg("CEC init\n");
 
-    amlogic_cec_write_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0xf);
+    amlogic_cec_set_logical_addr(0xf);
 
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
     hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
@@ -654,9 +572,29 @@ static int amlogic_cec_init(void)
 
     if (misc_register(&cec_misc_device))
     {
-	printk(KERN_WARNING " Couldn't register device 10, %d.\n", CEC_MINOR);
-	retval = -EBUSY;
+        printk(KERN_WARNING " Couldn't register device 10, %d.\n", CEC_MINOR);
+        retval = -EBUSY;
+    }
+
+    hrtimer_init(&cec_late_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    cec_late_timer.function = cec_late_check_rx_buffer;
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    if (request_irq(INT_HDMI_CEC, &amlogic_cec_irq_handler,
+        IRQF_SHARED, "amhdmitx-cec",(void *)hdmitx_device))
+    {
+        amlogic_cec_log_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
+    }
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    if (request_irq(INT_AO_CEC, &amlogic_cec_irq_handler,
+        IRQF_SHARED, "amhdmitx-aocec",(void *)hdmitx_device))
+    {
+        amlogic_cec_log_dbg("Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
     }
+#endif
 
     // release initial lock on init_mutex
     up(&init_mutex);
@@ -668,8 +606,16 @@ static int amlogic_cec_init(void)
 
 static void amlogic_cec_exit(void)
 {
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
+    free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    free_irq(INT_AO_CEC, (void *)hdmitx_device);
+#endif
     misc_deregister(&cec_misc_device);
 }
 
 module_init(amlogic_cec_init);
 module_exit(amlogic_cec_exit);
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
old mode 100644
new mode 100755
index da1d0763..8a5a2590
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_cec_key.c
@@ -1,178 +1,217 @@
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/irq.h>
-#include <linux/types.h>
-#include <linux/input.h>
-#include <linux/kernel.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/mm.h>
-#include <linux/major.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/cdev.h>
-#include <asm/irq.h>
-#include <asm/io.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/errno.h>
-
-#include <asm/uaccess.h>
-#include <asm/delay.h>
-#include <mach/am_regs.h>
-#include <mach/power_gate.h>
-#include <linux/amlogic/tvin/tvin.h>
-
-#include <mach/gpio.h>
-#include <mach/hdmi_tx_reg.h>
-#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
-#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
-hdmitx_dev_t *hdmitx_device = NULL;
-
-__u16 cec_key_map[160] = {
-    KEY_ENTER, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, 0 , 0 , 0 ,//0x00
-    0 , KEY_HOMEPAGE , KEY_MENU, 0, 0, KEY_BACK, 0, 0,
-    0 , 0, 0, 0, 0, 0, 0, 0,//0x10
-    0 , 0, 0, 0, 0, 0, 0, 0,
-    KEY_0 , KEY_1, KEY_2, KEY_3,KEY_4, KEY_5, KEY_6, KEY_7,//0x20
-    KEY_8 , KEY_9, KEY_DOT, 0, 0, 0, 0, 0,
-    KEY_CHANNELUP , KEY_CHANNELDOWN, KEY_CHANNEL, 0, 0, 0, 0, 0,//0x30
-    0 , 0, 0, 0, 0, 0, 0, 0,
-    
-    KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, KEY_RECORD,//0x40
-    KEY_REWIND, KEY_FASTFORWARD, KEY_EJECTCD, KEY_NEXTSONG, KEY_PREVIOUSSONG, 0, 0, 0,
-    0 , 0, 0, KEY_PROGRAM, 0, 0, 0, 0,//0x50
-    0 , 0, 0, 0, 0, 0, 0, 0,
-    KEY_PLAYCD, KEY_PLAYPAUSE, KEY_RECORD, KEY_PAUSECD, KEY_STOPCD, KEY_MUTE, 0, KEY_TUNER,//0x60
-    0 , KEY_MEDIA, 0, 0, KEY_POWER, 0, 0, 0,
-    0 , KEY_BLUE, KEY_RED, KEY_GREEN, KEY_YELLOW, 0, 0, 0,//0x70
-    0 , 0, 0, 0, 0, 0, 0, 0x2fd,
-    0 , 0, 0, 0, 0, 0, 0, 0,//0x80
-    0 , 0, 0, 0, 0, 0, 0, 0,
-    0 , KEY_EXIT, 0, 0, 0, 0, KEY_PVR, 0,//0x90  //samsung vendor buttons return and channel_list
-    0 , 0, 0, 0, 0, 0, 0, 0,
-};
-
-void cec_send_event(cec_rx_message_t* pcec_message)
-{
-    int i;
-    unsigned char brdcst, opcode;
-    unsigned char initiator, follower;
-    unsigned char operand_num;
-    unsigned char msg_length;
-    unsigned char operands[14];
-    
-    /* parse message */
-    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0)) return;
-
-    initiator   = pcec_message->content.msg.header >> 4;
-    follower    = pcec_message->content.msg.header & 0x0f;
-    opcode      = pcec_message->content.msg.opcode;   
-    operand_num = pcec_message->operand_num;
-    brdcst      = (follower == 0x0f);
-    msg_length  = pcec_message->msg_length;
-    
-    for (i = 0; i < operand_num; i++ ) {
-       operands[i] = pcec_message->content.msg.operands[i]; 
-       hdmi_print(INF, CEC  ":operands[%d]:%u\n", i, operands[i]);       
-    }
-    if(cec_global_info.cec_flag.cec_key_flag) {
-        input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 1);
-        input_sync(cec_global_info.remote_cec_dev);
-        hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands[0]]);
-    }
-    else{
-        input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 0);
-        input_sync(cec_global_info.remote_cec_dev);
-        hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands[0]]);
-    }   
-}
-
-
-void cec_send_event_irq(void)
-{
-    int i;
-    unsigned char   operand_num_irq;
-    unsigned char operands_irq[14];
-         
-    operand_num_irq = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num;
-    for (i = 0; i < operand_num_irq; i++ )
-    {
-        operands_irq[i] = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.operands[i]; 
-        hdmi_print(INF, CEC  ":operands_irq[%d]:0x%x\n", i, operands_irq[i]);       
-    }
-    
-    switch(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.operands[0]){
-    case 0x33:
-        //cec_system_audio_mode_request();
-        //cec_set_system_audio_mode();
-        break;
-    case 0x35:
-        break;
-    default:
-        break;      
-    }	
-    
-    input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 1);
-    input_sync(cec_global_info.remote_cec_dev);	
-    input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 0);
-    input_sync(cec_global_info.remote_cec_dev);
-    hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands_irq[0]]);      		  	 	
-}
-
-void cec_user_control_pressed_irq(void)
-{
-    hdmi_print(INF, CEC  ": Key pressed \n");
-    cec_send_event_irq();
-}
-
-void cec_user_control_released_irq(void)  
-{
-    hdmi_print(INF, CEC  ": Key released \n");
-} 
-
-void cec_user_control_pressed(cec_rx_message_t* pcec_message)
-{
-    hdmi_print(INF, CEC  ": Key pressed \n");
-    cec_global_info.cec_flag.cec_key_flag = 1;
-    cec_send_event(pcec_message);
-}
-
-void cec_user_control_released(cec_rx_message_t* pcec_message)  
-{
-    hdmi_print(INF, CEC  ": Key released \n");
-    cec_global_info.cec_flag.cec_key_flag = 1;
-    cec_send_event(pcec_message);
-}
-
-
-/*
- * STANDBY: get STANDBY command from TV
- */
-void cec_standby(cec_rx_message_t* pcec_message)
-{
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
-        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) {
-            hdmi_print(INF, CEC  ": System will be in standby mode\n");
-            input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_POWER, 1);
-            input_sync(cec_global_info.remote_cec_dev);
-            input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_POWER, 0);
-            input_sync(cec_global_info.remote_cec_dev);
-            cec_disable_irq();
-        }
-    }
-}
-
-void cec_key_init(void)
-{
-    extern hdmitx_dev_t * get_hdmitx_device(void);
-    hdmitx_device = get_hdmitx_device();
-}
-
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/power_gate.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#include <mach/gpio.h>
+#include <mach/hdmi_tx_reg.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+hdmitx_dev_t *hdmitx_device = NULL;
+
+__u16 cec_key_map[160] = {
+    KEY_SELECT, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, 0 , 0 , 0 ,//0x00
+    0 , KEY_HOMEPAGE , KEY_MENU, 0, 0, KEY_BACK, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x10
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    KEY_0 , KEY_1, KEY_2, KEY_3,KEY_4, KEY_5, KEY_6, KEY_7,//0x20
+    KEY_8 , KEY_9, KEY_DOT, 0, 0, 0, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x30
+    0 , 0, 0, 0, 0, 0, 0, 0,
+
+    KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, KEY_RECORD,//0x40
+    KEY_REWIND, KEY_FASTFORWARD, KEY_EJECTCD, KEY_NEXTSONG, KEY_PREVIOUSSONG, 0, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x50
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    KEY_PLAYCD, KEY_PLAYPAUSE, KEY_RECORD, KEY_PAUSECD, KEY_STOPCD, KEY_MUTE, 0, KEY_TUNER,//0x60
+    0 , KEY_MEDIA, 0, 0, KEY_POWER, KEY_POWER, 0, 0,
+    0 , KEY_BLUE, KEY_RED, KEY_GREEN, KEY_YELLOW, 0, 0, 0,//0x70
+    0 , 0, 0, 0, 0, 0, 0, 0x2fd,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x80
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    0 , KEY_BACK, 0, 0, 0, 0, 0, 0,//0x90
+    0 , 0, 0, 0, 0, 0, 0, 0,
+};
+
+void cec_send_event(cec_rx_message_t* pcec_message)
+{
+    int i;
+    unsigned char brdcst, opcode;
+    unsigned char initiator, follower;
+    unsigned char operand_num;
+    unsigned char msg_length;
+    unsigned char operands[14];
+
+    /* parse message */
+    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0)) return;
+
+    initiator   = pcec_message->content.msg.header >> 4;
+    follower    = pcec_message->content.msg.header & 0x0f;
+    opcode      = pcec_message->content.msg.opcode;
+    operand_num = pcec_message->operand_num;
+    brdcst      = (follower == 0x0f);
+    msg_length  = pcec_message->msg_length;
+
+    for (i = 0; i < operand_num; i++)
+    {
+       operands[i] = pcec_message->content.msg.operands[i];
+       hdmi_print(INF, CEC  ":operands[%d]:%u\n", i, operands[i]);
+    }
+    if (cec_global_info.cec_flag.cec_key_flag)
+    {
+        input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 1);
+        input_sync(cec_global_info.remote_cec_dev);
+        hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands[0]]);
+    }
+    else
+    {
+        input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 0);
+        input_sync(cec_global_info.remote_cec_dev);
+        hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands[0]]);
+    }
+}
+
+
+void cec_send_event_irq(void)
+{
+    int i;
+    unsigned char   operand_num_irq;
+    unsigned char operands_irq[14];
+    static unsigned int last_key = -1;
+    static s64 last_key_report = 0;
+    s64 cur_time;
+    ktime_t now = ktime_get();
+
+    operand_num_irq = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num;
+    for (i = 0; i < operand_num_irq; i++ )
+    {
+        operands_irq[i] = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.operands[i];
+        hdmi_print(INF, CEC  ":operands_irq[%d]:0x%x\n", i, operands_irq[i]);
+    }
+
+    switch (cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.operands[0])
+    {
+        case 0x33:
+            //cec_system_audio_mode_request();
+            //cec_set_system_audio_mode();
+            break;
+        case 0x35:
+            break;
+        default:
+            break;
+    }
+
+    cur_time = ktime_to_us(now);
+    if (last_key == -1) {
+        last_key = operands_irq[0];
+    } else {
+        /*
+         * filter for 2 key power function nearby
+         */
+        if ((cec_key_map[last_key] == cec_key_map[operands_irq[0]]) &&
+            (cec_key_map[operands_irq[0]] == KEY_POWER)) {
+            if (cur_time - last_key_report < (s64)(600 * 1000)) {  // small than 600ms
+                printk("same key function too quick, last key:%x, cur key:%x, lsat:%lld, cur:%lld, diff:%lld\n",
+                       last_key, operands_irq[0], cur_time, last_key_report, cur_time - last_key_report);
+                printk("ignore this key\n");
+                return ;
+            }
+        }
+    }
+
+    input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 1);
+    input_sync(cec_global_info.remote_cec_dev);
+    input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 0);
+    input_sync(cec_global_info.remote_cec_dev);
+    hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands_irq[0]]);
+    last_key_report = cur_time;
+    last_key = operands_irq[0];
+}
+
+void cec_user_control_pressed_irq(void)
+{
+    hdmi_print(INF, CEC  ": Key pressed \n");
+    cec_send_event_irq();
+}
+
+void cec_user_control_released_irq(void)
+{
+    hdmi_print(INF, CEC  ": Key released \n");
+}
+
+void cec_user_control_pressed(cec_rx_message_t* pcec_message)
+{
+    hdmi_print(INF, CEC  ": Key pressed \n");
+    cec_global_info.cec_flag.cec_key_flag = 1;
+    cec_send_event(pcec_message);
+}
+
+void cec_user_control_released(cec_rx_message_t* pcec_message)
+{
+    hdmi_print(INF, CEC  ": Key released \n");
+    cec_global_info.cec_flag.cec_key_flag = 1;
+    cec_send_event(pcec_message);
+}
+
+
+/*
+ * STANDBY: get STANDBY command from TV
+ */
+void cec_standby(cec_rx_message_t* pcec_message)
+{
+    unsigned int mask;
+    static s64 last_standby = 0;
+    s64 cur_time;
+
+    ktime_t now = ktime_get();
+    cur_time = ktime_to_us(now);
+    printk("cur time:%lld, last standby:%lld, diff:%lld\n",
+           cur_time, last_standby, cur_time - last_standby);
+    if (cur_time - last_standby < (s64)(600 * 1000)) {  // small than 600ms
+        printk("standby recieved too much\n");
+        return ;
+    }
+    mask = (1 << CEC_FUNC_MSAK) | (1 << ONE_TOUCH_STANDBY_MASK);
+    if ((hdmitx_device->cec_func_config & mask) == mask) {
+        hdmi_print(INF, CEC  ": System will be in standby mode\n");
+        input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_POWER, 1);
+        input_sync(cec_global_info.remote_cec_dev);
+        input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_POWER, 0);
+        input_sync(cec_global_info.remote_cec_dev);
+        //cec_disable_irq();
+    }
+    last_standby = cur_time;
+}
+
+void cec_key_init(void)
+{
+    extern hdmitx_dev_t * get_hdmitx_device(void);
+    hdmitx_device = get_hdmitx_device();
+}
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
index 985d2c5a..531d6c98 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx.c
@@ -48,6 +48,8 @@
 #include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
 #include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
 #include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_compliance.h>
+#include <linux/amlogic/vout/enc_clk_config.h>
 
 #define DEVICE_NAME "amhdmitx"
 #define HDMI_TX_COUNT 32
@@ -63,6 +65,9 @@ static int set_disp_mode_auto(void);
 const vinfo_t * hdmi_get_current_vinfo(void);
 
 struct hdmi_config_platform_data *hdmi_pdata;
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+static int suspend_flag=0;
+#endif
 
 static hdmitx_dev_t hdmitx_device;
 static struct switch_dev sdev = {      // android ics switch device
@@ -76,7 +81,9 @@ static void hdmitx_early_suspend(struct early_suspend *h)
     hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
     if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0))
         return;
-
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	suspend_flag=1;
+#endif
     phdmi->hpd_lock = 1;
     phdmi->HWOp.Cntl((hdmitx_dev_t *)h->param, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_EARLY_SUSPEND);
     phdmi->cur_VIC = HDMI_Unkown;
@@ -103,7 +110,9 @@ static void hdmitx_late_resume(struct early_suspend *h)
     hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
     hdmitx_device.internal_mode_change = 0;
     set_disp_mode_auto();
-
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	suspend_flag=0;
+#endif
     pr_info("amhdmitx: late resume module %d\n", __LINE__);
     phdmi->HWOp.Cntl((hdmitx_dev_t *)h->param, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_LATE_RESUME);
     hdmi_print(INF, SYS "late resume\n");
@@ -141,18 +150,9 @@ static int force_vout_index = 0;
 #endif
 static int hdmi_prbs_mode = 0xffff; /* 0xffff=disable; 0=PRBS 11; 1=PRBS 15; 2=PRBS 7; 3=PRBS 31*/
 static int hdmi_480p_force_clk = 0; /* 200, 225, 250, 270 */
-
+static int hdmi_detect_when_booting = 1;
 static int debug_level = INF;     // 1: error  2: important  3: normal  4: detailed
 
-void control_hdmiphy(int on)
-{
-	pr_info("%s - onoff : %d\n", __func__, on);
-	if (on)
-		hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_ENABLE);
-	else
-		hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
-}
-
 /*****************************
 *    hdmitx attr management :
 *    enable
@@ -320,11 +320,12 @@ static void hdmitx_pre_display_init(void)
 
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 // judge whether the mode exchange is between similar vmode, such as between 1080p60 and 1080p59hz
-// "vic_old==HDMI_720P60" means old vic is HDMI_1080p60, but vmode maybe VMODE_1080P or VMODE_1080P_59HZ 
+// "vic_old==HDMI_720P60" means old vic is HDMI_1080p60, but vmode maybe VMODE_1080P or VMODE_1080P_59HZ
 static int is_similar_hdmi_vic(HDMI_Video_Codes_t vic_old, vmode_t mode_new)
 {
+	printk("%s[%d] vic_old=%d,mode_new=%d\n", __FUNCTION__, __LINE__,vic_old,mode_new);
 	if( (vic_old==HDMI_480p60_16x9) && (mode_new==VMODE_480P_59HZ) )
-		return 1;	
+		return 1;
 	if( (vic_old==HDMI_720p60) && (mode_new==VMODE_720P_59HZ) )
 		return 1;
 	if( (vic_old==HDMI_1080i60) &&(mode_new==VMODE_1080I_59HZ) )
@@ -395,7 +396,6 @@ static int set_disp_mode_auto(void)
     else {
         hdmi_print(IMP, VID "get current mode: %s\n", info->name);
     }
-
 // If info->name equals to cvbs, then set mode to I mode to hdmi
     if((strncmp(info->name, "480cvbs", 7) == 0) || (strncmp(info->name, "576cvbs", 7) == 0) ||
        (strncmp(info->name, "panel", 5) == 0) || (strncmp(info->name, "null", 4) == 0)) {
@@ -429,16 +429,39 @@ static int set_disp_mode_auto(void)
     }
 
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	if( is_similar_hdmi_vic(vic_ready, info->mode) )
+	if(suspend_flag==1)
+		vic_ready = HDMI_Unkown;
+	else if( is_similar_hdmi_vic(vic_ready, info->mode) ){
 		vic_ready = HDMI_Unkown;
+		printk("%s[%d] is similiar vic\n", __FUNCTION__, __LINE__);
+	}
 #endif
 
     if((vic_ready != HDMI_Unkown) && (vic_ready == vic)) {
         hdmi_print(IMP, SYS "[%s] ALREADY init VIC = %d\n", __func__, vic);
-        if (voutmode_dvi_vga()) {
-			pr_emerg("hdmi: dvi case judgement -> IEEEOUI: %d\n", hdmitx_device.RXCap.IEEEOUI);
-			hdmitx_device.RXCap.IEEEOUI = 0;
+        if(hdmitx_device.RXCap.IEEEOUI == 0) {
+            // DVI case judgement. In uboot, directly output HDMI mode
             hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_HDMI_DVI_MODE, DVI_MODE);
+            hdmi_print(IMP, SYS "change to DVI mode\n");
+        }
+        switch (vic) {
+        case HDMI_3840x2160p24_16x9:
+        case HDMI_3840x2160p25_16x9:
+        case HDMI_3840x2160p30_16x9:
+        case HDMI_4096x2160p24_256x135:
+            hdmitx_special_handler_video(&hdmitx_device);
+            if (IS_MESON_M8_CPU && hdmitx_is_special_tv_process()) {
+                unsigned ret = 0;
+                printk("%s[%d]\n", __func__, __LINE__);
+                set_vmode_clk(VMODE_4K2K_30HZ);
+                msleep(200);
+                ret = reset_hpll();
+                if (!ret)
+                    reset_hpll();
+            }
+            break;
+        default:
+            break;
         }
         hdmitx_device.cur_VIC = vic;
         hdmitx_device.output_blank_flag = 1;
@@ -509,7 +532,7 @@ static unsigned char is_dispmode_valid_for_hdmi(void)
 static ssize_t show_disp_mode(struct device * dev, struct device_attribute *attr, char * buf)
 {
     int pos=0;
-    pos+=snprintf(buf+pos, PAGE_SIZE, "VIC:%d\r\n", hdmitx_device.cur_VIC);
+    pos+=snprintf(buf+pos, PAGE_SIZE, "VIC:%d\n", hdmitx_device.cur_VIC);
     return pos;
 }
 
@@ -560,22 +583,6 @@ static ssize_t store_cec_lang_config(struct device * dev, struct device_attribut
     return count;
 }
 
-#else
-
-extern unsigned long amlogic_cec_debug_flag;
-
-static ssize_t show_amlogic_cec_debug_config(struct device *dev, struct device_attribute *attr, char *buf)
-{
-    return snprintf(buf, PAGE_SIZE, "amlogic_cec_debug:%lu\n", amlogic_cec_debug_flag);
-}
-
-static ssize_t store_amlogic_cec_debug_config(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
-{
-   return kstrtoul(buf, 16, &amlogic_cec_debug_flag) ? 0 : count;
-}
-
-#endif
-
 static ssize_t show_cec_lang_config(struct device * dev, struct device_attribute *attr, char * buf)
 {
     int pos=0;
@@ -583,6 +590,7 @@ static ssize_t show_cec_lang_config(struct device * dev, struct device_attribute
     pos+=snprintf(buf+pos, PAGE_SIZE, "%x\n",cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang);
     return pos;
 }
+#endif
 
 /*aud_mode attr*/
 static ssize_t show_aud_mode(struct device * dev, struct device_attribute *attr, char * buf)
@@ -681,8 +689,8 @@ static ssize_t show_config(struct device * dev, struct device_attribute *attr, c
     default:
         aud_conf = "none";
     }
-    pos += snprintf(buf+pos, PAGE_SIZE, "disp switch (force or edid): %s\r\n", (hdmitx_device.disp_switch_config==DISP_SWITCH_FORCE)?"force":"edid");
-    pos += snprintf(buf+pos, PAGE_SIZE, "audio config: %s\r\n", aud_conf);
+    pos += snprintf(buf+pos, PAGE_SIZE, "disp switch (force or edid): %s\n", (hdmitx_device.disp_switch_config==DISP_SWITCH_FORCE)?"force":"edid");
+    pos += snprintf(buf+pos, PAGE_SIZE, "audio config: %s\n", aud_conf);
     return pos;
 }
 
@@ -754,8 +762,6 @@ static ssize_t store_debug(struct device * dev, struct device_attribute *attr, c
 
 // support format lists
 const char* disp_mode_t[]={
-    "480x320p60hz",
-    "480x272p60hz",
     "480i",
     "480i_rpt",
     "480p",
@@ -765,17 +771,6 @@ const char* disp_mode_t[]={
     "576p",
     "576p_rpt",
     "720p",
-    "800p",
-    "800x480p60hz",
-    "480x800p60hz",
-    "1366x768p60hz",
-    "1600x900p60hz",
-    "800x600p60hz",
-    "1024x600p60hz",
-    "1024x768p60hz",
-    "1360x768p60hz",
-    "1440x900p60hz",
-    "1680x1050p60hz",
     "1080i",
     "1080p",
     "720p50hz",
@@ -786,9 +781,6 @@ const char* disp_mode_t[]={
     "4k2k25hz",
     "4k2k24hz",
     "4k2ksmpte",
-    "vga",
-    "sxga",
-    "1920x1200",
     NULL
 };
 
@@ -846,7 +838,7 @@ static ssize_t show_disp_cap_3d(struct device * dev, struct device_attribute *at
             }
         }
     }
-    pos += snprintf(buf+pos, PAGE_SIZE, "\r\n");
+    pos += snprintf(buf+pos, PAGE_SIZE, "\n");
 
     return pos;
 }
@@ -921,13 +913,13 @@ static ssize_t show_hdcp_ksv_info(struct device * dev, struct device_attribute *
     for(i = 0;i < 5; i++) {
         pos+=snprintf(buf+pos, PAGE_SIZE, "%02x", aksv_buf[i]);
     }
-    pos+=snprintf(buf+pos, PAGE_SIZE, "  %s\r\n", hdcp_ksv_valid(aksv_buf) ? "Valid" : "Invalid");
+    pos+=snprintf(buf+pos, PAGE_SIZE, "  %s\n", hdcp_ksv_valid(aksv_buf) ? "Valid" : "Invalid");
 
     pos+=snprintf(buf+pos, PAGE_SIZE, "BKSV: ");
     for(i = 0;i < 5; i++) {
         pos+=snprintf(buf+pos, PAGE_SIZE, "%02x", bksv_buf[i]);
     }
-    pos+=snprintf(buf+pos, PAGE_SIZE, "  %s\r\n", hdcp_ksv_valid(bksv_buf) ? "Valid" : "Invalid");
+    pos+=snprintf(buf+pos, PAGE_SIZE, "  %s\n", hdcp_ksv_valid(bksv_buf) ? "Valid" : "Invalid");
 
     return pos;
 }
@@ -945,7 +937,7 @@ static ssize_t show_support_3d(struct device * dev, struct device_attribute *att
 {
     int pos=0;
 
-    pos += snprintf(buf+pos, PAGE_SIZE,"%d\r\n", hdmitx_device.RXCap.threeD_present);
+    pos += snprintf(buf+pos, PAGE_SIZE,"%d\n", hdmitx_device.RXCap.threeD_present);
     return pos;
 }
 
@@ -978,8 +970,6 @@ static DEVICE_ATTR(cec, S_IWUSR | S_IRUGO, show_cec, store_cec);
 static DEVICE_ATTR(cec_config, S_IWUSR | S_IRUGO | S_IWGRP, show_cec_config, store_cec_config);
 //static DEVICE_ATTR(cec_config, S_IWUGO | S_IRUGO , NULL, store_cec_config);
 static DEVICE_ATTR(cec_lang_config, S_IWUSR | S_IRUGO | S_IWGRP, show_cec_lang_config, store_cec_lang_config);
-#else
-static DEVICE_ATTR(amlogic_cec_debug_config, S_IWUSR | S_IRUGO | S_IWGRP, show_amlogic_cec_debug_config, store_amlogic_cec_debug_config);
 #endif
 
 /*****************************
@@ -988,15 +978,19 @@ static DEVICE_ATTR(amlogic_cec_debug_config, S_IWUSR | S_IRUGO | S_IWGRP, show_a
 ******************************/
 static int hdmitx_notify_callback_v(struct notifier_block *block, unsigned long cmd , void *para)
 {
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 	const vinfo_t *info = NULL;
 	HDMI_Video_Codes_t vic_ready = HDMI_Unkown;
+#endif
 	if(get_cur_vout_index()!=1)
         return 0;
 
     if (cmd != VOUT_EVENT_MODE_CHANGE)
         return 0;
-	
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION	
+
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	if(suspend_flag==1)
+		return 0;
 	// vic_ready got from IP
     vic_ready = hdmitx_device.HWOp.GetState(&hdmitx_device, STAT_VIDEO_VIC, 0);
 	// get current vinfo
@@ -1007,6 +1001,12 @@ static int hdmitx_notify_callback_v(struct notifier_block *block, unsigned long
     }
     else {
         hdmi_print(IMP, VID "get current mode: %s\n", info->name);
+    }
+    if ( ((vic_ready == HDMI_1080p24) && (info->mode == VMODE_1080P_23HZ)) ||
+        ((vic_ready == HDMI_1080p24) && (info->mode == VMODE_1080P_24HZ)) ) {
+        if (hdmitx_device.HWOp.SetAudN) {
+            hdmitx_device.HWOp.SetAudN();
+        }
     }
 	if( is_similar_hdmi_vic(vic_ready, info->mode) )
 		return 0;
@@ -1162,7 +1162,7 @@ static int hdmitx_notify_callback_a(struct notifier_block *block, unsigned long
     audio_fs_t n_rate = aud_samp_rate_map(substream->runtime->rate);
     audio_sample_size_t n_size = aud_size_map(substream->runtime->sample_bits);
 
-    hdmitx_device.audio_param_update_flag = 1;
+    hdmitx_device.audio_param_update_flag = 0;
     hdmitx_device.audio_notify_flag = 0;
 
     if(audio_param->sample_rate != n_rate) {
@@ -1226,6 +1226,15 @@ static int hdmitx_notify_callback_a(struct notifier_block *block, unsigned long
 /******************************
 *  hdmitx kernel task
 *******************************/
+int tv_audio_support(int type, rx_cap_t * pRXCap)
+{
+    int i, audio_check = 0;
+    for(i = 0; i < pRXCap->AUD_count; i++){
+        if(pRXCap->RxAudioCap[i].audio_format_code == type)
+        audio_check = 1;
+    }
+    return audio_check;
+}
 
 static int hdmi_task_handle(void *data)
 {
@@ -1280,7 +1289,8 @@ wait:
             }
 // Check audio status
 #ifndef CONFIG_AML_HDMI_TX_HDCP
-            if((hdmitx_device->cur_VIC != HDMI_Unkown) && (!(hdmitx_device->HWOp.GetState(hdmitx_device, STAT_AUDIO_PACK, 0)))) {
+            if((hdmitx_device->cur_VIC != HDMI_Unkown) && (!(hdmitx_device->HWOp.GetState(hdmitx_device, STAT_AUDIO_PACK, 0)))
+            	 && (tv_audio_support(hdmitx_device->cur_audio_param.type, &hdmitx_device->RXCap))) {
                 hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_UNMUTE);
             }
 #endif
@@ -1305,6 +1315,12 @@ wait:
                 if(!(hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_IS_EDID_DATA_READY, 0))) {
                     hdmi_print(ERR, EDID "edid failed\n");
                     hdmitx_device->tv_no_edid = 1;
+                    hdmi_print(ERR, EDID "setting HDMI vendor\n");
+                    hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_HDMI_DVI_MODE, HDMI_MODE);
+                    hdmitx_device->RXCap.IEEEOUI = 0x000c03; /* Need to stop us being switched in to DVI mode */
+                    set_disp_mode_auto();
+                    hdmi_print(ERR, EDID "manual cec now\n");
+                    cec_node_init(hdmitx_device);
                 }
                 else {
                     goto edid_op;
@@ -1338,6 +1354,14 @@ edid_op:
             hdmitx_set_audio(hdmitx_device, &(hdmitx_device->cur_audio_param), hdmi_ch);
             switch_set_state(&sdev, 1);
             cec_node_init(hdmitx_device);
+#ifdef CONFIG_AM_HDMI_ONLY
+#if MESON_CPU_TYPE != MESON_CPU_TYPE_MESON6
+            if(hdmi_detect_when_booting) {
+                extern int set_mode_and_show_logo(int hpd_state);
+                hdmi_detect_when_booting = set_mode_and_show_logo(hdmitx_device->hpd_state);
+            }
+#endif
+#endif
         }
         if(hdmitx_device->hpd_event == 2)
         {
@@ -1367,6 +1391,14 @@ edid_op:
             hdmitx_device->tv_cec_support = 0;
             switch_set_state(&sdev, 0);
             hdmitx_device->vic_count = 0;
+#ifdef CONFIG_AM_HDMI_ONLY
+#if MESON_CPU_TYPE != MESON_CPU_TYPE_MESON6
+            if(hdmi_detect_when_booting) {
+                extern int set_mode_and_show_logo(int hpd_state);
+                hdmi_detect_when_booting = set_mode_and_show_logo(hdmitx_device->hpd_state);
+            }
+#endif
+#endif
         }
         msleep_interruptible(100);
     }
@@ -1454,7 +1486,7 @@ static int get_dt_vend_init_data(struct device_node *np, struct vendor_info_data
         hdmi_print(INF, SYS "not find cec osd string\n");
         return 1;
     }
-    
+
     ret = of_property_read_u32(np, "ao_cec", &(vend->ao_cec));
     if(ret) {
         hdmi_print(INF, SYS "not find ao cec\n");
@@ -1551,6 +1583,8 @@ static void hdmitx_pwr_init(struct hdmi_pwr_ctl *ctl)
     }
 }
 
+extern void register_hdmi_is_special_tv_func( int (*pfunc)(void) );
+
 static int amhdmitx_probe(struct platform_device *pdev)
 {
 #ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
@@ -1620,8 +1654,6 @@ static int amhdmitx_probe(struct platform_device *pdev)
     ret=device_create_file(hdmitx_dev, &dev_attr_cec);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec_config);
     ret=device_create_file(hdmitx_dev, &dev_attr_cec_lang_config);
-#else
-    ret=device_create_file(hdmitx_dev, &dev_attr_amlogic_cec_debug_config);
 #endif
 
     if (hdmitx_dev == NULL) {
@@ -1635,7 +1667,7 @@ static int amhdmitx_probe(struct platform_device *pdev)
     vout2_register_client(&hdmitx_notifier_nb_v2);
 #endif
     aout_register_client(&hdmitx_notifier_nb_a);
-
+    register_hdmi_is_special_tv_func(hdmitx_is_special_tv);
 #ifdef CONFIG_USE_OF
     if(pdev->dev.of_node){
         memset(&hdmitx_device.config_data, 0, sizeof(struct hdmi_config_platform_data));
@@ -1753,7 +1785,6 @@ static int amhdmitx_remove(struct platform_device *pdev)
 #ifndef CONFIG_AML_HDMI_TX_NEW_CEC_DRIVER
     device_remove_file(hdmitx_dev, &dev_attr_cec);
 #endif
-
     cdev_del(&hdmitx_device.cdev);
 
     device_destroy(hdmitx_class, hdmitx_id);
@@ -1771,37 +1802,63 @@ static int amhdmitx_remove(struct platform_device *pdev)
 #ifdef CONFIG_PM
 static int amhdmitx_suspend(struct platform_device *pdev,pm_message_t state)
 {
-#if 0
-    pr_info("amhdmitx: hdmirx_suspend\n");
-    hdmitx_pre_display_init();
-    if(hdmi_pdata){
-        hdmi_pdata->hdmi_5v_ctrl ? hdmi_pdata->hdmi_5v_ctrl(0) : 0;
-        hdmi_pdata->hdmi_3v3_ctrl ? hdmi_pdata->hdmi_3v3_ctrl(1) : 0;   // prevent Voff leak current
-    }
-    if(hdmitx_device.HWOp.Cntl)
-        hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
+#ifndef CONFIG_HAS_EARLYSUSPEND
+    const vinfo_t *info = hdmi_get_current_vinfo();
+    if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0))
+        return;
+    hdmitx_device.hpd_lock = 1;
+    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_EARLY_SUSPEND);
+    hdmitx_device.cur_VIC = HDMI_Unkown;
+    hdmitx_device.output_blank_flag = 0;
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, DDC_RESET_HDCP);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_AVI_PACKET, 0);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
+    hdmi_print(IMP, SYS "HDMITX: suspend\n");
 #endif
     return 0;
 }
 
 static int amhdmitx_resume(struct platform_device *pdev)
 {
-#if 0
-    pr_info("amhdmitx: resume module\n");
-    if(hdmi_pdata){
-        hdmi_pdata->hdmi_5v_ctrl ? hdmi_pdata->hdmi_5v_ctrl(1) : 0;
+#ifndef CONFIG_HAS_EARLYSUSPEND
+    const vinfo_t *info = hdmi_get_current_vinfo();
+    if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0)) {
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+       return ;
+    } else {
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_BLANK);
     }
-    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+    hdmitx_device.hpd_lock = 0;
     hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
     hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
     hdmitx_device.internal_mode_change = 0;
     set_disp_mode_auto();
     pr_info("amhdmitx: resume module %d\n", __LINE__);
+    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_LATE_RESUME);
+    hdmi_print(INF, SYS "resume\n");
 #endif
     return 0;
 }
 #endif
 
+static int amhdmitx_shutdown(struct platform_device *pdev,pm_message_t state)
+{
+    const vinfo_t *info = hdmi_get_current_vinfo();
+    if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0))
+        return;
+    hdmitx_device.hpd_lock = 1;
+    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_EARLY_SUSPEND);
+    hdmitx_device.cur_VIC = HDMI_Unkown;
+    hdmitx_device.output_blank_flag = 0;
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, DDC_RESET_HDCP);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_AVI_PACKET, 0);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
+    hdmi_print(IMP, SYS "HDMITX: shutdown\n");
+    return 0;
+}
+
 #ifdef CONFIG_OF
 static const struct of_device_id meson_amhdmitx_dt_match[]={
     {
@@ -1819,6 +1876,7 @@ static struct platform_driver amhdmitx_driver = {
     .suspend    = amhdmitx_suspend,
     .resume     = amhdmitx_resume,
 #endif
+    .shutdown	= amhdmitx_shutdown,
     .driver     = {
         .name   = DEVICE_NAME,
             .owner    = THIS_MODULE,
@@ -1971,7 +2029,7 @@ static  int __init hdmitx_boot_para_setup(char *s)
             }
             else if(strncmp(token, "cec", 3)==0) {
                 unsigned int list = simple_strtoul(token+3,NULL,16);
-                if((list >= 0) && (list <= 0xf)) {
+                if ((list >= 0) && (list <= 0x2f)) {
                     hdmitx_device.cec_func_config = list;
                     aml_write_reg32(P_AO_DEBUG_REG0, hdmitx_device.cec_func_config);         // save cec function list to AO_REG
                 }
@@ -1991,29 +2049,15 @@ static  int __init hdmitx_boot_para_setup(char *s)
 
 __setup("hdmitx=",hdmitx_boot_para_setup);
 
-static int dvi_mode = VOUTMODE_HDMI;
-
-int odroidc_voutmode(void)
-{
-	return dvi_mode;
-}
-EXPORT_SYMBOL(odroidc_voutmode);
-
-static  int __init vout_setup(char *s) {
-	dvi_mode = VOUTMODE_HDMI;
-	if (!strcmp(s, "dvi"))
-		dvi_mode = VOUTMODE_DVI;
-	else if (!strcmp(s, "vga"))
-		dvi_mode = VOUTMODE_VGA;
-	return 0;
-}
-__setup("vout=", vout_setup);
-
 #ifdef CONFIG_AM_TV_OUTPUT2
 MODULE_PARM_DESC(force_vout_index, "\n force_vout_index\n");
 module_param(force_vout_index, uint, 0664);
 #endif
 
+MODULE_PARM_DESC(hdmi_detect_when_booting, "\n hdmi_detect_when_booting \n");
+module_param(hdmi_detect_when_booting, int, 0664);
+
+
 MODULE_PARM_DESC(hdmi_480p_force_clk, "\n hdmi_480p_force_clk \n");
 module_param(hdmi_480p_force_clk, int, 0664);
 
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.c
old mode 100644
new mode 100755
index 54b2a485..6887221e
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_audio.c
@@ -14,6 +14,7 @@
 
 #include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
 #include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_compliance.h>
 
 #undef PCM_USE_INFOFRAME
 
@@ -227,8 +228,6 @@ int hdmitx_set_audio(hdmitx_dev_t* hdmitx_device, Hdmi_tx_audio_para_t* audio_pa
         hdmitx_device->HWOp.SetAudioInfoFrame(AUD_DB, CHAN_STAT_BUF);
         ret = 0;
     }
+    hdmitx_special_handler_audio(hdmitx_device);
     return ret;
 }
-
-
-
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
index f571393c..ec49f473 100755
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_cec.c
@@ -1,1960 +1,2232 @@
-/*
- * Amlogic Meson HDMI Transmitter Driver
- * HDMI CEC Driver-----------HDMI_TX
- * Copyright (C) 2011 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- */
-
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/irq.h>
-#include <linux/types.h>
-#include <linux/input.h>
-#include <linux/kernel.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/mm.h>
-#include <linux/major.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/cdev.h>
-#include <asm/irq.h>
-#include <asm/io.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/spinlock_types.h>
-#include <linux/switch.h>
-#include <linux/workqueue.h>
-
-#include <asm/uaccess.h>
-#include <asm/delay.h>
-#include <mach/am_regs.h>
-#include <mach/power_gate.h>
-#include <linux/amlogic/tvin/tvin.h>
-
-#include <mach/gpio.h>
-#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
-#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
-#include <mach/hdmi_tx_reg.h>
-#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
-
-static hdmitx_dev_t* hdmitx_device = NULL;
-
-DEFINE_SPINLOCK(cec_input_key);
-
-/* global variables */
-static    unsigned char    gbl_msg[MAX_MSG];
-cec_global_info_t cec_global_info;
-unsigned char rc_long_press_pwr_key = 0;
-EXPORT_SYMBOL(rc_long_press_pwr_key);
-bool cec_msg_dbg_en = 0;
-
-ssize_t    cec_lang_config_state(struct switch_dev *sdev, char *buf){
-    int pos=0;
-    pos+=snprintf(buf+pos, PAGE_SIZE, "%c%c%c\n", (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >>16) & 0xff, 
-                                                  (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 8) & 0xff,
-                                                  (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 0) & 0xff);
-    return pos;  
-};
-
-struct switch_dev lang_dev = {    // android ics switch device
-    .name = "lang_config",
-    .print_state = cec_lang_config_state,
-    };
-EXPORT_SYMBOL(lang_dev);
-
-static DEFINE_SPINLOCK(p_tx_list_lock);
-static unsigned long cec_tx_list_flags;
-static unsigned int tx_msg_cnt = 0;
-static struct list_head cec_tx_msg_phead = LIST_HEAD_INIT(cec_tx_msg_phead);
-
-unsigned int menu_lang_array[] = {(((unsigned int)'c')<<16)|(((unsigned int)'h')<<8)|((unsigned int)'i'),
-                                  (((unsigned int)'e')<<16)|(((unsigned int)'n')<<8)|((unsigned int)'g'),
-                                  (((unsigned int)'j')<<16)|(((unsigned int)'p')<<8)|((unsigned int)'n'),
-                                  (((unsigned int)'k')<<16)|(((unsigned int)'o')<<8)|((unsigned int)'r'),
-                                  (((unsigned int)'f')<<16)|(((unsigned int)'r')<<8)|((unsigned int)'a'),
-                                  (((unsigned int)'g')<<16)|(((unsigned int)'e')<<8)|((unsigned int)'r')
-                                 };
-
-// CEC default setting
-static unsigned char * osd_name = "MBox";
-static unsigned int vendor_id = 0x00;
-
-static irqreturn_t cec_isr_handler(int irq, void *dev_instance);
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
-static struct early_suspend hdmitx_cec_early_suspend_handler;
-static void hdmitx_cec_early_suspend(struct early_suspend *h)
-{
-    hdmi_print(INF, CEC "early suspend!\n");
-    if(!hdmitx_device->hpd_state) { //if none HDMI out,no CEC features.
-        hdmi_print(INF, CEC "HPD low!\n");
-        return;
-    }
-    
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
-        cec_menu_status_smp(DEVICE_MENU_INACTIVE);
-        cec_inactive_source();
-
-        if(rc_long_press_pwr_key == 1) {
-            cec_set_standby();
-            msleep(100);
-            hdmi_print(INF, CEC "get power-off command from Romote Control\n");
-            rc_long_press_pwr_key = 0;
-        }
-    }
-    cec_disable_irq();
-}
-
-static void hdmitx_cec_late_resume(struct early_suspend *h)
-{
-    cec_enable_irq();
-    if(!hdmitx_device->hpd_state) { //if none HDMI out,no CEC features.
-        hdmi_print(INF, CEC "HPD low!\n");
-        return;
-    }
-    
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
-        cec_hw_reset();//for M8 CEC standby.
-        cec_imageview_on_smp();
-        cec_active_source_smp();
-        msleep(200);
-        cec_active_source_smp();
-        cec_menu_status_smp(DEVICE_MENU_ACTIVE);
-    }
-    hdmi_print(INF, CEC "late resume\n");
-}
-
-#endif
-
-void cec_isr_post_process(void)
-{
-    if(!hdmitx_device->hpd_state) { //if none HDMI out,no CEC features.
-        return;
-    }
-    /* isr post process */
-    while(cec_global_info.cec_rx_msg_buf.rx_read_pos != cec_global_info.cec_rx_msg_buf.rx_write_pos) {
-        cec_handle_message(&(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_read_pos]));
-        (cec_global_info.cec_rx_msg_buf.rx_read_pos == cec_global_info.cec_rx_msg_buf.rx_buf_size - 1) ? (cec_global_info.cec_rx_msg_buf.rx_read_pos = 0) : (cec_global_info.cec_rx_msg_buf.rx_read_pos++);
-    }
-}
-
-void cec_usr_cmd_post_process(void)
-{
-    cec_tx_message_list_t *p, *ptmp;
-    /* usr command post process */
-    list_for_each_entry_safe(p, ptmp, &cec_tx_msg_phead, list) {
-        cec_ll_tx(p->msg, p->length);
-        unregister_cec_tx_msg(p);
-    }
-}
-
-static int detect_tv_support_cec(unsigned addr)
-{
-    unsigned int ret = 0;
-    unsigned char msg[1];
-    msg[0] = (addr<<4) | 0x0;       // 0x0, TV's root address
-    ret = cec_ll_tx_polling(msg, 1);
-    cec_hw_reset();
-    hdmi_print(INF, CEC "tv%s have CEC feature\n", ret ? " " : " don\'t ");
-    return (hdmitx_device->tv_cec_support = ret);
-}
-
-void cec_node_init(hdmitx_dev_t* hdmitx_device)
-{
-    struct vendor_info_data *vend_data = NULL;
-    
-    int i, bool = 0;
-    const enum _cec_log_dev_addr_e player_dev[3] = {CEC_RECORDING_DEVICE_1_ADDR,
-                                                    CEC_RECORDING_DEVICE_2_ADDR,
-                                                    CEC_RECORDING_DEVICE_3_ADDR,
-                                                   };
-
-    unsigned long cec_phy_addr;
-
-    if((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
-        hdmi_print(INF, CEC "CEC not ready\n");
-        return;
-    }
-    else {
-        hdmi_print(INF, CEC "CEC node init\n");
-    }
-
-    if(hdmitx_device->config_data.vend_data)
-        vend_data = hdmitx_device->config_data.vend_data;
-
-    hdmi_print(INF, CEC "ao_cec:0x%x\n", vend_data->ao_cec);
-
-    if((vend_data) && (vend_data->cec_osd_string)) {
-        i = strlen(vend_data->cec_osd_string);
-        if(i > 14) 
-            vend_data->cec_osd_string[14] = '\0';   // OSD string length must be less than 14 bytes
-        osd_name = vend_data->cec_osd_string;
-    }
-    
-    if((vend_data) && (vend_data->vendor_id)) {
-        vendor_id = (vend_data->vendor_id ) & 0xffffff;
-    }
-
-    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
-        return ;
-
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1);
-    // Clear CEC Int. state and set CEC Int. mask
-    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
-    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
-
-#endif
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-#if 1           // Please match with H/W cec config
-// GPIOAO_12
-    aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 0, 14, 1);       // bit[14]: AO_PWM_C pinmux                  //0xc8100014
-    aml_set_reg32_bits(P_AO_RTI_PULL_UP_REG, 0, 12, 1);       // bit[12]: disable AO_12 internal pull-up   //0xc810002c
-    aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 17, 1);       // bit[17]: AO_CEC pinmux                    //0xc8100014
-    ao_cec_init();
-#else
-// GPIOH_3
-    aml_set_reg32_bits(P_PAD_PULL_UP_EN_REG1, 0, 19, 1);    // disable gpioh_3 internal pull-up
-    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 23, 1);      // gpioh_3 cec pinmux
-#endif
-    cec_arbit_bit_time_set(3, 0x118, 0);
-    cec_arbit_bit_time_set(5, 0x000, 0);
-    cec_arbit_bit_time_set(7, 0x2aa, 0);
-#endif
-    cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12) |
-                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)  |
-                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)  |
-                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
-
-    
-    for(i = 0; i < 3; i++){ 
-	    hdmi_print(INF, CEC "CEC: start poll dev\n");
-        cec_polling_online_dev(player_dev[i], &bool);
-        hdmi_print(INF, CEC "player_dev[%d]:0x%x\n", i, player_dev[i]);
-        if(bool == 0){  // 0 means that no any respond
-            // If VSDB is not valid,use last or default physical address.  
-            if(hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0) {
-                hdmi_print(INF, CEC "no valid cec physical address\n");
-                if(aml_read_reg32(P_AO_DEBUG_REG1))
-                    hdmi_print(INF, CEC "use last physical address\n");
-                else{
-                    aml_write_reg32(P_AO_DEBUG_REG1, 0x1000);
-                    hdmi_print(INF, CEC "use default physical address\n"); 
-                }  
-            }else{
-                aml_write_reg32(P_AO_DEBUG_REG1, cec_phy_addr);
-            } 
-            hdmi_print(INF, CEC "physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1));
-            
-            cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_STANDBY_TO_ON;
-            cec_global_info.my_node_index = player_dev[i];
-            aml_write_reg32(P_AO_DEBUG_REG3, aml_read_reg32(P_AO_DEBUG_REG3) | (cec_global_info.my_node_index & 0xf));
-            cec_global_info.cec_node_info[player_dev[i]].log_addr = player_dev[i];
-            // Set Physical address
-            cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4 = cec_phy_addr;
-
-            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.sys_audio_mode = OFF;
-            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_mute_status = OFF; 
-            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_volume_status = 0;         
-
-            cec_global_info.cec_node_info[player_dev[i]].cec_version = CEC_VERSION_14A;
-            cec_global_info.cec_node_info[player_dev[i]].vendor_id = vendor_id;
-            cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
-            cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
-            strcpy(cec_global_info.cec_node_info[player_dev[i]].osd_name, osd_name); //Max num: 14Bytes
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-            hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | player_dev[i]);
-#endif
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-            aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | player_dev[i]);
-#endif
-     		hdmi_print(INF, CEC "Set logical address: %d\n", player_dev[i]);
-
-            hdmi_print(INF, CEC "aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n" ,aml_read_reg32(P_AO_DEBUG_REG0));
-        	if(cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status == DEVICE_MENU_INACTIVE)
-        	    break;
-            msleep(100);
-			cec_report_physical_address_smp();
-            msleep(150);
-            cec_device_vendor_id((cec_rx_message_t*)0);
-
-            msleep(150);
-
-	    /* Disable switch TV on automatically */
-	    if (!(hdmitx_device->cec_func_config & (1 << AUTO_POWER_ON_MASK))) {
-		cec_usrcmd_get_device_power_status(CEC_TV_ADDR);
-		wait_event_interruptible(hdmitx_device->cec_wait_rx,
-			cec_global_info.cec_rx_msg_buf.rx_read_pos != cec_global_info.cec_rx_msg_buf.rx_write_pos);
-		cec_isr_post_process();
-
-		if (cec_global_info.tv_power_status)
-		    return;
-	    }
-
-            cec_imageview_on_smp();
-            msleep(100);
-
-            // here, we need to detect whether TV is supporting the CEC function
-            // if not, jump out to save system time
-            //if(!detect_tv_support_cec(player_dev[i])) {
-            //    break;
-            //}
-            cec_get_menu_language_smp();
-            msleep(350);
-
-            cec_active_source_smp();
-            msleep(120);
-
-            cec_menu_status_smp(DEVICE_MENU_ACTIVE);
-            msleep(100);
-
-            cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
-            cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_ON;
-            break;
-        }
-    }
-    if(bool == 1)
-        hdmi_print(INF, CEC "Can't get a valid logical address\n");
-    else
-        hdmi_print(INF, CEC "cec node init: cec features ok !\n");
-}
-
-void cec_node_uninit(hdmitx_dev_t* hdmitx_device)
-{
-    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
-       return ;
-    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_ON_TO_STANDBY;
-    hdmi_print(INF, CEC "cec node uninit!\n");
-    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_STANDBY;
-}
-
-static int cec_task(void *data)
-{
-    extern void dump_hdmi_cec_reg(void);
-    hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*) data;
-    cec_global_info.cec_flag.cec_init_flag = 1;
-
-#ifdef CONFIG_HAS_EARLYSUSPEND
-    hdmitx_cec_early_suspend_handler.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
-    hdmitx_cec_early_suspend_handler.suspend = hdmitx_cec_early_suspend;
-    hdmitx_cec_early_suspend_handler.resume = hdmitx_cec_late_resume;
-    hdmitx_cec_early_suspend_handler.param = hdmitx_device;
-
-    register_early_suspend(&hdmitx_cec_early_suspend_handler);
-#endif
-
-    // Get logical address
-
-    hdmi_print(INF, CEC "CEC task process\n");
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)){
-        msleep_interruptible(15000);
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-        cec_gpi_init();
-#endif
-        cec_node_init(hdmitx_device);
-    }
-    while (1) {
-    	if (kthread_should_stop()){
-    		break;
-    	}
-    	wait_event_interruptible(hdmitx_device->cec_wait_rx,
-		cec_global_info.cec_rx_msg_buf.rx_read_pos != cec_global_info.cec_rx_msg_buf.rx_write_pos);
-        cec_isr_post_process();
-        //cec_usr_cmd_post_process();
-    }
-
-    return 0;
-}
-
-/***************************** cec low level code end *****************************/
-
-
-/***************************** cec middle level code *****************************/
-
-void register_cec_rx_msg(unsigned char *msg, unsigned char len )
-{
-    unsigned long flags;
-    spin_lock_irqsave(&cec_input_key,flags);
-    memset((void*)(&(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos])), 0, sizeof(cec_rx_message_t));
-    memcpy(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.buffer, msg, len);
-
-    cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num = len >= 2 ? len - 2 : 0;
-    cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].msg_length = len;
-
-    cec_input_handle_message();
-
-    (cec_global_info.cec_rx_msg_buf.rx_write_pos == cec_global_info.cec_rx_msg_buf.rx_buf_size - 1) ? (cec_global_info.cec_rx_msg_buf.rx_write_pos = 0) : (cec_global_info.cec_rx_msg_buf.rx_write_pos++);
-    spin_unlock_irqrestore(&cec_input_key,flags);
-}
-
-void register_cec_tx_msg(unsigned char *msg, unsigned char len )
-{
-    cec_tx_message_list_t* cec_usr_message_list = kmalloc(sizeof(cec_tx_message_list_t), GFP_ATOMIC);
-
-    if (cec_usr_message_list != NULL) {
-        memset(cec_usr_message_list, 0, sizeof(cec_tx_message_list_t));
-        memcpy(cec_usr_message_list->msg, msg, len);
-        cec_usr_message_list->length = len;
-
-        spin_lock_irqsave(&p_tx_list_lock, cec_tx_list_flags);
-        list_add_tail(&cec_usr_message_list->list, &cec_tx_msg_phead);
-        spin_unlock_irqrestore(&p_tx_list_lock, cec_tx_list_flags);
-
-        tx_msg_cnt++;
-    }
-}
-void cec_input_handle_message(void)
-{
-    unsigned char   opcode;
-
-    opcode = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.opcode;
-
-    /* process key event messages from tv */
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
-    {
-        switch (opcode) {
-        case CEC_OC_USER_CONTROL_PRESSED:
-            // check valid msg
-            {
-                unsigned char opernum;
-                unsigned char follower;
-                opernum  = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num;
-                follower = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.header & 0x0f;
-                if(opernum != 1 || follower == 0xf) break;
-            }
-            cec_user_control_pressed_irq();
-            break;
-        default:
-            break;
-        }
-    }
-}
-
-void unregister_cec_tx_msg(cec_tx_message_list_t* cec_tx_message_list)
-{
-
-    if (cec_tx_message_list != NULL) {
-        list_del(&cec_tx_message_list->list);
-        kfree(cec_tx_message_list);
-        cec_tx_message_list = NULL;
-
-        if (tx_msg_cnt > 0) tx_msg_cnt--;
-    }
-}
-
-unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message)
-{
-    unsigned char rt = 0;
-    unsigned char opcode;
-    unsigned char opernum;
-    unsigned char follower;
-    if (!pcec_message)
-        return rt;
-
-    opcode = pcec_message->content.msg.opcode;
-    opernum = pcec_message->operand_num;
-
-    switch (opcode) {
-        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
-        case CEC_OC_STANDBY:
-        case CEC_OC_RECORD_OFF:
-        case CEC_OC_RECORD_TV_SCREEN:
-        case CEC_OC_TUNER_STEP_DECREMENT:
-        case CEC_OC_TUNER_STEP_INCREMENT:
-        case CEC_OC_GIVE_AUDIO_STATUS:
-        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_USER_CONTROL_RELEASED:
-        case CEC_OC_GIVE_OSD_NAME:
-        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
-        case CEC_OC_GET_CEC_VERSION:
-        case CEC_OC_GET_MENU_LANGUAGE:
-        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
-        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
-        case CEC_OC_TEXT_VIEW_ON:
-        case CEC_OC_IMAGE_VIEW_ON:
-        case CEC_OC_ABORT_MESSAGE:
-        case CEC_OC_REQUEST_ACTIVE_SOURCE:
-            if ( opernum == 0)  rt = 1;
-            break;
-        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
-        case CEC_OC_RECORD_STATUS:
-        case CEC_OC_DECK_CONTROL:
-        case CEC_OC_DECK_STATUS:
-        case CEC_OC_GIVE_DECK_STATUS:
-        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
-        case CEC_OC_PLAY:
-        case CEC_OC_MENU_REQUEST:
-        case CEC_OC_MENU_STATUS:
-        case CEC_OC_REPORT_AUDIO_STATUS:
-        case CEC_OC_TIMER_CLEARED_STATUS:
-        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_USER_CONTROL_PRESSED:
-        case CEC_OC_CEC_VERSION:
-        case CEC_OC_REPORT_POWER_STATUS:
-        case CEC_OC_SET_AUDIO_RATE:
-            if ( opernum == 1)  rt = 1;
-            break;
-        case CEC_OC_INACTIVE_SOURCE:
-        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
-        case CEC_OC_FEATURE_ABORT:
-        case CEC_OC_ACTIVE_SOURCE:
-        case CEC_OC_ROUTING_INFORMATION:
-        case CEC_OC_SET_STREAM_PATH:
-            if (opernum == 2) rt = 1;
-            break;
-        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
-        case CEC_OC_SET_MENU_LANGUAGE:
-        case CEC_OC_DEVICE_VENDOR_ID:
-            if (opernum == 3) rt = 1;
-            break;
-        case CEC_OC_ROUTING_CHANGE:
-        case CEC_OC_SELECT_ANALOGUE_SERVICE:
-            if (opernum == 4) rt = 1;
-            break;
-        case CEC_OC_VENDOR_COMMAND_WITH_ID:
-            if ((opernum > 3)&&(opernum < 15))  rt = 1;
-            break;
-        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
-            if (opernum < 15)  rt = 1;
-            break;
-        case CEC_OC_SELECT_DIGITAL_SERVICE:
-            if (opernum == 7) rt = 1;
-            break;
-        case CEC_OC_SET_ANALOGUE_TIMER:
-        case CEC_OC_CLEAR_ANALOGUE_TIMER:
-            if (opernum == 11) rt = 1;
-            break;
-        case CEC_OC_SET_DIGITAL_TIMER:
-        case CEC_OC_CLEAR_DIGITAL_TIMER:
-            if (opernum == 14) rt = 1;
-            break;
-        case CEC_OC_TIMER_STATUS:
-            if ((opernum == 1 || opernum == 3)) rt = 1;
-            break;
-        case CEC_OC_TUNER_DEVICE_STATUS:
-            if ((opernum == 5 || opernum == 8)) rt = 1;
-            break;
-        case CEC_OC_RECORD_ON:
-            if (opernum > 0 && opernum < 9)  rt = 1;
-            break;
-        case CEC_OC_CLEAR_EXTERNAL_TIMER:
-        case CEC_OC_SET_EXTERNAL_TIMER:
-            if ((opernum == 9 || opernum == 10)) rt = 1;
-            break;
-        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
-        case CEC_OC_SET_OSD_NAME:
-            if (opernum > 0 && opernum < 15) rt = 1;
-            break;
-        case CEC_OC_SET_OSD_STRING:
-            if (opernum > 1 && opernum < 15) rt = 1;
-            break;
-        case CEC_OC_VENDOR_COMMAND:
-            if (opernum < 15)   rt = 1;
-            break;
-        default:
-            rt = 1;
-            break;
-    }
-
- // for CTS12.2
-    follower = pcec_message->content.msg.header & 0x0f;
-    switch (opcode) {
-        case CEC_OC_ACTIVE_SOURCE:
-        case CEC_OC_REQUEST_ACTIVE_SOURCE:
-        case CEC_OC_ROUTING_CHANGE:
-        case CEC_OC_ROUTING_INFORMATION:
-        case CEC_OC_SET_STREAM_PATH:
-        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
-        case CEC_OC_SET_MENU_LANGUAGE:
-        case CEC_OC_DEVICE_VENDOR_ID:
-            // broadcast only
-            if(follower != 0xf) rt = 0;
-            break;
-
-        case CEC_OC_IMAGE_VIEW_ON:
-        case CEC_OC_TEXT_VIEW_ON:
-        case CEC_OC_INACTIVE_SOURCE:
-        case CEC_OC_RECORD_OFF:
-        case CEC_OC_RECORD_ON:
-        case CEC_OC_RECORD_STATUS:
-        case CEC_OC_RECORD_TV_SCREEN:
-        case CEC_OC_CLEAR_ANALOGUE_TIMER:
-        case CEC_OC_CLEAR_DIGITAL_TIMER:
-        case CEC_OC_CLEAR_EXTERNAL_TIMER:
-        case CEC_OC_SET_ANALOGUE_TIMER:
-        case CEC_OC_SET_DIGITAL_TIMER:
-        case CEC_OC_SET_EXTERNAL_TIMER:
-        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
-        case CEC_OC_TIMER_CLEARED_STATUS:
-        case CEC_OC_TIMER_STATUS:
-        case CEC_OC_CEC_VERSION:
-        case CEC_OC_GET_CEC_VERSION:
-        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
-        case CEC_OC_GET_MENU_LANGUAGE:
-        case CEC_OC_DECK_CONTROL:
-        case CEC_OC_DECK_STATUS:
-        case CEC_OC_GIVE_DECK_STATUS:
-        case CEC_OC_PLAY:
-        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
-        case CEC_OC_SELECT_ANALOGUE_SERVICE:
-        case CEC_OC_SELECT_DIGITAL_SERVICE:
-        case CEC_OC_TUNER_DEVICE_STATUS:
-        case CEC_OC_TUNER_STEP_DECREMENT:
-        case CEC_OC_TUNER_STEP_INCREMENT:
-        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
-        case CEC_OC_VENDOR_COMMAND:
-        case CEC_OC_SET_OSD_STRING:
-        case CEC_OC_GIVE_OSD_NAME:
-        case CEC_OC_SET_OSD_NAME:
-        case CEC_OC_MENU_REQUEST:
-        case CEC_OC_MENU_STATUS:
-        case CEC_OC_USER_CONTROL_PRESSED:
-        case CEC_OC_USER_CONTROL_RELEASED:
-        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
-        case CEC_OC_REPORT_POWER_STATUS:
-        case CEC_OC_FEATURE_ABORT:
-        case CEC_OC_ABORT_MESSAGE:
-        case CEC_OC_GIVE_AUDIO_STATUS:
-        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_REPORT_AUDIO_STATUS:
-        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
-        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_SET_AUDIO_RATE:
-            // directly addressed only
-            if(follower == 0xf) rt = 0;
-            break;
-
-        case CEC_OC_STANDBY:
-        case CEC_OC_VENDOR_COMMAND_WITH_ID:
-        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
-        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
-        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
-            // both broadcast and directly addressed
-            break;
-
-        default:
-            break;
-    }
-
-    if ((rt == 0) & (opcode != 0)){
-        hdmirx_cec_dbg_print("CEC: opcode & opernum not match: %x, %x\n", opcode, opernum);
-    }
-    return rt;
-}
-
-static irqreturn_t cec_isr_handler(int irq, void *dev_instance)
-{
-    unsigned char rx_msg[MAX_MSG], rx_len;
-
-    //cec_disable_irq();
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    unsigned int intr_stat = 0;
-    intr_stat = aml_read_reg32(P_AO_CEC_INTR_STAT);
-    hdmi_print(INF, CEC "aocec irq %x\n", intr_stat);
-
-    if(intr_stat & (1<<1)) { // aocec tx intr
-        tx_irq_handle();
-        //cec_enable_irq();
-        return IRQ_HANDLED;
-    }
-#endif
-    if((-1) == cec_ll_rx(rx_msg, &rx_len)){
-        //cec_enable_irq();
-        return IRQ_HANDLED;
-    }
-
-    register_cec_rx_msg(rx_msg, rx_len);
-    wake_up(&hdmitx_device->cec_wait_rx);
-
-    //cec_enable_irq();
-
-    return IRQ_HANDLED;
-}
-
-unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
-{
-    unsigned short us = CEC_UNREGISTERED_DEVICE_TYPE;
-    if ((1 << log_addr) & CEC_DISPLAY_DEVICE) {
-        us = CEC_DISPLAY_DEVICE_TYPE;
-    } else if ((1 << log_addr) & CEC_RECORDING_DEVICE) {
-        us = CEC_RECORDING_DEVICE_TYPE;
-    } else if ((1 << log_addr) & CEC_PLAYBACK_DEVICE) {
-        us = CEC_PLAYBACK_DEVICE_TYPE;
-    } else if ((1 << log_addr) & CEC_TUNER_DEVICE) {
-        us = CEC_TUNER_DEVICE_TYPE;
-    } else if ((1 << log_addr) & CEC_AUDIO_SYSTEM_DEVICE) {
-        us = CEC_AUDIO_SYSTEM_DEVICE_TYPE;
-    }
-
-    return us;
-}
-// -------------- command from cec devices ---------------------
-//***************************************************************
-void cec_device_vendor_id(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char msg[5];
-    
-    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-    msg[1] = CEC_OC_DEVICE_VENDOR_ID;
-    msg[2] = (vendor_id >> 16) & 0xff;
-    msg[3] = (vendor_id >> 8) & 0xff;
-    msg[4] = (vendor_id >> 0) & 0xff;
-    
-    cec_ll_tx(msg, 5);
-}
-
-void cec_report_power_status(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char msg[3];
-
-    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-    msg[1] = CEC_OC_REPORT_POWER_STATUS;
-    msg[2] = cec_global_info.cec_node_info[index].power_status;
-    cec_ll_tx(msg, 3);
-
-}
-
-void cec_feature_abort(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char opcode = pcec_message->content.msg.opcode;
-    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
-    unsigned char dst_log_addr = pcec_message->content.msg.header & 0xf;
-    if(dst_log_addr != 0xf){
-        unsigned char msg[4];
-        
-        msg[0] = ((index & 0xf) << 4) | src_log_addr;
-        msg[1] = CEC_OC_FEATURE_ABORT;
-        msg[2] = opcode;
-        msg[3] = CEC_UNRECONIZED_OPCODE;
-        
-        cec_ll_tx(msg, 4);        
-    }
-}
-
-void cec_report_version(cec_rx_message_t* pcec_message)
-{
-    ;//todo
-}
-
-
-void cec_report_physical_address_smp(void)
-{
-    unsigned char msg[5]; 
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
-    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-    msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
-    msg[2] = phy_addr_ab;
-    msg[3] = phy_addr_cd;
-    msg[4] = cec_global_info.cec_node_info[index].dev_type;
-
-    cec_ll_tx(msg, 5);
-        
-}
-
-void cec_imageview_on_smp(void)
-{
-    unsigned char msg[2];
-    unsigned char index = cec_global_info.my_node_index;
-
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
-        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {
-            msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-            msg[1] = CEC_OC_IMAGE_VIEW_ON;
-            cec_ll_tx(msg, 2);
-        }
-    }  
-}
-
-void cec_get_menu_language_smp(void)
-{
-    unsigned char msg[2];
-    unsigned char index = cec_global_info.my_node_index;
-
-    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-    msg[1] = CEC_OC_GET_MENU_LANGUAGE;
-    
-    cec_ll_tx(msg, 2);
-    
-}
-
-void cec_menu_status(cec_rx_message_t* pcec_message)
-{
-    unsigned char msg[3];
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
-
-     if(0xf != src_log_addr) {
-        msg[0] = ((index & 0xf) << 4) | src_log_addr;
-        msg[1] = CEC_OC_MENU_STATUS;
-        msg[2] = cec_global_info.cec_node_info[index].menu_status;
-        cec_ll_tx(msg, 3);
-    }
-}
-
-void cec_menu_status_smp(cec_device_menu_state_e status)
-{
-    unsigned char msg[3];
-    unsigned char index = cec_global_info.my_node_index;
-
-    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-    msg[1] = CEC_OC_MENU_STATUS;
-    if(status == DEVICE_MENU_ACTIVE){
-        msg[2] = DEVICE_MENU_ACTIVE;
-        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
-    }else{
-        msg[2] = DEVICE_MENU_INACTIVE;
-        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
-    }
-    cec_ll_tx(msg, 3);
-}
-
-void cec_menu_status_smp_irq(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-
-    if(1 == pcec_message->content.msg.operands[0]){
-        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
-    }else if(0 == pcec_message->content.msg.operands[0]){
-        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
-    }
-}
-
-void cec_active_source_rx(cec_rx_message_t* pcec_message)
-{
-    unsigned int phy_addr_active;
-
-    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
-                                    (pcec_message->content.msg.operands[1] << 0));
-
-	if(phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
-	}else{
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
-	}
-}
-
-void cec_active_source_smp(void)
-{
-    unsigned char msg[4];
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;      
-
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
-        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {
-            msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-            msg[1] = CEC_OC_ACTIVE_SOURCE;
-            msg[2] = phy_addr_ab;
-            msg[3] = phy_addr_cd;
-            cec_ll_tx(msg, 4);
-        }
-    }
-    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
-}
-void cec_active_source(cec_rx_message_t* pcec_message)
-{
-    unsigned char msg[4];
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
-    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-    msg[1] = CEC_OC_ACTIVE_SOURCE;
-    msg[2] = phy_addr_ab;
-    msg[3] = phy_addr_cd;
-    cec_ll_tx(msg, 4);
-    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
-}
-
-
-void cec_set_stream_path(cec_rx_message_t* pcec_message)
-{
-    unsigned int phy_addr_active;
-
-    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
-                                    (pcec_message->content.msg.operands[1] << 0));
-
-	if(phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
-	    cec_active_source_smp();
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
-	}else{
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
-	}
-}
-void cec_set_system_audio_mode(void)
-{
-    unsigned char index = cec_global_info.my_node_index;
-
-    MSG_P1( index, CEC_TV_ADDR,
-            CEC_OC_SET_SYSTEM_AUDIO_MODE,
-            cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode
-            );
-
-    cec_ll_tx(gbl_msg, 3);
-    if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == ON)
-        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
-    else
-        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
-}
-
-void cec_system_audio_mode_request(void)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
-    if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == OFF){
-        MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
-                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST,
-                phy_addr_ab,
-                phy_addr_cd
-                );
-        cec_ll_tx(gbl_msg, 4);
-        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
-    }
-    else{
-        MSG_P0( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
-                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST
-                );
-        cec_ll_tx(gbl_msg, 2);
-        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
-    }
-}
-
-void cec_report_audio_status(void)
-{
-    unsigned char index = cec_global_info.my_node_index;
-
-    MSG_P1( index, CEC_TV_ADDR,
-            CEC_OC_REPORT_AUDIO_STATUS,
-            cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_mute_status | \
-            cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_volume_status
-            );
-
-    cec_ll_tx(gbl_msg, 3);
-}
-void cec_request_active_source(cec_rx_message_t* pcec_message)
-{
-    cec_set_stream_path(pcec_message);
-}
-
-void cec_set_imageview_on_irq(void)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char msg[2];
-
-    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-    msg[1] = CEC_OC_IMAGE_VIEW_ON;
-
-    cec_ll_tx(msg, 2);
-}
-
-void cec_inactive_source(void)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char msg[4];
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
-    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-    msg[1] = CEC_OC_INACTIVE_SOURCE;
-	msg[2] = phy_addr_ab;
-	msg[3] = phy_addr_cd;
-
-    cec_ll_tx(msg, 4);
-    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
-}
-
-void cec_inactive_source_rx(cec_rx_message_t* pcec_message)
-{
-    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
-}
-
-void cec_get_version(cec_rx_message_t* pcec_message)
-{
-    unsigned char dest_log_addr = pcec_message->content.msg.header&0xf;
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char msg[3];
-
-    if (0xf != dest_log_addr) {
-        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-        msg[1] = CEC_OC_CEC_VERSION;
-        msg[2] = CEC_VERSION_14A;
-        cec_ll_tx(msg, 3);
-    }
-}
-
-void cec_give_deck_status(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char msg[3];
-
-    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-    msg[1] = CEC_OC_DECK_STATUS;
-    msg[2] = 0x20;
-    cec_ll_tx(msg, 3);
-}
-
-
-void cec_deck_status(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-
-    if (cec_global_info.dev_mask & (1 << index)) {
-        cec_global_info.cec_node_info[index].specific_info.playback.deck_info = pcec_message->content.msg.operands[0];
-        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_DECK_INfO;
-        hdmirx_cec_dbg_print("cec_deck_status: %x\n", cec_global_info.cec_node_info[index].specific_info.playback.deck_info);
-    }
-}
-
-// STANDBY: long press our remote control, send STANDBY to TV
-void cec_set_standby(void)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char msg[2];
-    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-    msg[1] = CEC_OC_STANDBY;
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
-        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) {
-			cec_ll_tx(msg, 2);
-		}
-	}
-}
-
-void cec_set_osd_name(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-	unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
-    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
-    unsigned char msg[16];
-
-    if(0xf != src_log_addr) {
-        msg[0] = ((index & 0xf) << 4) | src_log_addr;
-        msg[1] = CEC_OC_SET_OSD_NAME;
-        memcpy(&msg[2], cec_global_info.cec_node_info[index].osd_name, osd_len);
-
-        cec_ll_tx(msg, 2 + osd_len);
-    }
-}
-
-void cec_set_osd_name_init(void)
-{
-    unsigned char index = cec_global_info.my_node_index;
-	unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
-    unsigned char msg[16];
-
-    msg[0] = ((index & 0xf) << 4) | 0;
-    msg[1] = CEC_OC_SET_OSD_NAME;
-    memcpy(&msg[2], cec_global_info.cec_node_info[index].osd_name, osd_len);
-
-    cec_ll_tx(msg, 2 + osd_len);
-}
-
-void cec_vendor_cmd_with_id(cec_rx_message_t* pcec_message)
-{
-    ;//todo
-}
-
-
-void cec_set_menu_language(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
-
-    if(0x0 == src_log_addr) {
-        cec_global_info.cec_node_info[index].menu_lang = (int)((pcec_message->content.msg.operands[0] << 16)  |
-                                                               (pcec_message->content.msg.operands[1] <<  8)  |
-                                                               (pcec_message->content.msg.operands[2]));
-
-        switch_set_state(&lang_dev, cec_global_info.cec_node_info[index].menu_lang);
-        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_MENU_LANGUAGE;
-        hdmi_print(INF, CEC "cec_set_menu_language:%c.%c.%c\n", (cec_global_info.cec_node_info[index].menu_lang >>16) & 0xff,
-                                                                (cec_global_info.cec_node_info[index].menu_lang >> 8) & 0xff,
-                                                                (cec_global_info.cec_node_info[index].menu_lang >> 0) & 0xff);
-    }
-}
-
-void cec_handle_message(cec_rx_message_t* pcec_message)
-{
-    unsigned char	brdcst, opcode;
-    unsigned char	initiator, follower;
-    unsigned char   operand_num;
-    unsigned char   msg_length;
-
-    /* parse message */
-    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0))
-        return;
-
-    initiator	= pcec_message->content.msg.header >> 4;
-    follower	= pcec_message->content.msg.header & 0x0f;
-    opcode		= pcec_message->content.msg.opcode;
-    operand_num = pcec_message->operand_num;
-    brdcst      = (follower == 0x0f);
-    msg_length  = pcec_message->msg_length;
-
-    if(0 == pcec_message->content.msg.header)
-        return;
-
-    /* process messages from tv polling and cec devices */
-    if(CEC_OC_GIVE_OSD_NAME == opcode)
-        cec_set_osd_name(pcec_message);
-    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
-    {
-
-        switch (opcode) {
-        case CEC_OC_ACTIVE_SOURCE:
-            cec_active_source_rx(pcec_message);
-            break;
-        case CEC_OC_INACTIVE_SOURCE:
-            break;
-        case CEC_OC_CEC_VERSION:
-            break;
-        case CEC_OC_DECK_STATUS:
-            break;
-        case CEC_OC_DEVICE_VENDOR_ID:
-            break;
-        case CEC_OC_FEATURE_ABORT:
-            break;
-        case CEC_OC_GET_CEC_VERSION:
-            cec_get_version(pcec_message);
-            break;
-        case CEC_OC_GIVE_DECK_STATUS:
-            cec_give_deck_status(pcec_message);
-            break;
-        case CEC_OC_MENU_STATUS:
-            cec_menu_status_smp_irq(pcec_message);
-            break;
-        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
-            break;
-        case CEC_OC_REPORT_POWER_STATUS:
-	    cec_global_info.tv_power_status = pcec_message->content.msg.operands[0];
-            break;
-        case CEC_OC_SET_OSD_NAME:
-            break;
-        case CEC_OC_VENDOR_COMMAND_WITH_ID:
-            break;
-        case CEC_OC_SET_MENU_LANGUAGE:
-            cec_set_menu_language(pcec_message);
-            break;
-        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
-            cec_report_physical_address_smp();
-            break;
-        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
-            cec_device_vendor_id(pcec_message);
-            break;
-        case CEC_OC_GIVE_OSD_NAME:
-            break;
-        case CEC_OC_STANDBY:
-            cec_inactive_source_rx(pcec_message);
-            cec_standby(pcec_message);
-            break;
-        case CEC_OC_SET_STREAM_PATH:
-            cec_set_stream_path(pcec_message);
-            break;
-        case CEC_OC_REQUEST_ACTIVE_SOURCE:
-            if(cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status != DEVICE_MENU_ACTIVE)
-                break;
-            cec_active_source_smp();
-            break;
-        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
-            cec_report_power_status(pcec_message);
-            break;
-        case CEC_OC_USER_CONTROL_PRESSED:
-            break;
-        case CEC_OC_USER_CONTROL_RELEASED:
-            break;
-        case CEC_OC_IMAGE_VIEW_ON:      //not support in source
-            cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
-            break;
-        case CEC_OC_ROUTING_CHANGE:
-            cec_routing_change(pcec_message);
-            break;
-        case CEC_OC_ROUTING_INFORMATION:
-        	cec_routing_information(pcec_message);
-        	break;
-        case CEC_OC_GIVE_AUDIO_STATUS:
-        	cec_report_audio_status();
-        	break;
-        case CEC_OC_MENU_REQUEST:
-            cec_menu_status(pcec_message);
-            break;
-        case CEC_OC_PLAY:
-            hdmi_print(INF, CEC "CEC_OC_PLAY:0x%x\n",pcec_message->content.msg.operands[0]);
-            switch(pcec_message->content.msg.operands[0]){
-                case 0x24:
-                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
-                    input_sync(cec_global_info.remote_cec_dev);
-                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
-                    input_sync(cec_global_info.remote_cec_dev);
-                    break;
-                case 0x25:
-                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
-                    input_sync(cec_global_info.remote_cec_dev);
-                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
-                    input_sync(cec_global_info.remote_cec_dev);
-                    break;
-                default:
-                    break;
-            }
-            break;
-        case CEC_OC_DECK_CONTROL:
-            hdmi_print(INF, CEC "CEC_OC_DECK_CONTROL:0x%x\n",pcec_message->content.msg.operands[0]);
-            switch(pcec_message->content.msg.operands[0]){
-                case 0x3:
-                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_STOP, 1);
-                    input_sync(cec_global_info.remote_cec_dev);
-                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_STOP, 0);
-                    input_sync(cec_global_info.remote_cec_dev);
-                    break;
-                default:
-                    break;
-            }
-            break;
-        case CEC_OC_VENDOR_COMMAND:
-	    if (pcec_message->content.msg.operands[0] == 0x1) {
-		    cec_report_power_status(pcec_message);
-		    cec_send_simplink_alive(pcec_message);
-	    } else if (pcec_message->content.msg.operands[0]
-			    == 0x4) {
-		    cec_send_simplink_ack(pcec_message);
-	    }
-	    break;
-        case CEC_OC_GET_MENU_LANGUAGE:
-        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
-        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
-            hdmi_print(INF, CEC "CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:0x%x\n",pcec_message->content.msg.operands[0]);
-            switch(pcec_message->content.msg.operands[0]){
-                case 0x91:
-                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_EXIT, 1);
-                    input_sync(cec_global_info.remote_cec_dev);
-                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_EXIT, 0);
-                    input_sync(cec_global_info.remote_cec_dev);
-                    hdmi_print(INF, CEC  ":key map:%d\n",KEY_EXIT);
-                    break;
-                case 0x96:
-                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_LIST, 1);
-                    input_sync(cec_global_info.remote_cec_dev);
-                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_LIST, 0);
-                    input_sync(cec_global_info.remote_cec_dev);
-                    hdmi_print(INF, CEC  ":key map:%d\n",KEY_LIST);
-                    break;
-                default:
-                    break;
-            }
-            break;
-        case CEC_OC_CLEAR_ANALOGUE_TIMER:
-        case CEC_OC_CLEAR_DIGITAL_TIMER:
-        case CEC_OC_CLEAR_EXTERNAL_TIMER:
-        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
-        case CEC_OC_SET_OSD_STRING:
-        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
-        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
-        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
-        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
-        case CEC_OC_TEXT_VIEW_ON:
-        case CEC_OC_TIMER_CLEARED_STATUS:
-        case CEC_OC_TIMER_STATUS:
-        case CEC_OC_TUNER_DEVICE_STATUS:
-        case CEC_OC_TUNER_STEP_DECREMENT:
-        case CEC_OC_TUNER_STEP_INCREMENT:
-        case CEC_OC_SELECT_ANALOGUE_SERVICE:
-        case CEC_OC_SELECT_DIGITAL_SERVICE:
-        case CEC_OC_SET_ANALOGUE_TIMER :
-        case CEC_OC_SET_AUDIO_RATE:
-        case CEC_OC_SET_DIGITAL_TIMER:
-        case CEC_OC_SET_EXTERNAL_TIMER:
-        case CEC_OC_RECORD_OFF:
-        case CEC_OC_RECORD_ON:
-        case CEC_OC_RECORD_STATUS:
-        case CEC_OC_RECORD_TV_SCREEN:
-        case CEC_OC_REPORT_AUDIO_STATUS:
-        case CEC_OC_ABORT_MESSAGE:
-            cec_feature_abort(pcec_message);
-            break;
-        default:
-            break;
-        }
-    }
-}
-
-
-// --------------- cec command from user application --------------------
-
-void cec_usrcmd_parse_all_dev_online(void)
-{
-    int i;
-    unsigned short tmp_mask;
-
-    hdmirx_cec_dbg_print("cec online: ###############################################\n");
-    hdmirx_cec_dbg_print("active_log_dev %x\n", cec_global_info.active_log_dev);
-    for (i = 0; i < MAX_NUM_OF_DEV; i++) {
-        tmp_mask = 1 << i;
-        if (tmp_mask & cec_global_info.dev_mask) {
-            hdmirx_cec_dbg_print("cec online: -------------------------------------------\n");
-            hdmirx_cec_dbg_print("hdmi_port:     %x\n", cec_global_info.cec_node_info[i].hdmi_port);
-            hdmirx_cec_dbg_print("dev_type:      %x\n", cec_global_info.cec_node_info[i].dev_type);
-            hdmirx_cec_dbg_print("power_status:  %x\n", cec_global_info.cec_node_info[i].power_status);
-            hdmirx_cec_dbg_print("cec_version:   %x\n", cec_global_info.cec_node_info[i].cec_version);
-            hdmirx_cec_dbg_print("vendor_id:     %x\n", cec_global_info.cec_node_info[i].vendor_id);
-            hdmirx_cec_dbg_print("phy_addr:      %x\n", cec_global_info.cec_node_info[i].phy_addr.phy_addr_4);
-            hdmirx_cec_dbg_print("log_addr:      %x\n", cec_global_info.cec_node_info[i].log_addr);
-            hdmirx_cec_dbg_print("osd_name:      %s\n", cec_global_info.cec_node_info[i].osd_name);
-            hdmirx_cec_dbg_print("osd_name_def:  %s\n", cec_global_info.cec_node_info[i].osd_name_def);
-            hdmirx_cec_dbg_print("menu_state:    %x\n", cec_global_info.cec_node_info[i].menu_state);
-
-            if (cec_global_info.cec_node_info[i].dev_type == CEC_PLAYBACK_DEVICE_TYPE) {
-                hdmirx_cec_dbg_print("deck_cnt_mode: %x\n", cec_global_info.cec_node_info[i].specific_info.playback.deck_cnt_mode);
-                hdmirx_cec_dbg_print("deck_info:     %x\n", cec_global_info.cec_node_info[i].specific_info.playback.deck_info);
-                hdmirx_cec_dbg_print("play_mode:     %x\n", cec_global_info.cec_node_info[i].specific_info.playback.play_mode);
-            }
-        }
-    }
-    hdmirx_cec_dbg_print("##############################################################\n");
-}
-
-void cec_usrcmd_get_cec_version(unsigned char log_addr)
-{
-    MSG_P0(cec_global_info.my_node_index, log_addr,
-            CEC_OC_GET_CEC_VERSION);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-void cec_usrcmd_get_audio_status(unsigned char log_addr)
-{
-    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_AUDIO_STATUS);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-void cec_usrcmd_get_deck_status(unsigned char log_addr)
-{
-    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DECK_STATUS, STATUS_REQ_ON);
-
-    cec_ll_tx(gbl_msg, 3);
-}
-
-void cec_usrcmd_set_deck_cnt_mode(unsigned char log_addr, deck_cnt_mode_e deck_cnt_mode)
-{
-    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_DECK_CONTROL, deck_cnt_mode);
-
-    cec_ll_tx(gbl_msg, 3);
-}
-
-void cec_usrcmd_get_device_power_status(unsigned char log_addr)
-{
-    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_POWER_STATUS);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-void cec_usrcmd_get_device_vendor_id(unsigned char log_addr)
-{
-    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_VENDOR_ID);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-void cec_usrcmd_get_osd_name(unsigned char log_addr)
-{
-    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_OSD_NAME);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-void cec_usrcmd_get_physical_address(unsigned char log_addr)
-{
-    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_PHYSICAL_ADDRESS);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-void cec_usrcmd_get_system_audio_mode_status(unsigned char log_addr)
-{
-    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-void cec_usrcmd_set_standby(unsigned char log_addr)
-{
-    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_STANDBY);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-/////////////////////////
-void cec_usrcmd_set_imageview_on(unsigned char log_addr)
-{
-    MSG_P0(cec_global_info.my_node_index, log_addr,
-            CEC_OC_IMAGE_VIEW_ON);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-void cec_usrcmd_text_view_on(unsigned char log_addr)
-{
-    MSG_P0(cec_global_info.my_node_index, log_addr,
-            CEC_OC_TEXT_VIEW_ON);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-void cec_usrcmd_get_tuner_device_status(unsigned char log_addr)
-{
-    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_TUNER_DEVICE_STATUS);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-void cec_usrcmd_set_play_mode(unsigned char log_addr, play_mode_e play_mode)
-{
-    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_PLAY, play_mode);
-
-    cec_ll_tx(gbl_msg, 3);
-}
-
-void cec_usrcmd_get_menu_state(unsigned char log_addr)
-{
-    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, MENU_REQ_QUERY);
-
-    cec_ll_tx(gbl_msg, 3);
-}
-
-void cec_usrcmd_set_menu_state(unsigned char log_addr, menu_req_type_e menu_req_type)
-{
-    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, menu_req_type);
-
-    cec_ll_tx(gbl_msg, 3);
-}
-
-void cec_usrcmd_get_menu_language(unsigned char log_addr)
-{
-    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GET_MENU_LANGUAGE);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-void cec_usrcmd_get_active_source(void)
-{
-    MSG_P0(cec_global_info.my_node_index, 0xF, CEC_OC_REQUEST_ACTIVE_SOURCE);
-
-    cec_ll_tx(gbl_msg, 2);
-}
-
-void cec_usrcmd_set_active_source(void)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
-    MSG_P2(index, CEC_BROADCAST_ADDR,
-            CEC_OC_ACTIVE_SOURCE,
-			phy_addr_ab,
-			phy_addr_cd);
-
-    cec_ll_tx(gbl_msg, 4);
-}
-
-void cec_usrcmd_set_deactive_source(unsigned char log_addr)
-{
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
-    MSG_P2(cec_global_info.my_node_index, log_addr, CEC_OC_INACTIVE_SOURCE,
-           phy_addr_ab,
-           phy_addr_cd);
-
-    cec_ll_tx(gbl_msg, 4);
-}
-
-void cec_usrcmd_clear_node_dev_real_info_mask(unsigned char log_addr, cec_info_mask mask)
-{
-    cec_global_info.cec_node_info[log_addr].real_info_mask &= ~mask;
-}
-
-
-void cec_usrcmd_set_osd_name(cec_rx_message_t* pcec_message)
-{
-
-    unsigned char log_addr = pcec_message->content.msg.header >> 4 ;
-    unsigned char index = cec_global_info.my_node_index;
-
-    MSG_P14(index, log_addr,
-            CEC_OC_SET_OSD_NAME,
-            cec_global_info.cec_node_info[index].osd_name[0],
-            cec_global_info.cec_node_info[index].osd_name[1],
-            cec_global_info.cec_node_info[index].osd_name[2],
-            cec_global_info.cec_node_info[index].osd_name[3],
-            cec_global_info.cec_node_info[index].osd_name[4],
-            cec_global_info.cec_node_info[index].osd_name[5],
-            cec_global_info.cec_node_info[index].osd_name[6],
-            cec_global_info.cec_node_info[index].osd_name[7],
-            cec_global_info.cec_node_info[index].osd_name[8],
-            cec_global_info.cec_node_info[index].osd_name[9],
-            cec_global_info.cec_node_info[index].osd_name[10],
-            cec_global_info.cec_node_info[index].osd_name[11],
-            cec_global_info.cec_node_info[index].osd_name[12],
-            cec_global_info.cec_node_info[index].osd_name[13]);
-
-    cec_ll_tx(gbl_msg, 16);
-}
-
-
-
-void cec_usrcmd_set_device_vendor_id(void)
-{
-    unsigned char index = cec_global_info.my_node_index;
-
-    MSG_P3(index, CEC_BROADCAST_ADDR,
-            CEC_OC_DEVICE_VENDOR_ID,
-            (cec_global_info.cec_node_info[index].vendor_id >> 16) & 0xff,
-            (cec_global_info.cec_node_info[index].vendor_id >> 8) & 0xff,
-            (cec_global_info.cec_node_info[index].vendor_id >> 0) & 0xff);
-
-    cec_ll_tx(gbl_msg, 5);
-}
-void cec_usrcmd_set_report_physical_address(void)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-
-    MSG_P3(index, CEC_BROADCAST_ADDR,
-           CEC_OC_REPORT_PHYSICAL_ADDRESS,
-           phy_addr_ab,
-           phy_addr_cd,
-           CEC_PLAYBACK_DEVICE_TYPE);
-
-    cec_ll_tx(gbl_msg, 5);
-}
-
-void cec_routing_change(cec_rx_message_t* pcec_message)
-{
-    unsigned int phy_addr_origin;
-    unsigned int phy_addr_destination;
-
-    phy_addr_origin = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
-                                    (pcec_message->content.msg.operands[1] << 0));
-    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[2] << 8) |
-                                         (pcec_message->content.msg.operands[3] << 0));
-
-	if(phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
-	}else{
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
-	}
-}
-
-void cec_routing_information(cec_rx_message_t* pcec_message)
-{
-    unsigned char index = cec_global_info.my_node_index;
-    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
-    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
-    unsigned int phy_addr_destination;
-    unsigned char msg[4];
-
-    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
-                                         (pcec_message->content.msg.operands[1] << 0));
-
-	if(phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
-    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
-    msg[1] = CEC_OC_ROUTING_INFORMATION;
-    msg[2] = phy_addr_ab;
-    msg[3] = phy_addr_cd;
-    cec_ll_tx(msg, 4);
-	}else{
-	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
-	}
-}
-
-void cec_send_simplink_alive(cec_rx_message_t *pcec_message)
-{
-	unsigned char index = cec_global_info.my_node_index;
-	unsigned char msg[4];
-
-	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-	msg[1] = CEC_OC_VENDOR_COMMAND;
-	msg[2] = 0x2;
-	msg[3] = 0x5;
-
-	cec_ll_tx(msg, 4);
-}
-
-void cec_send_simplink_ack(cec_rx_message_t *pcec_message)
-{
-	unsigned char index = cec_global_info.my_node_index;
-	unsigned char msg[4];
-
-	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
-	msg[1] = CEC_OC_VENDOR_COMMAND;
-	msg[2] = 0x5;
-	msg[3] = 0x1;
-
-	cec_ll_tx(msg, 4);
-}
-/***************************** cec middle level code end *****************************/
-
-
-/***************************** cec high level code *****************************/
-
-static int __init cec_init(void)
-{
-    int i;
-    extern __u16 cec_key_map[160];
-    extern hdmitx_dev_t * get_hdmitx_device(void);
-    hdmitx_device = get_hdmitx_device();
-    init_waitqueue_head(&hdmitx_device->cec_wait_rx);
-    cec_key_init();
-    hdmi_print(INF, CEC "CEC init\n");
-
-    memset(&cec_global_info, 0, sizeof(cec_global_info_t));
-    
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
-    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
-#endif
-
-    cec_global_info.cec_rx_msg_buf.rx_buf_size = 
-        sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message)/sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message[0]);
-
-    cec_global_info.hdmitx_device = hdmitx_device;
-    
-    hdmitx_device->task_cec = kthread_run(cec_task, (void*)hdmitx_device, "kthread_cec");
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-    if(request_irq(INT_HDMI_CEC, &cec_isr_handler,
-                IRQF_SHARED, "amhdmitx-cec",
-                (void *)hdmitx_device)){
-        hdmi_print(INF, CEC "Can't register IRQ %d\n",INT_HDMI_CEC);
-        return -EFAULT;
-    }
-#endif
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    if(request_irq(INT_AO_CEC, &cec_isr_handler,
-                IRQF_SHARED, "amhdmitx-aocec",
-                (void *)hdmitx_device)){
-        hdmi_print(INF, CEC "Can't register IRQ %d\n",INT_HDMI_CEC);
-        return -EFAULT;
-    }
-#endif
-
-    cec_global_info.remote_cec_dev = input_allocate_device();
-    if (!cec_global_info.remote_cec_dev)
-    {
-        hdmi_print(INF, CEC "remote_cec.c: Not enough memory\n");
-    }
-    cec_global_info.remote_cec_dev->name = "cec_input";
-
-    cec_global_info.remote_cec_dev->evbit[0] = BIT_MASK(EV_KEY);
-    cec_global_info.remote_cec_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);
-    cec_global_info.remote_cec_dev->id.bustype = BUS_ISA;
-    cec_global_info.remote_cec_dev->id.vendor = 0x1b8e;
-    cec_global_info.remote_cec_dev->id.product = 0x0cec;
-    cec_global_info.remote_cec_dev->id.version = 0x0001;
-
-    for (i = 0; i < 160; i++){
-          set_bit( cec_key_map[i], cec_global_info.remote_cec_dev->keybit);
-      }
-
-    if(input_register_device(cec_global_info.remote_cec_dev)) {
-        hdmi_print(INF, CEC "remote_cec.c: Failed to register device\n");
-        input_free_device(cec_global_info.remote_cec_dev);
-    }
-
-    hdmitx_device->cec_init_ready = 1;
-    hdmi_print(INF, CEC "hdmitx_device->cec_init_ready:0x%x", hdmitx_device->cec_init_ready);
-    return 0;
-}
-
-static void __exit cec_uninit(void)
-{
-    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))) {
-        return ;
-    }
-    hdmi_print(INF, CEC "cec uninit!\n");
-    if (cec_global_info.cec_flag.cec_init_flag == 1) {
-
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
-        free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
-#endif
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-        free_irq(INT_AO_CEC, (void *)hdmitx_device);
-#endif
-    	kthread_stop(hdmitx_device->task_cec);
-        cec_global_info.cec_flag.cec_init_flag = 0;
-    }
-
-    hdmitx_device->cec_init_ready = 0;
-    input_unregister_device(cec_global_info.remote_cec_dev);
-    cec_global_info.cec_flag.cec_fiq_flag = 0;
-}
-
-size_t cec_usrcmd_get_global_info(char * buf)
-{
-    int i = 0;
-    int dev_num = 0;
-
-    cec_node_info_t * buf_node_addr = (cec_node_info_t *)(buf + (unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online));
-
-    for (i = 0; i < MAX_NUM_OF_DEV; i++) {
-        if (cec_global_info.dev_mask & (1 << i)) {
-            memcpy(&(buf_node_addr[dev_num]), &(cec_global_info.cec_node_info[i]), sizeof(cec_node_info_t));
-            dev_num++;
-        }
-    }
-
-    buf[0] = dev_num;
-    buf[1] = cec_global_info.active_log_dev;
-#if 0
-    hdmi_print(INF, CEC "\n");
-    hdmi_print(INF, CEC "%x\n",(unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online));
-    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->dev_number);
-    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->active_log_dev);
-    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->cec_node_info_online[0].hdmi_port);
-    for (i=0; i < (sizeof(cec_node_info_t) * dev_num) + 2; i++) {
-        hdmi_print(INF, CEC "%x,",buf[i]);
-    }
-    hdmi_print(INF, CEC "\n");
-#endif
-    return (sizeof(cec_node_info_t) * dev_num) + (unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online);
-}
-
-void cec_usrcmd_set_lang_config(const char * buf, size_t count)
-{
-    char tmpbuf[128];
-    int i=0;
-
-    while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
-        tmpbuf[i]=buf[i];
-        i++;    
-    }
-
-    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang = simple_strtoul(tmpbuf, NULL, 16);
-
-}
-void cec_usrcmd_set_config(const char * buf, size_t count)
-{
-    int i = 0;
-    int j = 0;
-    unsigned long value;
-    char param[16] = {0};
-
-    if(count > 32){
-        hdmi_print(INF, CEC "too many args\n");
-    }
-    for(i = 0; i < count; i++){
-        if ( (buf[i] >= '0') && (buf[i] <= 'f') ){
-            param[j] = simple_strtoul(&buf[i], NULL, 16);
-            j ++;
-        }
-        while ( buf[i] != ' ' )
-            i ++;
-    }
-    value = aml_read_reg32(P_AO_DEBUG_REG0);
-    aml_set_reg32_bits(P_AO_DEBUG_REG0, param[0], 0, 32);
-    hdmitx_device->cec_func_config = aml_read_reg32(P_AO_DEBUG_REG0);
-    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) || !hdmitx_device->hpd_state ) {
-        return ;
-    }
-    if((0 == (value & 0x1)) && (1 == (param[0] & 1))){
-        hdmitx_device->cec_init_ready = 1;
-        hdmitx_device->hpd_state = 1;
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
-        cec_gpi_init();
-#endif
-        cec_node_init(hdmitx_device);
-    }
-    if((1 == (param[0] & 1)) && (0x2 == (value & 0x2)) && (0x0 == (param[0] & 0x2))){
-        cec_menu_status_smp(DEVICE_MENU_INACTIVE);
-    }
-    if((1 == (param[0] & 1)) && (0x0 == (value & 0x2)) && (0x2 == (param[0] & 0x2))){
-        cec_active_source_smp();
-    }
-    if((0x20 == (param[0] & 0x20)) && (0x0 == (value & 0x20)) ){
-        cec_get_menu_language_smp();
-    }
-    hdmi_print(INF, CEC "cec_func_config:0x%x : 0x%x\n",hdmitx_device->cec_func_config, aml_read_reg32(P_AO_DEBUG_REG0));
-}
-
-
-void cec_usrcmd_set_dispatch(const char * buf, size_t count)
-{
-    int i = 0;
-    int j = 0;
-    int bool = 0;
-    char param[32] = {0};
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    unsigned bit_set;
-    unsigned time_set;
-#endif
-    unsigned char msg[4] = {0};
-    
-    hdmi_print(INF, CEC "cec usrcmd set dispatch start:\n");
-    if(!hdmitx_device->hpd_state) { //if none HDMI out,no CEC features.
-        hdmi_print(INF, CEC "HPD low!\n");
-        return;
-    }
-    
-    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))){
-        hdmi_print(INF, CEC "cec function masked!\n");
-        return;
-    }
-        
-    if(count > 32){
-        hdmi_print(INF, CEC "too many args\n");
-    }
-    for(i = 0; i < count; i++){
-        param[j] = simple_strtoul(&buf[i], NULL, 16);
-        j ++;
-        while ( buf[i] != ' ' )
-            i ++;
-    }
-    param[j]=0;
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    if(strncmp(buf, "waocec", 6)==0){
-        bit_set = simple_strtoul(buf+6, NULL, 16);
-        time_set = simple_strtoul(buf+8, NULL, 16);
-        cec_arbit_bit_time_set(bit_set, time_set, 1);
-        return;
-    }else if(strncmp(buf, "raocec", 6)==0){
-        cec_arbit_bit_time_read();
-        return;
-    }
-#endif
-    switch (param[0]) {
-    case GET_CEC_VERSION:   //0 LA
-        cec_usrcmd_get_cec_version(param[1]);
-        break;
-    case GET_DEV_POWER_STATUS:
-        cec_usrcmd_get_device_power_status(param[1]);
-        break;
-    case GET_DEV_VENDOR_ID:
-        cec_usrcmd_get_device_vendor_id(param[1]);
-        break;
-    case GET_OSD_NAME:
-        cec_usrcmd_get_osd_name(param[1]);
-        break;
-    case GET_PHYSICAL_ADDR:
-        cec_usrcmd_get_physical_address(param[1]);
-        break;
-    case SET_STANDBY:       //d LA
-        cec_usrcmd_set_standby(param[1]);
-        break;
-    case SET_IMAGEVIEW_ON:  //e LA
-        cec_usrcmd_set_imageview_on(param[1]);
-        break;
-    case GIVE_DECK_STATUS:
-        cec_usrcmd_get_deck_status(param[1]);
-        break;
-    case SET_DECK_CONTROL_MODE:
-        cec_usrcmd_set_deck_cnt_mode(param[1], param[2]);
-        break;
-    case SET_PLAY_MODE:
-        cec_usrcmd_set_play_mode(param[1], param[2]);
-        break;
-    case GET_SYSTEM_AUDIO_MODE:
-        cec_usrcmd_get_system_audio_mode_status(param[1]);
-        break;
-    case GET_TUNER_DEV_STATUS:
-        cec_usrcmd_get_tuner_device_status(param[1]);
-        break;
-    case GET_AUDIO_STATUS:
-        cec_usrcmd_get_audio_status(param[1]);
-        break;
-    case GET_OSD_STRING:
-        break;
-    case GET_MENU_STATE:
-        cec_usrcmd_get_menu_state(param[1]);
-        break;
-    case SET_MENU_STATE:
-        cec_usrcmd_set_menu_state(param[1], param[2]);
-        break;
-    case SET_MENU_LANGAGE:
-        break;
-    case GET_MENU_LANGUAGE:
-        cec_usrcmd_get_menu_language(param[1]);
-        break;
-    case GET_ACTIVE_SOURCE:     //13
-        cec_usrcmd_get_active_source();
-        break;
-    case SET_ACTIVE_SOURCE:
-        cec_usrcmd_set_active_source();
-        break;
-    case SET_DEACTIVE_SOURCE:
-        cec_usrcmd_set_deactive_source(param[1]);
-        break;
-    case REPORT_PHYSICAL_ADDRESS:    //17
-    	cec_usrcmd_set_report_physical_address();
-    	break;
-    case SET_TEXT_VIEW_ON:          //18 LA
-    	cec_usrcmd_text_view_on(param[1]);
-        break;
-    case POLLING_ONLINE_DEV:    //19 LA
-        cec_polling_online_dev(param[1], &bool);
-        break;
-
-    case CEC_OC_MENU_STATUS:
-        cec_menu_status_smp(DEVICE_MENU_INACTIVE);
-        break;
-    case CEC_OC_ABORT_MESSAGE:
-
-        msg[0] = 0x40;
-        msg[1] = CEC_OC_FEATURE_ABORT;
-        msg[2] = 0;
-        msg[3] = CEC_UNRECONIZED_OPCODE;
-
-        cec_ll_tx(msg, 4);
-        break;
-    case PING_TV:    //0x1a LA : For TV CEC detected.
-        detect_tv_support_cec(param[1]);
-        break;
-    default:
-        break;
-    }
-    hdmi_print(INF, CEC "cec usrcmd set dispatch end!\n\n");
-}
-
-/***************************** cec high level code end *****************************/
-
-late_initcall(cec_init);
-module_exit(cec_uninit);
-MODULE_DESCRIPTION("AMLOGIC HDMI TX CEC driver");
-MODULE_LICENSE("GPL");
-//MODULE_LICENSE("Dual BSD/GPL");
-//MODULE_VERSION("1.0.0");
-
-MODULE_PARM_DESC(cec_msg_dbg_en, "\n cec_msg_dbg_en\n");
-module_param(cec_msg_dbg_en, bool, 0664);
-
-
-
-
-
+/*
+ * Amlogic Meson HDMI Transmitter Driver
+ * HDMI CEC Driver-----------HDMI_TX
+ * Copyright (C) 2011 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <linux/switch.h>
+#include <linux/workqueue.h>
+#include <linux/timer.h>
+
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/power_gate.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#include <mach/gpio.h>
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <mach/hdmi_tx_reg.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+extern hdmitx_dev_t * get_hdmitx_device(void);
+static hdmitx_dev_t* hdmitx_device = NULL;
+static struct workqueue_struct *cec_workqueue = NULL;
+static struct hrtimer cec_late_timer;
+static unsigned char rx_msg[MAX_MSG];
+static unsigned char rx_len;
+
+DEFINE_SPINLOCK(cec_input_key);
+
+/* global variables */
+static unsigned char gbl_msg[MAX_MSG];
+cec_global_info_t cec_global_info;
+unsigned char rc_long_press_pwr_key = 0;
+EXPORT_SYMBOL(rc_long_press_pwr_key);
+bool cec_msg_dbg_en = 1;
+
+ssize_t cec_lang_config_state(struct switch_dev *sdev, char *buf)
+{
+    int pos=0;
+    pos+=snprintf(buf+pos, PAGE_SIZE, "%c%c%c\n", (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >>16) & 0xff,
+                                                  (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 8) & 0xff,
+                                                  (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 0) & 0xff);
+    return pos;
+};
+
+struct switch_dev lang_dev = {    // android ics switch device
+    .name = "lang_config",
+    .print_state = cec_lang_config_state,
+    };
+EXPORT_SYMBOL(lang_dev);
+
+static DEFINE_SPINLOCK(p_tx_list_lock);
+static unsigned long cec_tx_list_flags;
+static unsigned int tx_msg_cnt = 0;
+static struct list_head cec_tx_msg_phead = LIST_HEAD_INIT(cec_tx_msg_phead);
+
+unsigned int menu_lang_array[] = {(((unsigned int)'c')<<16)|(((unsigned int)'h')<<8)|((unsigned int)'i'),
+                                  (((unsigned int)'e')<<16)|(((unsigned int)'n')<<8)|((unsigned int)'g'),
+                                  (((unsigned int)'j')<<16)|(((unsigned int)'p')<<8)|((unsigned int)'n'),
+                                  (((unsigned int)'k')<<16)|(((unsigned int)'o')<<8)|((unsigned int)'r'),
+                                  (((unsigned int)'f')<<16)|(((unsigned int)'r')<<8)|((unsigned int)'a'),
+                                  (((unsigned int)'g')<<16)|(((unsigned int)'e')<<8)|((unsigned int)'r')
+                                 };
+
+// CEC default setting
+static unsigned char * osd_name = "MBox";
+static unsigned int vendor_id = 0x00;
+
+static irqreturn_t cec_isr_handler(int irq, void *dev_instance);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+static struct early_suspend hdmitx_cec_early_suspend_handler;
+static void hdmitx_cec_early_suspend(struct early_suspend *h)
+{
+    hdmi_print(INF, CEC "early suspend!\n");
+    if (!hdmitx_device->hpd_state)
+    { //if none HDMI out,no CEC features.
+        hdmi_print(INF, CEC "HPD low!\n");
+        return;
+    }
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_STANDBY;
+    printk("CEC return, power status:%d\n", cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status);
+    cec_report_power_status(NULL);
+    if (rc_long_press_pwr_key == 1)
+    {
+        cec_set_standby();
+        msleep(100);
+        hdmi_print(INF, CEC "get power-off command from Romote Control\n");
+        rc_long_press_pwr_key = 0;
+    }
+    return ;
+}
+
+static void hdmitx_cec_late_resume(struct early_suspend *h)
+{
+    cec_enable_irq();
+    if (cec_rx_buf_check()) {
+        cec_rx_buf_clear();
+    }
+    hdmitx_device->hpd_state = hdmitx_device->HWOp.CntlMisc(hdmitx_device, MISC_HPD_GPI_ST, 0);
+    if (!hdmitx_device->hpd_state)
+    { //if none HDMI out,no CEC features.
+        hdmi_print(INF, CEC "HPD low!\n");
+        return;
+    }
+
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        cec_hw_reset();//for M8 CEC standby.
+        msleep(10);
+        cec_imageview_on_smp();
+        msleep(30);
+        cec_active_source_smp();
+        //msleep(100);
+        //cec_active_source_smp();
+        //msleep(100);
+        //cec_menu_status_smp(DEVICE_MENU_ACTIVE);
+    }
+
+    hdmi_print(INF, CEC "late resume\n");
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_ON;
+}
+
+#endif
+
+void cec_isr_post_process(void)
+{
+    if (!hdmitx_device->hpd_state)
+    { //if none HDMI out,no CEC features.
+        return;
+    }
+    /* isr post process */
+    while (cec_global_info.cec_rx_msg_buf.rx_read_pos != cec_global_info.cec_rx_msg_buf.rx_write_pos)
+    {
+        cec_handle_message(&(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_read_pos]));
+        (cec_global_info.cec_rx_msg_buf.rx_read_pos == cec_global_info.cec_rx_msg_buf.rx_buf_size - 1) ? (cec_global_info.cec_rx_msg_buf.rx_read_pos = 0) : (cec_global_info.cec_rx_msg_buf.rx_read_pos++);
+    }
+}
+
+void cec_usr_cmd_post_process(void)
+{
+    cec_usr_message_list_t *p, *ptmp;
+    /* usr command post process */
+    list_for_each_entry_safe(p, ptmp, &cec_tx_msg_phead, list)
+    {
+        cec_ll_tx(p->msg, p->length);
+        unregister_cec_tx_msg(p);
+    }
+}
+
+static int detect_tv_support_cec(unsigned addr)
+{
+    unsigned int ret = 0;
+    unsigned char msg[1];
+    msg[0] = (addr<<4) | 0x0;       // 0x0, TV's root address
+    ret = cec_ll_tx_polling(msg, 1);
+    cec_hw_reset();
+    hdmi_print(INF, CEC "tv%s have CEC feature\n", ret ? " " : " don\'t ");
+    hdmitx_device->tv_cec_support = (ret == TX_DONE) ? 1 : 0;
+    return hdmitx_device->tv_cec_support;
+}
+
+void cec_node_init(hdmitx_dev_t* hdmitx_device)
+{
+    struct vendor_info_data *vend_data = NULL;
+
+    int i, bool = 0;
+    const enum _cec_log_dev_addr_e player_dev[3] = {CEC_PLAYBACK_DEVICE_1_ADDR,
+                                                    CEC_PLAYBACK_DEVICE_2_ADDR,
+                                                    CEC_PLAYBACK_DEVICE_3_ADDR,
+                                                   };
+
+    unsigned long cec_phy_addr;
+    unsigned int reg;
+
+    if ((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0))
+    {   // If no connect, return directly
+        hdmi_print(INF, CEC "CEC not ready\n");
+        return;
+    }
+    else
+    {
+        hdmi_print(INF, CEC "CEC node init\n");
+    }
+
+    if (hdmitx_device->config_data.vend_data)
+    {
+        vend_data = hdmitx_device->config_data.vend_data;
+    }
+
+    if ((vend_data) && (vend_data->cec_osd_string))
+    {
+        i = strlen(vend_data->cec_osd_string);
+        if (i > 14)
+            vend_data->cec_osd_string[14] = '\0';   // OSD string length must be less than 14 bytes
+        //osd_name = vend_data->cec_osd_string;
+    }
+
+    if ((vend_data) && (vend_data->vendor_id))
+    {
+        vendor_id = (vend_data->vendor_id ) & 0xffffff;
+    }
+
+    if (!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
+        return ;
+
+    hdmi_print(INF, CEC "cec_func_config: 0x%x; P_AO_DEBUG_REG0:0x%x\n", hdmitx_device->cec_func_config, aml_read_reg32(P_AO_DEBUG_REG0));
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 25, 1);
+    // Clear CEC Int. state and set CEC Int. mask
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_STAT_CLR) | (1 << 23));    // Clear the interrupt
+    aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) | (1 << 23));            // Enable the hdmi cec interrupt
+
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+#if 1           // Please match with H/W cec config
+// GPIOAO_12
+    aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 0, 14, 1);       // bit[14]: AO_PWM_C pinmux                  //0xc8100014
+    aml_set_reg32_bits(P_AO_RTI_PULL_UP_REG, 1, 12, 1);       // bit[12]: enable AO_12 internal pull-up   //0xc810002c
+    aml_set_reg32_bits(P_AO_RTI_PIN_MUX_REG, 1, 17, 1);       // bit[17]: AO_CEC pinmux                    //0xc8100014
+    ao_cec_init();
+#else
+// GPIOH_3
+    aml_set_reg32_bits(P_PAD_PULL_UP_EN_REG1, 0, 19, 1);    // disable gpioh_3 internal pull-up
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_1, 1, 23, 1);      // gpioh_3 cec pinmux
+#endif
+    cec_arbit_bit_time_set(3, 0x118, 0);
+    cec_arbit_bit_time_set(5, 0x000, 0);
+    cec_arbit_bit_time_set(7, 0x2aa, 0);
+#endif
+    cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12) |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)  |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)  |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
+
+
+    for (i = 0; i < 3; i++)
+    {
+        hdmi_print(INF, CEC "CEC: start poll dev\n");
+        cec_polling_online_dev(player_dev[i], &bool);
+        hdmi_print(INF, CEC "player_dev[%d]:0x%x\n", i, player_dev[i]);
+        if (bool == 0)
+        {   // 0 means that no any respond
+            // If VSDB is not valid,use last or default physical address.
+            if (hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0)
+            {
+                hdmi_print(INF, CEC "no valid cec physical address\n");
+                if (aml_read_reg32(P_AO_DEBUG_REG1))
+                {
+                    hdmi_print(INF, CEC "use last physical address\n");
+                }
+                else
+                {
+                    aml_write_reg32(P_AO_DEBUG_REG1, 0x1000);
+                    hdmi_print(INF, CEC "use default physical address\n");
+                }
+            }
+            else
+            {
+                aml_write_reg32(P_AO_DEBUG_REG1, cec_phy_addr);
+            }
+            hdmi_print(INF, CEC "physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1));
+
+            cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_STANDBY_TO_ON;
+            cec_global_info.my_node_index = player_dev[i];
+            /*
+             * use DEBUG_REG1 bit 16 ~ 31 to save logic address.
+             * So uboot can use this logic address directly
+             */
+            reg  = (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff);
+            reg |= player_dev[i] << 16;
+            aml_write_reg32(P_AO_DEBUG_REG1, reg);
+
+            aml_write_reg32(P_AO_DEBUG_REG3, aml_read_reg32(P_AO_DEBUG_REG3) | (cec_global_info.my_node_index & 0xf));
+            cec_global_info.cec_node_info[player_dev[i]].log_addr = player_dev[i];
+            // Set Physical address
+            cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4 = cec_phy_addr;
+
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.sys_audio_mode = OFF;
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_mute_status = OFF;
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_volume_status = 0;
+
+            cec_global_info.cec_node_info[player_dev[i]].cec_version = CEC_VERSION_14A;
+            cec_global_info.cec_node_info[player_dev[i]].vendor_id = vendor_id;
+            cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
+            cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
+            strcpy(cec_global_info.cec_node_info[player_dev[i]].osd_name, osd_name); //Max num: 14Bytes
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+            hdmi_wr_reg(CEC0_BASE_ADDR+CEC_LOGICAL_ADDR0, (0x1 << 4) | player_dev[i]);
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+            aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | player_dev[i]);
+#endif
+             hdmi_print(INF, CEC "Set logical address: %d\n", player_dev[i]);
+
+            if (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status == DEVICE_MENU_INACTIVE)
+                break;
+            msleep(100);
+            cec_report_physical_address_smp();
+            msleep(150);
+            cec_device_vendor_id((cec_rx_message_t*)0);
+
+            msleep(150);
+
+	    /* Disable switch TV on automatically */
+	    if (!(hdmitx_device->cec_func_config & (1 << AUTO_POWER_ON_MASK))) {
+		cec_usrcmd_get_device_power_status(CEC_TV_ADDR);
+		wait_event_interruptible(hdmitx_device->cec_wait_rx,
+			cec_global_info.cec_rx_msg_buf.rx_read_pos != cec_global_info.cec_rx_msg_buf.rx_write_pos);
+		cec_isr_post_process();
+
+		if (cec_global_info.tv_power_status)
+		    return;
+	    }
+
+            cec_imageview_on_smp();
+            msleep(100);
+
+            // here, we need to detect whether TV is supporting the CEC function
+            // if not, jump out to save system time
+            //if (!detect_tv_support_cec(player_dev[i]))
+            //{
+            //    break;
+            //}
+            cec_get_menu_language_smp();
+            msleep(350);
+
+            cec_active_source_smp();
+            msleep(120);
+
+            cec_system_audio_mode_request_smp();
+            msleep(100);
+
+            cec_menu_status_smp(DEVICE_MENU_ACTIVE);
+            msleep(100);
+
+            cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+            cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_ON;
+            break;
+        }
+    }
+    if (bool == 1)
+        hdmi_print(INF, CEC "Can't get a valid logical address\n");
+    else
+        hdmi_print(INF, CEC "cec node init: cec features ok !\n");
+}
+
+void cec_node_uninit(hdmitx_dev_t* hdmitx_device)
+{
+    if (!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
+       return ;
+
+    cec_inactive_source_smp();
+
+    cec_system_audio_mode_release_smp();
+
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_ON_TO_STANDBY;
+    hdmi_print(INF, CEC "cec node uninit!\n");
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_STANDBY;
+}
+
+static enum hrtimer_restart cec_late_check_rx_buffer(struct hrtimer *timer)
+{
+    int ret;
+
+    ret = cec_rx_buf_check();
+    if (ret) {
+        /*
+         * start another check if rx buffer is full
+         */
+        if ((-1) == cec_ll_rx(rx_msg, &rx_len)) {
+            hdmi_print(INF, CEC, "buffer got unrecorgnized msg\n");
+            cec_rx_buf_clear();
+        } else {
+            register_cec_rx_msg(rx_msg, rx_len);
+            queue_work(cec_workqueue, &hdmitx_device->cec_work);
+        }
+    }
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        hrtimer_start(&cec_late_timer, ktime_set(0, 384*1000*1000), HRTIMER_MODE_REL);
+    }
+
+    return HRTIMER_NORESTART;
+}
+
+static void cec_task(struct work_struct *work)
+{
+    extern void dump_hdmi_cec_reg(void);
+    hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*)container_of(work, hdmitx_dev_t, cec_work);
+
+    // Get logical address
+    hdmi_print(INF, CEC "CEC task process\n");
+    if ((hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) &&
+        !cec_global_info.cec_flag.cec_init_flag) {
+        msleep_interruptible(15000);
+        cec_global_info.cec_flag.cec_init_flag = 1;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+        cec_gpi_init();
+#endif
+        cec_node_init(hdmitx_device);
+    }
+    //cec_rx_buf_check();
+    cec_isr_post_process();
+    //cec_usr_cmd_post_process();
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        /* start timer for late cec rx buffer check */
+        hrtimer_start(&cec_late_timer, ktime_set(0, 384*1000*1000), HRTIMER_MODE_REL);
+    }
+}
+
+/***************************** cec low level code end *****************************/
+
+
+/***************************** cec middle level code *****************************/
+
+void register_cec_rx_msg(unsigned char *msg, unsigned char len )
+{
+    unsigned long flags;
+    spin_lock_irqsave(&cec_input_key,flags);
+    memset((void*)(&(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos])), 0, sizeof(cec_rx_message_t));
+    memcpy(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.buffer, msg, len);
+
+    cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num = len >= 2 ? len - 2 : 0;
+    cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].msg_length = len;
+
+    cec_input_handle_message();
+
+    (cec_global_info.cec_rx_msg_buf.rx_write_pos == cec_global_info.cec_rx_msg_buf.rx_buf_size - 1) ? (cec_global_info.cec_rx_msg_buf.rx_write_pos = 0) : (cec_global_info.cec_rx_msg_buf.rx_write_pos++);
+    spin_unlock_irqrestore(&cec_input_key,flags);
+}
+
+void register_cec_tx_msg(unsigned char *msg, unsigned char len )
+{
+    cec_usr_message_list_t* cec_usr_message_list = kmalloc(sizeof(cec_usr_message_list_t), GFP_ATOMIC);
+
+    if (cec_usr_message_list != NULL)
+    {
+        memset(cec_usr_message_list, 0, sizeof(cec_usr_message_list_t));
+        memcpy(cec_usr_message_list->msg, msg, len);
+        cec_usr_message_list->length = len;
+
+        spin_lock_irqsave(&p_tx_list_lock, cec_tx_list_flags);
+        list_add_tail(&cec_usr_message_list->list, &cec_tx_msg_phead);
+        spin_unlock_irqrestore(&p_tx_list_lock, cec_tx_list_flags);
+
+        tx_msg_cnt++;
+    }
+}
+
+void cec_input_handle_message(void)
+{
+    unsigned char   opcode;
+
+    opcode = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.opcode;
+
+    if (NULL == hdmitx_device)
+    {
+        hdmitx_device = get_hdmitx_device();
+        hdmi_print(INF, CEC "Error:hdmitx_device NULL!\n");
+        return;
+    }
+
+    /* process key event messages from tv */
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        switch (opcode)
+        {
+            case CEC_OC_USER_CONTROL_PRESSED:
+            case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+                // check valid msg
+                {
+                    unsigned char opernum;
+                    unsigned char follower;
+                    opernum  = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num;
+                    follower = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.header & 0x0f;
+                    if (opernum != 1 || follower == 0xf) break;
+                }
+                cec_user_control_pressed_irq();
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+void unregister_cec_tx_msg(cec_usr_message_list_t* cec_tx_message_list)
+{
+
+    if (cec_tx_message_list != NULL)
+    {
+        list_del(&cec_tx_message_list->list);
+        kfree(cec_tx_message_list);
+        cec_tx_message_list = NULL;
+
+        if (tx_msg_cnt > 0) tx_msg_cnt--;
+    }
+}
+
+unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message)
+{
+    unsigned char rt = 0;
+    unsigned char opcode;
+    unsigned char opernum;
+    unsigned char follower;
+    if (!pcec_message)
+        return rt;
+
+    opcode = pcec_message->content.msg.opcode;
+    opernum = pcec_message->operand_num;
+
+    switch (opcode)
+    {
+        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
+        case CEC_OC_STANDBY:
+        case CEC_OC_RECORD_OFF:
+        case CEC_OC_RECORD_TV_SCREEN:
+        case CEC_OC_TUNER_STEP_DECREMENT:
+        case CEC_OC_TUNER_STEP_INCREMENT:
+        case CEC_OC_GIVE_AUDIO_STATUS:
+        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_USER_CONTROL_RELEASED:
+        case CEC_OC_GIVE_OSD_NAME:
+        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+        case CEC_OC_GET_CEC_VERSION:
+        case CEC_OC_GET_MENU_LANGUAGE:
+        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+        case CEC_OC_TEXT_VIEW_ON:
+        case CEC_OC_IMAGE_VIEW_ON:
+        case CEC_OC_ABORT_MESSAGE:
+        case CEC_OC_REQUEST_ACTIVE_SOURCE:
+            if ( opernum == 0)  rt = 1;
+            break;
+        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
+        case CEC_OC_RECORD_STATUS:
+        case CEC_OC_DECK_CONTROL:
+        case CEC_OC_DECK_STATUS:
+        case CEC_OC_GIVE_DECK_STATUS:
+        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
+        case CEC_OC_PLAY:
+        case CEC_OC_MENU_REQUEST:
+        case CEC_OC_MENU_STATUS:
+        case CEC_OC_REPORT_AUDIO_STATUS:
+        case CEC_OC_TIMER_CLEARED_STATUS:
+        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_USER_CONTROL_PRESSED:
+        case CEC_OC_CEC_VERSION:
+        case CEC_OC_REPORT_POWER_STATUS:
+        case CEC_OC_SET_AUDIO_RATE:
+            if ( opernum == 1)  rt = 1;
+            break;
+        case CEC_OC_INACTIVE_SOURCE:
+        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
+        case CEC_OC_FEATURE_ABORT:
+        case CEC_OC_ACTIVE_SOURCE:
+        case CEC_OC_ROUTING_INFORMATION:
+        case CEC_OC_SET_STREAM_PATH:
+            if (opernum == 2) rt = 1;
+            break;
+        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+        case CEC_OC_SET_MENU_LANGUAGE:
+        case CEC_OC_DEVICE_VENDOR_ID:
+            if (opernum == 3) rt = 1;
+            break;
+        case CEC_OC_ROUTING_CHANGE:
+        case CEC_OC_SELECT_ANALOGUE_SERVICE:
+            if (opernum == 4) rt = 1;
+            break;
+        case CEC_OC_VENDOR_COMMAND_WITH_ID:
+            if ((opernum > 3)&&(opernum < 15))  rt = 1;
+            break;
+        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+            if (opernum < 15)  rt = 1;
+            break;
+        case CEC_OC_SELECT_DIGITAL_SERVICE:
+            if (opernum == 7) rt = 1;
+            break;
+        case CEC_OC_SET_ANALOGUE_TIMER:
+        case CEC_OC_CLEAR_ANALOGUE_TIMER:
+            if (opernum == 11) rt = 1;
+            break;
+        case CEC_OC_SET_DIGITAL_TIMER:
+        case CEC_OC_CLEAR_DIGITAL_TIMER:
+            if (opernum == 14) rt = 1;
+            break;
+        case CEC_OC_TIMER_STATUS:
+            if ((opernum == 1 || opernum == 3)) rt = 1;
+            break;
+        case CEC_OC_TUNER_DEVICE_STATUS:
+            if ((opernum == 5 || opernum == 8)) rt = 1;
+            break;
+        case CEC_OC_RECORD_ON:
+            if (opernum > 0 && opernum < 9)  rt = 1;
+            break;
+        case CEC_OC_CLEAR_EXTERNAL_TIMER:
+        case CEC_OC_SET_EXTERNAL_TIMER:
+            if ((opernum == 9 || opernum == 10)) rt = 1;
+            break;
+        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
+        case CEC_OC_SET_OSD_NAME:
+            if (opernum > 0 && opernum < 15) rt = 1;
+            break;
+        case CEC_OC_SET_OSD_STRING:
+            if (opernum > 1 && opernum < 15) rt = 1;
+            break;
+        case CEC_OC_VENDOR_COMMAND:
+            if (opernum < 15)   rt = 1;
+            break;
+        default:
+            rt = 1;
+            break;
+    }
+
+ // for CTS12.2
+    follower = pcec_message->content.msg.header & 0x0f;
+    switch (opcode)
+    {
+        case CEC_OC_ACTIVE_SOURCE:
+        case CEC_OC_REQUEST_ACTIVE_SOURCE:
+        case CEC_OC_ROUTING_CHANGE:
+        case CEC_OC_ROUTING_INFORMATION:
+        case CEC_OC_SET_STREAM_PATH:
+        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+        case CEC_OC_SET_MENU_LANGUAGE:
+        case CEC_OC_DEVICE_VENDOR_ID:
+            // broadcast only
+            if (follower != 0xf) rt = 0;
+            break;
+
+        case CEC_OC_IMAGE_VIEW_ON:
+        case CEC_OC_TEXT_VIEW_ON:
+        case CEC_OC_INACTIVE_SOURCE:
+        case CEC_OC_RECORD_OFF:
+        case CEC_OC_RECORD_ON:
+        case CEC_OC_RECORD_STATUS:
+        case CEC_OC_RECORD_TV_SCREEN:
+        case CEC_OC_CLEAR_ANALOGUE_TIMER:
+        case CEC_OC_CLEAR_DIGITAL_TIMER:
+        case CEC_OC_CLEAR_EXTERNAL_TIMER:
+        case CEC_OC_SET_ANALOGUE_TIMER:
+        case CEC_OC_SET_DIGITAL_TIMER:
+        case CEC_OC_SET_EXTERNAL_TIMER:
+        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
+        case CEC_OC_TIMER_CLEARED_STATUS:
+        case CEC_OC_TIMER_STATUS:
+        case CEC_OC_CEC_VERSION:
+        case CEC_OC_GET_CEC_VERSION:
+        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+        case CEC_OC_GET_MENU_LANGUAGE:
+        case CEC_OC_DECK_CONTROL:
+        case CEC_OC_DECK_STATUS:
+        case CEC_OC_GIVE_DECK_STATUS:
+        case CEC_OC_PLAY:
+        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
+        case CEC_OC_SELECT_ANALOGUE_SERVICE:
+        case CEC_OC_SELECT_DIGITAL_SERVICE:
+        case CEC_OC_TUNER_DEVICE_STATUS:
+        case CEC_OC_TUNER_STEP_DECREMENT:
+        case CEC_OC_TUNER_STEP_INCREMENT:
+        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+        case CEC_OC_VENDOR_COMMAND:
+        case CEC_OC_SET_OSD_STRING:
+        case CEC_OC_GIVE_OSD_NAME:
+        case CEC_OC_SET_OSD_NAME:
+        case CEC_OC_MENU_REQUEST:
+        case CEC_OC_MENU_STATUS:
+        case CEC_OC_USER_CONTROL_PRESSED:
+        case CEC_OC_USER_CONTROL_RELEASED:
+        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+        case CEC_OC_REPORT_POWER_STATUS:
+        case CEC_OC_FEATURE_ABORT:
+        case CEC_OC_ABORT_MESSAGE:
+        case CEC_OC_GIVE_AUDIO_STATUS:
+        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_REPORT_AUDIO_STATUS:
+        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
+        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_SET_AUDIO_RATE:
+            // directly addressed only
+            if (follower == 0xf) rt = 0;
+            break;
+
+        case CEC_OC_STANDBY:
+        case CEC_OC_VENDOR_COMMAND_WITH_ID:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
+        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
+            // both broadcast and directly addressed
+            break;
+
+        default:
+            break;
+    }
+
+    if ((rt == 0) & (opcode != 0))
+    {
+        hdmi_print(INF, CEC "CEC: opcode & opernum not match: %x, %x\n", opcode, opernum);
+    }
+    return rt;
+}
+
+static irqreturn_t cec_isr_handler(int irq, void *dev_instance)
+{
+    //unsigned char rx_msg[MAX_MSG], rx_len;
+
+    udelay(100); //Delay execution a little. This fixes an issue when HDMI CEC stops working after a while.
+    //cec_disable_irq();
+    hdmitx_dev_t* hdmitx;
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    unsigned int intr_stat = 0;
+    intr_stat = aml_read_reg32(P_AO_CEC_INTR_STAT);
+    if (cec_msg_dbg_en  == 1)
+    {
+        hdmi_print(INF, CEC "aocec irq %x\n", intr_stat);
+    }
+    if (intr_stat & (1<<1))
+    {   // aocec tx intr
+        tx_irq_handle();
+        //cec_enable_irq();
+        return IRQ_HANDLED;
+    }
+#endif
+    if ((-1) == cec_ll_rx(rx_msg, &rx_len))
+    {
+        //cec_enable_irq();
+        //cec_rx_buf_check();
+        return IRQ_HANDLED;
+    }
+
+    hdmitx = (hdmitx_dev_t*)dev_instance;
+    register_cec_rx_msg(rx_msg, rx_len);
+    queue_work(cec_workqueue, &hdmitx->cec_work);
+    //cec_rx_buf_check();
+
+    //cec_enable_irq();
+
+    return IRQ_HANDLED;
+}
+
+unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
+{
+    unsigned short us = CEC_UNREGISTERED_DEVICE_TYPE;
+    if ((1 << log_addr) & CEC_DISPLAY_DEVICE)
+    {
+        us = CEC_DISPLAY_DEVICE_TYPE;
+    }
+    else if ((1 << log_addr) & CEC_RECORDING_DEVICE)
+    {
+        us = CEC_RECORDING_DEVICE_TYPE;
+    }
+    else if ((1 << log_addr) & CEC_PLAYBACK_DEVICE)
+    {
+        us = CEC_PLAYBACK_DEVICE_TYPE;
+    }
+    else if ((1 << log_addr) & CEC_TUNER_DEVICE)
+    {
+        us = CEC_TUNER_DEVICE_TYPE;
+    }
+    else if ((1 << log_addr) & CEC_AUDIO_SYSTEM_DEVICE)
+    {
+        us = CEC_AUDIO_SYSTEM_DEVICE_TYPE;
+    }
+
+    return us;
+}
+// -------------- command from cec devices ---------------------
+//***************************************************************
+void cec_device_vendor_id(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[5];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_DEVICE_VENDOR_ID;
+    msg[2] = (vendor_id >> 16) & 0xff;
+    msg[3] = (vendor_id >> 8) & 0xff;
+    msg[4] = (vendor_id >> 0) & 0xff;
+
+    cec_ll_tx(msg, 5);
+}
+
+void cec_report_power_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[3];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_REPORT_POWER_STATUS;
+    msg[2] = cec_global_info.cec_node_info[index].power_status;
+    cec_ll_tx(msg, 3);
+
+}
+
+void cec_feature_abort(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char opcode = pcec_message->content.msg.opcode;
+    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
+    unsigned char dst_log_addr = pcec_message->content.msg.header & 0xf;
+    if (dst_log_addr != 0xf)
+    {
+        unsigned char msg[4];
+
+        msg[0] = ((index & 0xf) << 4) | src_log_addr;
+        msg[1] = CEC_OC_FEATURE_ABORT;
+        msg[2] = opcode;
+        msg[3] = CEC_UNRECONIZED_OPCODE;
+
+        cec_ll_tx(msg, 4);
+    }
+}
+
+void cec_report_version(cec_rx_message_t* pcec_message)
+{
+    ;//todo
+}
+
+
+void cec_report_physical_address_smp(void)
+{
+    unsigned char msg[5];
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+    msg[4] = cec_global_info.cec_node_info[index].dev_type;
+
+    cec_ll_tx(msg, 5);
+}
+
+void cec_imageview_on_smp(void)
+{
+    unsigned char msg[2];
+    unsigned char index = cec_global_info.my_node_index;
+
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        if (hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK))
+        {
+            msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+            msg[1] = CEC_OC_IMAGE_VIEW_ON;
+            cec_ll_tx(msg, 2);
+        }
+    }
+}
+
+void cec_get_menu_language_smp(void)
+{
+    unsigned char msg[2];
+    unsigned char index = cec_global_info.my_node_index;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_GET_MENU_LANGUAGE;
+
+    cec_ll_tx(msg, 2);
+}
+
+void cec_menu_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char msg[3];
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
+
+    if (0xf != src_log_addr)
+    {
+        msg[0] = ((index & 0xf) << 4) | src_log_addr;
+        msg[1] = CEC_OC_MENU_STATUS;
+        msg[2] = cec_global_info.cec_node_info[index].menu_status;
+        cec_ll_tx(msg, 3);
+    }
+}
+
+void cec_menu_status_smp(cec_device_menu_state_e status)
+{
+    unsigned char msg[3];
+    unsigned char index = cec_global_info.my_node_index;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_MENU_STATUS;
+    if (status == DEVICE_MENU_ACTIVE)
+    {
+        msg[2] = DEVICE_MENU_ACTIVE;
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
+    }
+    else
+    {
+        msg[2] = DEVICE_MENU_INACTIVE;
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
+    }
+    cec_ll_tx(msg, 3);
+}
+
+void cec_menu_status_smp_irq(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    if (1 == pcec_message->content.msg.operands[0])
+    {
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
+    }
+    else if (0 == pcec_message->content.msg.operands[0])
+    {
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
+    }
+}
+
+void cec_active_source_rx(cec_rx_message_t* pcec_message)
+{
+    unsigned int phy_addr_active;
+
+    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+
+    if (phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff))
+    {
+        cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+    }
+    else
+    {
+        cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+    }
+}
+
+void cec_active_source_smp(void)
+{
+    unsigned char msg[4];
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        if (hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK))
+        {
+            msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+            msg[1] = CEC_OC_ACTIVE_SOURCE;
+            msg[2] = phy_addr_ab;
+            msg[3] = phy_addr_cd;
+            cec_ll_tx(msg, 4);
+        }
+    }
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+}
+
+void cec_inactive_source_smp(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[4];
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        if (hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK))
+        {
+            msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+            msg[1] = CEC_OC_INACTIVE_SOURCE;
+            msg[2] = phy_addr_ab;
+            msg[3] = phy_addr_cd;
+            cec_ll_tx(msg, 4);
+        }
+    }
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+}
+
+void cec_system_audio_mode_request_smp(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        if (hdmitx_device->cec_func_config & (1 << SYSTEM_AUDIO_MASK))
+        {
+            if (cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == OFF)
+            {
+                MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                        CEC_OC_SYSTEM_AUDIO_MODE_REQUEST,
+                        phy_addr_ab,
+                        phy_addr_cd
+                );
+                cec_ll_tx(gbl_msg, 4);
+                cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
+            }
+        }
+    }
+}
+
+void cec_system_audio_mode_release_smp(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        if (hdmitx_device->cec_func_config & (1 << SYSTEM_AUDIO_MASK))
+        {
+            if (cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == ON)
+            {
+                MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                        CEC_OC_SYSTEM_AUDIO_MODE_REQUEST,
+						0, 0	// physical address of TV
+                );
+                cec_ll_tx(gbl_msg, 4);
+                cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
+            }
+        }
+    }
+}
+
+void cec_active_source(cec_rx_message_t* pcec_message)
+{
+    unsigned char msg[4];
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_ACTIVE_SOURCE;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+    cec_ll_tx(msg, 4);
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+}
+
+
+void cec_set_stream_path(cec_rx_message_t* pcec_message)
+{
+    unsigned int phy_addr_active;
+
+    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+
+    if (phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff))
+    {
+        cec_active_source_smp();
+        cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+    }
+    else
+    {
+        cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+    }
+}
+void cec_set_system_audio_mode(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    MSG_P1( index, CEC_TV_ADDR,
+            CEC_OC_SET_SYSTEM_AUDIO_MODE,
+            cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode
+            );
+
+    cec_ll_tx(gbl_msg, 3);
+    if (cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == ON)
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
+    else
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
+}
+
+void cec_system_audio_mode_request(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    if (cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == OFF)
+    {
+        MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST,
+                phy_addr_ab,
+                phy_addr_cd
+                );
+        cec_ll_tx(gbl_msg, 4);
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
+    }
+    else
+    {
+        MSG_P0( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST
+                );
+        cec_ll_tx(gbl_msg, 2);
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
+    }
+}
+
+void cec_report_audio_status(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    MSG_P1( index, CEC_TV_ADDR,
+            CEC_OC_REPORT_AUDIO_STATUS,
+            cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_mute_status | \
+            cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_volume_status
+            );
+
+    cec_ll_tx(gbl_msg, 3);
+}
+void cec_request_active_source(cec_rx_message_t* pcec_message)
+{
+    cec_set_stream_path(pcec_message);
+}
+
+void cec_set_imageview_on_irq(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[2];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_IMAGE_VIEW_ON;
+
+    cec_ll_tx(msg, 2);
+}
+
+void cec_inactive_source(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[4];
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_INACTIVE_SOURCE;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+
+    cec_ll_tx(msg, 4);
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+}
+
+void cec_inactive_source_rx(cec_rx_message_t* pcec_message)
+{
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+}
+
+void cec_get_version(cec_rx_message_t* pcec_message)
+{
+    unsigned char dest_log_addr = pcec_message->content.msg.header&0xf;
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[3];
+
+    if (0xf != dest_log_addr)
+    {
+        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+        msg[1] = CEC_OC_CEC_VERSION;
+        msg[2] = CEC_VERSION_14A;
+        cec_ll_tx(msg, 3);
+    }
+}
+
+void cec_give_deck_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[3];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_DECK_STATUS;
+    msg[2] = 0x20;
+    cec_ll_tx(msg, 3);
+}
+
+
+void cec_deck_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    if (cec_global_info.dev_mask & (1 << index))
+    {
+        cec_global_info.cec_node_info[index].specific_info.playback.deck_info = pcec_message->content.msg.operands[0];
+        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_DECK_INfO;
+        hdmi_print(INF, CEC "cec_deck_status: %x\n", cec_global_info.cec_node_info[index].specific_info.playback.deck_info);
+    }
+}
+
+// STANDBY: long press our remote control, send STANDBY to TV
+void cec_set_standby(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[2];
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_STANDBY;
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        if (hdmitx_device->cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK))
+        {
+            cec_ll_tx(msg, 2);
+        }
+    }
+}
+
+void cec_set_osd_name(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
+    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
+    unsigned char msg[16];
+
+    if (0xf != src_log_addr)
+    {
+        msg[0] = ((index & 0xf) << 4) | src_log_addr;
+        msg[1] = CEC_OC_SET_OSD_NAME;
+        memcpy(&msg[2], cec_global_info.cec_node_info[index].osd_name, osd_len);
+
+        cec_ll_tx(msg, 2 + osd_len);
+    }
+}
+
+void cec_set_osd_name_init(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
+    unsigned char msg[16];
+
+    msg[0] = ((index & 0xf) << 4) | 0;
+    msg[1] = CEC_OC_SET_OSD_NAME;
+    memcpy(&msg[2], cec_global_info.cec_node_info[index].osd_name, osd_len);
+
+    cec_ll_tx(msg, 2 + osd_len);
+}
+
+void cec_vendor_cmd_with_id(cec_rx_message_t* pcec_message)
+{
+    ;//todo
+}
+
+
+void cec_set_menu_language(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
+
+    if (0x0 == src_log_addr)
+    {
+        cec_global_info.cec_node_info[index].menu_lang = (int)((pcec_message->content.msg.operands[0] << 16)  |
+                                                               (pcec_message->content.msg.operands[1] <<  8)  |
+                                                               (pcec_message->content.msg.operands[2]));
+
+        switch_set_state(&lang_dev, cec_global_info.cec_node_info[index].menu_lang);
+        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_MENU_LANGUAGE;
+        hdmi_print(INF, CEC "cec_set_menu_language:%c.%c.%c\n", (cec_global_info.cec_node_info[index].menu_lang >>16) & 0xff,
+                                                                (cec_global_info.cec_node_info[index].menu_lang >> 8) & 0xff,
+                                                                (cec_global_info.cec_node_info[index].menu_lang >> 0) & 0xff);
+    }
+}
+
+void cec_handle_message(cec_rx_message_t* pcec_message)
+{
+    unsigned char    brdcst, opcode;
+    unsigned char    initiator, follower;
+    unsigned char   operand_num;
+    unsigned char   msg_length;
+
+    /* parse message */
+    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0))
+        return;
+
+    initiator    = pcec_message->content.msg.header >> 4;
+    follower    = pcec_message->content.msg.header & 0x0f;
+    opcode        = pcec_message->content.msg.opcode;
+    operand_num = pcec_message->operand_num;
+    brdcst      = (follower == 0x0f);
+    msg_length  = pcec_message->msg_length;
+
+    if (0 == pcec_message->content.msg.header)
+        return;
+
+    /* process messages from tv polling and cec devices */
+    if (CEC_OC_GIVE_OSD_NAME == opcode)
+        cec_set_osd_name(pcec_message);
+    if (hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+
+        switch (opcode)
+        {
+            case CEC_OC_ACTIVE_SOURCE:
+                cec_active_source_rx(pcec_message);
+                break;
+            case CEC_OC_INACTIVE_SOURCE:
+                break;
+            case CEC_OC_CEC_VERSION:
+                break;
+            case CEC_OC_DECK_STATUS:
+                break;
+            case CEC_OC_DEVICE_VENDOR_ID:
+                break;
+            case CEC_OC_FEATURE_ABORT:
+                break;
+            case CEC_OC_GET_CEC_VERSION:
+                cec_get_version(pcec_message);
+                break;
+            case CEC_OC_GIVE_DECK_STATUS:
+                cec_give_deck_status(pcec_message);
+                break;
+            case CEC_OC_MENU_STATUS:
+                cec_menu_status_smp_irq(pcec_message);
+                break;
+            case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+                break;
+            case CEC_OC_REPORT_POWER_STATUS:
+	    cec_global_info.tv_power_status = pcec_message->content.msg.operands[0];
+                break;
+            case CEC_OC_SET_OSD_NAME:
+                break;
+            case CEC_OC_VENDOR_COMMAND_WITH_ID:
+                break;
+            case CEC_OC_SET_MENU_LANGUAGE:
+                cec_set_menu_language(pcec_message);
+                break;
+            case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+                cec_report_physical_address_smp();
+                break;
+            case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+                cec_device_vendor_id(pcec_message);
+                break;
+            case CEC_OC_GIVE_OSD_NAME:
+                break;
+            case CEC_OC_STANDBY:
+                cec_inactive_source_rx(pcec_message);
+                /* platform already enter standby state, ignore this meesage */
+                if (cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status == POWER_STANDBY)
+                    break;
+                cec_standby(pcec_message);
+                break;
+            case CEC_OC_SET_STREAM_PATH:
+                cec_set_stream_path(pcec_message);
+                break;
+            case CEC_OC_REQUEST_ACTIVE_SOURCE:
+                if (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status != DEVICE_MENU_ACTIVE)
+                    break;
+                /* do not active soruce when standby */
+                if (cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status == POWER_STANDBY)
+                    break;
+                cec_active_source_smp();
+                break;
+            case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+                cec_report_power_status(pcec_message);
+                break;
+            case CEC_OC_USER_CONTROL_PRESSED:
+                break;
+            case CEC_OC_USER_CONTROL_RELEASED:
+                break;
+            case CEC_OC_IMAGE_VIEW_ON:      //not support in source
+                cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
+                break;
+            case CEC_OC_ROUTING_CHANGE:
+                cec_routing_change(pcec_message);
+                break;
+            case CEC_OC_ROUTING_INFORMATION:
+                cec_routing_information(pcec_message);
+                break;
+            case CEC_OC_GIVE_AUDIO_STATUS:
+                cec_report_audio_status();
+                break;
+            case CEC_OC_MENU_REQUEST:
+                cec_menu_status(pcec_message);
+                break;
+            case CEC_OC_PLAY:
+                hdmi_print(INF, CEC "CEC_OC_PLAY:0x%x\n",pcec_message->content.msg.operands[0]);
+                switch (pcec_message->content.msg.operands[0])
+                {
+                    case 0x24:
+                        input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
+                        input_sync(cec_global_info.remote_cec_dev);
+                        input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
+                        input_sync(cec_global_info.remote_cec_dev);
+                        break;
+                    case 0x25:
+                        input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
+                        input_sync(cec_global_info.remote_cec_dev);
+                        input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
+                        input_sync(cec_global_info.remote_cec_dev);
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            case CEC_OC_DECK_CONTROL:
+                hdmi_print(INF, CEC "CEC_OC_DECK_CONTROL:0x%x\n",pcec_message->content.msg.operands[0]);
+                switch (pcec_message->content.msg.operands[0])
+                {
+                    case 0x3:
+                        input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_STOP, 1);
+                        input_sync(cec_global_info.remote_cec_dev);
+                        input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_STOP, 0);
+                        input_sync(cec_global_info.remote_cec_dev);
+                        break;
+                    default:
+                        break;
+                }
+                break;
+            case CEC_OC_VENDOR_COMMAND:
+                if (pcec_message->content.msg.operands[0] == 0x1) {
+                    cec_report_power_status(pcec_message);
+                    cec_send_simplink_alive(pcec_message);
+                } else if (pcec_message->content.msg.operands[0]
+                                == 0x4) {
+                    cec_send_simplink_ack(pcec_message);
+                }
+                break;
+            case CEC_OC_GET_MENU_LANGUAGE:
+            case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+            case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
+            case CEC_OC_CLEAR_ANALOGUE_TIMER:
+            case CEC_OC_CLEAR_DIGITAL_TIMER:
+            case CEC_OC_CLEAR_EXTERNAL_TIMER:
+            case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+            case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
+            case CEC_OC_SET_OSD_STRING:
+            case CEC_OC_SET_SYSTEM_AUDIO_MODE:
+            case CEC_OC_SET_TIMER_PROGRAM_TITLE:
+            case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
+            case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
+            case CEC_OC_TEXT_VIEW_ON:
+            case CEC_OC_TIMER_CLEARED_STATUS:
+            case CEC_OC_TIMER_STATUS:
+            case CEC_OC_TUNER_DEVICE_STATUS:
+            case CEC_OC_TUNER_STEP_DECREMENT:
+            case CEC_OC_TUNER_STEP_INCREMENT:
+            case CEC_OC_SELECT_ANALOGUE_SERVICE:
+            case CEC_OC_SELECT_DIGITAL_SERVICE:
+            case CEC_OC_SET_ANALOGUE_TIMER :
+            case CEC_OC_SET_AUDIO_RATE:
+            case CEC_OC_SET_DIGITAL_TIMER:
+            case CEC_OC_SET_EXTERNAL_TIMER:
+            case CEC_OC_RECORD_OFF:
+            case CEC_OC_RECORD_ON:
+            case CEC_OC_RECORD_STATUS:
+            case CEC_OC_RECORD_TV_SCREEN:
+            case CEC_OC_REPORT_AUDIO_STATUS:
+            case CEC_OC_ABORT_MESSAGE:
+                cec_feature_abort(pcec_message);
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+
+// --------------- cec command from user application --------------------
+
+void cec_usrcmd_parse_all_dev_online(void)
+{
+    int i;
+    unsigned short tmp_mask;
+
+    hdmi_print(INF, CEC "cec online: ###############################################\n");
+    hdmi_print(INF, CEC "active_log_dev %x\n", cec_global_info.active_log_dev);
+    for (i = 0; i < MAX_NUM_OF_DEV; i++)
+    {
+        tmp_mask = 1 << i;
+        if (tmp_mask & cec_global_info.dev_mask)
+        {
+            hdmi_print(INF, CEC "cec online: -------------------------------------------\n");
+            hdmi_print(INF, CEC "hdmi_port:     %x\n", cec_global_info.cec_node_info[i].hdmi_port);
+            hdmi_print(INF, CEC "dev_type:      %x\n", cec_global_info.cec_node_info[i].dev_type);
+            hdmi_print(INF, CEC "power_status:  %x\n", cec_global_info.cec_node_info[i].power_status);
+            hdmi_print(INF, CEC "cec_version:   %x\n", cec_global_info.cec_node_info[i].cec_version);
+            hdmi_print(INF, CEC "vendor_id:     %x\n", cec_global_info.cec_node_info[i].vendor_id);
+            hdmi_print(INF, CEC "phy_addr:      %x\n", cec_global_info.cec_node_info[i].phy_addr.phy_addr_4);
+            hdmi_print(INF, CEC "log_addr:      %x\n", cec_global_info.cec_node_info[i].log_addr);
+            hdmi_print(INF, CEC "osd_name:      %s\n", cec_global_info.cec_node_info[i].osd_name);
+            hdmi_print(INF, CEC "osd_name_def:  %s\n", cec_global_info.cec_node_info[i].osd_name_def);
+            hdmi_print(INF, CEC "menu_state:    %x\n", cec_global_info.cec_node_info[i].menu_state);
+
+            if (cec_global_info.cec_node_info[i].dev_type == CEC_PLAYBACK_DEVICE_TYPE)
+            {
+                hdmi_print(INF, CEC "deck_cnt_mode: %x\n", cec_global_info.cec_node_info[i].specific_info.playback.deck_cnt_mode);
+                hdmi_print(INF, CEC "deck_info:     %x\n", cec_global_info.cec_node_info[i].specific_info.playback.deck_info);
+                hdmi_print(INF, CEC "play_mode:     %x\n", cec_global_info.cec_node_info[i].specific_info.playback.play_mode);
+            }
+        }
+    }
+    hdmi_print(INF, CEC "##############################################################\n");
+}
+
+void cec_usrcmd_get_cec_version(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr,
+            CEC_OC_GET_CEC_VERSION);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_audio_status(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_AUDIO_STATUS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_deck_status(unsigned char log_addr)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DECK_STATUS, STATUS_REQ_ON);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_set_deck_cnt_mode(unsigned char log_addr, deck_cnt_mode_e deck_cnt_mode)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_DECK_CONTROL, deck_cnt_mode);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_get_device_power_status(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_POWER_STATUS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_device_vendor_id(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_VENDOR_ID);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_osd_name(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_OSD_NAME);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_physical_address(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_PHYSICAL_ADDRESS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_system_audio_mode_status(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_set_standby(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_STANDBY);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+/////////////////////////
+void cec_usrcmd_set_imageview_on(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr,
+            CEC_OC_IMAGE_VIEW_ON);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_text_view_on(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr,
+            CEC_OC_TEXT_VIEW_ON);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_tuner_device_status(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_TUNER_DEVICE_STATUS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_set_play_mode(unsigned char log_addr, play_mode_e play_mode)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_PLAY, play_mode);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_get_menu_state(unsigned char log_addr)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, MENU_REQ_QUERY);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_set_menu_state(unsigned char log_addr, menu_req_type_e menu_req_type)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, menu_req_type);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_get_menu_language(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GET_MENU_LANGUAGE);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_active_source(void)
+{
+    MSG_P0(cec_global_info.my_node_index, 0xF, CEC_OC_REQUEST_ACTIVE_SOURCE);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_set_active_source(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    MSG_P2(index, CEC_BROADCAST_ADDR,
+            CEC_OC_ACTIVE_SOURCE,
+            phy_addr_ab,
+            phy_addr_cd);
+
+    cec_ll_tx(gbl_msg, 4);
+}
+
+void cec_usrcmd_set_deactive_source(unsigned char log_addr)
+{
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    MSG_P2(cec_global_info.my_node_index, log_addr, CEC_OC_INACTIVE_SOURCE,
+           phy_addr_ab,
+           phy_addr_cd);
+
+    cec_ll_tx(gbl_msg, 4);
+}
+
+void cec_usrcmd_clear_node_dev_real_info_mask(unsigned char log_addr, cec_info_mask mask)
+{
+    cec_global_info.cec_node_info[log_addr].real_info_mask &= ~mask;
+}
+
+
+void cec_usrcmd_set_osd_name(cec_rx_message_t* pcec_message)
+{
+
+    unsigned char log_addr = pcec_message->content.msg.header >> 4 ;
+    unsigned char index = cec_global_info.my_node_index;
+
+    MSG_P14(index, log_addr,
+            CEC_OC_SET_OSD_NAME,
+            cec_global_info.cec_node_info[index].osd_name[0],
+            cec_global_info.cec_node_info[index].osd_name[1],
+            cec_global_info.cec_node_info[index].osd_name[2],
+            cec_global_info.cec_node_info[index].osd_name[3],
+            cec_global_info.cec_node_info[index].osd_name[4],
+            cec_global_info.cec_node_info[index].osd_name[5],
+            cec_global_info.cec_node_info[index].osd_name[6],
+            cec_global_info.cec_node_info[index].osd_name[7],
+            cec_global_info.cec_node_info[index].osd_name[8],
+            cec_global_info.cec_node_info[index].osd_name[9],
+            cec_global_info.cec_node_info[index].osd_name[10],
+            cec_global_info.cec_node_info[index].osd_name[11],
+            cec_global_info.cec_node_info[index].osd_name[12],
+            cec_global_info.cec_node_info[index].osd_name[13]);
+
+    cec_ll_tx(gbl_msg, 16);
+}
+
+
+
+void cec_usrcmd_set_device_vendor_id(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    MSG_P3(index, CEC_BROADCAST_ADDR,
+            CEC_OC_DEVICE_VENDOR_ID,
+            (cec_global_info.cec_node_info[index].vendor_id >> 16) & 0xff,
+            (cec_global_info.cec_node_info[index].vendor_id >> 8) & 0xff,
+            (cec_global_info.cec_node_info[index].vendor_id >> 0) & 0xff);
+
+    cec_ll_tx(gbl_msg, 5);
+}
+void cec_usrcmd_set_report_physical_address(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    MSG_P3(index, CEC_BROADCAST_ADDR,
+           CEC_OC_REPORT_PHYSICAL_ADDRESS,
+           phy_addr_ab,
+           phy_addr_cd,
+           CEC_PLAYBACK_DEVICE_TYPE);
+
+    cec_ll_tx(gbl_msg, 5);
+}
+
+void cec_routing_change(cec_rx_message_t* pcec_message)
+{
+    unsigned int phy_addr_origin;
+    unsigned int phy_addr_destination;
+
+    phy_addr_origin = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[2] << 8) |
+                                         (pcec_message->content.msg.operands[3] << 0));
+
+    if (phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff))
+    {
+        cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+    }else{
+        cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+    }
+}
+
+void cec_routing_information(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+    unsigned int phy_addr_destination;
+    unsigned char msg[4];
+
+    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                         (pcec_message->content.msg.operands[1] << 0));
+
+    if (phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff))
+    {
+        cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+        msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+        msg[1] = CEC_OC_ROUTING_INFORMATION;
+        msg[2] = phy_addr_ab;
+        msg[3] = phy_addr_cd;
+        cec_ll_tx(msg, 4);
+    }
+    else
+    {
+        cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+    }
+}
+
+void cec_usrcmd_device_menu_control(unsigned char log_addr, unsigned char button)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_USER_CONTROL_PRESSED, button);
+    cec_ll_tx(gbl_msg, 3);
+
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_USER_CONTROL_RELEASED);
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_send_simplink_alive(cec_rx_message_t *pcec_message)
+{
+	unsigned char index = cec_global_info.my_node_index;
+	unsigned char msg[4];
+
+	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+	msg[1] = CEC_OC_VENDOR_COMMAND;
+	msg[2] = 0x2;
+	msg[3] = 0x5;
+
+	cec_ll_tx(msg, 4);
+}
+
+void cec_send_simplink_ack(cec_rx_message_t *pcec_message)
+{
+	unsigned char index = cec_global_info.my_node_index;
+	unsigned char msg[4];
+
+	msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+	msg[1] = CEC_OC_VENDOR_COMMAND;
+	msg[2] = 0x5;
+	msg[3] = 0x1;
+
+	cec_ll_tx(msg, 4);
+}
+/***************************** cec middle level code end *****************************/
+
+
+/***************************** cec high level code *****************************/
+
+static int __init cec_init(void)
+{
+    int i;
+    extern __u16 cec_key_map[128];
+    extern hdmitx_dev_t * get_hdmitx_device(void);
+    hdmitx_device = get_hdmitx_device();
+    cec_key_init();
+    hdmi_print(INF, CEC "CEC init\n");
+    memset(&cec_global_info, 0, sizeof(cec_global_info_t));
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_H, 0x00 );
+    hdmi_wr_reg(CEC0_BASE_ADDR+CEC_CLOCK_DIV_L, 0xf0 );
+#endif
+
+    cec_global_info.cec_rx_msg_buf.rx_buf_size = sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message)/sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message[0]);
+    cec_global_info.hdmitx_device = hdmitx_device;
+
+    cec_workqueue = create_workqueue("cec_work");
+    if (cec_workqueue == NULL) {
+        printk("create work queue failed\n");
+        return -EFAULT;
+    }
+    INIT_WORK(&hdmitx_device->cec_work, cec_task);
+    hrtimer_init(&cec_late_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);
+    cec_late_timer.function = cec_late_check_rx_buffer;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+    if (request_irq(INT_HDMI_CEC, &cec_isr_handler,
+    IRQF_SHARED, "amhdmitx-cec",(void *)hdmitx_device))
+    {
+        hdmi_print(INF, CEC "Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
+    }
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    if (request_irq(INT_AO_CEC, &cec_isr_handler,
+    IRQF_SHARED, "amhdmitx-aocec",(void *)hdmitx_device))
+    {
+        hdmi_print(INF, CEC "Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
+    }
+#endif
+
+    cec_global_info.remote_cec_dev = input_allocate_device();
+    if (!cec_global_info.remote_cec_dev)
+    {
+        hdmi_print(INF, CEC "remote_cec.c: Not enough memory\n");
+    }
+    cec_global_info.remote_cec_dev->name = "cec_input";
+
+    cec_global_info.remote_cec_dev->evbit[0] = BIT_MASK(EV_KEY);
+    cec_global_info.remote_cec_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);
+    cec_global_info.remote_cec_dev->id.bustype = BUS_ISA;
+    cec_global_info.remote_cec_dev->id.vendor = 0x1b8e;
+    cec_global_info.remote_cec_dev->id.product = 0x0cec;
+    cec_global_info.remote_cec_dev->id.version = 0x0001;
+
+    for (i = 0; i < 128; i++)
+    {
+          set_bit( cec_key_map[i], cec_global_info.remote_cec_dev->keybit);
+    }
+
+    if (input_register_device(cec_global_info.remote_cec_dev))
+    {
+        hdmi_print(INF, CEC "remote_cec.c: Failed to register device\n");
+        input_free_device(cec_global_info.remote_cec_dev);
+    }
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    hdmitx_cec_early_suspend_handler.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
+    hdmitx_cec_early_suspend_handler.suspend = hdmitx_cec_early_suspend;
+    hdmitx_cec_early_suspend_handler.resume = hdmitx_cec_late_resume;
+    hdmitx_cec_early_suspend_handler.param = hdmitx_device;
+
+    register_early_suspend(&hdmitx_cec_early_suspend_handler);
+#endif
+
+    hdmitx_device->cec_init_ready = 1;
+    cec_global_info.cec_flag.cec_init_flag = 0;
+    hdmi_print(INF, CEC "hdmitx_device->cec_init_ready:0x%x", hdmitx_device->cec_init_ready);
+    queue_work(cec_workqueue, &hdmitx_device->cec_work);    // for init
+    return 0;
+}
+
+static void __exit cec_uninit(void)
+{
+    if (!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
+    {
+        return ;
+    }
+
+    cec_node_uninit(hdmitx_device);
+
+    hdmi_print(INF, CEC "cec uninit!\n");
+    if (cec_global_info.cec_flag.cec_init_flag == 1)
+    {
+
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+        aml_write_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK, aml_read_reg32(P_SYS_CPU_0_IRQ_IN1_INTR_MASK) & ~(1 << 23));            // Disable the hdmi cec interrupt
+        free_irq(INT_HDMI_CEC, (void *)hdmitx_device);
+#endif
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+        free_irq(INT_AO_CEC, (void *)hdmitx_device);
+#endif
+        cec_global_info.cec_flag.cec_init_flag = 0;
+    }
+
+    if (cec_workqueue) {
+        cancel_work_sync(&hdmitx_device->cec_work);
+        destroy_workqueue(cec_workqueue);
+    }
+    hdmitx_device->cec_init_ready = 0;
+    input_unregister_device(cec_global_info.remote_cec_dev);
+    cec_global_info.cec_flag.cec_fiq_flag = 0;
+}
+
+size_t cec_usrcmd_get_global_info(char * buf)
+{
+    int i = 0;
+    int dev_num = 0;
+
+    cec_node_info_t * buf_node_addr = (cec_node_info_t *)(buf + (unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online));
+
+    for (i = 0; i < MAX_NUM_OF_DEV; i++)
+    {
+        if (cec_global_info.dev_mask & (1 << i))
+        {
+            memcpy(&(buf_node_addr[dev_num]), &(cec_global_info.cec_node_info[i]), sizeof(cec_node_info_t));
+            dev_num++;
+        }
+    }
+
+    buf[0] = dev_num;
+    buf[1] = cec_global_info.active_log_dev;
+#if 0
+    hdmi_print(INF, CEC "\n");
+    hdmi_print(INF, CEC "%x\n",(unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online));
+    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->dev_number);
+    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->active_log_dev);
+    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->cec_node_info_online[0].hdmi_port);
+    for (i=0; i < (sizeof(cec_node_info_t) * dev_num) + 2; i++)
+    {
+        hdmi_print(INF, CEC "%x,",buf[i]);
+    }
+    hdmi_print(INF, CEC "\n");
+#endif
+    return (sizeof(cec_node_info_t) * dev_num) + (unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online);
+}
+
+void cec_usrcmd_set_lang_config(const char * buf, size_t count)
+{
+    char tmpbuf[128];
+    int i=0;
+
+    while ((buf[i]) && (buf[i] != ',') && (buf[i] != ' '))
+    {
+        tmpbuf[i] = buf[i];
+        i++;
+    }
+
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang = simple_strtoul(tmpbuf, NULL, 16);
+
+}
+void cec_usrcmd_set_config(const char * buf, size_t count)
+{
+    int i = 0;
+    int j = 0;
+    unsigned long value;
+    char param[16] = {0};
+
+    if (count > 32)
+    {
+        hdmi_print(INF, CEC "too many args\n");
+    }
+    for (i = 0; i < count; i++)
+    {
+        if ( (buf[i] >= '0') && (buf[i] <= 'f') )
+        {
+            param[j] = simple_strtoul(&buf[i], NULL, 16);
+            j ++;
+        }
+        while ( buf[i] != ' ' )
+            i ++;
+    }
+    hdmi_print(INF, CEC "cec_func_config entry :0x%x : 0x%x\n",hdmitx_device->cec_func_config, aml_read_reg32(P_AO_DEBUG_REG0));
+    value = aml_read_reg32(P_AO_DEBUG_REG0);
+    aml_set_reg32_bits(P_AO_DEBUG_REG0, param[0], 0, 32);
+    hdmitx_device->cec_func_config = aml_read_reg32(P_AO_DEBUG_REG0);
+    if ((0 == (value & 0x1)) && (1 == (param[0] & 1)))
+    {
+        hdmitx_device->cec_init_ready = 1;
+        hdmitx_device->hpd_state = 1;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
+        cec_gpi_init();
+#endif
+        cec_global_info.cec_flag.cec_init_flag = 1;
+        cec_node_init(hdmitx_device);
+    } else if ((value & 0x01) && !(param[0] & 0x01)) {
+        /* toggle off cec funtion by user */
+        hdmi_print(INF, CEC "user disable cec\n");
+        /* disable irq to stop rx/tx process */
+        cec_keep_reset();
+    }
+    if (!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) ||
+        !hdmitx_device->hpd_state) {
+        return ;
+    }
+    if ((1 == (param[0] & 1)) && ((value & 0x2) != (param[0] & 0x2)))
+    {
+        if (0x2 == (param[0] & 0x2))
+        {
+            cec_active_source_smp();
+        }
+        else
+        {
+        	//cec_inactive_source();
+            cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+        }
+    }
+    if ((0x20 == (param[0] & 0x20)) && (0x0 == (value & 0x20)) )
+    {
+        cec_get_menu_language_smp();
+    }
+    if ((1 == (param[0] & 1)) && ((param[0] & 0x40) != (value & 0x40)))
+    {
+        if (0x40 == (param[0] & 0x40))
+        {
+            hdmi_print(INF, CEC "cec_func_config: cec_system_audio_mode_request_smp");
+            cec_system_audio_mode_request_smp();
+        }
+        else
+        {
+            hdmi_print(INF, CEC "cec_func_config: cec_system_audio_mode_release_smp");
+            cec_system_audio_mode_release_smp();
+        }
+    }
+    hdmi_print(INF, CEC "cec_func_config exit:0x%x : 0x%x\n",hdmitx_device->cec_func_config, aml_read_reg32(P_AO_DEBUG_REG0));
+}
+
+
+void cec_usrcmd_set_dispatch(const char * buf, size_t count)
+{
+    int i = 0;
+    int j = 0;
+    int bool = 0;
+    char param[32] = {0};
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    unsigned int addr;
+    unsigned int value;
+    unsigned bit_set;
+    unsigned time_set;
+#endif
+    unsigned char msg[4] = {0};
+
+    hdmi_print(INF, CEC "cec usrcmd set dispatch start:\n");
+    if (!hdmitx_device->hpd_state)
+    {   //if none HDMI out,no CEC features.
+        hdmi_print(INF, CEC "HPD low!\n");
+        return;
+    }
+
+    if (!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
+    {
+        hdmi_print(INF, CEC "cec function masked!\n");
+        return;
+    }
+
+    if (count > 32)
+    {
+        hdmi_print(INF, CEC "too many args\n");
+    }
+    for (i = 0; i < count; i++)
+    {
+        param[j] = simple_strtoul(&buf[i], NULL, 16);
+        j ++;
+        while ( buf[i] != ' ' )
+            i ++;
+    }
+    param[j]=0;
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    if (strncmp(buf, "settiming", 9) == 0)
+    {
+        bit_set = simple_strtoul(buf+9, NULL, 16);
+        time_set = simple_strtoul(buf+11, NULL, 16);
+        cec_arbit_bit_time_set(bit_set, time_set, 1);
+        return;
+    }
+    else if (strncmp(buf, "getttiming", 9)==0)
+    {
+        cec_arbit_bit_time_read();
+        return;
+    }
+    else if (strncmp(buf, "dumpaocecreg", 12)==0)
+    {
+        dumpaocecreg();
+        return;
+    }
+    else if (strncmp(buf, "waocec", 6)==0)
+    {
+        addr = simple_strtoul(buf+6, NULL, 16);
+        value = simple_strtoul(buf+9, NULL, 16);
+        waocec(addr, value);
+        return;
+    }
+    else if (strncmp(buf, "raocec", 6)==0)
+    {
+        addr = simple_strtoul(buf+6, NULL, 16);
+        raocec(addr);
+        return;
+    }
+#endif
+    switch (param[0])
+    {
+        case GET_CEC_VERSION:   //0 LA
+            cec_usrcmd_get_cec_version(param[1]);
+            break;
+        case GET_DEV_POWER_STATUS:
+            cec_usrcmd_get_device_power_status(param[1]);
+            break;
+        case GET_DEV_VENDOR_ID:
+            cec_usrcmd_get_device_vendor_id(param[1]);
+            break;
+        case GET_OSD_NAME:
+            cec_usrcmd_get_osd_name(param[1]);
+            break;
+        case GET_PHYSICAL_ADDR:
+            cec_usrcmd_get_physical_address(param[1]);
+            break;
+        case SET_STANDBY:       //d LA
+            cec_usrcmd_set_standby(param[1]);
+            break;
+        case SET_IMAGEVIEW_ON:  //e LA
+            cec_usrcmd_set_imageview_on(param[1]);
+            break;
+        case GIVE_DECK_STATUS:
+            cec_usrcmd_get_deck_status(param[1]);
+            break;
+        case SET_DECK_CONTROL_MODE:
+            cec_usrcmd_set_deck_cnt_mode(param[1], param[2]);
+            break;
+        case SET_PLAY_MODE:
+            cec_usrcmd_set_play_mode(param[1], param[2]);
+            break;
+        case GET_SYSTEM_AUDIO_MODE:
+            cec_usrcmd_get_system_audio_mode_status(param[1]);
+            break;
+        case GET_TUNER_DEV_STATUS:
+            cec_usrcmd_get_tuner_device_status(param[1]);
+            break;
+        case GET_AUDIO_STATUS:
+            cec_usrcmd_get_audio_status(param[1]);
+            break;
+        case GET_OSD_STRING:
+            break;
+        case GET_MENU_STATE:
+            cec_usrcmd_get_menu_state(param[1]);
+            break;
+        case SET_MENU_STATE:
+            cec_usrcmd_set_menu_state(param[1], param[2]);
+            break;
+        case SET_MENU_LANGAGE:
+            break;
+        case GET_MENU_LANGUAGE:
+            cec_usrcmd_get_menu_language(param[1]);
+            break;
+        case GET_ACTIVE_SOURCE:     //13
+            cec_usrcmd_get_active_source();
+            break;
+        case SET_ACTIVE_SOURCE:
+            cec_usrcmd_set_active_source();
+            break;
+        case SET_DEACTIVE_SOURCE:
+            cec_usrcmd_set_deactive_source(param[1]);
+            break;
+        case REPORT_PHYSICAL_ADDRESS:    //17
+            cec_usrcmd_set_report_physical_address();
+            break;
+        case SET_TEXT_VIEW_ON:          //18 LA
+            cec_usrcmd_text_view_on(param[1]);
+            break;
+        case POLLING_ONLINE_DEV:    //19 LA
+            cec_polling_online_dev(param[1], &bool);
+            break;
+        case CEC_OC_MENU_STATUS:
+            cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+            break;
+        case CEC_OC_ABORT_MESSAGE:
+            msg[0] = 0x40;
+            msg[1] = CEC_OC_FEATURE_ABORT;
+            msg[2] = 0;
+            msg[3] = CEC_UNRECONIZED_OPCODE;
+            cec_ll_tx(msg, 4);
+            break;
+        case PING_TV:    //0x1a LA : For TV CEC detected.
+            detect_tv_support_cec(param[1]);
+            break;
+        case DEVICE_MENU_CONTROL:    //0x1b
+            cec_usrcmd_device_menu_control(param[1], param[2]);
+            break;
+        default:
+            break;
+    }
+    hdmi_print(INF, CEC "cec usrcmd set dispatch end!\n\n");
+}
+
+/***************************** cec high level code end *****************************/
+
+late_initcall(cec_init);
+module_exit(cec_uninit);
+MODULE_DESCRIPTION("AMLOGIC HDMI TX CEC driver");
+MODULE_LICENSE("GPL");
+//MODULE_LICENSE("Dual BSD/GPL");
+//MODULE_VERSION("1.0.0");
+
+MODULE_PARM_DESC(cec_msg_dbg_en, "\n cec_msg_dbg_en\n");
+module_param(cec_msg_dbg_en, bool, 0664);
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_compliance.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_compliance.c
old mode 100644
new mode 100755
index 0bb69917..0776d237
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_compliance.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_compliance.c
@@ -39,88 +39,131 @@
 #include <mach/clock.h>
 #include <linux/amlogic/vout/vinfo.h>
 #include <linux/amlogic/vout/enc_clk_config.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_compliance.h>
 
-#include "hdmi_info_global.h"
-#include "hdmi_tx_module.h"
-#include "hdmi_tx_compliance.h"
-#include "hdmi_tx_cec.h"
-#include "hdmi_tx_hdcp.h"
-#include "hw/hdmi_tx_reg.h"
+typedef struct {
+    char *ReceiverBrandName;
+    char *ReceiverProductName;
+    unsigned char blk0_chksum;
+}special_tv;
 
-// Note: 
-// set P_HHI_VID_PLL_CNTL as 0x43e, get better clock performance
-// while as 0x21ef, get better clock precision
-// 24 * 62 = 1488
-// 24 / 8 * 495 = 1485
+static special_tv special_N_6144x2_tv_tab[]= {
+    /*SONY KDL-32R300B*/
+    {
+        .ReceiverBrandName="SNY",
+        .ReceiverProductName="SONY",
+        .blk0_chksum=0xf8,
+    },
+    /*TCL L19F3270B*/
+    {
+        .ReceiverBrandName="TCL",
+        .ReceiverProductName="MST6M16",
+        .blk0_chksum=0xa9,
+    },
+    /*Panasonic TH-32A400C*/
+    {
+        .ReceiverBrandName="MEI",
+        .ReceiverProductName="Panasonic-TV",
+        .blk0_chksum=0x28,
+    },
+};
 
-static void hdmitx_get_clk_better_performance(hdmitx_dev_t* hdmitx_device)
+static special_tv samsung_future_tv_tab[]= {
+    /*UA50HU7000JXXZ*/
+    {
+        .ReceiverBrandName="SAM",
+        .ReceiverProductName="SAMSUNG",
+    },
+};
+
+
+/*
+ * # cat /sys/class/amhdmitx/amhdmitx0/edid
+ * Receiver Brand Name: GSM
+ * Receiver Product Name: LG
+ * blk0 chksum: 0xe7
+ *
+ * recoginze_tv()
+ * parameters:
+ *      brand_name: the name of "Receiver Brand Name"
+ *      prod_name: the name of "Receiver Product Name"
+ *      blk0_chksum: the value of blk0 chksum
+ */
+static int recoginze_tv(hdmitx_dev_t* hdev, char *brand_name, char *prod_name, unsigned char blk0_chksum)
 {
-    if((aml_read_reg32(P_HHI_VID_PLL_CNTL) & 0x3fff ) == 0x21ef) {
-        aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0x43e, 0, 15);
-    }
+    if ((strncmp(hdev->RXCap.ReceiverBrandName, brand_name, strlen(brand_name)) == 0) && \
+        (strncmp(hdev->RXCap.ReceiverProductName, prod_name, strlen(prod_name)) == 0) && \
+        (hdev->RXCap.blk0_chksum == blk0_chksum))
+        return 1;
+    else
+        return 0;
 }
 
-static void hdmitx_reset_audio_n(hdmitx_dev_t* hdmitx_device)
+static int is_special_tv = 0;
+int hdmitx_is_special_tv(void)
 {
-    static int rewrite_flag = 0;
-    unsigned int audio_N_para = 6144;
-    switch(hdmitx_device->cur_VIC) {
-    case HDMI_480p60:
-    case HDMI_480p60_16x9:
-    case HDMI_576p50:
-    case HDMI_576p50_16x9:
-    case HDMI_480i60:
-    case HDMI_480i60_16x9:
-    case HDMI_576i50:
-    case HDMI_576i50_16x9:
-        switch(hdmitx_device->cur_audio_param.sample_rate){
-        case FS_44K1:
-            audio_N_para = 6272 * 3;
-            rewrite_flag = 1;
-            break;
-        case FS_48K:
-            audio_N_para = 6144 * 3;
-            rewrite_flag = 1;
+    if (is_special_tv)
+        return 1;
+    else
+        return 0;
+}
+
+static int is_support_4k_60(rx_cap_t *pRXCap)
+{
+    int i;
+
+    for (i = 0 ; i < pRXCap->VIC_count; i++) {
+        switch (pRXCap->VIC[i]) {
+        case HDMI_3840x2160p60_16x9:
+        case HDMI_3840x2160p50_16x9:
+        case HDMI_4096x2160p50_256x135:
+        case HDMI_4096x2160p60_256x135:
+            printk("support 4k 60/50\n");
+            return 1;
             break;
         default:
             break;
         }
-        break;
-    default:
-        break;
-    }
-    if(rewrite_flag) {
-        hdmi_wr_reg(TX_SYS1_ACR_N_0, (audio_N_para&0xff)); // N[7:0]
-        hdmi_wr_reg(TX_SYS1_ACR_N_1, (audio_N_para>>8)&0xff); // N[15:8]
-        hdmi_wr_reg(TX_SYS1_ACR_N_2, hdmi_rd_reg(TX_SYS1_ACR_N_2) | ((audio_N_para>>16)&0xf)); // N[19:16]
     }
+    return 0;
 }
 
-// a sony special tv edid hash value: "acc0df36f1e523a2e02cfd54514732513e3a4351"
-// got the first 4 bytes
-static unsigned int SONY_EDID_HASH = 0xacc0df36;
-static int edid_hash_compare(unsigned char *dat, unsigned int SPECIAL)
+/*
+ * hdmitx_special_handler_video()
+ */
+void hdmitx_special_handler_video(hdmitx_dev_t* hdev)
 {
-    int ret = 0;
-
-    if((dat[0] == ((SPECIAL >> 24)&0xff)) && (dat[1] == ((SPECIAL >> 16)&0xff)) && (dat[2] == ((SPECIAL >> 8)&0xff)) && (dat[3] == (SPECIAL & 0xff)))
-        ret = 1;
-    return ret;
+    int i = 0;
+    for (i = 0; i < ARRAY_SIZE(samsung_future_tv_tab); i++) {
+        if ((strncmp(hdev->RXCap.ReceiverBrandName, samsung_future_tv_tab[i].ReceiverBrandName, strlen(samsung_future_tv_tab[i].ReceiverBrandName)) == 0)
+            && (strncmp(hdev->RXCap.ReceiverProductName, samsung_future_tv_tab[i].ReceiverProductName, strlen(samsung_future_tv_tab[i].ReceiverProductName)) == 0)
+            && (is_support_4k_60(&hdev->RXCap))) {
+            is_special_tv = 1;
+            return;
+        }
+    }
+    is_special_tv = 0;
 }
 
-void hdmitx_special_handler_audio(hdmitx_dev_t* hdmitx_device)
+/*
+ * hdmitx_special_handler_audio()
+ */
+void hdmitx_special_handler_audio(hdmitx_dev_t* hdev)
 {
-    if(edid_hash_compare(&hdmitx_device->EDID_hash[0], SONY_EDID_HASH)) {
-        hdmitx_reset_audio_n(hdmitx_device);
+    int i = 0;
+    for(i = 0; i < ARRAY_SIZE(special_N_6144x2_tv_tab); i++) {
+        if (recoginze_tv(hdev, special_N_6144x2_tv_tab[i].ReceiverBrandName, special_N_6144x2_tv_tab[i].ReceiverProductName, special_N_6144x2_tv_tab[i].blk0_chksum))
+			hdev->HWOp.CntlMisc(hdev, MISC_COMP_AUDIO, COMP_AUDIO_SET_N_6144x2);
     }
-}
 
-void hdmitx_special_handler_video(hdmitx_dev_t* hdmitx_device)
-{
-    if(strncmp(hdmitx_device->RXCap.ReceiverBrandName, HDMI_RX_VIEWSONIC, strlen(HDMI_RX_VIEWSONIC)) == 0) {
-        if(strncmp(hdmitx_device->RXCap.ReceiverProductName, HDMI_RX_VIEWSONIC_MODEL, strlen(HDMI_RX_VIEWSONIC_MODEL)) == 0) {
-            hdmitx_get_clk_better_performance(hdmitx_device);
-        }
+#if 0
+	// TODO
+
+	if (recoginze_tv(hdev, "SAM", "SAMSUNG", 0x22)) {
+        hdev->HWOp.CntlMisc(hdev, MISC_COMP_AUDIO, COMP_AUDIO_SET_N_6144x2);
+    }
+    if (recoginze_tv(hdev, "GSM", "LG", 0xE7)) {
+        hdev->HWOp.CntlMisc(hdev, MISC_COMP_AUDIO, COMP_AUDIO_SET_N_6144x3);
     }
+#endif
 }
-
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
old mode 100644
new mode 100755
index eb508cd0..a2d3c5b9
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_edid.c
@@ -195,7 +195,7 @@ void Edid_DecodeStandardTiming(HDMI_TX_INFO_t * info, unsigned char * Data, unsi
      }
 }
 
-static unsigned char Edid_TimingDescriptors[216]=    //12x18
+static unsigned char Edid_TimingDescriptors[204]=    //12x17
  {
  //pixel clk --hsync active & blank  -- vsync  active & blank-- hsync/vsync off & wid -- Image size
     0x8C,0x0A,  0xA0,0x14,0x51,     0xF0,0x16,0x00,     0x26,0x7c,0x43,0x00,    //0x13,0x8e,   //480i(4:3)
@@ -208,7 +208,6 @@ static unsigned char Edid_TimingDescriptors[216]=    //12x18
      0x8C,0x0A,  0xD0,0x90,0x20,     0x40,0x31,0x20,     0x0c,0x40,0x55,0x00,   // 0xc4,0x8e,  //576p  (16:9)
     0x01,0x1D,    0x00,0x72,0x51,     0xD0,0x1E,0x20,     0x6e,0x28,0x55,0x00,  //  0xc4,0x8e,  //720p60(16:9)
     0x01,0x1D,    0x00,0xBC,0x52,     0xD0,0x1E,0x20,     0xb8,0x28,0x55,0x40,  //  0xc4,0x8e,  //720p50 (16:9)
-    0x01,0x1D,    0x00,0xBC,0x52,     0xD0,0x1E,0x20,     0xb8,0x28,0x55,0x40,  //  0xc4,0x8e,  //1280x1024 (4:3)
     0x01,0x1D,    0x80,0x18,0x71,     0x1C,0x16,0x20,     0x58,0x2c,0x25,0x00,  //  0xc4,0x8e,  //1080i60 (16:9)
     0x01,0x1D,    0x80,0xD0,0x72,     0x1C,0x16,0x20,     0x10,0x2c,0x25,0x80,  //  0xc4,0x8e,   //1080i50 (16:9)
     0x02,0x3a,    0x80,0x18,0x71,     0x38,0x2d,0x40,     0x58,0x2c,0x45,0x00,  //  0xc4,0x8e,  //1080p60 (16:9)
@@ -976,7 +975,7 @@ static int hdmitx_edid_block_parse(hdmitx_dev_t* hdmitx_device, unsigned char *B
         tag = BlockBuf[offset] >> 5 ;
         count = BlockBuf[offset] & 0x1f ;
         switch( tag ){
-            case HDMI_EDID_BLOCK_TYPE_AUDIO: 
+            case HDMI_EDID_BLOCK_TYPE_AUDIO:
                 pRXCap->AUD_count = count/3 ;
                 offset++ ;
                 for( i = 0 ; i < pRXCap->AUD_count ; i++)
@@ -988,7 +987,7 @@ static int hdmitx_edid_block_parse(hdmitx_dev_t* hdmitx_device, unsigned char *B
                 }
                 offset += count;
                 break ;
-            
+
             case HDMI_EDID_BLOCK_TYPE_VIDEO:
                 offset ++;
                 for( i = 0 ; i < count ; i++)
@@ -1003,8 +1002,8 @@ static int hdmitx_edid_block_parse(hdmitx_dev_t* hdmitx_device, unsigned char *B
                 }
                 offset += count;
                 break ;
-            
-            case HDMI_EDID_BLOCK_TYPE_VENDER: 
+
+            case HDMI_EDID_BLOCK_TYPE_VENDER:
                 offset ++ ;
                 pRXCap->IEEEOUI = (unsigned long)BlockBuf[offset+2] ;
                 pRXCap->IEEEOUI <<= 8 ;
@@ -1040,19 +1039,19 @@ static int hdmitx_edid_block_parse(hdmitx_dev_t* hdmitx_device, unsigned char *B
                 }
                 offset += count ; // ignore the remaind.
                 break ;
-            
-            case HDMI_EDID_BLOCK_TYPE_SPEAKER: 
+
+            case HDMI_EDID_BLOCK_TYPE_SPEAKER:
                 offset ++ ;
                 pRXCap->RxSpeakerAllocation = BlockBuf[offset] ;
                 offset += count;
                 break ;
 
-            case HDMI_EDID_BLOCK_TYPE_VESA: 
+            case HDMI_EDID_BLOCK_TYPE_VESA:
                 offset ++;
                 offset += count;
                 break ;
 
-            case HDMI_EDID_BLOCK_TYPE_EXTENDED_TAG: 
+            case HDMI_EDID_BLOCK_TYPE_EXTENDED_TAG:
                 offset ++;
                 offset += count;
                 break ;
@@ -1091,7 +1090,7 @@ static void hdmitx_edid_set_default_vic(hdmitx_dev_t* hdmitx_device)
 #if 0
 #define PRINT_HASH(hash) {printk("%s:%d ",__func__,__LINE__);int __i;for(__i=0;__i<20;__i++)printk("%02x,",hash[__i]);printk("\n");}
 #else
-#define PRINT_HASH(hash) 
+#define PRINT_HASH(hash)
 #endif
 
 static int edid_hash_calc(unsigned char *hash, const char *data, unsigned int len)
@@ -1131,15 +1130,95 @@ static int hdmitx_edid_search_IEEEOUI(char *buf)
     return 0;
 }
 
+// check EDID strictly
+static int edid_check_valid(unsigned char *buf)
+{
+    unsigned int chksum = 0;
+    unsigned int i = 0;
+
+    // check block 0 first 8 bytes
+    if((buf[0] != 0) && (buf[7] != 0))
+        return 0;
+    for(i = 1; i < 7; i ++) {
+        if(buf[i] != 0xff)
+            return 0;
+    }
+
+    // check block 0 checksum
+    for(chksum = 0, i = 0; i < 0x80; i++) {
+        chksum += buf[i];
+    }
+    if((chksum & 0xff) != 0)
+        return 0;
+
+    // check Extension flag at block 0
+    if(buf[0x7e] == 0)
+        return 0;
+
+    // check block 1 extension tag
+    if(buf[0x80] != 0x2)
+        return 0;
+
+    // check block 1 checksum
+    for(chksum = 0, i = 0x80; i < 0x100; i++) {
+        chksum += buf[i];
+    }
+    if((chksum & 0xff) != 0)
+        return 0;
+
+    return 1;
+}
+
+static int check_dvi_hdmi_edid_valid(unsigned char *buf)
+{
+    unsigned int chksum = 0;
+    unsigned int i = 0;
+
+    // check block 0 first 8 bytes
+    if ((buf[0] != 0) && (buf[7] != 0))
+        return 0;
+    for (i = 1; i < 7; i ++) {
+        if (buf[i] != 0xff)
+            return 0;
+    }
+
+    // check block 0 checksum
+    for (chksum = 0, i = 0; i < 0x80; i++) {
+        chksum += buf[i];
+    }
+    if ((chksum & 0xff) != 0)
+        return 0;
+
+    if (buf[0x7e] == 0)// check Extension flag at block 0
+        return 1;
+    else if (buf[0x80] != 0x2)// check block 1 extension tag
+        return 0;
+
+    // check block 1 checksum
+    for (chksum = 0, i = 0x80; i < 0x100; i++) {
+        chksum += buf[i];
+    }
+    if ((chksum & 0xff) != 0)
+        return 0;
+
+    return 1;
+}
+
 int hdmitx_edid_parse(hdmitx_dev_t* hdmitx_device)
 {
     unsigned char CheckSum ;
     unsigned char zero_numbers;
     unsigned char BlockCount ;
-    unsigned char* EDID_buf = hdmitx_device->EDID_buf;
+    unsigned char* EDID_buf ;
     int i, j, ret_val ;
     int idx[4];
     rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+    if (check_dvi_hdmi_edid_valid(hdmitx_device->EDID_buf)) {
+        EDID_buf = hdmitx_device->EDID_buf;
+    }
+    else {
+        EDID_buf = hdmitx_device->EDID_buf1;
+    }
     hdmi_print(0, "EDID Parser:\n");
 
     // Calculate the EDID hash for special use
@@ -1156,14 +1235,14 @@ int hdmitx_edid_parse(hdmitx_dev_t* hdmitx_device)
         CheckSum += EDID_buf[i] ;
         CheckSum &= 0xFF ;
     }
-    
+
     if( CheckSum != 0 )
     {
         hdmitx_device->hdmi_info.output_state = CABLE_PLUGIN_DVI_OUT;
         hdmi_print(0, "PLUGIN_DVI_OUT\n");
 //        return -1 ;
     }
-    
+
     Edid_ReceiverBrandNameParse(&hdmitx_device->RXCap, &EDID_buf[8]);
 
     idx[0] = EDID_DETAILED_TIMING_DES_BLOCK0_POS;
@@ -1177,7 +1256,8 @@ int hdmitx_edid_parse(hdmitx_dev_t* hdmitx_device)
     Edid_DecodeStandardTiming(&hdmitx_device->hdmi_info, &EDID_buf[26], 8);
     Edid_ParseCEADetailedTimingDescriptors(&hdmitx_device->hdmi_info, 4, 0x36, &EDID_buf[0]);
 
-    BlockCount = EDID_buf[0x7E] ;
+    BlockCount = EDID_buf[0x7E];
+    hdmitx_device->RXCap.blk0_chksum = EDID_buf[0x7F];
 
     if( BlockCount == 0 ){
         hdmitx_device->hdmi_info.output_state = CABLE_PLUGIN_DVI_OUT;
@@ -1267,13 +1347,23 @@ int hdmitx_edid_parse(hdmitx_dev_t* hdmitx_device)
 
     if((pRXCap->IEEEOUI != 0x0c03) || (pRXCap->IEEEOUI == 0x0)|| (pRXCap->VIC_count == 0)){
         hdmitx_edid_set_default_vic(hdmitx_device);
-    }    
+    }
+
+    // strictly DVI device judgement
+    // valid EDID & no audio tag & no IEEEOUI
+    if( edid_check_valid(&EDID_buf[0]) && (pRXCap->AUD_count == 0)
+        && !hdmitx_edid_search_IEEEOUI(&EDID_buf[128]) ) {
+        pRXCap->IEEEOUI = 0x0;
+        printk("hdmitx: edid: sink is DVI device\n");
+    } else {
+        pRXCap->IEEEOUI = 0x0c03;
+    }
 
-#if 1    
+#if 1
     i=hdmitx_edid_dump(hdmitx_device, (char*)(hdmitx_device->tmp_buf), HDMI_TMP_BUF_SIZE);
     hdmitx_device->tmp_buf[i]=0;
     hdmi_print(0,"\n");
-#endif    
+#endif
     return 0;
 
 }
@@ -1285,8 +1375,6 @@ typedef struct{
 
 static dispmode_vic_t dispmode_VIC_tab[]=
 {
-    {"480x320p60hz", HDMI_480x320p60hz},
-    {"480x272p60hz", HDMI_480x272p60hz},
     {"480i_4_3",  HDMI_480i60},
     {"480i_rpt",  HDMI_480i60_16x9_rpt},
     {"480i",      HDMI_480i60_16x9},
@@ -1294,7 +1382,7 @@ static dispmode_vic_t dispmode_VIC_tab[]=
     {"480p_rpt",  HDMI_480p60_16x9_rpt},
     {"480p",      HDMI_480p60_16x9},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    {"480p59hz",  HDMI_480p60_16x9},
+	{"480p59hz",  HDMI_480p60_16x9},
 #endif
     {"576i_4_3",  HDMI_576i50},
     {"576i_rpt",  HDMI_576i50_16x9_rpt},
@@ -1305,22 +1393,8 @@ static dispmode_vic_t dispmode_VIC_tab[]=
     {"720p50hz",  HDMI_720p50},
     {"720p",      HDMI_720p60},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    {"720p59hz",  HDMI_720p60},
+	{"720p59hz",  HDMI_720p60},
 #endif
-    {"800p",	  HDMI_800p},
-    {"800x480p60hz", HDMI_800x480p60hz},
-    {"480x800p60hz", HDMI_480x800p60hz},
-    {"1366x768p60hz", HDMI_1366x768p60hz},
-    {"1600x900p60hz", HDMI_1600x900p60hz},
-    {"800x600p60hz", HDMI_800x600p60hz},
-    {"1024x600p60hz", HDMI_1024x600p60hz},
-    {"1024x768p60hz", HDMI_1024x768p60hz},
-    {"1360x768p60hz", HDMI_1360x768p60hz},
-    {"1440x900p60hz", HDMI_1440x900p60hz},
-    {"1680x1050p60hz", HDMI_1680x1050p60hz},
-    {"vga",       HDMI_640x480p60},
-    {"sxga",      HDMI_1280x1024},
-    {"1920x1200", HDMI_1920x1200},
     {"1080i50hz", HDMI_1080i50},
     {"1080i",     HDMI_1080i60},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
@@ -1330,22 +1404,24 @@ static dispmode_vic_t dispmode_VIC_tab[]=
     {"1080p30hz", HDMI_1080p30},
     {"1080p24hz", HDMI_1080p24},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    {"1080p23hz", HDMI_1080p24},
+	{"1080p23hz", HDMI_1080p24},
 #endif
     {"1080p",     HDMI_1080p60},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    {"1080p59hz", HDMI_1080p60},
+	{"1080p59hz", HDMI_1080p60},
 #endif
+#if MESON_CPU_TYPE > MESON_CPU_TYPE_MESON6
     {"4k2k30hz",  HDMI_4k2k_30},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    {"4k2k29hz",  HDMI_4k2k_30},
+	{"4k2k29hz",  HDMI_4k2k_30},
 #endif
     {"4k2k25hz",  HDMI_4k2k_25},
     {"4k2k24hz",  HDMI_4k2k_24},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    {"4k2k23hz",  HDMI_4k2k_24},
+	{"4k2k23hz",  HDMI_4k2k_24},
 #endif
     {"4k2ksmpte", HDMI_4k2k_smpte_24},
+#endif // MESON_CPU_TYPE > MESON_CPU_TYPE_MESON6
 };
 
 int hdmitx_edid_VIC_support(HDMI_Video_Codes_t vic)
@@ -1416,23 +1492,23 @@ HDMI_Video_Codes_t hdmitx_edid_get_VIC(hdmitx_dev_t* hdmitx_device, const char*
         }
     }
     return vic;
-}    
+}
 
 const char* hdmitx_edid_get_native_VIC(hdmitx_dev_t* hdmitx_device)
 {
     rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
 
     return hdmitx_edid_vic_tab_map_string(pRXCap->native_VIC);
-}    
+}
 
 //Clear HDMI Hardware Module EDID RAM and EDID Buffer
 void hdmitx_edid_ram_buffer_clear(hdmitx_dev_t* hdmitx_device)
 {
     unsigned int i = 0;
-    
+
     //Clear HDMI Hardware Module EDID RAM
     hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_EDID_CLEAR_RAM, 0);
-    
+
     //Clear EDID Buffer
     for(i = 0; i < EDID_MAX_BLOCK*128; i++) {
         hdmitx_device->EDID_buf[i] = 0;
@@ -1569,40 +1645,40 @@ int hdmitx_edid_dump(hdmitx_dev_t* hdmitx_device, char* buffer, int buffer_len)
     int i,pos=0;
     rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
 
-    pos+=snprintf(buffer+pos, buffer_len-pos, "Receiver Brand Name: %s\r\n", pRXCap->ReceiverBrandName);
-    pos+=snprintf(buffer+pos, buffer_len-pos, "Receiver Product Name: %s\r\n", pRXCap->ReceiverProductName);
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Receiver Brand Name: %s\n", pRXCap->ReceiverBrandName);
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Receiver Product Name: %s\n", pRXCap->ReceiverProductName);
 
-    pos+=snprintf(buffer+pos, buffer_len-pos, "EDID block number: 0x%x\r\n",hdmitx_device->EDID_buf[0x7e]);
+    pos+=snprintf(buffer+pos, buffer_len-pos, "EDID block number: 0x%x\n",hdmitx_device->EDID_buf[0x7e]);
+    pos+=snprintf(buffer+pos, buffer_len-pos, "blk0 chksum: 0x%02x\n", pRXCap->blk0_chksum);
 
-    pos+=snprintf(buffer+pos, buffer_len-pos, "Source Physical Address[a.b.c.d]: %x.%x.%x.%x\r\n",
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Source Physical Address[a.b.c.d]: %x.%x.%x.%x\n",
         hdmitx_device->hdmi_info.vsdb_phy_addr.a, hdmitx_device->hdmi_info.vsdb_phy_addr.b, hdmitx_device->hdmi_info.vsdb_phy_addr.c, hdmitx_device->hdmi_info.vsdb_phy_addr.d);
 
-    pos+=snprintf(buffer+pos, buffer_len-pos, "native Mode %x, VIC (native %d):\r\n",
+    pos+=snprintf(buffer+pos, buffer_len-pos, "native Mode %x, VIC (native %d):\n",
         pRXCap->native_Mode, pRXCap->native_VIC);
 
-    pos+=snprintf(buffer+pos, buffer_len-pos, "ColorDeepSupport %x, MaxTMDSClock %d\r\n",
-        pRXCap->ColorDeepSupport, pRXCap->Max_TMDS_Clock); 
+    pos+=snprintf(buffer+pos, buffer_len-pos, "ColorDeepSupport %x, MaxTMDSClock %d\n",
+        pRXCap->ColorDeepSupport, pRXCap->Max_TMDS_Clock);
 
     for( i = 0 ; i < pRXCap->VIC_count ; i++ )
     {
         pos+=snprintf(buffer+pos, buffer_len-pos,"%d ", pRXCap->VIC[i]);
     }
-    pos+=snprintf(buffer+pos, buffer_len-pos,"\r\n");
-    pos+=snprintf(buffer+pos, buffer_len-pos, "Audio {format, channel, freq, cce}\r\n");
+    pos+=snprintf(buffer+pos, buffer_len-pos,"\n");
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Audio {format, channel, freq, cce}\n");
     for(i = 0; i< pRXCap->AUD_count; i++) {
-        pos+=snprintf(buffer+pos, buffer_len-pos, "{%d, %d, %x, %x}\r\n", pRXCap->RxAudioCap[i].audio_format_code,
+        pos+=snprintf(buffer+pos, buffer_len-pos, "{%d, %d, %x, %x}\n", pRXCap->RxAudioCap[i].audio_format_code,
             pRXCap->RxAudioCap[i].channel_num_max, pRXCap->RxAudioCap[i].freq_cc, pRXCap->RxAudioCap[i].cc3);
     }
-    pos+=snprintf(buffer+pos,buffer_len-pos,"Speaker Allocation: %x\r\n", pRXCap->RxSpeakerAllocation);
-    pos+=snprintf(buffer+pos,buffer_len-pos,"Vendor: %x\r\n", pRXCap->IEEEOUI);
+    pos+=snprintf(buffer+pos,buffer_len-pos,"Speaker Allocation: %x\n", pRXCap->RxSpeakerAllocation);
+    pos+=snprintf(buffer+pos,buffer_len-pos,"Vendor: %x\n", pRXCap->IEEEOUI);
 
-    pos+=snprintf(buffer+pos,buffer_len-pos,"Rx 3D Format Support List:\r\n{VIC FramePacking TopBottom SidebySide}\r\n");
+    pos+=snprintf(buffer+pos,buffer_len-pos,"Rx 3D Format Support List:\n{VIC FramePacking TopBottom SidebySide}\n");
     for(i = 0 ; i < pRXCap->VIC_count; i++){
-        pos+=snprintf(buffer+pos,buffer_len-pos,"{ %d\t%d\t%d\t%d }\n", pRXCap->VIC[i], 
+        pos+=snprintf(buffer+pos,buffer_len-pos,"{ %d\t%d\t%d\t%d }\n", pRXCap->VIC[i],
                                                                    pRXCap->support_3d_format[pRXCap->VIC[i]].frame_packing,
                                                                    pRXCap->support_3d_format[pRXCap->VIC[i]].top_and_bottom,
                                                                    pRXCap->support_3d_format[pRXCap->VIC[i]].side_by_side);
     }
-    return pos;        
-}    
-
+    return pos;
+}
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.c
old mode 100644
new mode 100755
index 96234238..42f5b242
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.c
@@ -1,165 +1,165 @@
-#include <linux/version.h>
-#include <linux/module.h>
-#include <linux/irq.h>
-#include <linux/types.h>
-#include <linux/input.h>
-#include <linux/kernel.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/interrupt.h>
-#include <linux/fs.h>
-#include <linux/init.h>
-#include <linux/device.h>
-#include <linux/mm.h>
-#include <linux/major.h>
-#include <linux/platform_device.h>
-#include <linux/mutex.h>
-#include <linux/cdev.h>
-#include <asm/irq.h>
-#include <asm/io.h>
-#include <linux/module.h>
-#include <linux/kernel.h>
-#include <linux/slab.h>
-#include <linux/list.h>
-#include <linux/spinlock.h>
-#include <linux/spinlock_types.h>
-#include <linux/switch.h>
-#include <asm/uaccess.h>
-#include <mach/am_regs.h>
-#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
-#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
-#include <mach/hdmi_tx_reg.h>
-#include "hdmi_tx_hdcp.h"
-/*
-    hdmi_tx_hdcp.c
-    version 1.1
-*/
-
-static struct switch_dev hdcp_dev = {  // android ics switch device
-       .name = "hdcp",
-};
-
-// For most cases, we don't use HDCP
-// If using HDCP, need add follow command in boot/init.rc and recovery/boot/init.rc
-// write /sys/module/hdmitx/parameters/hdmi_output_force 0
-static int hdmi_output_force = 1;
-static int hdmi_authenticated = -1;
-static int hdmi_hdcp_process = 1;   // default hdcp is on, if aksv is 0, then disable
-
-// Notic: the HDCP key setting has been moved to uboot
-// On MBX project, it is too late for HDCP get from 
-// other devices
-
-/* verify ksv, 20 ones and 20 zeroes*/
-int hdcp_ksv_valid(unsigned char * dat)
-{
-    int i, j, one_num = 0;
-    for(i = 0; i < 5; i++){
-        for(j=0;j<8;j++) {
-            if((dat[i]>>j)&0x1) {
-                one_num++;
-            }
-        }
-    }
-    if(one_num == 0)
-        hdmi_print(INF, HDCP "no HDCP key available\n");
-    return (one_num == 20);
-}
-
-static struct timer_list hdcp_monitor_timer;
-static void hdcp_monitor_func(unsigned long arg)
-{
-    //static int hdcp_auth_flag = 0;
-    hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t* )hdcp_monitor_timer.data;
-    if((hdmitx_device->HWOp.Cntl) && (hdmitx_device->log & (HDMI_LOG_HDCP))){
-        hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_MONITOR, 1);
-    }
-
-    mod_timer(&hdcp_monitor_timer, jiffies + 2 * HZ);
-}
-
-static int hdmitx_hdcp_task(void *data)
-{
-    static int err_cnt = 0;
-    static int time_cnt = 0;
-    hdmitx_dev_t *hdmitx_device = (hdmitx_dev_t*)data;
-
-    init_timer(&hdcp_monitor_timer);
-    hdcp_monitor_timer.data = (ulong) data;
-    hdcp_monitor_timer.function = hdcp_monitor_func;
-    hdcp_monitor_timer.expires = jiffies + HZ;
-    add_timer(&hdcp_monitor_timer);
-
-    while(hdmitx_device->hpd_event != 0xff) {
-        if((hdmitx_device->output_blank_flag == 1) && (hdmitx_device->hpd_state == 1) && (hdmitx_device->cur_VIC != HDMI_Unkown)) {
-            err_cnt = 0;
-            time_cnt = 1;
-            hdmitx_device->output_blank_flag = 0;
-#ifdef CONFIG_AML_HDMI_TX_HDCP
-            hdmi_print(INF, HDCP "start hdcp\n");
-            hdmitx_device->HWOp.CntlDDC(hdmitx_device, AVMUTE_OFF, 0);
-            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_RESET_EDID, 0);
-            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_EDID_READ_DATA, 0);
-            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_RESET_HDCP, 0);
-            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_HDCP_OP, HDCP_ON);
-            msleep(100);
-            while((hdmitx_device->hpd_state == 1) && (hdmitx_device->cur_VIC != HDMI_Unkown)) {
-                hdmi_authenticated = hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_HDCP_GET_AUTH, 0);
-                switch_set_state(&hdcp_dev, hdmi_authenticated);
-                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_VIDEO_BLANK_OP, hdmi_authenticated ? VIDEO_UNBLANK: VIDEO_BLANK);
-                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_AUDIO_MUTE_OP, hdmi_authenticated ? AUDIO_UNMUTE : AUDIO_MUTE);
-                if( !hdmi_authenticated ) {
-                    err_cnt ++;
-                    if(err_cnt & (3 << time_cnt)) {
-                        time_cnt ++;
-                        hdmi_print(ERR, HDCP "authenticated failed\n");
-                    }
-                }
-                msleep(20);
-                if(hdmitx_device->output_blank_flag == 1)
-                    break;
-            }
-#else
-            hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
-            hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_UNMUTE);
-            hdmitx_device->audio_step = 1;
-#endif
-        }
-        msleep_interruptible(100);
-    }
-
-    return 0;
-}
-
-static int __init hdmitx_hdcp_init(void)
-{
-    hdmitx_dev_t *hdmitx_device = get_hdmitx_device();
-
-    switch_dev_register(&hdcp_dev);
-
-    hdmitx_device->task_hdcp = kthread_run(hdmitx_hdcp_task, (void*)hdmitx_device, "kthread_hdcp");
-
-    return 0;
-}
-
-static void __exit hdmitx_hdcp_exit(void)
-{
-    switch_dev_unregister(&hdcp_dev);
-}
-
-
-MODULE_PARM_DESC(hdmi_authenticated, "\n hdmi_authenticated \n");
-module_param(hdmi_authenticated, int, S_IRUGO);
-
-MODULE_PARM_DESC(hdmi_hdcp_process, "\n hdmi_hdcp_process \n");
-module_param(hdmi_hdcp_process, int, 0664);
-
-MODULE_PARM_DESC(hdmi_output_force, "\n hdmi_output_force \n");
-module_param(hdmi_output_force, int, 0664);
-
-
-module_init(hdmitx_hdcp_init);
-//device_initcall_sync(hdmitx_hdcp_init);
-module_exit(hdmitx_hdcp_exit);
-MODULE_DESCRIPTION("AMLOGIC HDMI TX HDCP driver");
-MODULE_LICENSE("GPL");
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <linux/switch.h>
+#include <asm/uaccess.h>
+#include <mach/am_regs.h>
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <mach/hdmi_tx_reg.h>
+#include "hdmi_tx_hdcp.h"
+/*
+    hdmi_tx_hdcp.c
+    version 1.1
+*/
+
+static struct switch_dev hdcp_dev = {  // android ics switch device
+       .name = "hdcp",
+};
+
+// For most cases, we don't use HDCP
+// If using HDCP, need add follow command in boot/init.rc and recovery/boot/init.rc
+// write /sys/module/hdmitx/parameters/hdmi_output_force 0
+static int hdmi_output_force = 1;
+static int hdmi_authenticated = -1;
+static int hdmi_hdcp_process = 1;   // default hdcp is on, if aksv is 0, then disable
+
+// Notic: the HDCP key setting has been moved to uboot
+// On MBX project, it is too late for HDCP get from
+// other devices
+
+/* verify ksv, 20 ones and 20 zeroes*/
+int hdcp_ksv_valid(unsigned char * dat)
+{
+    int i, j, one_num = 0;
+    for(i = 0; i < 5; i++){
+        for(j=0;j<8;j++) {
+            if((dat[i]>>j)&0x1) {
+                one_num++;
+            }
+        }
+    }
+    if(one_num == 0)
+        hdmi_print(INF, HDCP "no HDCP key available\n");
+    return (one_num == 20);
+}
+
+static struct timer_list hdcp_monitor_timer;
+static void hdcp_monitor_func(unsigned long arg)
+{
+    //static int hdcp_auth_flag = 0;
+    hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t* )hdcp_monitor_timer.data;
+    if((hdmitx_device->HWOp.Cntl) && (hdmitx_device->log & (HDMI_LOG_HDCP))){
+        hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_MONITOR, 1);
+    }
+
+    mod_timer(&hdcp_monitor_timer, jiffies + 2 * HZ);
+}
+
+static int hdmitx_hdcp_task(void *data)
+{
+    static int err_cnt = 0;
+    static int time_cnt = 0;
+    hdmitx_dev_t *hdmitx_device = (hdmitx_dev_t*)data;
+
+    init_timer(&hdcp_monitor_timer);
+    hdcp_monitor_timer.data = (ulong) data;
+    hdcp_monitor_timer.function = hdcp_monitor_func;
+    hdcp_monitor_timer.expires = jiffies + HZ;
+    add_timer(&hdcp_monitor_timer);
+
+    while(hdmitx_device->hpd_event != 0xff) {
+        if((hdmitx_device->output_blank_flag == 1) && (hdmitx_device->hpd_state == 1) && (hdmitx_device->cur_VIC != HDMI_Unkown)) {
+            err_cnt = 0;
+            time_cnt = 1;
+            hdmitx_device->output_blank_flag = 0;
+#ifdef CONFIG_AML_HDMI_TX_HDCP
+            hdmi_print(INF, HDCP "start hdcp\n");
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, AVMUTE_OFF, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_RESET_EDID, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_EDID_READ_DATA, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_RESET_HDCP, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_HDCP_OP, HDCP_ON);
+            msleep(100);
+            while((hdmitx_device->hpd_state == 1) && (hdmitx_device->cur_VIC != HDMI_Unkown)) {
+                hdmi_authenticated = hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_HDCP_GET_AUTH, 0);
+                switch_set_state(&hdcp_dev, hdmi_authenticated);
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_VIDEO_BLANK_OP, hdmi_authenticated ? VIDEO_UNBLANK: VIDEO_BLANK);
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_AUDIO_MUTE_OP, hdmi_authenticated ? AUDIO_UNMUTE : AUDIO_MUTE);
+                if( !hdmi_authenticated ) {
+                    err_cnt ++;
+                    if(err_cnt & (3 << time_cnt)) {
+                        time_cnt ++;
+                        hdmi_print(ERR, HDCP "authenticated failed\n");
+                    }
+                }
+                msleep(20);
+                if(hdmitx_device->output_blank_flag == 1)
+                    break;
+            }
+#else
+            hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+            hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_UNMUTE);
+            hdmitx_device->audio_step = 1;
+#endif
+        }
+        msleep_interruptible(100);
+    }
+
+    return 0;
+}
+
+static int __init hdmitx_hdcp_init(void)
+{
+    hdmitx_dev_t *hdmitx_device = get_hdmitx_device();
+
+    switch_dev_register(&hdcp_dev);
+
+    hdmitx_device->task_hdcp = kthread_run(hdmitx_hdcp_task, (void*)hdmitx_device, "kthread_hdcp");
+
+    return 0;
+}
+
+static void __exit hdmitx_hdcp_exit(void)
+{
+    switch_dev_unregister(&hdcp_dev);
+}
+
+
+MODULE_PARM_DESC(hdmi_authenticated, "\n hdmi_authenticated \n");
+module_param(hdmi_authenticated, int, S_IRUGO);
+
+MODULE_PARM_DESC(hdmi_hdcp_process, "\n hdmi_hdcp_process \n");
+module_param(hdmi_hdcp_process, int, 0664);
+
+MODULE_PARM_DESC(hdmi_output_force, "\n hdmi_output_force \n");
+module_param(hdmi_output_force, int, 0664);
+
+
+module_init(hdmitx_hdcp_init);
+//device_initcall_sync(hdmitx_hdcp_init);
+module_exit(hdmitx_hdcp_exit);
+MODULE_DESCRIPTION("AMLOGIC HDMI TX HDCP driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.h b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.h
old mode 100644
new mode 100755
index eac0270f..11470329
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.h
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_hdcp.h
@@ -14,4 +14,3 @@
 int hdcp_ksv_valid(unsigned char * dat);
 
 #endif
-
diff --git a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.c b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.c
old mode 100644
new mode 100755
index 7123cbd3..e1138248
--- a/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.c
+++ b/drivers/amlogic/hdmi/hdmi_tx/hdmi_tx_video.c
@@ -14,36 +14,14 @@
 
 #include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
 #include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_compliance.h>
 
 static unsigned char hdmi_output_rgb = 0;
 static void hdmitx_set_spd_info(hdmitx_dev_t* hdmitx_device);
 static void hdmi_set_vend_spec_infofram(hdmitx_dev_t* hdmitx_device, HDMI_Video_Codes_t VideoCode);
-extern int dvi_mode;
 
 static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
 {
-    {
-        .VIC            = HDMI_480x320p60hz,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,
-        .sc             = SC_SCALE_HORIZ_VERT,
-    },
-    {
-        .VIC            = HDMI_480x272p60hz,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,
-        .sc             = SC_SCALE_HORIZ_VERT,
-    },
     {
         .VIC            = HDMI_640x480p60,
         .color_prefer   = COLOR_SPACE_RGB444,
@@ -102,127 +80,6 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .cc             = CC_ITU709,
         .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
-    },
-	{
-		.VIC			= HDMI_800p,
-		.color_prefer	= COLOR_SPACE_RGB444,
-		.color_depth 	= COLOR_24BIT,
-		.bar_info		= B_BAR_VERT_HORIZ,
-		.repeat_time	= NO_REPEAT,
-		.aspect_ratio 	= TV_ASPECT_RATIO_16_9,
-		.cc				= CC_ITU709,
-		.ss				= SS_SCAN_UNDER,
-		.sc				= SC_SCALE_HORIZ_VERT,
-	},
-    {
-        .VIC            = HDMI_800x480p60hz,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,
-        .sc             = SC_SCALE_HORIZ_VERT,
-    },
-    {
-        .VIC            = HDMI_480x800p60hz,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,
-        .sc             = SC_SCALE_HORIZ_VERT,
-    },
-    {
-        .VIC            = HDMI_1366x768p60hz,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,
-        .sc             = SC_SCALE_HORIZ_VERT,
-    },
-    {
-        .VIC            = HDMI_1600x900p60hz,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,
-        .sc             = SC_SCALE_HORIZ_VERT,
-    },
-    {
-        .VIC            = HDMI_800x600p60hz,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,
-        .sc             = SC_SCALE_HORIZ_VERT,
-    },
-    {
-        .VIC            = HDMI_1024x600p60hz,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,
-        .sc             = SC_SCALE_HORIZ_VERT,
-    },
-    {
-        .VIC            = HDMI_1024x768p60hz,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,
-        .sc             = SC_SCALE_HORIZ_VERT,
-    },
-    {
-        .VIC            = HDMI_1360x768p60hz,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,
-        .sc             = SC_SCALE_HORIZ_VERT,
-    },
-    {
-        .VIC            = HDMI_1440x900p60hz,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,
-        .sc             = SC_SCALE_HORIZ_VERT,
-    },
-    {
-        .VIC            = HDMI_1680x1050p60hz,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,
-        .sc             = SC_SCALE_HORIZ_VERT,
     },
     {
         .VIC            = HDMI_1080i60,
@@ -337,28 +194,6 @@ static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
         .cc             = CC_ITU709,
         .ss             = SS_SCAN_UNDER,
         .sc             = SC_SCALE_HORIZ_VERT,
-    },
-     { 
-        .VIC            = HDMI_1280x1024,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,   
-        .sc             = SC_SCALE_HORIZ_VERT,
-    },
-     { 
-        .VIC            = HDMI_1920x1200,
-        .color_prefer   = COLOR_SPACE_RGB444,
-        .color_depth    = COLOR_24BIT,
-        .bar_info       = B_BAR_VERT_HORIZ,
-        .repeat_time    = NO_REPEAT,
-        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
-        .cc             = CC_ITU709,
-        .ss             = SS_SCAN_UNDER,   
-        .sc             = SC_SCALE_HORIZ_VERT,
     },
     {
         .VIC            = HDMI_1080i50,
@@ -576,14 +411,10 @@ void hdmitx_init_parameters(HDMI_TX_INFO_t *info)
 //If not, treated as a DVI Device
 static int is_dvi_device(rx_cap_t* pRXCap)
 {
-	if (voutmode_hdmi()) {
-		pr_emerg("hdmi: Fixing to HDMI Mode\n");
-		return 0;
-	}
-
-	pr_emerg("hdmi: fixing to %s mode\n",
-			voutmode_dvi() ? "DVI" : "VGA");
-	return 1;
+    if(pRXCap->IEEEOUI != 0x000c03)
+        return 1;
+    else
+        return 0;
 }
 
 void hdmitx_output_rgb(void)
@@ -609,9 +440,9 @@ int hdmitx_set_display(hdmitx_dev_t* hdmitx_device, HDMI_Video_Codes_t VideoCode
     hdmi_print(IMP, SYS "already init VIC = %d  Now VIC = %d\n", vic, VideoCode);
     if((vic != HDMI_Unkown) && (vic == VideoCode)) {
         hdmitx_device->cur_VIC = vic;
-        return 1;
+        return 1;;
     }
-
+    hdmitx_special_handler_video(hdmitx_device);
     param = hdmi_get_video_param(VideoCode);
     hdmitx_device->cur_video_param = param;
     if(param){
@@ -640,30 +471,30 @@ int hdmitx_set_display(hdmitx_dev_t* hdmitx_device, HDMI_Video_Codes_t VideoCode
 //0: DVI Mode       1: HDMI Mode
             //if(hdmitx_device->hdmi_info.output_state==CABLE_PLUGIN_DVI_OUT)
             if(is_dvi_device(&hdmitx_device->RXCap)) {
-                pr_emerg("hdmi: Sink is DVI device\n");
+                hdmi_print(1,"Sink is DVI device\n");
                 hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_HDMI_DVI_MODE, DVI_MODE);        //todo ColorFormat
             }
             else {
-                pr_emerg("hdmi: Sink is HDMI device\n");
+                hdmi_print(1,"Sink is HDMI device\n");
                 hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_HDMI_DVI_MODE, HDMI_MODE);
             }
 //check system status by reading EDID_STATUS
             switch(hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_SYSTEM_ST, 0))
             {
                 case 0:
-                    pr_emerg("hdmi: No sink attached\n");
+                    hdmi_print(1,"No sink attached\n");
                     break;
                 case 1:
-                    pr_emerg("hdmi: Source reading EDID\n");
+                    hdmi_print(1,"Source reading EDID\n");
                     break;
                 case 2:
-                    pr_emerg("hdmi: Source in DVI Mode\n");
+                    hdmi_print(1,"Source in DVI Mode\n");
                     break;
                 case 3:
-                    pr_emerg("hdmi: Source in HDMI Mode\n");
+                    hdmi_print(1,"Source in HDMI Mode\n");
                     break;
                 default:
-                    pr_emerg("hdmi: EDID Status error\n");
+                    hdmi_print(1,"EDID Status error\n");
             }
 
             hdmi_tx_construct_avi_packet(param, (char*)AVI_DB);
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/Makefile b/drivers/amlogic/hdmi/hdmi_tx_2/Makefile
new file mode 100644
index 00000000..487ba81f
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/Makefile
@@ -0,0 +1,5 @@
+obj-$(CONFIG_AML_HDMI_TX_20)		+= hdmitx2.o
+
+hdmitx2-objs := hdmi_tx_main.o hdmi_tx_cec.o hdmi_cec_key.o hdmi_tx_video.o hdmi_tx_audio.o hdmi_tx_edid.o hdmi_tx_audio.o hdmi_tx_hdcp.o hdmi_tx_scdc.o
+
+#EXTRA_CFLAGS += -O2
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_cec_key.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_cec_key.c
new file mode 100644
index 00000000..57652d77
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_cec_key.c
@@ -0,0 +1,172 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/errno.h>
+
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/power_gate.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#include <mach/gpio.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+hdmitx_dev_t *hdmitx_device = NULL;
+
+__u16 cec_key_map[128] = {
+    KEY_SELECT, KEY_UP, KEY_DOWN, KEY_LEFT, KEY_RIGHT, 0 , 0 , 0 ,//0x00
+    0 , KEY_HOMEPAGE , KEY_MENU, 0, 0, KEY_BACK, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x10
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    KEY_0 , KEY_1, KEY_2, KEY_3,KEY_4, KEY_5, KEY_6, KEY_7,//0x20
+    KEY_8 , KEY_9, KEY_DOT, 0, 0, 0, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x30
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    
+    KEY_POWER , KEY_VOLUMEUP, KEY_VOLUMEDOWN, KEY_MUTE, KEY_PLAYPAUSE, KEY_STOP, KEY_PLAYPAUSE, KEY_RECORD,//0x40
+    KEY_REWIND, KEY_FASTFORWARD, KEY_EJECTCD, KEY_NEXTSONG, KEY_PREVIOUSSONG, 0, 0, 0,
+    0 , 0, 0, 0, 0, 0, 0, 0,//0x50
+    0 , 0, 0, 0, 0, 0, 0, 0,
+    KEY_PLAYCD, KEY_PLAYPAUSE, KEY_RECORD, KEY_PAUSECD, KEY_STOPCD, KEY_MUTE, 0, KEY_TUNER,//0x60
+    0 , KEY_MEDIA, 0, 0, KEY_POWER, 0, 0, 0,
+    0 , KEY_BLUE, KEY_RED, KEY_GREEN, KEY_YELLOW, 0, 0, 0,//0x70
+    0 , 0, 0, 0, 0, 0, 0, 0x2fd,
+};
+
+void cec_send_event(cec_rx_message_t* pcec_message)
+{
+    int i;
+    unsigned char brdcst, opcode;
+    unsigned char initiator, follower;
+    unsigned char operand_num;
+    unsigned char msg_length;
+    unsigned char operands[14];
+    
+    /* parse message */
+    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0)) return;
+
+    initiator   = pcec_message->content.msg.header >> 4;
+    follower    = pcec_message->content.msg.header & 0x0f;
+    opcode      = pcec_message->content.msg.opcode;   
+    operand_num = pcec_message->operand_num;
+    brdcst      = (follower == 0x0f);
+    msg_length  = pcec_message->msg_length;
+    
+    for (i = 0; i < operand_num; i++ ) {
+       operands[i] = pcec_message->content.msg.operands[i]; 
+       hdmi_print(INF, CEC  ":operands[%d]:%u\n", i, operands[i]);       
+    }
+    if(cec_global_info.cec_flag.cec_key_flag) {
+        input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 1);
+        input_sync(cec_global_info.remote_cec_dev);
+        hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands[0]]);
+    }
+    else{
+        input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands[0]], 0);
+        input_sync(cec_global_info.remote_cec_dev);
+        hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands[0]]);
+    }   
+}
+
+
+void cec_send_event_irq(void)
+{
+    int i;
+    unsigned char   operand_num_irq;
+    unsigned char operands_irq[14];
+         
+    operand_num_irq = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num;
+    for (i = 0; i < operand_num_irq; i++ )
+    {
+        operands_irq[i] = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.operands[i]; 
+        hdmi_print(INF, CEC  ":operands_irq[%d]:0x%x\n", i, operands_irq[i]);       
+    }
+    
+    switch(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.operands[0]){
+    case 0x33:
+        //cec_system_audio_mode_request();
+        //cec_set_system_audio_mode();
+        break;
+    case 0x35:
+        break;
+    default:
+        break;      
+    }	
+    
+    input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 1);
+    input_sync(cec_global_info.remote_cec_dev);	
+    input_event(cec_global_info.remote_cec_dev, EV_KEY, cec_key_map[operands_irq[0]], 0);
+    input_sync(cec_global_info.remote_cec_dev);
+    hdmi_print(INF, CEC  ":key map:%d\n",cec_key_map[operands_irq[0]]);      		  	 	
+}
+
+void cec_user_control_pressed_irq(void)
+{
+    hdmi_print(INF, CEC  ": Key pressed \n");
+    cec_send_event_irq();
+}
+
+void cec_user_control_released_irq(void)  
+{
+    hdmi_print(INF, CEC  ": Key released \n");
+} 
+
+void cec_user_control_pressed(cec_rx_message_t* pcec_message)
+{
+    hdmi_print(INF, CEC  ": Key pressed \n");
+    cec_global_info.cec_flag.cec_key_flag = 1;
+    cec_send_event(pcec_message);
+}
+
+void cec_user_control_released(cec_rx_message_t* pcec_message)  
+{
+    hdmi_print(INF, CEC  ": Key released \n");
+    cec_global_info.cec_flag.cec_key_flag = 1;
+    cec_send_event(pcec_message);
+}
+
+
+/*
+ * STANDBY: get STANDBY command from TV
+ */
+void cec_standby(cec_rx_message_t* pcec_message)
+{
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) {
+            hdmi_print(INF, CEC  ": System will be in standby mode\n");
+            input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_POWER, 1);
+            input_sync(cec_global_info.remote_cec_dev);
+            input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_POWER, 0);
+            input_sync(cec_global_info.remote_cec_dev);
+        }
+    }
+}
+
+void cec_key_init(void)
+{
+    extern hdmitx_dev_t * get_hdmitx_device(void);
+    hdmitx_device = get_hdmitx_device();
+}
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_audio.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_audio.c
new file mode 100644
index 00000000..5d66bde3
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_audio.c
@@ -0,0 +1,236 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+
+#undef PCM_USE_INFOFRAME
+
+static const unsigned char channel_status_freq[]=
+{
+    0x0,
+    0x3, //32K
+    0x0, //44.1k
+    0x2, //48k
+    0x8, //88.2k
+    0xa, //96k
+    0xc, //176.4k
+    0xe, //192k
+};
+
+static const unsigned char channel_status_sample_word_length[]=
+{
+    0x0,
+    0x2, //16 bits
+    0x3, //20 bits
+    0xb //24 bits
+};
+
+void hdmi_tx_set_N_CTS(unsigned N_value, unsigned CTS)
+{
+}
+
+#if 0
+static void hdmi_tx_construct_aud_packet(Hdmi_tx_audio_para_t* audio_param, unsigned char* AUD_DB, unsigned char* CHAN_STAT_BUF, int hdmi_ch)
+{
+#ifndef PCM_USE_INFOFRAME
+    if(audio_param->type == CT_PCM){
+        hdmi_print(INF, AUD "Audio Type: PCM\n");
+        if(AUD_DB){
+//Note: HDMI Spec V1.4 Page 154
+            if((audio_param->channel_num == CC_2CH) || (audio_param->channel_num == CC_REFER_TO_STREAM))
+                AUD_DB[0] = 0;
+            else
+                AUD_DB[0] = (0<<4)|(audio_param->channel_num);
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[2] = 0x0;
+            if(audio_param->channel_num == CC_6CH)
+                AUD_DB[3] = 0xb; //CA, 6 channel
+            else if(audio_param->channel_num == CC_8CH){
+                if(hdmi_ch == CC_6CH){
+                    AUD_DB[3] = 0x0b; //CA, 6 channel
+                }
+                else{
+                    AUD_DB[3] = 0x13; //CA, 8 channel
+               }
+            }
+            else
+                AUD_DB[3] = 0; //CA, 2 channel, default
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+        if(CHAN_STAT_BUF){
+            CHAN_STAT_BUF[2]=0x10|(audio_param->channel_num+1);  CHAN_STAT_BUF[24+2]=0x20|(audio_param->channel_num+1);
+            CHAN_STAT_BUF[3]=CHAN_STAT_BUF[24+3]=channel_status_freq[audio_param->sample_rate];
+            CHAN_STAT_BUF[4]=CHAN_STAT_BUF[24+4]=channel_status_sample_word_length[audio_param->sample_size]|
+                    ((~channel_status_freq[audio_param->sample_rate])<<4);
+        }
+    }
+    else if(audio_param->type == CT_AC_3){
+        hdmi_print(INF, AUD "Audio Type: AC3\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_AC_3<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_MPEG1){
+        hdmi_print(INF, AUD "Audio Type: MPEG1\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_MPEG1<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_MP3){
+        hdmi_print(INF, AUD "Audio Type: MP3\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_MP3<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_MPEG2){
+        hdmi_print(INF, AUD "Audio Type: MPEG2\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_MPEG2<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_AAC){
+        hdmi_print(INF, AUD "Audio Type: AAC\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_AAC<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_DTS){
+        hdmi_print(INF, AUD "Audio Type: DTS\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_DTS<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_ATRAC){
+        hdmi_print(INF, AUD "Audio Type: ATRAC\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_ATRAC<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_ONE_BIT_AUDIO){
+        hdmi_print(INF, AUD "Audio Type: One Bit Audio\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_ONE_BIT_AUDIO<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_DOLBY_D){
+        hdmi_print(INF, AUD "Audio Type: Dobly Digital +\n");
+        if(AUD_DB){
+            AUD_DB[0] = (FS_REFER_TO_STREAM<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+        if(CHAN_STAT_BUF){
+            CHAN_STAT_BUF[0] = CHAN_STAT_BUF[24+0]= 0x2;
+            CHAN_STAT_BUF[3] = CHAN_STAT_BUF[24+3]= 0x1e;
+            CHAN_STAT_BUF[4] = CHAN_STAT_BUF[24+4]= 0x1;
+        }
+    }
+    else if(audio_param->type == CT_DTS_HD){
+        hdmi_print(INF, AUD "Audio Type: DTS-HD\n");
+        if(AUD_DB){
+            AUD_DB[0] = (FS_REFER_TO_STREAM<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_MAT){
+        hdmi_print(INF, AUD "Audio Type: MAT(MLP)\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_MAT<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_DST){
+        hdmi_print(INF, AUD "Audio Type: DST\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_DST<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else if(audio_param->type == CT_WMA){
+        hdmi_print(INF, AUD "Audio Type: WMA Pro\n");
+        if(AUD_DB){
+            AUD_DB[0] = (CT_WMA<<4)|(CC_REFER_TO_STREAM) ;
+            AUD_DB[1] = (FS_REFER_TO_STREAM<<2)|SS_REFER_TO_STREAM;
+            AUD_DB[3] = 0; //CA, 2 channel
+            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+        }
+    }
+    else
+#endif
+    {
+//        if(AUD_DB){
+//            AUD_DB[0] = (audio_param->type<<4)|audio_param->channel_num ;
+//            AUD_DB[1] = (audio_param->sample_rate<<2)|audio_param->sample_size;
+//            AUD_DB[3] = 0; //CA, 2 channel
+//            AUD_DB[4] = 0;//DM_INH<<7|LSV<<3
+//        }
+//        if(CHAN_STAT_BUF){
+//            CHAN_STAT_BUF[3]=CHAN_STAT_BUF[24+3]=channel_status_freq[audio_param->sample_rate];
+//        }
+    }
+    AUD_DB[0] = AUD_DB[0] & 0xf;        // bit[7:4] always set to 0 in HDMI
+    AUD_DB[1] = 0;                      // always set to 0 in HDMI
+}
+#endif
+
+int hdmitx_set_audio(hdmitx_dev_t* hdmitx_device, Hdmi_tx_audio_para_t* audio_param, int hdmi_ch)
+{
+    int i,ret=-1;
+    unsigned char AUD_DB[32];
+    unsigned char CHAN_STAT_BUF[24*2];
+    for(i=0;i<32;i++) AUD_DB[i]=0;
+    for(i=0;i<(24*2);i++) CHAN_STAT_BUF[i]=0;
+    if(hdmitx_device->HWOp.SetAudMode(hdmitx_device, audio_param)>=0){
+//        hdmi_tx_construct_aud_packet(audio_param, AUD_DB, CHAN_STAT_BUF, hdmi_ch);
+
+//        hdmitx_device->HWOp.SetAudioInfoFrame(AUD_DB, CHAN_STAT_BUF);
+        ret = 0;
+    }
+    return ret;
+}
+
+
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_cec.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_cec.c
new file mode 100644
index 00000000..4dcee13d
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_cec.c
@@ -0,0 +1,2425 @@
+/*
+ * Amlogic Meson HDMI Transmitter Driver
+ * HDMI CEC Driver-----------HDMI_TX
+ * Copyright (C) 2011 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <linux/switch.h>
+#include <linux/workqueue.h>
+#include <linux/poll.h>
+
+#include <asm/uaccess.h>
+#include <asm/delay.h>
+#include <mach/am_regs.h>
+#include <mach/power_gate.h>
+#include <linux/amlogic/tvin/tvin.h>
+
+#include <mach/gpio.h>
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+
+static hdmitx_dev_t* hdmitx_device = NULL;
+static struct class *cec_class;
+static struct device *cec_device;
+static dev_t devno;
+#define DEVICE_NAME "aocec"
+
+#define CEC_MSG_BUF_SIZE 16
+static unsigned char msg_log_buf[512] = { 0 };
+
+void cec_do_tasklet(unsigned long data);
+DECLARE_TASKLET(cec_tasklet, cec_do_tasklet, 0);
+
+static DEFINE_SPINLOCK(p_tx_list_lock);
+//static DEFINE_SPINLOCK(p_rx_list_lock);
+static unsigned long cec_tx_list_flags;
+//static unsigned long cec_rx_list_flags;
+static unsigned int tx_msg_cnt = 0;
+static unsigned int rx_msg_cnt = 0;
+static struct list_head cec_tx_msg_phead = LIST_HEAD_INIT(cec_tx_msg_phead);
+static struct list_head cec_rx_msg_phead = LIST_HEAD_INIT(cec_rx_msg_phead);
+static unsigned char rx_msg[MAX_MSG];
+static unsigned char rx_len;
+static unsigned char g_rx_buf[128];
+static int g_rx_len = 0;
+
+struct cec_dev
+{
+    struct cdev cdev;
+    unsigned int current_len;
+    unsigned char cec_msg_buf[CEC_MSG_BUF_SIZE];
+    struct semaphore sem;
+    struct file_operations *ops;
+    wait_queue_head_t r_wait;
+    wait_queue_head_t w_wait;
+};
+
+static struct cec_dev *cec_devp;
+
+static int cec_open(struct inode *inode, struct file *file)
+{
+    hdmi_print(INF, CEC "file open!\n");
+    return 0;
+}
+
+static int cec_release(struct inode *inode, struct file *file)
+{
+    hdmi_print(INF, CEC "file release!\n");
+    return 0;
+}
+
+static ssize_t cec_read(struct file *filp, char __user *buf, size_t count, loff_t *ppos)
+{
+//    unsigned long pp = *ppos;
+//    char * buf_tmp = buf;
+    int ret = 0;
+   // int n;
+   // int pos;
+    cec_usr_message_list_t *p, *ptmp;
+//    struct cec_dev *dev = cec_devp;
+//    DECLARE_WAITQUEUE(wait, current);
+//    down(&dev->sem);
+
+    printk("\ngoing to read cec data in driver........\n");
+    //add_wait_queue(&dev->r_wait, &wait);
+/*
+    list_for_each_entry_safe(p, ptmp, &cec_rx_msg_phead, list) 
+    {
+        {
+            pos = 0;
+            pos += sprintf(msg_log_buf + pos, "CEC111: read file: rx msg len: %d   dat: ", p->length);
+            for(n = 0; n < p->length; n++)
+            {
+                pos += sprintf(msg_log_buf + pos, "%02x ", p->msg[n]);
+            }
+            pos += sprintf(msg_log_buf + pos, "\n");
+
+            msg_log_buf[pos] = '\0';
+            printk("%s", msg_log_buf);
+        }
+
+        copy_to_user(buf, p->msg, p->length);
+        unregister_cec_rx_msg(p);
+    }
+
+return p->length;*/
+    list_for_each_entry_safe(p, ptmp, &cec_rx_msg_phead, list) {
+
+        // {
+        //     pos = 0;
+        //     pos += sprintf(msg_log_buf + pos, "\n-------file-------\nCEC: read file: rx msg len: %d   dat: ", p->length);
+        //     for(n = 0; n < p->length; n++) {
+        //         pos += sprintf(msg_log_buf + pos, "%02x ", p->msg[n]);
+        //     }
+        //     pos += sprintf(msg_log_buf + pos, "\n");
+
+        //     msg_log_buf[pos] = '\0';
+        //     printk("%s", msg_log_buf);
+        // }
+/*        if(filp->f_flags & O_NONBLOCK)
+        {
+            ret = - EAGAIN;
+            goto out;
+        }
+        __set_current_state(TASK_INTERRUPTIBLE);
+        up(&dev->sem);
+
+        schedule();
+        if(signal_pending(current))
+        {
+            ret = - ERESTARTSYS;
+            goto out2;
+        }
+        down(&dev->sem);*/
+        // if (pp >= p->length)
+        // {
+        //     return count ? -ENXIO : 0;
+        // }
+
+/*        if(pp >= 16)
+        {
+            printk("HDMI CEC:: pp >= 16!\n");
+            return count;
+        }
+        if(count > 16 - pp)
+            count = 16 - pp;*/
+
+        //pp += count;
+        #if 1
+        printk("The data len is:%d\n", g_rx_len);
+        if(copy_to_user(buf, g_rx_buf, g_rx_len))
+        {
+            ret = -EFAULT;
+            printk("HDMI CEC:: ret = -EFAULT\n");
+            //goto out;
+        }
+        ret = g_rx_len;
+
+        #else
+        p->msg[p->length] = '\0';
+        if(copy_to_user(buf_tmp, p->msg, p->length + 1))
+        {
+            ret = -EFAULT;
+            printk("HDMI CEC:: ret = -EFAULT\n");
+            //goto out;
+        }
+        else
+        {
+
+            {
+                pos = 0;
+                pos += sprintf(msg_log_buf + pos, "\n-------buf--------\nCEC: read buf: rx msg len: %d   dat: ", p->length);
+                for(n = 0; n < p->length; n++) {
+                    pos += sprintf(msg_log_buf + pos, "%02x ", buf_tmp[n]);
+                }
+                pos += sprintf(msg_log_buf + pos, "\n");
+
+                msg_log_buf[pos] = '\0';
+                printk("%s", msg_log_buf);
+            }
+
+            *ppos += p->length;
+            for(n = 0; n < p->length + 1; n++)
+            {
+                printk("buf_tmp[%d]:0x%02x\n", n, buf_tmp[n]);
+            }
+            
+            buf_tmp += (p->length + 1);
+
+            // memcpy(dev->cec_msg_buf, dev->cec_msg_buf, dev->current_len - count);
+            // dev->current_len -=count;
+            //wake_up_interruptible(&dev->w_wait);
+            ret = p->length; 
+
+            //printk(KERN_INFO "HDMI CEC:: read %d bytes, current_len: %d\n", count, dev->current_len);
+        }
+        #endif
+        unregister_cec_rx_msg(p);
+
+    }
+
+/*    while(dev->current_len == 0)
+    {
+        if(filp->f_flags & O_NONBLOCK)
+        {
+            ret = - EAGAIN;
+            goto out;
+        }
+        __set_current_state(TASK_INTERRUPTIBLE);
+        up(&dev->sem);
+
+        schedule();
+        if(signal_pending(current))
+        {
+            ret = - ERESTARTSYS;
+            goto out2;
+        }
+        down(&dev->sem);
+    }
+
+    if(count > dev->current_len)
+        count = dev->current_len;*/
+
+    // if(p >= CEC_MSG_BUF_SIZE)
+    //     return count ? -ENXIO : 0;
+    // if(count > CEC_MSG_BUF_SIZE - p)
+    //     count = CEC_MSG_BUF_SIZE - p;
+
+    // if(copy_to user(buf, (void*) (cec_dev.cec_msg_buf + p), count))
+/*    if(copy_to_user(buf, dev->cec_msg_buf, count))
+    {
+        ret = -EFAULT;
+        goto out;
+    }
+    else
+    {
+        // *ppos +=count;
+        memcpy(dev->cec_msg_buf, dev->cec_msg_buf, dev->current_len - count);
+        dev->current_len -=count;
+        wake_up_interruptible(&dev->w_wait);
+        ret = count; 
+
+        printk(KERN_INFO "HDMI CEC:: read %d bytes, current_len: %d\n", count, dev->current_len);
+    }*/
+    //out: up(&dev->sem);
+    //out2: remove_wait_queue(&dev->r_wait, &wait);
+    //set_current_state(TASK_RUNNING);
+    //return (ssize_t)(buf_tmp - buf);
+    return (ssize_t)(ret);
+}
+
+static ssize_t cec_write(struct file *filp, const char __user *buf, size_t count, loff_t *ppos)
+{
+    // unsigned long p = 16*(*ppos);
+    int ret = 0;
+    char param[32] = {0};
+    unsigned len = 0;
+    DECLARE_WAITQUEUE(wait, current);
+
+//    int i;
+    struct cec_dev *dev = cec_devp;
+
+    unsigned int idx = 0;
+    for(idx = 0; idx < count; idx++)
+    {
+        printk("data %d is:0x%x\n", idx, buf[idx]);
+        param[idx] = buf[idx];
+    }
+    len = count;
+    printk("len:%d\n", len);
+
+    //len = dispatch_buffer_parse(buf, "", param, count);
+
+    //down(&dev->sem);
+    add_wait_queue(&dev->w_wait, &wait);
+
+/*    while(dev->current_len == CEC_MSG_BUF_SIZE)
+    {
+        if(filp->f_flags * O_NONBLOCK)
+        {
+            ret = -EAGAIN;
+            goto out;
+        }
+        __set_current_state(TASK_INTERRUPTIBLE);
+        up(&dev->sem);
+
+        schedule();
+        if(signal_pending(current))
+        {
+            ret = -ERESTARTSYS;
+            goto out2;
+        }
+
+        down(&dev->sem);
+    }
+
+    // if(p >= CEC_MSG_BUF_SIZE)
+    //     return count ? -ENXIO : 0;
+
+    // if(count > CEC_MSG_BUF_SIZE - p)
+    //     count = CEC_MSG_BUF_SIZE - p;
+    if(count > CEC_MSG_BUF_SIZE - dev->current_len)
+        count = CEC_MSG_BUF_SIZE - dev->current_len;
+
+    if(copy_from_user(dev->cec_msg_buf + dev->current_len, buf, count))
+    {
+        ret = -EFAULT;
+        goto out;
+    }
+    else
+    {
+        // *ppos += count;
+        dev->current_len += count;
+        ret = count;
+
+        printk(KERN_INFO "HDMI CEC:: written %d bytes,current_len: %d \n", count, dev->current_len);
+        wake_up_interruptible(&dev->r_wait);
+    }
+*/
+
+    //if(len > CEC_MSG_BUF_SIZE)
+    //    len = CEC_MSG_BUF_SIZE;
+
+    register_cec_tx_msg(param, len);
+
+    //out: up(&dev->sem);
+    ret = count;
+    remove_wait_queue(&dev->w_wait, &wait);
+    // set_current_state(TASK_RUNNING);
+    return ret;
+}
+
+static long cec_ioctl(struct file* filp, unsigned int cmd,unsigned long arg)
+{
+    switch(cmd)
+    {
+        case 1:
+        case 2:
+        default:
+        return - EINVAL;
+    }
+    return 0;
+}
+
+
+static unsigned int cec_poll(struct file *filp, struct poll_table_struct *wait)
+{
+    unsigned int mask = 0;
+
+    struct cec_dev *dev = cec_devp;
+
+    //down(&dev->sem);
+
+    poll_wait(filp, &dev->r_wait, wait);
+    poll_wait(filp, &dev->w_wait, wait);
+
+    if(rx_msg_cnt >=100)
+    {
+        printk("HDMI CEC:: too many msg, rx_msg_cnt:%d\n", rx_msg_cnt);
+        return mask;
+    }
+    printk("cec_poll::tx_msg_cnt:%d\n", tx_msg_cnt);
+    if(tx_msg_cnt >=100)
+    {
+        printk("HDMI CEC:: too many msg, tx_msg_cnt:%d\n", tx_msg_cnt);
+        return mask;
+    }
+
+    if(rx_msg_cnt != 0)
+    {
+        mask|= POLLIN | POLLRDNORM;
+    }
+
+    if(tx_msg_cnt == 0)
+    {
+        mask |=POLLOUT | POLLWRNORM;
+    }
+
+    //up(&dev->sem);
+    return mask;
+}
+
+static struct file_operations cec_fops =
+{
+    .owner = THIS_MODULE,
+    .open = cec_open,
+    .release = cec_release,
+    .read = cec_read,
+    .write = cec_write,
+    .unlocked_ioctl = cec_ioctl,
+    .poll = cec_poll,
+};
+
+static void cec_setup_cdev(void)
+{
+    int err;
+
+    cdev_init(&cec_devp->cdev, &cec_fops);
+    cec_devp->cdev.owner = THIS_MODULE;
+    cec_devp->ops = &cec_fops;
+
+    err = cdev_add(&cec_devp->cdev, devno, 1);
+
+    if(err)
+    {
+        printk(KERN_NOTICE "Error %d adding cec\n", err);
+    }
+
+}
+
+DEFINE_SPINLOCK(cec_input_key);
+
+/* global variables */
+static    unsigned char    gbl_msg[MAX_MSG];
+cec_global_info_t cec_global_info;
+unsigned char rc_long_press_pwr_key = 0;
+EXPORT_SYMBOL(rc_long_press_pwr_key);
+bool cec_msg_dbg_en = 0;
+
+ssize_t    cec_lang_config_state(struct switch_dev *sdev, char *buf){
+    int pos=0;
+    pos+=snprintf(buf+pos, PAGE_SIZE, "%c%c%c\n", (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >>16) & 0xff, 
+                                                  (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 8) & 0xff,
+                                                  (cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang >> 0) & 0xff);
+    return pos;  
+};
+
+struct switch_dev lang_dev = {    // android ics switch device
+    .name = "lang_config",
+    .print_state = cec_lang_config_state,
+    };
+EXPORT_SYMBOL(lang_dev);
+
+unsigned int menu_lang_array[] = {(((unsigned int)'c')<<16)|(((unsigned int)'h')<<8)|((unsigned int)'i'),
+                                  (((unsigned int)'e')<<16)|(((unsigned int)'n')<<8)|((unsigned int)'g'),
+                                  (((unsigned int)'j')<<16)|(((unsigned int)'p')<<8)|((unsigned int)'n'),
+                                  (((unsigned int)'k')<<16)|(((unsigned int)'o')<<8)|((unsigned int)'r'),
+                                  (((unsigned int)'f')<<16)|(((unsigned int)'r')<<8)|((unsigned int)'a'),
+                                  (((unsigned int)'g')<<16)|(((unsigned int)'e')<<8)|((unsigned int)'r')
+                                 };
+
+// CEC default setting
+static unsigned char * osd_name = "Amlogic MBox";
+static unsigned int vendor_id = 0x00;
+
+static irqreturn_t cec_isr_handler(int irq, void *dev_instance);
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+static struct early_suspend hdmitx_cec_early_suspend_handler;
+static void hdmitx_cec_early_suspend(struct early_suspend *h)
+{
+    hdmi_print(INF, CEC "early suspend!\n");
+    if(!hdmitx_device->hpd_state) { //if none HDMI out,no CEC features.
+        hdmi_print(INF, CEC "HPD low!\n");
+        return;
+    }
+    
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+        cec_inactive_source();
+
+        if(rc_long_press_pwr_key == 1) {
+            cec_set_standby();
+            msleep(100);
+            hdmi_print(INF, CEC "get power-off command from Romote Control\n");
+            rc_long_press_pwr_key = 0;
+        }
+    }
+    cec_disable_irq();
+}
+
+static void hdmitx_cec_late_resume(struct early_suspend *h)
+{
+    cec_enable_irq();
+    if(!hdmitx_device->hpd_state) { //if none HDMI out,no CEC features.
+        hdmi_print(INF, CEC "HPD low!\n");
+        return;
+    }
+    
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        cec_hw_reset();//for M8 CEC standby.
+        cec_imageview_on_smp();
+        cec_active_source_smp();
+        msleep(200);
+        cec_active_source_smp();
+        cec_menu_status_smp(DEVICE_MENU_ACTIVE);
+    }
+    hdmi_print(INF, CEC "late resume\n");
+}
+
+#endif
+
+void cec_isr_post_process(void)
+{
+    if(!hdmitx_device->hpd_state) { //if none HDMI out,no CEC features.
+        return;
+    }
+    /* isr post process */
+    while(cec_global_info.cec_rx_msg_buf.rx_read_pos != cec_global_info.cec_rx_msg_buf.rx_write_pos) {
+        cec_handle_message(&(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_read_pos]));
+        (cec_global_info.cec_rx_msg_buf.rx_read_pos == cec_global_info.cec_rx_msg_buf.rx_buf_size - 1) ? (cec_global_info.cec_rx_msg_buf.rx_read_pos = 0) : (cec_global_info.cec_rx_msg_buf.rx_read_pos++);
+    }
+}
+
+void cec_rx_cmd_post_process(void)
+{
+    cec_usr_message_list_t *p, *ptmp;
+    /* usr command post process */
+    list_for_each_entry_safe(p, ptmp, &cec_rx_msg_phead, list) {
+
+        unregister_cec_rx_msg(p);
+    }
+}
+
+void cec_tx_cmd_post_process(void)
+{
+    cec_usr_message_list_t *p, *ptmp;
+    /* usr command post process */
+    list_for_each_entry_safe(p, ptmp, &cec_tx_msg_phead, list) {
+        cec_ll_tx(p->msg, p->length);
+        unregister_cec_tx_msg(p);
+    }
+}
+
+static int detect_tv_support_cec(unsigned addr)
+{
+    unsigned int ret = 0;
+    unsigned char msg[1];
+    msg[0] = (addr<<4) | 0x0;       // 0x0, TV's root address
+    ret = cec_ll_tx_polling(msg, 1);
+    cec_hw_reset();
+    hdmi_print(INF, CEC "tv%s have CEC feature\n", ret ? " " : " don\'t ");
+    return (hdmitx_device->tv_cec_support = ret);
+}
+
+void cec_node_init(hdmitx_dev_t* hdmitx_device)
+{
+    struct vendor_info_data *vend_data = NULL;
+
+    int i, bool = 0;
+    const enum _cec_log_dev_addr_e player_dev[3] = {CEC_PLAYBACK_DEVICE_1_ADDR,
+                                                    CEC_PLAYBACK_DEVICE_2_ADDR,
+                                                    CEC_PLAYBACK_DEVICE_3_ADDR,
+                                                   };
+
+    unsigned long cec_phy_addr;
+
+    if((hdmitx_device->cec_init_ready == 0) || (hdmitx_device->hpd_state == 0)) {      // If no connect, return directly
+        hdmi_print(INF, CEC "CEC not ready\n");
+        return;
+    }
+    else {
+        hdmi_print(INF, CEC "CEC node init\n");
+    }
+
+    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
+        return ;
+
+#if 1       //todo
+    if(hdmitx_device->config_data.vend_data)
+        vend_data = hdmitx_device->config_data.vend_data;
+    if((vend_data) && (vend_data->cec_osd_string)) {
+        i = strlen(vend_data->cec_osd_string);
+        if(i > 14) 
+            vend_data->cec_osd_string[14] = '\0';   // OSD string length must be less than 14 bytes
+        osd_name = vend_data->cec_osd_string;
+    }
+    if((vend_data) && (vend_data->vendor_id)) {
+        vendor_id = (vend_data->vendor_id ) & 0xffffff;
+    }
+#endif
+
+   cec_hw_init();
+
+    cec_phy_addr = (((hdmitx_device->hdmi_info.vsdb_phy_addr.a) & 0xf) << 12) |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.b) & 0xf) << 8)  |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.c) & 0xf) << 4)  |
+                   (((hdmitx_device->hdmi_info.vsdb_phy_addr.d) & 0xf) << 0);
+
+//#ifdef G9_CEC
+#if 0
+    hdmi_print(INF, CEC "G9 CEC: start poll dev\n");
+    aml_write_reg32(P_AO_DEBUG_REG1, cec_phy_addr);
+    cec_global_info.my_node_index = 0x4;
+    aocec_wr_reg(CEC_LOGICAL_ADDR0, (0x1 << 4) | 0x4);
+    hdmi_print(INF, CEC "G9 CEC: node init end.\n");
+    return;
+#endif
+    
+    for(i = 0; i < 3; i++){ 
+	    hdmi_print(INF, CEC "CEC: start poll dev\n");
+        cec_polling_online_dev(player_dev[i], &bool);
+        i = 0;
+        bool = 0;
+        hdmi_print(INF, CEC "player_dev[%d]:0x%x\n", i, player_dev[i]);
+        if(bool == 0){  // 0 means that no any respond
+            // If VSDB is not valid,use last or default physical address.  
+            if(hdmitx_device->hdmi_info.vsdb_phy_addr.valid == 0) {
+                hdmi_print(INF, CEC "no valid cec physical address\n");
+                if(aml_read_reg32(P_AO_DEBUG_REG1))
+                    hdmi_print(INF, CEC "use last physical address\n");
+                else{
+                    aml_write_reg32(P_AO_DEBUG_REG1, 0x1000);
+                    hdmi_print(INF, CEC "use default physical address\n"); 
+                }  
+            }else{
+                aml_write_reg32(P_AO_DEBUG_REG1, cec_phy_addr);
+            } 
+            hdmi_print(INF, CEC "physical address:0x%x\n", aml_read_reg32(P_AO_DEBUG_REG1));
+            
+            cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_STANDBY_TO_ON;
+            cec_global_info.my_node_index = player_dev[i];
+            aml_write_reg32(P_AO_DEBUG_REG3, aml_read_reg32(P_AO_DEBUG_REG3) | (cec_global_info.my_node_index & 0xf));
+            cec_global_info.cec_node_info[player_dev[i]].log_addr = player_dev[i];
+            // Set Physical address
+            cec_global_info.cec_node_info[player_dev[i]].phy_addr.phy_addr_4 = cec_phy_addr;
+
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.sys_audio_mode = OFF;
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_mute_status = OFF; 
+            cec_global_info.cec_node_info[player_dev[i]].specific_info.audio.audio_status.audio_volume_status = 0;         
+
+            cec_global_info.cec_node_info[player_dev[i]].cec_version = CEC_VERSION_14A;
+            cec_global_info.cec_node_info[player_dev[i]].vendor_id = vendor_id;
+            cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
+            cec_global_info.cec_node_info[player_dev[i]].dev_type = cec_log_addr_to_dev_type(player_dev[i]);
+            strcpy(cec_global_info.cec_node_info[player_dev[i]].osd_name, osd_name); //Max num: 14Bytes
+
+            cec_logic_addr_set(CEC_PLAYBACK_DEVICE_1_ADDR);
+            
+     		hdmi_print(INF, CEC "Set logical address: %d\n", player_dev[i]);
+
+            hdmi_print(INF, CEC "P_AO_DEBUG_REG0:0x%x\n" ,aml_read_reg32(P_AO_DEBUG_REG0));
+        	if(cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status == DEVICE_MENU_INACTIVE)
+        	    break;
+            msleep(100);
+			cec_report_physical_address_smp();
+            msleep(150);
+            cec_device_vendor_id((cec_rx_message_t*)0);
+
+            msleep(150);
+            cec_imageview_on_smp();
+            msleep(100);
+
+            // here, we need to detect whether TV is supporting the CEC function
+            // if not, jump out to save system time
+            //if(!detect_tv_support_cec(player_dev[i])) {
+            //    break;
+            //}
+            cec_get_menu_language_smp();
+            msleep(350);
+
+            cec_active_source_smp();
+            msleep(120);
+
+            cec_menu_status_smp(DEVICE_MENU_ACTIVE);
+            msleep(100);
+
+            cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+            cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_ON;
+            break;
+        }
+    }
+    if(bool == 1)
+        hdmi_print(INF, CEC "Can't get a valid logical address\n");
+    else
+        hdmi_print(INF, CEC "cec node init: cec features ok !\n");
+}
+
+void cec_node_uninit(hdmitx_dev_t* hdmitx_device)
+{
+    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)))
+       return ;
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = TRANS_ON_TO_STANDBY;
+    hdmi_print(INF, CEC "cec node uninit!\n");
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].power_status = POWER_STANDBY;
+}
+
+static int cec_task(void *data)
+{
+    extern void dump_hdmi_cec_reg(void);
+    hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*) data;
+    cec_global_info.cec_flag.cec_init_flag = 1;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    hdmitx_cec_early_suspend_handler.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 20;
+    hdmitx_cec_early_suspend_handler.suspend = hdmitx_cec_early_suspend;
+    hdmitx_cec_early_suspend_handler.resume = hdmitx_cec_late_resume;
+    hdmitx_cec_early_suspend_handler.param = hdmitx_device;
+
+    register_early_suspend(&hdmitx_cec_early_suspend_handler);
+#endif
+
+    // Get logical address
+
+    hdmi_print(INF, CEC "CEC task process\n");
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)){
+        msleep_interruptible(10000);
+        
+        cec_node_init(hdmitx_device);
+    }
+    while (1) {
+   /*  	if (kthread_should_stop()){
+     		break;
+     	}
+     	wait_event_interruptible(hdmitx_device->cec_wait_rx,
+		 cec_global_info.cec_rx_msg_buf.rx_read_pos != cec_global_info.cec_rx_msg_buf.rx_write_pos);*/
+        msleep_interruptible(10);
+        cec_isr_post_process();
+        cec_tx_cmd_post_process();
+    }
+
+    return 0;
+}
+
+/***************************** cec low level code end *****************************/
+
+
+/***************************** cec middle level code *****************************/
+
+
+void register_cec_rx_msg_sub(unsigned char *msg, unsigned char len )
+{
+    cec_usr_message_list_t* cec_rx_message_list = kmalloc(sizeof(cec_usr_message_list_t), GFP_ATOMIC);
+    int pos;
+    int n;
+
+    if (cec_rx_message_list != NULL)
+    {
+        memset(g_rx_buf, 0, sizeof(g_rx_buf));
+        g_rx_len = len;
+        memcpy(g_rx_buf, msg, g_rx_len);
+
+        memset(cec_rx_message_list, 0, sizeof(cec_usr_message_list_t));      
+        memcpy(cec_rx_message_list->msg, msg, len);
+        cec_rx_message_list->length = len;
+
+        //spin_lock_irqsave(&p_rx_list_lock, cec_rx_list_flags);
+        list_add_tail(&cec_rx_message_list->list, &cec_rx_msg_phead);
+        //spin_unlock_irqrestore(&p_rx_list_lock, cec_rx_list_flags);
+        rx_msg_cnt++;
+
+        //if(cec_msg_dbg_en  == 1)
+        {
+            pos = 0;
+            pos += sprintf(msg_log_buf + pos, "CEC: register rx msg len: %d   dat: ", len);
+            for(n = 0; n < len; n++) {
+                pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+            }
+            pos += sprintf(msg_log_buf + pos, "\n");
+
+            msg_log_buf[pos] = '\0';
+            printk("%s", msg_log_buf);
+        }
+    }
+}
+
+void register_cec_rx_msg(unsigned char *msg, unsigned char len )
+{
+    unsigned long flags;
+    spin_lock_irqsave(&cec_input_key,flags);
+    //memset((void*)(&(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos])), 0, sizeof(cec_rx_message_t));
+    memcpy(cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.buffer, msg, len);
+
+    cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num = len >= 2 ? len - 2 : 0;
+    cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].msg_length = len;
+
+    //cec_input_handle_message();
+    register_cec_rx_msg_sub(msg, len);
+    (cec_global_info.cec_rx_msg_buf.rx_write_pos == cec_global_info.cec_rx_msg_buf.rx_buf_size - 1) ? 
+    (cec_global_info.cec_rx_msg_buf.rx_write_pos = 0) : (cec_global_info.cec_rx_msg_buf.rx_write_pos++);
+    spin_unlock_irqrestore(&cec_input_key,flags);
+}
+
+void register_cec_tx_msg(unsigned char *msg, unsigned char len )
+{
+    cec_usr_message_list_t* cec_tx_message_list = kmalloc(sizeof(cec_usr_message_list_t), GFP_ATOMIC);
+    int pos;
+    int n;
+    if (cec_tx_message_list != NULL)
+    {
+        memset(cec_tx_message_list, 0, sizeof(cec_usr_message_list_t));
+        memcpy(cec_tx_message_list->msg, msg, len);
+        cec_tx_message_list->length = len;
+
+        spin_lock_irqsave(&p_tx_list_lock, cec_tx_list_flags);
+        list_add_tail(&cec_tx_message_list->list, &cec_tx_msg_phead);
+        spin_unlock_irqrestore(&p_tx_list_lock, cec_tx_list_flags);
+
+        tx_msg_cnt++;
+
+        //if(cec_msg_dbg_en  == 1)
+        {
+            pos = 0;
+            pos += sprintf(msg_log_buf + pos, "CEC: register tx msg len: %d   dat: ", len);
+            for(n = 0; n < len; n++) {
+                pos += sprintf(msg_log_buf + pos, "%02x ", msg[n]);
+            }
+            pos += sprintf(msg_log_buf + pos, "\n");
+
+            msg_log_buf[pos] = '\0';
+            printk("%s", msg_log_buf);
+        }
+    }
+    wake_up_interruptible(&cec_devp->w_wait);
+}
+
+void cec_do_tasklet(unsigned long data)
+{
+    register_cec_rx_msg(rx_msg, rx_len);
+    udelay(1000);
+    wake_up_interruptible(&cec_devp->r_wait);
+}
+
+void cec_input_handle_message(void)
+{
+    unsigned char   opcode;
+
+    opcode = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.opcode;
+
+    /* process key event messages from tv */
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+        switch (opcode) {
+        case CEC_OC_USER_CONTROL_PRESSED:
+            // check valid msg
+            {
+                unsigned char opernum;
+                unsigned char follower;
+                opernum  = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].operand_num;
+                follower = cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos].content.msg.header & 0x0f;
+                if(opernum != 1 || follower == 0xf) break;
+            }
+            cec_user_control_pressed_irq();
+            break;
+        default:
+            break;
+        }
+    }
+}
+
+void unregister_cec_rx_msg(cec_usr_message_list_t* cec_rx_message_list)
+{
+
+    if (cec_rx_message_list != NULL) {
+        list_del(&cec_rx_message_list->list);
+        kfree(cec_rx_message_list);
+        cec_rx_message_list = NULL;
+
+        if (rx_msg_cnt > 0) rx_msg_cnt--;
+    }
+}
+
+void unregister_cec_tx_msg(cec_usr_message_list_t* cec_tx_message_list)
+{
+
+    if (cec_tx_message_list != NULL) {
+        list_del(&cec_tx_message_list->list);
+        kfree(cec_tx_message_list);
+        cec_tx_message_list = NULL;
+        printk("unregister_cec_tx_msg::tx_msg_cnt:%d\n", tx_msg_cnt);
+        if (tx_msg_cnt > 0) tx_msg_cnt--;
+    }
+}
+
+unsigned char check_cec_msg_valid(const cec_rx_message_t* pcec_message)
+{
+    unsigned char rt = 0;
+    unsigned char opcode;
+    unsigned char opernum;
+    unsigned char follower;
+    if (!pcec_message)
+        return rt;
+
+    opcode = pcec_message->content.msg.opcode;
+    opernum = pcec_message->operand_num;
+
+    switch (opcode) {
+        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
+        case CEC_OC_STANDBY:
+        case CEC_OC_RECORD_OFF:
+        case CEC_OC_RECORD_TV_SCREEN:
+        case CEC_OC_TUNER_STEP_DECREMENT:
+        case CEC_OC_TUNER_STEP_INCREMENT:
+        case CEC_OC_GIVE_AUDIO_STATUS:
+        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_USER_CONTROL_RELEASED:
+        case CEC_OC_GIVE_OSD_NAME:
+        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+        case CEC_OC_GET_CEC_VERSION:
+        case CEC_OC_GET_MENU_LANGUAGE:
+        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+        case CEC_OC_TEXT_VIEW_ON:
+        case CEC_OC_IMAGE_VIEW_ON:
+        case CEC_OC_ABORT_MESSAGE:
+        case CEC_OC_REQUEST_ACTIVE_SOURCE:
+            if ( opernum == 0)  rt = 1;
+            break;
+        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
+        case CEC_OC_RECORD_STATUS:
+        case CEC_OC_DECK_CONTROL:
+        case CEC_OC_DECK_STATUS:
+        case CEC_OC_GIVE_DECK_STATUS:
+        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
+        case CEC_OC_PLAY:
+        case CEC_OC_MENU_REQUEST:
+        case CEC_OC_MENU_STATUS:
+        case CEC_OC_REPORT_AUDIO_STATUS:
+        case CEC_OC_TIMER_CLEARED_STATUS:
+        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_USER_CONTROL_PRESSED:
+        case CEC_OC_CEC_VERSION:
+        case CEC_OC_REPORT_POWER_STATUS:
+        case CEC_OC_SET_AUDIO_RATE:
+            if ( opernum == 1)  rt = 1;
+            break;
+        case CEC_OC_INACTIVE_SOURCE:
+        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
+        case CEC_OC_FEATURE_ABORT:
+        case CEC_OC_ACTIVE_SOURCE:
+        case CEC_OC_ROUTING_INFORMATION:
+        case CEC_OC_SET_STREAM_PATH:
+            if (opernum == 2) rt = 1;
+            break;
+        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+        case CEC_OC_SET_MENU_LANGUAGE:
+        case CEC_OC_DEVICE_VENDOR_ID:
+            if (opernum == 3) rt = 1;
+            break;
+        case CEC_OC_ROUTING_CHANGE:
+        case CEC_OC_SELECT_ANALOGUE_SERVICE:
+            if (opernum == 4) rt = 1;
+            break;
+        case CEC_OC_VENDOR_COMMAND_WITH_ID:
+            if ((opernum > 3)&&(opernum < 15))  rt = 1;
+            break;
+        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+            if (opernum < 15)  rt = 1;
+            break;
+        case CEC_OC_SELECT_DIGITAL_SERVICE:
+            if (opernum == 7) rt = 1;
+            break;
+        case CEC_OC_SET_ANALOGUE_TIMER:
+        case CEC_OC_CLEAR_ANALOGUE_TIMER:
+            if (opernum == 11) rt = 1;
+            break;
+        case CEC_OC_SET_DIGITAL_TIMER:
+        case CEC_OC_CLEAR_DIGITAL_TIMER:
+            if (opernum == 14) rt = 1;
+            break;
+        case CEC_OC_TIMER_STATUS:
+            if ((opernum == 1 || opernum == 3)) rt = 1;
+            break;
+        case CEC_OC_TUNER_DEVICE_STATUS:
+            if ((opernum == 5 || opernum == 8)) rt = 1;
+            break;
+        case CEC_OC_RECORD_ON:
+            if (opernum > 0 && opernum < 9)  rt = 1;
+            break;
+        case CEC_OC_CLEAR_EXTERNAL_TIMER:
+        case CEC_OC_SET_EXTERNAL_TIMER:
+            if ((opernum == 9 || opernum == 10)) rt = 1;
+            break;
+        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
+        case CEC_OC_SET_OSD_NAME:
+            if (opernum > 0 && opernum < 15) rt = 1;
+            break;
+        case CEC_OC_SET_OSD_STRING:
+            if (opernum > 1 && opernum < 15) rt = 1;
+            break;
+        case CEC_OC_VENDOR_COMMAND:
+            if (opernum < 15)   rt = 1;
+            break;
+        default:
+            rt = 1;
+            break;
+    }
+
+ // for CTS12.2
+    follower = pcec_message->content.msg.header & 0x0f;
+    switch (opcode) {
+        case CEC_OC_ACTIVE_SOURCE:
+        case CEC_OC_REQUEST_ACTIVE_SOURCE:
+        case CEC_OC_ROUTING_CHANGE:
+        case CEC_OC_ROUTING_INFORMATION:
+        case CEC_OC_SET_STREAM_PATH:
+        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+        case CEC_OC_SET_MENU_LANGUAGE:
+        case CEC_OC_DEVICE_VENDOR_ID:
+            // broadcast only
+            if(follower != 0xf) rt = 0;
+            break;
+
+        case CEC_OC_IMAGE_VIEW_ON:
+        case CEC_OC_TEXT_VIEW_ON:
+        case CEC_OC_INACTIVE_SOURCE:
+        case CEC_OC_RECORD_OFF:
+        case CEC_OC_RECORD_ON:
+        case CEC_OC_RECORD_STATUS:
+        case CEC_OC_RECORD_TV_SCREEN:
+        case CEC_OC_CLEAR_ANALOGUE_TIMER:
+        case CEC_OC_CLEAR_DIGITAL_TIMER:
+        case CEC_OC_CLEAR_EXTERNAL_TIMER:
+        case CEC_OC_SET_ANALOGUE_TIMER:
+        case CEC_OC_SET_DIGITAL_TIMER:
+        case CEC_OC_SET_EXTERNAL_TIMER:
+        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
+        case CEC_OC_TIMER_CLEARED_STATUS:
+        case CEC_OC_TIMER_STATUS:
+        case CEC_OC_CEC_VERSION:
+        case CEC_OC_GET_CEC_VERSION:
+        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+        case CEC_OC_GET_MENU_LANGUAGE:
+        case CEC_OC_DECK_CONTROL:
+        case CEC_OC_DECK_STATUS:
+        case CEC_OC_GIVE_DECK_STATUS:
+        case CEC_OC_PLAY:
+        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
+        case CEC_OC_SELECT_ANALOGUE_SERVICE:
+        case CEC_OC_SELECT_DIGITAL_SERVICE:
+        case CEC_OC_TUNER_DEVICE_STATUS:
+        case CEC_OC_TUNER_STEP_DECREMENT:
+        case CEC_OC_TUNER_STEP_INCREMENT:
+        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+        case CEC_OC_VENDOR_COMMAND:
+        case CEC_OC_SET_OSD_STRING:
+        case CEC_OC_GIVE_OSD_NAME:
+        case CEC_OC_SET_OSD_NAME:
+        case CEC_OC_MENU_REQUEST:
+        case CEC_OC_MENU_STATUS:
+        case CEC_OC_USER_CONTROL_PRESSED:
+        case CEC_OC_USER_CONTROL_RELEASED:
+        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+        case CEC_OC_REPORT_POWER_STATUS:
+        case CEC_OC_FEATURE_ABORT:
+        case CEC_OC_ABORT_MESSAGE:
+        case CEC_OC_GIVE_AUDIO_STATUS:
+        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_REPORT_AUDIO_STATUS:
+        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
+        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_SET_AUDIO_RATE:
+            // directly addressed only
+            if(follower == 0xf) rt = 0;
+            break;
+
+        case CEC_OC_STANDBY:
+        case CEC_OC_VENDOR_COMMAND_WITH_ID:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
+        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
+            // both broadcast and directly addressed
+            break;
+
+        default:
+            break;
+    }
+
+    if ((rt == 0) & (opcode != 0)){
+        hdmirx_cec_dbg_print("CEC: opcode & opernum not match: %x, %x\n", opcode, opernum);
+    }
+    return rt;
+}
+
+static irqreturn_t cec_isr_handler(int irq, void *dev_instance)
+{
+    unsigned int intr_stat = 0;
+
+    //cec_disable_irq();
+    intr_stat = cec_intr_stat();
+    hdmi_print(INF, CEC "cec %s irq %x\n", (0x2 == intr_stat) ? "tx" : "rx",intr_stat);
+    if(!intr_stat){
+        cec_hw_reset();
+        return IRQ_HANDLED;
+    }
+        
+    if(intr_stat & (1<<1)) { // aocec tx intr
+        cec_tx_irq_handle();
+        //cec_enable_irq();
+        return IRQ_HANDLED;
+    }
+    
+    if((-1) == cec_rx_irq_handle(rx_msg, &rx_len)){
+        //cec_enable_irq();
+        return IRQ_HANDLED;
+    }
+
+    //register_cec_rx_msg(rx_msg, rx_len);
+    //wake_up(&hdmitx_device->cec_wait_rx);
+    tasklet_schedule(&cec_tasklet);
+
+    //cec_enable_irq();
+
+    return IRQ_HANDLED;
+}
+
+unsigned short cec_log_addr_to_dev_type(unsigned char log_addr)
+{
+    unsigned short us = CEC_UNREGISTERED_DEVICE_TYPE;
+    if ((1 << log_addr) & CEC_DISPLAY_DEVICE) {
+        us = CEC_DISPLAY_DEVICE_TYPE;
+    } else if ((1 << log_addr) & CEC_RECORDING_DEVICE) {
+        us = CEC_RECORDING_DEVICE_TYPE;
+    } else if ((1 << log_addr) & CEC_PLAYBACK_DEVICE) {
+        us = CEC_PLAYBACK_DEVICE_TYPE;
+    } else if ((1 << log_addr) & CEC_TUNER_DEVICE) {
+        us = CEC_TUNER_DEVICE_TYPE;
+    } else if ((1 << log_addr) & CEC_AUDIO_SYSTEM_DEVICE) {
+        us = CEC_AUDIO_SYSTEM_DEVICE_TYPE;
+    }
+
+    return us;
+}
+// -------------- command from cec devices ---------------------
+//***************************************************************
+void cec_device_vendor_id(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[5];
+    
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_DEVICE_VENDOR_ID;
+    msg[2] = (vendor_id >> 16) & 0xff;
+    msg[3] = (vendor_id >> 8) & 0xff;
+    msg[4] = (vendor_id >> 0) & 0xff;
+    
+    cec_ll_tx(msg, 5);
+}
+
+void cec_report_power_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[3];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_REPORT_POWER_STATUS;
+    msg[2] = cec_global_info.cec_node_info[index].power_status;
+    cec_ll_tx(msg, 3);
+
+}
+
+void cec_feature_abort(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char opcode = pcec_message->content.msg.opcode;
+    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
+    unsigned char dst_log_addr = pcec_message->content.msg.header & 0xf;
+    if(dst_log_addr != 0xf){
+        unsigned char msg[4];
+        
+        msg[0] = ((index & 0xf) << 4) | src_log_addr;
+        msg[1] = CEC_OC_FEATURE_ABORT;
+        msg[2] = opcode;
+        msg[3] = CEC_UNRECONIZED_OPCODE;
+        
+        cec_ll_tx(msg, 4);        
+    }
+}
+
+void cec_report_version(cec_rx_message_t* pcec_message)
+{
+    ;//todo
+}
+
+
+void cec_report_physical_address_smp(void)
+{
+    unsigned char msg[5]; 
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_REPORT_PHYSICAL_ADDRESS;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+    msg[4] = cec_global_info.cec_node_info[index].dev_type;
+
+    cec_ll_tx(msg, 5);
+        
+}
+
+void cec_imageview_on_smp(void)
+{
+    unsigned char msg[2];
+    unsigned char index = cec_global_info.my_node_index;
+
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {
+            msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+            msg[1] = CEC_OC_IMAGE_VIEW_ON;
+            cec_ll_tx(msg, 2);
+        }
+    }  
+}
+
+void cec_get_menu_language_smp(void)
+{
+    unsigned char msg[2];
+    unsigned char index = cec_global_info.my_node_index;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_GET_MENU_LANGUAGE;
+    
+    cec_ll_tx(msg, 2);
+    
+}
+
+void cec_menu_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char msg[3];
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
+
+     if(0xf != src_log_addr) {
+        msg[0] = ((index & 0xf) << 4) | src_log_addr;
+        msg[1] = CEC_OC_MENU_STATUS;
+        msg[2] = cec_global_info.cec_node_info[index].menu_status;
+        cec_ll_tx(msg, 3);
+    }
+}
+
+void cec_menu_status_smp(cec_device_menu_state_e status)
+{
+    unsigned char msg[3];
+    unsigned char index = cec_global_info.my_node_index;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_MENU_STATUS;
+    if(status == DEVICE_MENU_ACTIVE){
+        msg[2] = DEVICE_MENU_ACTIVE;
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
+    }else{
+        msg[2] = DEVICE_MENU_INACTIVE;
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
+    }
+    cec_ll_tx(msg, 3);
+}
+
+void cec_menu_status_smp_irq(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    if(1 == pcec_message->content.msg.operands[0]){
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_INACTIVE;
+    }else if(0 == pcec_message->content.msg.operands[0]){
+        cec_global_info.cec_node_info[index].menu_status = DEVICE_MENU_ACTIVE;
+    }
+}
+
+void cec_active_source_rx(cec_rx_message_t* pcec_message)
+{
+    unsigned int phy_addr_active;
+
+    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+
+	if(phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
+}
+
+void cec_active_source_smp(void)
+{
+    unsigned char msg[4];
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;      
+
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) {
+            msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+            msg[1] = CEC_OC_ACTIVE_SOURCE;
+            msg[2] = phy_addr_ab;
+            msg[3] = phy_addr_cd;
+            cec_ll_tx(msg, 4);
+        }
+    }
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+}
+void cec_active_source(cec_rx_message_t* pcec_message)
+{
+    unsigned char msg[4];
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_ACTIVE_SOURCE;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+    cec_ll_tx(msg, 4);
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+}
+
+
+void cec_set_stream_path(cec_rx_message_t* pcec_message)
+{
+    unsigned int phy_addr_active;
+
+    phy_addr_active = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+
+	if(phy_addr_active == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_active_source_smp();
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
+}
+void cec_set_system_audio_mode(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    MSG_P1( index, CEC_TV_ADDR,
+            CEC_OC_SET_SYSTEM_AUDIO_MODE,
+            cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode
+            );
+
+    cec_ll_tx(gbl_msg, 3);
+    if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == ON)
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
+    else
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
+}
+
+void cec_system_audio_mode_request(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    if(cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode == OFF){
+        MSG_P2( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST,
+                phy_addr_ab,
+                phy_addr_cd
+                );
+        cec_ll_tx(gbl_msg, 4);
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = ON;
+    }
+    else{
+        MSG_P0( index, CEC_AUDIO_SYSTEM_ADDR,//CEC_TV_ADDR,
+                CEC_OC_SYSTEM_AUDIO_MODE_REQUEST
+                );
+        cec_ll_tx(gbl_msg, 2);
+        cec_global_info.cec_node_info[index].specific_info.audio.sys_audio_mode = OFF;
+    }
+}
+
+void cec_report_audio_status(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    MSG_P1( index, CEC_TV_ADDR,
+            CEC_OC_REPORT_AUDIO_STATUS,
+            cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_mute_status | \
+            cec_global_info.cec_node_info[index].specific_info.audio.audio_status.audio_volume_status
+            );
+
+    cec_ll_tx(gbl_msg, 3);
+}
+void cec_request_active_source(cec_rx_message_t* pcec_message)
+{
+    cec_set_stream_path(pcec_message);
+}
+
+void cec_set_imageview_on_irq(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[2];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_IMAGE_VIEW_ON;
+
+    cec_ll_tx(msg, 2);
+}
+
+void cec_inactive_source(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[4];
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_INACTIVE_SOURCE;
+	msg[2] = phy_addr_ab;
+	msg[3] = phy_addr_cd;
+
+    cec_ll_tx(msg, 4);
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+}
+
+void cec_inactive_source_rx(cec_rx_message_t* pcec_message)
+{
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+}
+
+void cec_get_version(cec_rx_message_t* pcec_message)
+{
+    unsigned char dest_log_addr = pcec_message->content.msg.header&0xf;
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[3];
+
+    if (0xf != dest_log_addr) {
+        msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+        msg[1] = CEC_OC_CEC_VERSION;
+        msg[2] = CEC_VERSION_14A;
+        cec_ll_tx(msg, 3);
+    }
+}
+
+void cec_give_deck_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[3];
+
+    msg[0] = ((index & 0xf) << 4) | CEC_TV_ADDR;
+    msg[1] = CEC_OC_DECK_STATUS;
+    msg[2] = 0x1a;
+    cec_ll_tx(msg, 3);
+}
+
+
+void cec_deck_status(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    if (cec_global_info.dev_mask & (1 << index)) {
+        cec_global_info.cec_node_info[index].specific_info.playback.deck_info = pcec_message->content.msg.operands[0];
+        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_DECK_INfO;
+        hdmirx_cec_dbg_print("cec_deck_status: %x\n", cec_global_info.cec_node_info[index].specific_info.playback.deck_info);
+    }
+}
+
+// STANDBY: long press our remote control, send STANDBY to TV
+void cec_set_standby(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char msg[2];
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_STANDBY;
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK)) {
+        if(hdmitx_device->cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) {
+			cec_ll_tx(msg, 2);
+		}
+	}
+}
+
+void cec_set_osd_name(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+	unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
+    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
+    unsigned char msg[16];
+
+    if(0xf != src_log_addr) {
+        msg[0] = ((index & 0xf) << 4) | src_log_addr;
+        msg[1] = CEC_OC_SET_OSD_NAME;
+        memcpy(&msg[2], cec_global_info.cec_node_info[index].osd_name, osd_len);
+
+        cec_ll_tx(msg, 2 + osd_len);
+    }
+}
+
+void cec_set_osd_name_init(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+	unsigned char osd_len = strlen(cec_global_info.cec_node_info[index].osd_name);
+    unsigned char msg[16];
+
+    msg[0] = ((index & 0xf) << 4) | 0;
+    msg[1] = CEC_OC_SET_OSD_NAME;
+    memcpy(&msg[2], cec_global_info.cec_node_info[index].osd_name, osd_len);
+
+    cec_ll_tx(msg, 2 + osd_len);
+}
+
+void cec_vendor_cmd_with_id(cec_rx_message_t* pcec_message)
+{
+    ;//todo
+}
+
+
+void cec_set_menu_language(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char src_log_addr = (pcec_message->content.msg.header >> 4 )&0xf;
+
+    if(0x0 == src_log_addr) {
+        cec_global_info.cec_node_info[index].menu_lang = (int)((pcec_message->content.msg.operands[0] << 16)  |
+                                                               (pcec_message->content.msg.operands[1] <<  8)  |
+                                                               (pcec_message->content.msg.operands[2]));
+
+        switch_set_state(&lang_dev, cec_global_info.cec_node_info[index].menu_lang);
+        cec_global_info.cec_node_info[index].real_info_mask |= INFO_MASK_MENU_LANGUAGE;
+        hdmirx_cec_dbg_print("cec_set_menu_language:%c.%c.%c\n", (cec_global_info.cec_node_info[index].menu_lang >>16) & 0xff,
+                                                                 (cec_global_info.cec_node_info[index].menu_lang >> 8) & 0xff,
+                                                                 (cec_global_info.cec_node_info[index].menu_lang >> 0) & 0xff);
+    }
+}
+
+void cec_handle_message(cec_rx_message_t* pcec_message)
+{
+    unsigned char	brdcst, opcode;
+    unsigned char	initiator, follower;
+    unsigned char   operand_num;
+    unsigned char   msg_length;
+//#ifdef G9_CEC
+#if 0
+    return;
+#endif
+    /* parse message */
+    if ((!pcec_message) || (check_cec_msg_valid(pcec_message) == 0))
+        return;
+
+    initiator	= pcec_message->content.msg.header >> 4;
+    follower	= pcec_message->content.msg.header & 0x0f;
+    opcode		= pcec_message->content.msg.opcode;
+    operand_num = pcec_message->operand_num;
+    brdcst      = (follower == 0x0f);
+    msg_length  = pcec_message->msg_length;
+
+    if(0 == pcec_message->content.msg.header)
+        return;
+
+    /* process messages from tv polling and cec devices */
+    if(CEC_OC_GIVE_OSD_NAME == opcode)
+        cec_set_osd_name(pcec_message);
+    if(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))
+    {
+
+        switch (opcode) {
+        case CEC_OC_ACTIVE_SOURCE:
+            cec_active_source_rx(pcec_message);
+            break;
+        case CEC_OC_INACTIVE_SOURCE:
+            break;
+        case CEC_OC_CEC_VERSION:
+            break;
+        case CEC_OC_DECK_STATUS:
+            break;
+        case CEC_OC_DEVICE_VENDOR_ID:
+            break;
+        case CEC_OC_FEATURE_ABORT:
+            break;
+        case CEC_OC_GET_CEC_VERSION:
+            cec_get_version(pcec_message);
+            break;
+        case CEC_OC_GIVE_DECK_STATUS:
+            cec_give_deck_status(pcec_message);
+            break;
+        case CEC_OC_MENU_STATUS:
+            cec_menu_status_smp_irq(pcec_message);
+            break;
+        case CEC_OC_REPORT_PHYSICAL_ADDRESS:
+            break;
+        case CEC_OC_REPORT_POWER_STATUS:
+            break;
+        case CEC_OC_SET_OSD_NAME:
+            break;
+        case CEC_OC_VENDOR_COMMAND_WITH_ID:
+            break;
+        case CEC_OC_SET_MENU_LANGUAGE:
+            cec_set_menu_language(pcec_message);
+            break;
+        case CEC_OC_GIVE_PHYSICAL_ADDRESS:
+            cec_report_physical_address_smp();
+            break;
+        case CEC_OC_GIVE_DEVICE_VENDOR_ID:
+            cec_device_vendor_id(pcec_message);
+            break;
+        case CEC_OC_GIVE_OSD_NAME:
+            break;
+        case CEC_OC_STANDBY:
+            cec_inactive_source_rx(pcec_message);
+            cec_standby(pcec_message);
+            break;
+        case CEC_OC_SET_STREAM_PATH:
+            cec_set_stream_path(pcec_message);
+            break;
+        case CEC_OC_REQUEST_ACTIVE_SOURCE:
+            if(cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status != DEVICE_MENU_ACTIVE)
+                break;
+            cec_active_source_smp();
+            break;
+        case CEC_OC_GIVE_DEVICE_POWER_STATUS:
+            cec_report_power_status(pcec_message);
+            break;
+        case CEC_OC_USER_CONTROL_PRESSED:
+            break;
+        case CEC_OC_USER_CONTROL_RELEASED:
+            break;
+        case CEC_OC_IMAGE_VIEW_ON:      //not support in source
+            cec_usrcmd_set_imageview_on( CEC_TV_ADDR );   // Wakeup TV
+            break;
+        case CEC_OC_ROUTING_CHANGE:
+            cec_routing_change(pcec_message);
+            break;
+        case CEC_OC_ROUTING_INFORMATION:
+        	cec_routing_information(pcec_message);
+        	break;
+        case CEC_OC_GIVE_AUDIO_STATUS:
+        	cec_report_audio_status();
+        	break;
+        case CEC_OC_MENU_REQUEST:
+            cec_menu_status(pcec_message);
+            break;
+        case CEC_OC_PLAY:
+            hdmi_print(INF,CEC, "CEC_OC_PLAY:0x%x\n",pcec_message->content.msg.operands[0]);
+            switch(pcec_message->content.msg.operands[0]){
+                case 0x24:
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    break;
+                case 0x25:
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 1);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_PLAYPAUSE, 0);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case CEC_OC_DECK_CONTROL:
+            hdmi_print(INF, CEC "CEC_OC_DECK_CONTROL:0x%x\n",pcec_message->content.msg.operands[0]);
+            switch(pcec_message->content.msg.operands[0]){
+                case 0x3:
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_STOP, 1);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    input_event(cec_global_info.remote_cec_dev, EV_KEY, KEY_STOP, 0);
+                    input_sync(cec_global_info.remote_cec_dev);
+                    break;
+                default:
+                    break;
+            }
+            break;
+        case CEC_OC_GET_MENU_LANGUAGE:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_DOWN:
+        case CEC_OC_VENDOR_REMOTE_BUTTON_UP:
+        case CEC_OC_CLEAR_ANALOGUE_TIMER:
+        case CEC_OC_CLEAR_DIGITAL_TIMER:
+        case CEC_OC_CLEAR_EXTERNAL_TIMER:
+        case CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_GIVE_TUNER_DEVICE_STATUS:
+        case CEC_OC_SET_OSD_STRING:
+        case CEC_OC_SET_SYSTEM_AUDIO_MODE:
+        case CEC_OC_SET_TIMER_PROGRAM_TITLE:
+        case CEC_OC_SYSTEM_AUDIO_MODE_REQUEST:
+        case CEC_OC_SYSTEM_AUDIO_MODE_STATUS:
+        case CEC_OC_TEXT_VIEW_ON:
+        case CEC_OC_TIMER_CLEARED_STATUS:
+        case CEC_OC_TIMER_STATUS:
+        case CEC_OC_TUNER_DEVICE_STATUS:
+        case CEC_OC_TUNER_STEP_DECREMENT:
+        case CEC_OC_TUNER_STEP_INCREMENT:
+        case CEC_OC_VENDOR_COMMAND:
+        case CEC_OC_SELECT_ANALOGUE_SERVICE:
+        case CEC_OC_SELECT_DIGITAL_SERVICE:
+        case CEC_OC_SET_ANALOGUE_TIMER :
+        case CEC_OC_SET_AUDIO_RATE:
+        case CEC_OC_SET_DIGITAL_TIMER:
+        case CEC_OC_SET_EXTERNAL_TIMER:
+        case CEC_OC_RECORD_OFF:
+        case CEC_OC_RECORD_ON:
+        case CEC_OC_RECORD_STATUS:
+        case CEC_OC_RECORD_TV_SCREEN:
+        case CEC_OC_REPORT_AUDIO_STATUS:
+        case CEC_OC_ABORT_MESSAGE:
+            cec_feature_abort(pcec_message);
+            break;
+        default:
+            break;
+        }
+    }
+}
+
+
+// --------------- cec command from user application --------------------
+
+void cec_usrcmd_parse_all_dev_online(void)
+{
+    int i;
+    unsigned short tmp_mask;
+
+    hdmirx_cec_dbg_print("cec online: ###############################################\n");
+    hdmirx_cec_dbg_print("active_log_dev %x\n", cec_global_info.active_log_dev);
+    for (i = 0; i < MAX_NUM_OF_DEV; i++) {
+        tmp_mask = 1 << i;
+        if (tmp_mask & cec_global_info.dev_mask) {
+            hdmirx_cec_dbg_print("cec online: -------------------------------------------\n");
+            hdmirx_cec_dbg_print("hdmi_port:     %x\n", cec_global_info.cec_node_info[i].hdmi_port);
+            hdmirx_cec_dbg_print("dev_type:      %x\n", cec_global_info.cec_node_info[i].dev_type);
+            hdmirx_cec_dbg_print("power_status:  %x\n", cec_global_info.cec_node_info[i].power_status);
+            hdmirx_cec_dbg_print("cec_version:   %x\n", cec_global_info.cec_node_info[i].cec_version);
+            hdmirx_cec_dbg_print("vendor_id:     %x\n", cec_global_info.cec_node_info[i].vendor_id);
+            hdmirx_cec_dbg_print("phy_addr:      %x\n", cec_global_info.cec_node_info[i].phy_addr.phy_addr_4);
+            hdmirx_cec_dbg_print("log_addr:      %x\n", cec_global_info.cec_node_info[i].log_addr);
+            hdmirx_cec_dbg_print("osd_name:      %s\n", cec_global_info.cec_node_info[i].osd_name);
+            hdmirx_cec_dbg_print("osd_name_def:  %s\n", cec_global_info.cec_node_info[i].osd_name_def);
+            hdmirx_cec_dbg_print("menu_state:    %x\n", cec_global_info.cec_node_info[i].menu_state);
+
+            if (cec_global_info.cec_node_info[i].dev_type == CEC_PLAYBACK_DEVICE_TYPE) {
+                hdmirx_cec_dbg_print("deck_cnt_mode: %x\n", cec_global_info.cec_node_info[i].specific_info.playback.deck_cnt_mode);
+                hdmirx_cec_dbg_print("deck_info:     %x\n", cec_global_info.cec_node_info[i].specific_info.playback.deck_info);
+                hdmirx_cec_dbg_print("play_mode:     %x\n", cec_global_info.cec_node_info[i].specific_info.playback.play_mode);
+            }
+        }
+    }
+    hdmirx_cec_dbg_print("##############################################################\n");
+}
+
+void cec_usrcmd_get_cec_version(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr,
+            CEC_OC_GET_CEC_VERSION);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_audio_status(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_AUDIO_STATUS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_deck_status(unsigned char log_addr)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DECK_STATUS, STATUS_REQ_ON);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_set_deck_cnt_mode(unsigned char log_addr, deck_cnt_mode_e deck_cnt_mode)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_DECK_CONTROL, deck_cnt_mode);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_get_device_power_status(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_POWER_STATUS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_device_vendor_id(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_DEVICE_VENDOR_ID);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_osd_name(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_OSD_NAME);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_physical_address(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_PHYSICAL_ADDRESS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_system_audio_mode_status(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_SYSTEM_AUDIO_MODE_STATUS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_set_standby(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_STANDBY);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+/////////////////////////
+void cec_usrcmd_set_imageview_on(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr,
+            CEC_OC_IMAGE_VIEW_ON);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_text_view_on(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr,
+            CEC_OC_TEXT_VIEW_ON);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_tuner_device_status(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GIVE_TUNER_DEVICE_STATUS);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_set_play_mode(unsigned char log_addr, play_mode_e play_mode)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_PLAY, play_mode);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_get_menu_state(unsigned char log_addr)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, MENU_REQ_QUERY);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_set_menu_state(unsigned char log_addr, menu_req_type_e menu_req_type)
+{
+    MSG_P1(cec_global_info.my_node_index, log_addr, CEC_OC_MENU_REQUEST, menu_req_type);
+
+    cec_ll_tx(gbl_msg, 3);
+}
+
+void cec_usrcmd_get_menu_language(unsigned char log_addr)
+{
+    MSG_P0(cec_global_info.my_node_index, log_addr, CEC_OC_GET_MENU_LANGUAGE);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_get_active_source(void)
+{
+    MSG_P0(cec_global_info.my_node_index, 0xF, CEC_OC_REQUEST_ACTIVE_SOURCE);
+
+    cec_ll_tx(gbl_msg, 2);
+}
+
+void cec_usrcmd_set_active_source(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    MSG_P2(index, CEC_BROADCAST_ADDR,
+            CEC_OC_ACTIVE_SOURCE,
+			phy_addr_ab,
+			phy_addr_cd);
+
+    cec_ll_tx(gbl_msg, 4);
+}
+
+void cec_usrcmd_set_deactive_source(unsigned char log_addr)
+{
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    MSG_P2(cec_global_info.my_node_index, log_addr, CEC_OC_INACTIVE_SOURCE,
+           phy_addr_ab,
+           phy_addr_cd);
+
+    cec_ll_tx(gbl_msg, 4);
+}
+
+void cec_usrcmd_clear_node_dev_real_info_mask(unsigned char log_addr, cec_info_mask mask)
+{
+    cec_global_info.cec_node_info[log_addr].real_info_mask &= ~mask;
+}
+
+
+void cec_usrcmd_set_osd_name(cec_rx_message_t* pcec_message)
+{
+
+    unsigned char log_addr = pcec_message->content.msg.header >> 4 ;
+    unsigned char index = cec_global_info.my_node_index;
+
+    MSG_P14(index, log_addr,
+            CEC_OC_SET_OSD_NAME,
+            cec_global_info.cec_node_info[index].osd_name[0],
+            cec_global_info.cec_node_info[index].osd_name[1],
+            cec_global_info.cec_node_info[index].osd_name[2],
+            cec_global_info.cec_node_info[index].osd_name[3],
+            cec_global_info.cec_node_info[index].osd_name[4],
+            cec_global_info.cec_node_info[index].osd_name[5],
+            cec_global_info.cec_node_info[index].osd_name[6],
+            cec_global_info.cec_node_info[index].osd_name[7],
+            cec_global_info.cec_node_info[index].osd_name[8],
+            cec_global_info.cec_node_info[index].osd_name[9],
+            cec_global_info.cec_node_info[index].osd_name[10],
+            cec_global_info.cec_node_info[index].osd_name[11],
+            cec_global_info.cec_node_info[index].osd_name[12],
+            cec_global_info.cec_node_info[index].osd_name[13]);
+
+    cec_ll_tx(gbl_msg, 16);
+}
+
+
+
+void cec_usrcmd_set_device_vendor_id(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+
+    MSG_P3(index, CEC_BROADCAST_ADDR,
+            CEC_OC_DEVICE_VENDOR_ID,
+            (cec_global_info.cec_node_info[index].vendor_id >> 16) & 0xff,
+            (cec_global_info.cec_node_info[index].vendor_id >> 8) & 0xff,
+            (cec_global_info.cec_node_info[index].vendor_id >> 0) & 0xff);
+
+    cec_ll_tx(gbl_msg, 5);
+}
+void cec_usrcmd_set_report_physical_address(void)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+
+    MSG_P3(index, CEC_BROADCAST_ADDR,
+           CEC_OC_REPORT_PHYSICAL_ADDRESS,
+           phy_addr_ab,
+           phy_addr_cd,
+           CEC_PLAYBACK_DEVICE_TYPE);
+
+    cec_ll_tx(gbl_msg, 5);
+}
+
+void cec_routing_change(cec_rx_message_t* pcec_message)
+{
+    unsigned int phy_addr_origin;
+    unsigned int phy_addr_destination;
+
+    phy_addr_origin = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                    (pcec_message->content.msg.operands[1] << 0));
+    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[2] << 8) |
+                                         (pcec_message->content.msg.operands[3] << 0));
+
+	if(phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
+}
+
+void cec_routing_information(cec_rx_message_t* pcec_message)
+{
+    unsigned char index = cec_global_info.my_node_index;
+    unsigned char phy_addr_ab = (aml_read_reg32(P_AO_DEBUG_REG1) >> 8) & 0xff;
+    unsigned char phy_addr_cd = aml_read_reg32(P_AO_DEBUG_REG1) & 0xff;
+    unsigned int phy_addr_destination;
+    unsigned char msg[4];
+
+    phy_addr_destination = (unsigned int)((pcec_message->content.msg.operands[0] << 8) |
+                                         (pcec_message->content.msg.operands[1] << 0));
+
+	if(phy_addr_destination == (aml_read_reg32(P_AO_DEBUG_REG1) & 0xffff)){
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_ACTIVE;
+    msg[0] = ((index & 0xf) << 4) | CEC_BROADCAST_ADDR;
+    msg[1] = CEC_OC_ROUTING_INFORMATION;
+    msg[2] = phy_addr_ab;
+    msg[3] = phy_addr_cd;
+    cec_ll_tx(msg, 4);
+	}else{
+	    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_status = DEVICE_MENU_INACTIVE;
+	}
+}
+/***************************** cec middle level code end *****************************/
+
+
+/***************************** cec high level code *****************************/
+
+static int __init cec_init(void)
+{
+    int i;
+    int ret;
+    extern __u16 cec_key_map[128];
+    extern hdmitx_dev_t * get_hdmitx_device(void);
+    hdmitx_device = get_hdmitx_device();
+    //init_waitqueue_head(&hdmitx_device->cec_wait_rx);
+    cec_key_init();
+    hdmi_print(INF, CEC "CEC init\n");
+    cec_global_info.cec_flag.cec_key_flag = 0; 
+    cec_global_info.cec_flag.cec_fiq_flag = 0;
+    cec_global_info.cec_flag.cec_init_flag = 0;
+    
+
+
+    ret = alloc_chrdev_region(&devno, 0, 30, DEVICE_NAME);
+
+    if(ret < 0)
+    {
+        hdmi_print(INF, CEC "cec chrdev region fail\n");
+        return ret;
+    }
+
+    cec_devp = kmalloc(sizeof(struct cec_dev), GFP_KERNEL);
+    if(!cec_devp)
+    {
+        ret = - ENOMEM;
+        hdmi_print(INF, CEC "cec kmalloc fail\n");
+        goto out;
+    }
+    memset(cec_devp, 0, sizeof(struct cec_dev));
+    cec_setup_cdev();
+
+    cec_class = class_create(THIS_MODULE, "hdmitx_aocec");
+    if (IS_ERR(cec_class))
+    {
+        unregister_chrdev_region(devno, 1);
+        hdmi_print(INF, CEC "cec class create fail\n");
+        goto out;
+    }
+
+    cec_device = device_create(cec_class, NULL, devno, NULL, DEVICE_NAME);
+
+    sema_init(&cec_devp->sem, 1);
+    init_waitqueue_head(&cec_devp->r_wait);
+    init_waitqueue_head(&cec_devp->w_wait);
+
+    cec_global_info.cec_rx_msg_buf.rx_write_pos = 0;
+    cec_global_info.cec_rx_msg_buf.rx_read_pos = 0;
+    cec_global_info.cec_rx_msg_buf.rx_buf_size = sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message)/sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message[0]);
+    memset(cec_global_info.cec_rx_msg_buf.cec_rx_message, 0, sizeof(cec_global_info.cec_rx_msg_buf.cec_rx_message));
+
+    memset(&cec_global_info, 0, sizeof(cec_global_info_t));
+    
+    cec_global_info.hdmitx_device = hdmitx_device;
+    
+    hdmitx_device->task_cec = kthread_run(cec_task, (void*)hdmitx_device, "kthread_cec");
+
+    if(request_irq(INT_AO_CEC, &cec_isr_handler,
+                IRQF_SHARED, "amhdmitx-aocec",
+                (void *)hdmitx_device)){
+        hdmi_print(INF, CEC "Can't register IRQ %d\n",INT_HDMI_CEC);
+        return -EFAULT;
+    }
+
+    cec_global_info.remote_cec_dev = input_allocate_device();
+    if (!cec_global_info.remote_cec_dev)
+    {
+        hdmi_print(INF, CEC "remote_cec.c: Not enough memory\n");
+    }
+    cec_global_info.remote_cec_dev->name = "cec_input";
+
+    cec_global_info.remote_cec_dev->evbit[0] = BIT_MASK(EV_KEY);
+    cec_global_info.remote_cec_dev->keybit[BIT_WORD(BTN_0)] = BIT_MASK(BTN_0);
+    cec_global_info.remote_cec_dev->id.bustype = BUS_ISA;
+    cec_global_info.remote_cec_dev->id.vendor = 0x1b8e;
+    cec_global_info.remote_cec_dev->id.product = 0x0cec;
+    cec_global_info.remote_cec_dev->id.version = 0x0001;
+
+    for (i = 0; i < 128; i++){
+          set_bit( cec_key_map[i], cec_global_info.remote_cec_dev->keybit);
+      }
+
+    if(input_register_device(cec_global_info.remote_cec_dev)) {
+        hdmi_print(INF, CEC "remote_cec.c: Failed to register device\n");
+        input_free_device(cec_global_info.remote_cec_dev);
+    }
+
+    hdmitx_device->cec_init_ready = 1;
+    hdmi_print(INF, CEC "hdmitx_device->cec_init_ready:0x%x", hdmitx_device->cec_init_ready);
+    return 0;
+    out:unregister_chrdev_region(devno, 1);
+    return ret;
+}
+
+static void __exit cec_uninit(void)
+{
+    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))) {
+        return ;
+    }
+    hdmi_print(INF, CEC "cec uninit!\n");
+    if (cec_global_info.cec_flag.cec_init_flag == 1) {
+
+        free_irq(INT_AO_CEC, (void *)hdmitx_device);
+        
+    	kthread_stop(hdmitx_device->task_cec);
+        cec_global_info.cec_flag.cec_init_flag = 0;
+    }
+    
+    cdev_del(&cec_devp->cdev);
+    device_destroy(cec_class, devno);
+    class_destroy(cec_class);
+    unregister_chrdev_region(devno, 1);
+
+    hdmitx_device->cec_init_ready = 0;
+    input_unregister_device(cec_global_info.remote_cec_dev);
+    cec_global_info.cec_flag.cec_fiq_flag = 0;
+}
+
+size_t cec_usrcmd_get_global_info(char * buf)
+{
+    int i = 0;
+    int dev_num = 0;
+
+    cec_node_info_t * buf_node_addr = (cec_node_info_t *)(buf + (unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online));
+
+    for (i = 0; i < MAX_NUM_OF_DEV; i++) {
+        if (cec_global_info.dev_mask & (1 << i)) {
+            memcpy(&(buf_node_addr[dev_num]), &(cec_global_info.cec_node_info[i]), sizeof(cec_node_info_t));
+            dev_num++;
+        }
+    }
+
+    buf[0] = dev_num;
+    buf[1] = cec_global_info.active_log_dev;
+#if 0
+    hdmi_print(INF, CEC "\n");
+    hdmi_print(INF, CEC "%x\n",(unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online));
+    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->dev_number);
+    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->active_log_dev);
+    hdmi_print(INF, CEC "%x\n", ((cec_global_info_to_usr_t*)buf)->cec_node_info_online[0].hdmi_port);
+    for (i=0; i < (sizeof(cec_node_info_t) * dev_num) + 2; i++) {
+        hdmi_print(INF, CEC "%x,",buf[i]);
+    }
+    hdmi_print(INF, CEC "\n");
+#endif
+    return (sizeof(cec_node_info_t) * dev_num) + (unsigned int)(((cec_global_info_to_usr_t*)0)->cec_node_info_online);
+}
+
+void cec_usrcmd_set_lang_config(const char * buf, size_t count)
+{
+    char tmpbuf[128];
+    int i=0;
+
+    while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
+        tmpbuf[i]=buf[i];
+        i++;    
+    }
+
+    cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang = simple_strtoul(tmpbuf, NULL, 16);
+
+}
+void cec_usrcmd_set_config(const char * buf, size_t count)
+{
+    int i = 0;
+    int j = 0;
+    unsigned long value;
+    char param[16] = {0};
+
+    if(count > 32){
+        hdmi_print(INF, CEC "too many args\n");
+    }
+    for(i = 0; i < count; i++){
+        if ( (buf[i] >= '0') && (buf[i] <= 'f') ){
+            param[j] = simple_strtoul(&buf[i], NULL, 16);
+            j ++;
+        }
+        while ( buf[i] != ' ' )
+            i ++;
+    }
+    value = aml_read_reg32(P_AO_DEBUG_REG0) & 0x1;
+    aml_set_reg32_bits(P_AO_DEBUG_REG0, param[0], 0, 4);
+    hdmitx_device->cec_func_config = aml_read_reg32(P_AO_DEBUG_REG0);
+    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))) {
+        return ;
+    }
+    if((0 == value) && (1 == (param[0] & 1))){
+        hdmitx_device->cec_init_ready = 1;
+        hdmitx_device->hpd_state = 1;
+        
+        cec_node_init(hdmitx_device);
+    }
+    if((1 == (param[0] & 1)) && (0x2 == (value & 0x2)) && (0x0 == (param[0] & 0x2))){
+        cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+    }
+    if((1 == (param[0] & 1)) && (0x0 == (value & 0x2)) && (0x2 == (param[0] & 0x2))){
+        cec_active_source_smp();
+    }
+    hdmi_print(INF, CEC "cec_func_config:0x%x : 0x%x\n",hdmitx_device->cec_func_config, aml_read_reg32(P_AO_DEBUG_REG0));
+}
+
+unsigned int dispatch_buffer_parse(const char *buf, const char *string,  char *param, size_t count){
+    unsigned int i;
+    unsigned int j;
+    unsigned int len;
+    
+    j = 0;
+    len = ('\0' == *string) ? 0 : 1 ;
+    for(i = strlen(string) + len; i < count; i++){
+        param[j] = simple_strtoul(&buf[i], NULL, 16);
+        printk("param[%d]:0x%x\n", j, param[j]);
+        j ++;
+        while ( (buf[i] != ' ') && (buf[i] != ',') )
+            i ++;
+    }
+    param[j]=0;
+    return j;
+}
+
+void cec_usrcmd_set_dispatch(const char * buf, size_t count)
+{
+    int i = 0;
+//    int j = 0;
+    int bool = 0;
+    char param[32] = {0};
+    unsigned bit_set;
+    unsigned time_set;
+    unsigned param_count;
+    unsigned char msg[4] = {0};
+    unsigned char log_buf[912] = {0};
+    int pos = 0;
+    
+    hdmi_print(INF, CEC "cec usrcmd set dispatch start:\n");
+    if(!hdmitx_device->hpd_state) { //if none HDMI out,no CEC features.
+        hdmi_print(INF, CEC "HPD low!\n");
+        return;
+    }
+    
+    if(!(hdmitx_device->cec_func_config & (1 << CEC_FUNC_MSAK))){
+        hdmi_print(INF, CEC "cec function masked!\n");
+        return;
+    }
+        
+    if(count > 32){
+        hdmi_print(INF, CEC "too many args\n");
+    }
+    
+    if(!strncmp(buf, "waocec", 6))
+    {
+        bit_set = simple_strtoul(buf+6, NULL, 16);
+        time_set = simple_strtoul(buf+8, NULL, 16);
+        //cec_arbit_bit_time_set(bit_set, time_set, 1);
+    }else if(!strncmp(buf, "raocec", 6))
+    {
+        //cec_arbit_bit_time_read();
+    }else if(!strncmp(buf, "wcec", 4))
+    {
+        param_count = dispatch_buffer_parse(buf, "wcec", param, count);
+        printk("G9 CEC msg: param_count:%d :", param_count);
+        printk("%s\n", buf );
+        cec_ll_tx(param, param_count);
+    }else if(!strncmp(buf, "rcec", 4))
+    {
+        pos = 0;
+        pos += sprintf(log_buf + pos, "CEC rx msg::");
+        for (i = 0; i < cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos - 1].msg_length; ++i)
+        {
+            pos += sprintf(log_buf + pos, "%02x ", cec_global_info.cec_rx_msg_buf.cec_rx_message[cec_global_info.cec_rx_msg_buf.rx_write_pos - 1].content.buffer[i]);
+        }
+        pos += sprintf(log_buf + pos, "\n");
+        log_buf[pos] = '\0';
+        printk("%s", log_buf);
+        return;
+    }else if(!strncmp(buf, "dumpaocec", 9))
+    {
+        pos = 0;
+        for (i = 0; i < 0x68; ++i)
+        {
+            if(!(i%8))
+                pos += sprintf(log_buf + pos, "\nAO_CEC[0x%02x]:: ", i);
+            //pos += sprintf(log_buf + pos, "0x%02x  ", (unsigned char)aocec_rd_reg(i)); //modifiy later
+
+        }
+        
+        for (i = 0; i < 5; ++i)
+        {
+            pos += sprintf(log_buf + pos, "\nAO_REG[0x%x]:: 0x%x",
+            AOBUS_REG_ADDR( (0x00 << 10) | ((0x40 + i)<< 2) ),
+            aml_read_reg32( AOBUS_REG_ADDR( (0x00 << 10) | ((0x40 + i)<< 2)) ) );
+        }
+        pos += sprintf(log_buf + pos, "\n");
+        log_buf[pos] = '\0';
+        printk("%s", log_buf);
+        return;
+    }
+    
+    dispatch_buffer_parse(buf, "", param, count);
+    switch (param[0]) {
+    case GET_CEC_VERSION:   //0 LA
+        cec_usrcmd_get_cec_version(param[1]);
+        break;
+    case GET_DEV_POWER_STATUS:
+        cec_usrcmd_get_device_power_status(param[1]);
+        break;
+    case GET_DEV_VENDOR_ID:
+        cec_usrcmd_get_device_vendor_id(param[1]);
+        break;
+    case GET_OSD_NAME:
+        cec_usrcmd_get_osd_name(param[1]);
+        break;
+    case GET_PHYSICAL_ADDR:
+        cec_usrcmd_get_physical_address(param[1]);
+        break;
+    case SET_STANDBY:       //d LA
+        cec_usrcmd_set_standby(param[1]);
+        break;
+    case SET_IMAGEVIEW_ON:  //e LA
+        cec_usrcmd_set_imageview_on(param[1]);
+        break;
+    case GIVE_DECK_STATUS:
+        cec_usrcmd_get_deck_status(param[1]);
+        break;
+    case SET_DECK_CONTROL_MODE:
+        cec_usrcmd_set_deck_cnt_mode(param[1], param[2]);
+        break;
+    case SET_PLAY_MODE:
+        cec_usrcmd_set_play_mode(param[1], param[2]);
+        break;
+    case GET_SYSTEM_AUDIO_MODE:
+        cec_usrcmd_get_system_audio_mode_status(param[1]);
+        break;
+    case GET_TUNER_DEV_STATUS:
+        cec_usrcmd_get_tuner_device_status(param[1]);
+        break;
+    case GET_AUDIO_STATUS:
+        cec_usrcmd_get_audio_status(param[1]);
+        break;
+    case GET_OSD_STRING:
+        break;
+    case GET_MENU_STATE:
+        cec_usrcmd_get_menu_state(param[1]);
+        break;
+    case SET_MENU_STATE:
+        cec_usrcmd_set_menu_state(param[1], param[2]);
+        break;
+    case SET_MENU_LANGAGE:
+        break;
+    case GET_MENU_LANGUAGE:
+        cec_usrcmd_get_menu_language(param[1]);
+        break;
+    case GET_ACTIVE_SOURCE:     //13
+        cec_usrcmd_get_active_source();
+        break;
+    case SET_ACTIVE_SOURCE:
+        cec_usrcmd_set_active_source();
+        break;
+    case SET_DEACTIVE_SOURCE:
+        cec_usrcmd_set_deactive_source(param[1]);
+        break;
+    case REPORT_PHYSICAL_ADDRESS:    //17
+    	cec_usrcmd_set_report_physical_address();
+    	break;
+    case SET_TEXT_VIEW_ON:          //18 LA
+    	cec_usrcmd_text_view_on(param[1]);
+        break;
+    case POLLING_ONLINE_DEV:    //19 LA
+        cec_polling_online_dev(param[1], &bool);
+        break;
+
+    case CEC_OC_MENU_STATUS:
+        cec_menu_status_smp(DEVICE_MENU_INACTIVE);
+        break;
+    case CEC_OC_ABORT_MESSAGE:
+
+        msg[0] = 0x40;
+        msg[1] = CEC_OC_FEATURE_ABORT;
+        msg[2] = 0;
+        msg[3] = CEC_UNRECONIZED_OPCODE;
+
+        cec_ll_tx(msg, 4);
+        break;
+    case PING_TV:    //0x1a LA : For TV CEC detected.
+        detect_tv_support_cec(param[1]);
+        break;
+    default:
+        break;
+    }
+    hdmi_print(INF, CEC "cec usrcmd set dispatch end!\n\n");
+}
+
+/***************************** cec high level code end *****************************/
+
+
+
+late_initcall(cec_init);
+module_exit(cec_uninit);
+MODULE_DESCRIPTION("AMLOGIC HDMI TX CEC driver");
+MODULE_LICENSE("GPL");
+//MODULE_LICENSE("Dual BSD/GPL");
+//MODULE_VERSION("1.0.0");
+
+MODULE_PARM_DESC(cec_msg_dbg_en, "\n cec_msg_dbg_en\n");
+module_param(cec_msg_dbg_en, bool, 0664);
+
+
+
+
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_edid.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_edid.c
new file mode 100644
index 00000000..7e0bb8c2
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_edid.c
@@ -0,0 +1,1581 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/uaccess.h>
+//#include <mach/register.h>
+#include <plat/io.h>
+//#include "hw/hdmi_tx_reg.h"
+#include <crypto/hash.h>
+#include <linux/crypto.h>
+#include <linux/scatterlist.h>
+#include <mach/am_regs.h>
+
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+
+#define CEA_DATA_BLOCK_COLLECTION_ADDR_1StP 0x04
+#define VIDEO_TAG 0x40
+#define AUDIO_TAG 0x20
+#define VENDOR_TAG 0x60
+#define SPEAKER_TAG 0x80
+
+
+
+#define HDMI_EDID_BLOCK_TYPE_RESERVED     0
+#define HDMI_EDID_BLOCK_TYPE_AUDIO        1
+#define HDMI_EDID_BLOCK_TYPE_VIDEO        2
+#define HDMI_EDID_BLOCK_TYPE_VENDER       3
+#define HDMI_EDID_BLOCK_TYPE_SPEAKER      4
+#define HDMI_EDID_BLOCK_TYPE_VESA         5
+#define HDMI_EDID_BLOCK_TYPE_RESERVED2    6
+#define HDMI_EDID_BLOCK_TYPE_EXTENDED_TAG 7
+
+#define EDID_DETAILED_TIMING_DES_BLOCK0_POS 0x36
+#define EDID_DETAILED_TIMING_DES_BLOCK1_POS 0x48
+#define EDID_DETAILED_TIMING_DES_BLOCK2_POS 0x5A
+#define EDID_DETAILED_TIMING_DES_BLOCK3_POS 0x6C
+
+
+//-----------------------------------------------------------
+static int Edid_DecodeHeader(HDMI_TX_INFO_t *info, unsigned char *buff)
+{
+    int i, ret = 0;
+//    UpdateCRC16WithBlock( pCRC16, 8, Data);
+    if(!(buff[0] | buff[7]))
+    {
+        for(i = 1; i < 7; i++){
+           if(buff[i]!= 0xFF)
+               {
+                info->output_state = CABLE_PLUGIN_DVI_OUT;
+                ret = -1;
+               }
+        }
+    }
+    else
+        {
+            info->output_state = CABLE_PLUGIN_DVI_OUT;
+            ret = -1;
+        }
+    return ret;
+}
+
+static void Edid_ReceiverBrandNameParse(rx_cap_t * pRxCap, unsigned char * data)
+{
+    int i;
+    unsigned char uppercase[26] = { 0 };
+    unsigned char brand[3];
+
+    // Fill array uppercase with 'A' to 'Z'
+    for(i = 0; i < 26; i++)
+        uppercase[i] = 'A' + i;
+
+    brand[0] = data[0] >> 2;
+    brand[1] = ((data[0] & 0x3) << 3) + (data[1] >> 5);
+    brand[2] = data[1] & 0x1f;
+
+    for(i = 0; i < 3; i++) {
+        pRxCap->ReceiverBrandName[i] = uppercase[brand[i] - 1];
+    }
+}
+
+static int Edid_find_name_block(unsigned char * data)
+{
+    int ret = 0;
+    int i;
+    for(i = 0; i < 3; i++) {
+        if(data[i])
+            return ret;
+    }
+    if(data[3] == 0xfc)
+        ret = 1;
+    return ret;
+}
+
+static void Edid_ReceiverProductNameParse(rx_cap_t * pRxCap, unsigned char * data)
+{
+    int i = 0;
+    while((data[i] != 0x0a) && (data[i] != 0x20) && (i < 13)) {  // some Display Product name end with 0x20, not 0x0a
+        pRxCap->ReceiverProductName[i] = data[i];
+        i++;
+    }
+    pRxCap->ReceiverProductName[i] = '\0';
+}
+
+void Edid_DecodeStandardTiming(HDMI_TX_INFO_t * info, unsigned char * Data, unsigned char length)
+{
+     unsigned char  i, TmpVal;
+     int hor_pixel, frame_rate;
+
+     for(i = 0; i < length; i++ )
+     {
+        if((Data[i*2] != 0x01)&&(Data[i*2 + 1] != 0x01))   //else
+        {
+             hor_pixel = (int)((Data[i*2]+31)*8);
+             TmpVal = Data[i*2 + 1] & 0xC0;
+
+             frame_rate = (int)((Data[i*2 + 1])& 0x3F) + 60;
+
+             if((hor_pixel == 720) && (frame_rate == 30))
+                 {
+                   info->hdmi_sup_480i  = 1;
+                 }
+
+             else if((hor_pixel == 720) && (frame_rate == 25))
+                {
+                   info->hdmi_sup_576i  = 1;
+                 }
+
+             else if((hor_pixel == 720) && (frame_rate == 60))
+                {
+                   info->hdmi_sup_480p  = 1;
+//                   if(TmpVal==0x40)
+//                       info->video_480p.support_4_3  = 1;
+//                   else if(TmpVal==0xc0)
+//                       info->video_480p.support_16_9  = 1;
+                 }
+
+             else if((hor_pixel == 720) && (frame_rate == 50))
+               {
+                   info->hdmi_sup_576p  = 1;
+                 }
+
+             else if((hor_pixel == 1280) && (frame_rate == 60))
+             {
+                   info->hdmi_sup_720p_60hz  = 1;
+                 }
+
+             else if((hor_pixel == 1280) && (frame_rate == 50))
+             {
+                   info->hdmi_sup_720p_50hz  = 1;
+                 }
+
+             else if((hor_pixel == 1920) && (frame_rate == 30))
+             {
+                   info->hdmi_sup_1080i_60hz  = 1;
+                 }
+
+             else if((hor_pixel == 1920) && (frame_rate == 25))
+             {
+                   info->hdmi_sup_1080i_50hz  = 1;
+                 }
+
+             else if((hor_pixel == 1920) && (frame_rate == 60))
+             {
+                   info->hdmi_sup_1080p_60hz  = 1;
+                 }
+
+             else if((hor_pixel == 1920) && (frame_rate == 50))
+             {
+                   info->hdmi_sup_1080p_50hz  = 1;
+                 }
+             else if((hor_pixel == 1920) && (frame_rate == 24))
+             {
+                   info->hdmi_sup_1080p_24hz  = 1;
+                 }
+             else if((hor_pixel == 1920) && (frame_rate == 25))
+             {
+                   info->hdmi_sup_1080p_25hz  = 1;
+                 }
+             else if((hor_pixel == 1920) && (frame_rate == 30))
+             {
+                   info->hdmi_sup_1080p_30hz  = 1;
+                 }
+
+          }
+     }
+}
+
+static unsigned char Edid_TimingDescriptors[204]=    //12x17
+ {
+ //pixel clk --hsync active & blank  -- vsync  active & blank-- hsync/vsync off & wid -- Image size
+    0x8C,0x0A,  0xA0,0x14,0x51,     0xF0,0x16,0x00,     0x26,0x7c,0x43,0x00,    //0x13,0x8e,   //480i(4:3)
+     0x8C,0x0A,  0xA0,0x14,0x51,     0xF0,0x16,0x00,     0x26,0x7c,0x43,0x00,   // 0xc4,0x8e,   //480i(16:9)
+     0x8C,0x0A,  0xA0,0x20,0x51,     0x20,0x18,0x10,     0x18,0x7e,0x23,0x00,   // 0x13,0x8e,   //576i (4:3)
+     0x8C,0x0A,  0xA0,0x20,0x51,     0x20,0x18,0x10,     0x18,0x7e,0x23,0x00,   // 0xc4,0x8e,   //576i (16:9)
+     0x8C,0x0A,  0xD0,0x8A,0x20,     0xE0,0x2D,0x10,     0x10,0x3e,0x96,0x00,   // 0x13,0x8e,   //480p (4:3)
+     0x8C,0x0A,  0xD0,0x8A,0x20,     0xE0,0x2D,0x10,     0x10,0x3e,0x96,0x00,   // 0xc4,0x8e,   //480p (16:9)
+     0x8C,0x0A,  0xD0,0x90,0x20,     0x40,0x31,0x20,     0x0c,0x40,0x55,0x00,   // 0x13,0x8e,   //576p  (4:3)
+     0x8C,0x0A,  0xD0,0x90,0x20,     0x40,0x31,0x20,     0x0c,0x40,0x55,0x00,   // 0xc4,0x8e,  //576p  (16:9)
+    0x01,0x1D,    0x00,0x72,0x51,     0xD0,0x1E,0x20,     0x6e,0x28,0x55,0x00,  //  0xc4,0x8e,  //720p60(16:9)
+    0x01,0x1D,    0x00,0xBC,0x52,     0xD0,0x1E,0x20,     0xb8,0x28,0x55,0x40,  //  0xc4,0x8e,  //720p50 (16:9)
+    0x01,0x1D,    0x80,0x18,0x71,     0x1C,0x16,0x20,     0x58,0x2c,0x25,0x00,  //  0xc4,0x8e,  //1080i60 (16:9)
+    0x01,0x1D,    0x80,0xD0,0x72,     0x1C,0x16,0x20,     0x10,0x2c,0x25,0x80,  //  0xc4,0x8e,   //1080i50 (16:9)
+    0x02,0x3a,    0x80,0x18,0x71,     0x38,0x2d,0x40,     0x58,0x2c,0x45,0x00,  //  0xc4,0x8e,  //1080p60 (16:9)
+    0x02,0x3a,    0x80,0xD0,0x72,     0x38,0x2d,0x40,     0x10,0x2c,0x45,0x80,  //  0xc4,0x8e ,  //1080p50 (16:9)
+    0xfa,0x1c,    0x80,0x3e,0x73,     0x38,0x2d,0x40,     0x7e,0x2c,0x45,0x80,  //  0xc4,0x8e,  //1080p24 (16:9)
+    0x01,0x1D,    0x80,0xD0,0x72,     0x38,0x2d,0x40,     0x10,0x2c,0x45,0x80,  //  0xc4,0x8e,   //1080p25 (16:9)
+    0x01,0x1D,    0x80,0x18,0x71,     0x38,0x2d,0x40,     0x58,0x2c,0x45,0x00,  //  0xc4,0x8e,  //1080p30 (16:9)
+
+ };
+
+//-----------------------------------------------------------
+void Edid_CompareTimingDescriptors(HDMI_TX_INFO_t * info, unsigned char *Data)
+{
+   int index1,index2;
+
+    for(index1=0;index1<17;index1++)
+    {
+        for(index2=0;index2<12;index2++)
+        {
+            if(Data[index2]!=Edid_TimingDescriptors[index1*14+index2])
+                break;
+        }
+        if(index2==12)
+        {
+            switch(index1)
+            {
+                case 0:
+                case 1:
+                    info->hdmi_sup_480i  = 1;
+                    break;
+
+                case 2:
+                case 3:
+                     info->hdmi_sup_576i  = 1;
+                   break;
+
+                case 4:
+                case 5:
+                     info->hdmi_sup_480p  = 1;
+//                  if((Data[12]==Edid_TimingDescriptors[4*14 + 12]) && (Data[13]==Edid_TimingDescriptors[4*14 + 13]))
+//                     info->video_480p.support_4_3  = 1;
+//                  else if((Data[12]==Edid_TimingDescriptors[5*14 + 12]) && (Data[13]==Edid_TimingDescriptors[5*14 + 13]))
+//                     info->video_480p.support_16_9  = 1;
+                    break;
+
+                case 6:
+                case 7:
+                     info->hdmi_sup_576p  = 1;
+                    break;
+
+                case 8:
+                     info->hdmi_sup_720p_60hz  = 1;
+                       break;
+
+                case 9:
+                     info->hdmi_sup_720p_50hz  = 1;
+                       break;
+
+                case 10:
+                     info->hdmi_sup_1080i_60hz  = 1;
+                       break;
+
+                case 11:
+                     info->hdmi_sup_1080i_50hz  = 1;
+                    break;
+
+                case 12:
+                     info->hdmi_sup_1080p_60hz  = 1;
+                    break;
+
+                case 13:
+                     info->hdmi_sup_1080p_50hz  = 1;
+                    break;
+
+                case 14:
+                     info->hdmi_sup_1080p_24hz  = 1;
+                    break;
+
+                case 15:
+                     info->hdmi_sup_1080p_25hz  = 1;
+                    break;
+
+                case 16:
+                     info->hdmi_sup_1080p_30hz  = 1;
+                    break;
+                default:
+                    break;
+            }
+            break;
+        }
+    }
+}
+
+
+//-----------------------------------------------------------
+void Edid_ParseCEADetailedTimingDescriptors(HDMI_TX_INFO_t * info, unsigned char blk_mun, unsigned char BaseAddr, unsigned char *buff)
+{
+    unsigned char index_edid;
+
+    for( index_edid = 0; index_edid < blk_mun; index_edid++)
+    {
+        Edid_CompareTimingDescriptors(info, &buff[BaseAddr]);
+        BaseAddr += 18;
+       if((BaseAddr + 18) > 0x7d)   //there is not the TimingDescriptors
+                break;
+      }
+
+}
+static vsdb_phy_addr_t vsdb_local = {0};
+int get_vsdb_phy_addr(vsdb_phy_addr_t * vsdb)
+{
+    vsdb = &vsdb_local;
+    return vsdb->valid;
+}
+
+void set_vsdb_phy_addr(vsdb_phy_addr_t * vsdb, unsigned char *edid_offset)
+{
+    vsdb->a = (edid_offset[4] >> 4 ) & 0xf;
+    vsdb->b = (edid_offset[4] >> 0 ) & 0xf;
+    vsdb->c = (edid_offset[5] >> 4 ) & 0xf;
+    vsdb->d = (edid_offset[5] >> 0 ) & 0xf;
+    vsdb_local = *vsdb;
+    vsdb->valid = 1;
+}
+
+int Edid_Parse_check_HDMI_VSDB(HDMI_TX_INFO_t * info, unsigned char *buff)
+{
+    unsigned char  VSpecificBoundary, BlockAddr,  len;
+    int temp_addr=0;
+    VSpecificBoundary = buff[2] ;
+    if(VSpecificBoundary < 4)
+    {
+        info->output_state = CABLE_PLUGIN_DVI_OUT;
+        return -1;
+    }
+    BlockAddr = CEA_DATA_BLOCK_COLLECTION_ADDR_1StP;
+    while( BlockAddr < VSpecificBoundary) {
+        len = buff[BlockAddr] & 0x1F;
+             if((buff[BlockAddr] & 0xE0)== VENDOR_TAG){        //find the HDMI Vendor Specific Data Block
+                    break;
+        }
+        temp_addr =     BlockAddr + len + 1;
+        if(temp_addr >= VSpecificBoundary)
+            break;
+        BlockAddr = BlockAddr + len + 1;
+    }
+
+    set_vsdb_phy_addr(&info->vsdb_phy_addr, &buff[BlockAddr]);
+
+    if(temp_addr >= VSpecificBoundary)
+    {
+        info->output_state = CABLE_PLUGIN_DVI_OUT;
+        return -1;
+    }
+    else
+    {
+        if((buff[BlockAddr + 1]!= 0x03)||(buff[BlockAddr + 2]!= 0x0C)||(buff[BlockAddr + 3]!= 0x0))
+        {
+            info->output_state = CABLE_PLUGIN_DVI_OUT;
+            return -1;
+        }
+    }
+    return 0;
+}
+
+//-----------------------------------------------------------
+void Edid_MonitorCapable861(HDMI_TX_INFO_t * info, unsigned char edid_flag)
+{
+     if(edid_flag & 0x80)
+        info->support_underscan_flag = 1;
+     if(edid_flag & 0x40)
+        info->support_basic_audio_flag =1;
+     if(edid_flag & 0x20)
+         {
+            info->support_ycbcr444_flag =1;
+//            info->videopath_outindex = 1;    // Video Output Color Space Conversion : 0 - RGB out; 1 - YCbr (4:4:4) out; 2 - YCbr (4:2:2) out;
+      }
+     if(edid_flag & 0x10)
+         {
+            info->support_ycbcr422_flag =1 ;
+//            if(!(edid_flag & 0x20))
+//                info->videopath_outindex = 2;    // Video Output Color Space Conversion : 0 - RGB out; 1 - YCbr (4:4:4) out; 2 - YCbr (4:2:2) out;
+      }
+}
+
+
+//-----------------------------------------------------------
+static void Edid_ParsingVideoDATABlock(HDMI_TX_INFO_t * info, unsigned char *buff, unsigned char BaseAddr, unsigned char NBytes)
+{
+    unsigned char i;
+    NBytes &= 0x1F;
+    for(i = 0; i < NBytes; i++)
+      {
+        switch(buff[i + BaseAddr]&0x7F)
+        {
+            case 6:
+            case 7:
+                info->hdmi_sup_480i  = 1;
+                break;
+
+            case 21:
+            case 22:
+                info->hdmi_sup_576i  = 1;
+                  break;
+
+            case 2:
+            case 3:
+                info->hdmi_sup_480p  = 1;
+                break;
+
+            case 17:
+            case 18:
+                info->hdmi_sup_576p  = 1;
+                break;
+
+            case 4:
+                info->hdmi_sup_720p_60hz  = 1;
+                break;
+
+            case 19:
+                info->hdmi_sup_720p_50hz  = 1;
+                break;
+
+            case 5:
+                info->hdmi_sup_1080i_60hz  = 1;
+                break;
+
+            case 20:
+               info->hdmi_sup_1080i_50hz  = 1;
+               break;
+
+            case 16:
+                info->hdmi_sup_1080p_60hz  = 1;
+                break;
+
+            case 31:
+                info->hdmi_sup_1080p_50hz  = 1;
+                break;
+
+            case 32:
+                info->hdmi_sup_1080p_24hz  = 1;
+                break;
+
+            case 33:
+                info->hdmi_sup_1080p_25hz  = 1;
+                break;
+            case 34:
+                info->hdmi_sup_1080p_30hz  = 1;
+                break;
+            default:
+                break;
+        }
+    }
+}
+
+//-----------------------------------------------------------
+static void Edid_ParsingAudioDATABlock(HDMI_TX_INFO_t * info, unsigned char *Data, unsigned char BaseAddr, unsigned char NBytes)
+{
+     unsigned char AudioFormatCode;
+     int i = BaseAddr ;
+   NBytes&=0x1F;
+   do{
+        AudioFormatCode = (Data[i]&0xF8)>>3;
+        switch(AudioFormatCode)
+          {
+                case 1:
+                         info->tv_audio_info._60958_PCM.support_flag = 1;
+                         info->tv_audio_info._60958_PCM.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._60958_PCM._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._60958_PCM._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._60958_PCM._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._60958_PCM._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._60958_PCM._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._60958_PCM._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._60958_PCM._32k = 1;
+                         if((Data[i+2]&0x04))
+                             info->tv_audio_info._60958_PCM._24bit = 1;
+                         if((Data[i+2]&0x02))
+                             info->tv_audio_info._60958_PCM._20bit = 1;
+                         if((Data[i+2]&0x01))
+                             info->tv_audio_info._60958_PCM._16bit = 1;
+                         break;
+
+                case 2:
+                         info->tv_audio_info._AC3.support_flag = 1;
+                         info->tv_audio_info._AC3.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._AC3._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._AC3._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._AC3._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._AC3._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._AC3._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._AC3._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._AC3._32k = 1;
+                         info->tv_audio_info._AC3._max_bit = Data[i+2];
+                         break;
+
+                case 3:
+                         info->tv_audio_info._MPEG1.support_flag = 1;
+                         info->tv_audio_info._MPEG1.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._MPEG1._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._MPEG1._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._MPEG1._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._MPEG1._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._MPEG1._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._MPEG1._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._MPEG1._32k = 1;
+                         info->tv_audio_info._MPEG1._max_bit = Data[i+2];
+                         break;
+
+                case 4:
+                         info->tv_audio_info._MP3.support_flag = 1;
+                         info->tv_audio_info._MP3.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._MP3._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._MP3._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._MP3._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._MP3._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._MP3._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._MP3._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._MP3._32k = 1;
+                         info->tv_audio_info._MP3._max_bit = Data[i+2];
+                         break;
+
+                case 5:
+                        info->tv_audio_info._MPEG2.support_flag = 1;
+                         info->tv_audio_info._MPEG2.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._MPEG2._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._MPEG2._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._MPEG2._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._MPEG2._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._MPEG2._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._MPEG2._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._MPEG2._32k = 1;
+                         info->tv_audio_info._MPEG2._max_bit = Data[i+2];
+                         break;
+
+                case 6:
+                        info->tv_audio_info._AAC.support_flag = 1;
+                         info->tv_audio_info._AAC.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._AAC._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._AAC._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._AAC._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._AAC._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._AAC._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._AAC._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._AAC._32k = 1;
+                         info->tv_audio_info._AAC._max_bit = Data[i+2];
+                         break;
+
+                case 7:
+                        info->tv_audio_info._DTS.support_flag = 1;
+                         info->tv_audio_info._DTS.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._DTS._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._DTS._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._DTS._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._DTS._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._DTS._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._DTS._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._DTS._32k = 1;
+                         info->tv_audio_info._DTS._max_bit = Data[i+2];
+                         break;
+
+                case 8:
+                        info->tv_audio_info._ATRAC.support_flag = 1;
+                         info->tv_audio_info._ATRAC.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._ATRAC._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._ATRAC._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._ATRAC._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._ATRAC._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._ATRAC._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._ATRAC._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._ATRAC._32k = 1;
+                         info->tv_audio_info._ATRAC._max_bit = Data[i+2];
+                         break;
+
+                case 9:
+                        info->tv_audio_info._One_Bit_Audio.support_flag = 1;
+                         info->tv_audio_info._One_Bit_Audio.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._One_Bit_Audio._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._One_Bit_Audio._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._One_Bit_Audio._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._One_Bit_Audio._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._One_Bit_Audio._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._One_Bit_Audio._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._One_Bit_Audio._32k = 1;
+                         info->tv_audio_info._One_Bit_Audio._max_bit = Data[i+2];
+                         break;
+
+                case 10:
+                        info->tv_audio_info._Dolby.support_flag = 1;
+                         info->tv_audio_info._Dolby.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._Dolby._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._Dolby._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._Dolby._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._Dolby._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._Dolby._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._Dolby._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._Dolby._32k = 1;
+                         info->tv_audio_info._Dolby._max_bit = Data[i+2];
+                         break;
+
+                case 11:
+                        info->tv_audio_info._DTS_HD.support_flag = 1;
+                         info->tv_audio_info._DTS_HD.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._DTS_HD._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._DTS_HD._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._DTS_HD._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._DTS_HD._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._DTS_HD._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._DTS_HD._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._DTS_HD._32k = 1;
+                         info->tv_audio_info._DTS_HD._max_bit = Data[i+2];
+                         break;
+
+
+                case 12:
+                        info->tv_audio_info._MAT.support_flag = 1;
+                         info->tv_audio_info._MAT.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._MAT._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._MAT._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._MAT._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._MAT._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._MAT._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._MAT._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._MAT._32k = 1;
+                         info->tv_audio_info._MAT._max_bit = Data[i+2];
+                         break;
+
+                case 13:
+                        info->tv_audio_info._ATRAC.support_flag = 1;
+                         info->tv_audio_info._ATRAC.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._DST._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._DST._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._DST._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._DST._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._DST._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._DST._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._DST._32k = 1;
+                         info->tv_audio_info._DST._max_bit = Data[i+2];
+                         break;
+
+                case 14:
+                        info->tv_audio_info._WMA.support_flag = 1;
+                         info->tv_audio_info._WMA.max_channel_num = (Data[i]&0x07);
+                         if((Data[i+1]&0x40))
+                             info->tv_audio_info._WMA._192k = 1;
+                         if((Data[i+1]&0x20))
+                             info->tv_audio_info._WMA._176k = 1;
+                         if((Data[i+1]&0x10))
+                             info->tv_audio_info._WMA._96k = 1;
+                         if((Data[i+1]&0x08))
+                             info->tv_audio_info._WMA._88k = 1;
+                         if((Data[i+1]&0x04))
+                             info->tv_audio_info._WMA._48k = 1;
+                         if((Data[i+1]&0x02))
+                             info->tv_audio_info._WMA._44k = 1;
+                         if((Data[i+1]&0x01))
+                             info->tv_audio_info._WMA._32k = 1;
+                         info->tv_audio_info._WMA._max_bit = Data[i+2];
+                         break;
+
+                default:
+                         break;
+                 }
+                i+=3;
+      }while (i < (NBytes + BaseAddr));
+}
+
+//-----------------------------------------------------------
+static void Edid_ParsingSpeakerDATABlock(HDMI_TX_INFO_t * info, unsigned char *buff, unsigned char BaseAddr)
+{
+   int ii;
+   for(ii = 1; ii < 0x80; )
+   {
+     switch(buff[BaseAddr] & ii)
+      {
+            case 0x40:
+                info->tv_audio_info.speaker_allocation.rlc_rrc = 1;
+                break;
+
+            case 0x20:
+                info->tv_audio_info.speaker_allocation.flc_frc = 1;
+                break;
+
+            case 0x10:
+                info->tv_audio_info.speaker_allocation.rc = 1;
+                break;
+
+            case 0x08:
+                info->tv_audio_info.speaker_allocation.rl_rr = 1;
+                break;
+
+            case 0x04:
+                info->tv_audio_info.speaker_allocation.fc = 1;
+                break;
+
+            case 0x02:
+                info->tv_audio_info.speaker_allocation.lfe = 1;
+                break;
+
+            case 0x01:
+                info->tv_audio_info.speaker_allocation.fl_fr = 1;
+                break;
+
+          default :
+              break;
+       }
+       ii = ii << 1;
+     }
+}
+
+
+
+//-----------------------------------------------------------
+int Edid_ParsingCEADataBlockCollection(HDMI_TX_INFO_t * info, unsigned char *buff)
+{
+   unsigned char AddrTag, D, Addr, Data;
+   int temp_addr;
+
+   D = buff[2];   //Byte number offset d where Detailed Timing data begins
+   Addr = 4;
+
+   AddrTag = Addr;
+   do{
+        Data = buff[AddrTag];
+        switch(Data&0xE0)
+        {
+            case VIDEO_TAG:
+                if((Addr + (Data&0x1f)) < D)
+                      Edid_ParsingVideoDATABlock(info, buff, Addr + 1, (Data & 0x1F) );
+                break;
+
+            case AUDIO_TAG:
+                if((Addr + (Data&0x1f)) < D)
+                      Edid_ParsingAudioDATABlock(info, buff, Addr + 1, (Data & 0x1F) );
+                break;
+
+            case SPEAKER_TAG:
+                if((Addr + (Data&0x1f)) < D)
+                      Edid_ParsingSpeakerDATABlock(info, buff, Addr + 1 );
+                break;
+
+            case VENDOR_TAG:
+                if((Addr + (Data&0x1f)) < D)
+                {
+                         if((buff[Addr + 1] != 0x03) || (buff[Addr + 2] != 0x0c) || (buff[Addr + 3] != 0x00))
+                         {
+                              info->auth_state = HDCP_NO_AUTH ;
+                              info->output_state = CABLE_PLUGIN_DVI_OUT;
+                         }
+                      if((Data&0x1f) > 5)
+                      {
+                     //A Source shall not transmit an ISRC1 or ISRC2 Packet to a Sink that does not have Supports_AI = 1
+                     //International Standard Recording Code (ISRC)
+                          if(buff[Addr + 6] & 0x80)
+                              info->support_ai_flag = 1;
+                      }
+                }
+                break;
+
+            default:
+                break;
+          }
+          Addr += ( Data & 0x1F ) ;   // next Tag Address
+          AddrTag = ++Addr;
+        temp_addr =   Addr + ( Data & 0x1F ) ;
+        if(temp_addr >= D)    //force to break;
+            break;
+     }while (Addr < D);
+
+   return 0;
+}
+
+//-----------------------------------------------------------
+
+//parse Sink 3D information
+static int hdmitx_edid_3d_parse(rx_cap_t* pRXCap, unsigned char *dat, unsigned size)
+{
+    int j = 0;
+    int bit = 16;
+    unsigned int base = 0;
+    unsigned int pos = base + 1;
+
+    if(dat[base] & (1<<7))
+        pos += 2;
+    if(dat[base] & (1<<6))
+        pos += 2;
+    if(dat[base] & (1<<5)){
+        pRXCap->threeD_present = dat[pos] >> 7;
+        pRXCap->threeD_Multi_present = (dat[pos] >> 5) & 0x3;
+        pos += 1;
+        pRXCap->HDMI_VIC_LEN = (dat[pos] ) >> 5;
+        pRXCap->HDMI_3D_LEN = (dat[pos] ) & 0x1f;
+        pos += pRXCap->HDMI_VIC_LEN + 1;
+        if((pRXCap->threeD_Multi_present == 0x01) || (pRXCap->threeD_Multi_present == 0x2)) {
+            pRXCap->threeD_Structure_ALL_15_0 = (dat[pos] << 8) + dat[pos+1];
+            pos +=2;
+        }
+        if(pRXCap->threeD_Multi_present == 0x2) {
+            pRXCap->threeD_MASK_15_0 = (dat[pos] << 8) + dat[pos+1];
+            pos +=2;
+        }
+    }
+    while(pos < size) {
+        if((dat[pos] & 0xf) == 0x0 ){ // frame packing
+            pRXCap->support_3d_format[pRXCap->VIC[((dat[pos] & 0xf0) >> 4)]].frame_packing = 1;
+            pRXCap->support_3d_format[pRXCap->VIC[((dat[pos+1] & 0xf0) >> 4)]].frame_packing = 1;
+        }
+        if((dat[pos] & 0xf) == 0x6 ){ // top and bottom
+            pRXCap->support_3d_format[pRXCap->VIC[((dat[pos] & 0xf0) >> 4)]].top_and_bottom = 1;
+            pRXCap->support_3d_format[pRXCap->VIC[((dat[pos+1] & 0xf0) >> 4)]].top_and_bottom = 1;
+        }
+        if((dat[pos] & 0xf) == 0x8 ){ // top and bottom
+            pRXCap->support_3d_format[pRXCap->VIC[((dat[pos] & 0xf0) >> 4)]].side_by_side = 1;
+            pRXCap->support_3d_format[pRXCap->VIC[((dat[pos+1] & 0xf0) >> 4)]].side_by_side = 1;
+        }
+        pos += 2;
+    }
+
+    while(bit--){
+        if(((pRXCap->threeD_MASK_15_0) >> j) & 0x1)
+            if(pRXCap->threeD_Structure_ALL_15_0 & (1 << 0)) { // frame packing
+                pRXCap->support_3d_format[pRXCap->VIC[j]].frame_packing = 1;
+            }
+            if(pRXCap->threeD_Structure_ALL_15_0 & (1 << 6)) { // top and bottom
+                pRXCap->support_3d_format[pRXCap->VIC[j]].top_and_bottom = 1;
+            }
+            if(pRXCap->threeD_Structure_ALL_15_0 & (1 << 8)) { // top and bottom
+                pRXCap->support_3d_format[pRXCap->VIC[j]].side_by_side = 1;
+            }
+        j++;
+    }
+    return 1;
+}
+
+//parse Sink 4k2k information
+static void hdmitx_edid_4k2k_parse(rx_cap_t* pRXCap, unsigned char *dat, unsigned size)
+{
+    if((size > 4) || (size == 0)) {
+        hdmi_print(ERR, EDID "HDMI: 4k2k in edid out of range, SIZE = %d\n", size);
+        return;
+    }
+    while(size--) {
+        if(*dat == 1)
+            pRXCap->VIC[pRXCap->VIC_count] = HDMI_4k2k_30;
+        else if(*dat == 2)
+            pRXCap->VIC[pRXCap->VIC_count] = HDMI_4k2k_25;
+        else if(*dat == 3)
+            pRXCap->VIC[pRXCap->VIC_count] = HDMI_4k2k_24;
+        else if(*dat == 4)
+            pRXCap->VIC[pRXCap->VIC_count] = HDMI_4k2k_smpte_24;
+        else {
+        }
+        dat ++;
+        pRXCap->VIC_count++ ;
+    }
+}
+
+static int hdmitx_edid_block_parse(hdmitx_dev_t* hdmitx_device, unsigned char *BlockBuf)
+{
+    unsigned char offset,End ;
+    unsigned char count ;
+    unsigned char tag ;
+    int i, tmp, idx;
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+
+    if( BlockBuf[0] != 0x02 )
+        return -1 ; // not a CEA BLOCK.
+    End = BlockBuf[2]  ; // CEA description.
+    pRXCap->native_Mode = BlockBuf[3] ;
+
+      pRXCap->VIC_count = 0 ;
+    pRXCap->native_VIC = 0xff ;
+    for( offset = 4 ; offset < End ; ){
+        tag = BlockBuf[offset] >> 5 ;
+        count = BlockBuf[offset] & 0x1f ;
+        switch( tag ){
+            case HDMI_EDID_BLOCK_TYPE_AUDIO: 
+                pRXCap->AUD_count = count/3 ;
+                offset++ ;
+                for( i = 0 ; i < pRXCap->AUD_count ; i++)
+                {
+                    pRXCap->RxAudioCap[i].audio_format_code = (BlockBuf[offset + i * 3]>>3)&0xf;
+                    pRXCap->RxAudioCap[i].channel_num_max = BlockBuf[offset + i * 3]&0x7;
+                    pRXCap->RxAudioCap[i].freq_cc = BlockBuf[offset + i * 3 +1]&0x7f;
+                    pRXCap->RxAudioCap[i].cc3 = BlockBuf[offset + i * 3 + 2]&0x7;
+                }
+                offset += count;
+                break ;
+            
+            case HDMI_EDID_BLOCK_TYPE_VIDEO:
+                offset ++;
+                for( i = 0 ; i < count ; i++)
+                {
+                    unsigned char VIC ;
+                    VIC = BlockBuf[offset + i] & (~0x80) ;
+                    pRXCap->VIC[pRXCap->VIC_count] = VIC ;
+                    if( BlockBuf[offset + i] & 0x80 ){
+                        pRXCap->native_VIC = VIC;
+                    }
+                    pRXCap->VIC_count++ ;
+                }
+                offset += count;
+                break ;
+            
+            case HDMI_EDID_BLOCK_TYPE_VENDER: 
+                offset ++ ;
+                pRXCap->IEEEOUI = (unsigned long)BlockBuf[offset+2] ;
+                pRXCap->IEEEOUI <<= 8 ;
+                pRXCap->IEEEOUI += (unsigned long)BlockBuf[offset+1] ;
+                pRXCap->IEEEOUI <<= 8 ;
+                pRXCap->IEEEOUI += (unsigned long)BlockBuf[offset] ;
+                /**/
+                hdmi_print(0, "HDMI_EDID_BLOCK_TYPE_VENDER: IEEEOUI %x:", pRXCap->IEEEOUI);
+                for(i = 0; i<count ;i++){
+                    hdmi_print(0, "%d: %02x\n",i+1, BlockBuf[offset+i]);
+                }
+                /**/
+                pRXCap->ColorDeepSupport = (unsigned long)BlockBuf[offset+5];
+                pRXCap->Max_TMDS_Clock = (unsigned long)BlockBuf[offset+6];
+                if(count > 7) {
+                    tmp = BlockBuf[offset+7];
+                    idx = offset + 8;
+                    if(tmp & (1<<6)) {
+                        idx += 2;
+                    }
+                    if(tmp & (1<<7)) {
+                        idx += 2;
+                    }
+                    if(tmp & (1<<5)) {
+                        idx += 1;
+                        if(BlockBuf[idx] & 0xe0) {   //valid 4k
+                            hdmitx_edid_4k2k_parse(pRXCap, &BlockBuf[idx + 1], BlockBuf[idx] >> 5);
+                        }
+                        if(BlockBuf[idx-1] & 0xe0) {  //valid 3D
+                            hdmitx_edid_3d_parse(pRXCap, &BlockBuf[offset+7], count - 7);
+                        }
+                    }
+                }
+                offset += count ; // ignore the remaind.
+                break ;
+            
+            case HDMI_EDID_BLOCK_TYPE_SPEAKER: 
+                offset ++ ;
+                pRXCap->RxSpeakerAllocation = BlockBuf[offset] ;
+                offset += count;
+                break ;
+
+            case HDMI_EDID_BLOCK_TYPE_VESA: 
+                offset ++;
+                offset += count;
+                break ;
+
+            case HDMI_EDID_BLOCK_TYPE_EXTENDED_TAG: 
+                offset ++;
+                offset += count;
+                break ;
+
+            case HDMI_EDID_BLOCK_TYPE_RESERVED:
+                offset ++;
+                offset += count;
+                break;
+
+            case HDMI_EDID_BLOCK_TYPE_RESERVED2:
+                offset ++;
+                offset += count;
+                break;
+
+            default:
+                break;
+        }
+    }
+    hdmitx_device->vic_count=pRXCap->VIC_count;
+    return 0 ;
+}
+
+// add default VICs for DVI case
+static void hdmitx_edid_set_default_vic(hdmitx_dev_t* hdmitx_device)
+{
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+    pRXCap->VIC_count = 0x3;
+    pRXCap->VIC[0] = 2;
+    pRXCap->VIC[1] = 4;
+    pRXCap->VIC[2] = 16;
+    pRXCap->native_VIC = 4;
+    hdmitx_device->vic_count = pRXCap->VIC_count;
+    hdmi_print(IMP, EDID "HDMI: set default vic\n");
+}
+
+#if 0
+#define PRINT_HASH(hash) {printk("%s:%d ",__func__,__LINE__);int __i;for(__i=0;__i<20;__i++)printk("%02x,",hash[__i]);printk("\n");}
+#else
+#define PRINT_HASH(hash) 
+#endif
+
+static int edid_hash_calc(unsigned char *hash, const char *data, unsigned int len)
+{
+    struct scatterlist sg;
+
+    struct crypto_hash *tfm;
+    struct hash_desc desc;
+
+    tfm = crypto_alloc_hash("sha1", 0, CRYPTO_ALG_ASYNC);
+    PRINT_HASH(hash);
+    if (IS_ERR(tfm))
+        return -EINVAL;
+
+    PRINT_HASH(hash);
+    /* ... set up the scatterlists ... */
+    sg_init_one(&sg, (u8 *) data, len);
+    desc.tfm = tfm;
+    desc.flags = 0;
+
+    if (crypto_hash_digest(&desc, &sg,len, hash))
+        return -EINVAL;
+    PRINT_HASH(hash);
+    crypto_free_hash(tfm);
+    return 1;
+}
+
+static int hdmitx_edid_search_IEEEOUI(char *buf)
+{
+    int i;
+
+    for(i = 0; i < 125; i++) {
+        if((buf[i] == 0x03) && (buf[i+1] == 0x0c) && (buf[i+2] == 0x00)) {
+            return 1;
+        }
+    }
+    return 0;
+}
+
+int hdmitx_edid_parse(hdmitx_dev_t* hdmitx_device)
+{
+    unsigned char CheckSum ;
+    unsigned char zero_numbers;
+    unsigned char BlockCount ;
+    unsigned char* EDID_buf = hdmitx_device->EDID_buf;
+    int i, j, ret_val ;
+    int idx[4];
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+    hdmi_print(0, "EDID Parser:\n");
+
+    // Calculate the EDID hash for special use
+    memset(hdmitx_device->EDID_hash, 0, ARRAY_SIZE(hdmitx_device->EDID_hash));
+    edid_hash_calc(hdmitx_device->EDID_hash, hdmitx_device->EDID_buf, 256);
+
+    ret_val = Edid_DecodeHeader(&hdmitx_device->hdmi_info, &EDID_buf[0]);
+
+//    if(ret_val == -1)
+//        return -1;
+
+    for( i = 0, CheckSum = 0 ; i < 128 ; i++ )
+    {
+        CheckSum += EDID_buf[i] ;
+        CheckSum &= 0xFF ;
+    }
+    
+    if( CheckSum != 0 )
+    {
+        hdmitx_device->hdmi_info.output_state = CABLE_PLUGIN_DVI_OUT;
+        hdmi_print(0, "PLUGIN_DVI_OUT\n");
+//        return -1 ;
+    }
+    
+    Edid_ReceiverBrandNameParse(&hdmitx_device->RXCap, &EDID_buf[8]);
+
+    idx[0] = EDID_DETAILED_TIMING_DES_BLOCK0_POS;
+    idx[1] = EDID_DETAILED_TIMING_DES_BLOCK1_POS;
+    idx[2] = EDID_DETAILED_TIMING_DES_BLOCK2_POS;
+    idx[3] = EDID_DETAILED_TIMING_DES_BLOCK3_POS;
+    for(i = 0; i < 4; i++) {
+        if(Edid_find_name_block(&EDID_buf[idx[i]]))
+            Edid_ReceiverProductNameParse(&hdmitx_device->RXCap, &EDID_buf[idx[i]+5]);
+    }
+    Edid_DecodeStandardTiming(&hdmitx_device->hdmi_info, &EDID_buf[26], 8);
+    Edid_ParseCEADetailedTimingDescriptors(&hdmitx_device->hdmi_info, 4, 0x36, &EDID_buf[0]);
+
+    BlockCount = EDID_buf[0x7E] ;
+
+    if( BlockCount == 0 ){
+        hdmitx_device->hdmi_info.output_state = CABLE_PLUGIN_DVI_OUT;
+        hdmi_print(0, "EDID BlockCount=0\n");
+        hdmitx_edid_set_default_vic(hdmitx_device);
+
+        // DVI case judgement: only contains one block and checksum valid
+        CheckSum = 0;
+        zero_numbers = 0;
+        for(i = 0; i < 128; i++) {
+            CheckSum += EDID_buf[i];
+            if(EDID_buf[i] == 0)
+                zero_numbers ++;
+        }
+        hdmi_print(INF, EDID "edid blk0 checksum:%d ext_flag:%d\n",CheckSum, EDID_buf[0x7e]);
+        if((CheckSum & 0xff) == 0) {
+            hdmitx_device->RXCap.IEEEOUI = 0;
+        } else {
+            hdmitx_device->RXCap.IEEEOUI = 0x0c03;
+        }
+        if(zero_numbers > 120)
+            hdmitx_device->RXCap.IEEEOUI = 0x0c03;
+
+        return 0 ; // do nothing.
+    }
+
+    if((BlockCount == 1) && (EDID_buf[0x81] == 1)) {    // Note: some DVI monitor have more than 1 block
+        hdmitx_device->RXCap.IEEEOUI = 0;
+        return 0;
+    }
+
+    else if ( BlockCount > EDID_MAX_BLOCK )
+    {
+        BlockCount = EDID_MAX_BLOCK ;
+    }
+
+    for( i = 1 ; i <= BlockCount ; i++ )
+    {
+
+        if((BlockCount > 1) && (i == 1))
+        {
+                CheckSum = 0;       //ignore the block1 data
+        }
+        else
+        {
+            if(((BlockCount == 1) && (i == 1)) || ((BlockCount > 1) && (i == 2)))
+                Edid_Parse_check_HDMI_VSDB( &hdmitx_device->hdmi_info,  &EDID_buf[i * 128]);
+
+            for( j = 0, CheckSum = 0 ; j < 128 ; j++ )
+            {
+                CheckSum += EDID_buf[i*128 + j] ;
+                CheckSum &= 0xFF ;
+            }
+            if( CheckSum != 0 )
+            {
+                    hdmitx_device->hdmi_info.output_state = CABLE_PLUGIN_DVI_OUT;
+            }
+            else
+            {
+                Edid_MonitorCapable861(&hdmitx_device->hdmi_info, EDID_buf[i * 128 + 3]);
+                ret_val = Edid_ParsingCEADataBlockCollection(&hdmitx_device->hdmi_info, &EDID_buf[i * 128]);
+                Edid_ParseCEADetailedTimingDescriptors(&hdmitx_device->hdmi_info, 5, EDID_buf[i * 128 + 2], &EDID_buf[i * 128]);
+                if(hdmitx_device->hdmi_info.output_state != CABLE_PLUGIN_DVI_OUT)
+                    hdmitx_device->hdmi_info.output_state = CABLE_PLUGIN_HDMI_OUT;
+            }
+
+        }
+
+        if( EDID_buf[i*128+0] == 0x2  )
+        {
+            if(hdmitx_edid_block_parse(hdmitx_device, &(EDID_buf[i*128]))>=0){
+                if(hdmitx_device->RXCap.IEEEOUI==0x0c03){
+                    break;
+                }
+            }
+        }
+    }
+
+    if(hdmitx_edid_search_IEEEOUI(&EDID_buf[128])) {
+        pRXCap->IEEEOUI = 0x0c03;
+        printk("hdmitx: edid: find IEEEOUT\n");
+    }
+    else {
+        pRXCap->IEEEOUI = 0x0;
+        printk("hdmitx: edid: not find IEEEOUT\n");
+    }
+
+    if((pRXCap->IEEEOUI != 0x0c03) || (pRXCap->IEEEOUI == 0x0)|| (pRXCap->VIC_count == 0)){
+        hdmitx_edid_set_default_vic(hdmitx_device);
+    }    
+
+#if 1    
+    i=hdmitx_edid_dump(hdmitx_device, (char*)(hdmitx_device->tmp_buf), HDMI_TMP_BUF_SIZE);
+    hdmitx_device->tmp_buf[i]=0;
+    hdmi_print(0,"\n");
+#endif    
+    return 0;
+
+}
+
+typedef struct{
+    const char* disp_mode;
+    HDMI_Video_Codes_t VIC;
+}dispmode_vic_t;
+
+static dispmode_vic_t dispmode_VIC_tab[]=
+{
+    {"480i_4_3",  HDMI_480i60},
+    {"480i_rpt",  HDMI_480i60_16x9_rpt},
+    {"480i",      HDMI_480i60_16x9},
+    {"480p_4_3",  HDMI_480p60},
+    {"480p_rpt",  HDMI_480p60_16x9_rpt},
+    {"480p",      HDMI_480p60_16x9},
+    {"576i_4_3",  HDMI_576i50},
+    {"576i_rpt",  HDMI_576i50_16x9_rpt},
+    {"576i",      HDMI_576i50_16x9},
+    {"576p_4_3",  HDMI_576p50},
+    {"576p_rpt",  HDMI_576p50_16x9_rpt},
+    {"576p",      HDMI_576p50_16x9},
+    {"720p50hz",  HDMI_720p50},
+    {"720p",      HDMI_720p60},
+    {"1080i50hz", HDMI_1080i50},
+    {"1080i",     HDMI_1080i60},
+    {"1080p50hz", HDMI_1080p50},
+    {"1080p30hz", HDMI_1080p30},
+    {"1080p24hz", HDMI_1080p24},
+    {"1080p",     HDMI_1080p60},
+    {"4k2k30hz",  HDMI_4k2k_30},
+    {"4k2k25hz",  HDMI_4k2k_25},
+    {"4k2k24hz",  HDMI_4k2k_24},
+    {"4k2ksmpte", HDMI_4k2k_smpte_24},
+    {"4k2k5g",    HDMI_3840x2160p50_16x9},
+    {"4k2k60hz420", HDMI_3840x2160p60_16x9},
+    {"4k2k60hz",  HDMI_3840x2160p60_16x9},
+    {"4k1k100hz", HDMI_3840x1080p100hz},
+    {"4k1k100hz420", HDMI_3840x1080p100hz},
+    {"4k1k120hz", HDMI_3840x1080p120hz},
+    {"4k1k120hz420", HDMI_3840x1080p120hz},
+    {"4k05k200hz", HDMI_3840x540p200hz},
+    {"4k05k200hz420", HDMI_3840x540p200hz},
+    {"4k05k240hz", HDMI_3840x540p240hz},
+    {"4k05k240hz420", HDMI_3840x540p240hz},
+};
+
+int hdmitx_edid_VIC_support(HDMI_Video_Codes_t vic)
+{
+    int i;
+
+    for(i = 0; i < ARRAY_SIZE(dispmode_VIC_tab); i++) {
+        if(vic == dispmode_VIC_tab[i].VIC)
+            return 1;
+    }
+
+    return 0;
+}
+
+HDMI_Video_Codes_t hdmitx_edid_vic_tab_map_vic(const char* disp_mode)
+{
+    HDMI_Video_Codes_t vic = HDMI_Unkown;
+    int i;
+
+    for(i = 0; i < ARRAY_SIZE(dispmode_VIC_tab); i++) {
+        if(strncmp(disp_mode, dispmode_VIC_tab[i].disp_mode, strlen(dispmode_VIC_tab[i].disp_mode))==0) {
+            vic = dispmode_VIC_tab[i].VIC;
+            break;
+        }
+    }
+
+    if(vic == HDMI_Unkown)
+        hdmi_print(INF, EDID "not find mapped vic\n");
+
+    return vic;
+}
+
+const char * hdmitx_edid_vic_tab_map_string(HDMI_Video_Codes_t vic)
+{
+    int i;
+    const char * disp_str = NULL;
+
+    for(i = 0; i < ARRAY_SIZE(dispmode_VIC_tab); i++) {
+        if(vic == dispmode_VIC_tab[i].VIC) {
+            disp_str = dispmode_VIC_tab[i].disp_mode;
+            break;
+        }
+    }
+
+    if(!disp_str)
+        hdmi_print(INF, EDID "not find mapped display mode\n");
+
+    return disp_str;
+}
+
+// force_flag: 0 means check with RX's edid
+//             1 means no check wich RX's edid
+HDMI_Video_Codes_t hdmitx_edid_get_VIC(hdmitx_dev_t* hdmitx_device, const char* disp_mode, char force_flag)
+{
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+    int  j;
+    HDMI_Video_Codes_t vic = hdmitx_edid_vic_tab_map_vic(disp_mode);
+
+    if(vic != HDMI_Unkown) {
+        if(force_flag == 0) {
+            for( j = 0 ; j < pRXCap->VIC_count ; j++ ){
+                if(pRXCap->VIC[j]==vic)
+                    break;
+            }
+            if(j>=pRXCap->VIC_count){
+                vic = HDMI_Unkown;
+            }
+        }
+    }
+    return vic;
+}    
+
+const char* hdmitx_edid_get_native_VIC(hdmitx_dev_t* hdmitx_device)
+{
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+
+    return hdmitx_edid_vic_tab_map_string(pRXCap->native_VIC);
+}    
+
+//Clear HDMI Hardware Module EDID RAM and EDID Buffer
+void hdmitx_edid_ram_buffer_clear(hdmitx_dev_t* hdev)
+{
+    unsigned int i = 0;
+    
+    //Clear HDMI Hardware Module EDID RAM
+    hdev->HWOp.CntlDDC(hdev, DDC_EDID_CLEAR_RAM, 0);
+    
+    //Clear EDID Buffer
+    for(i = 0; i < EDID_MAX_BLOCK*128; i++) {
+        hdev->EDID_buf[i] = 0;
+    }
+    for(i = 0; i < EDID_MAX_BLOCK*128; i++) {
+        hdev->EDID_buf1[i] = 0;
+    }
+}
+
+//Clear the Parse result of HDMI Sink's EDID.
+void hdmitx_edid_clear(hdmitx_dev_t* hdmitx_device)
+{
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+    hdmitx_device->vic_count=0;
+    pRXCap->VIC_count = 0;
+    pRXCap->AUD_count = 0;
+    // Note: in most cases, we think that rx is tv and the default IEEEOUI is HDMI Identifier
+    pRXCap->IEEEOUI = 0x000c03;
+    pRXCap->native_Mode = 0;
+    pRXCap->native_VIC = 0xff;
+    pRXCap->RxSpeakerAllocation = 0;
+    hdmitx_device->hdmi_info.vsdb_phy_addr.a = 0;
+    hdmitx_device->hdmi_info.vsdb_phy_addr.b = 0;
+    hdmitx_device->hdmi_info.vsdb_phy_addr.c = 0;
+    hdmitx_device->hdmi_info.vsdb_phy_addr.d = 0;
+    hdmitx_device->hdmi_info.vsdb_phy_addr.valid = 0;
+    memset(&vsdb_local, 0, sizeof(vsdb_phy_addr_t));
+    pRXCap->Video_Latency = 0;
+    pRXCap->Audio_Latency = 0;
+    pRXCap->Interlaced_Video_Latency=0;
+    pRXCap->Interlaced_Audio_Latency=0;
+    pRXCap->threeD_present=0;
+    pRXCap->threeD_Multi_present=0;
+    pRXCap->HDMI_VIC_LEN=0;
+    pRXCap->HDMI_3D_LEN=0;
+    pRXCap->threeD_Structure_ALL_15_0=0;
+    pRXCap->threeD_MASK_15_0=0;
+    memset(pRXCap->ReceiverBrandName, 0, sizeof(pRXCap->ReceiverBrandName));
+    memset(pRXCap->ReceiverProductName, 0, sizeof(pRXCap->ReceiverProductName));
+    memset(&hdmitx_device->RXCap.support_3d_format[0], 0, sizeof(hdmitx_device->RXCap.support_3d_format));
+    memset(&hdmitx_device->EDID_hash[0], 0, sizeof(hdmitx_device->EDID_hash));
+}
+
+/*
+ * print one block data of edid
+ */
+static void hdmitx_edid_blk_print(unsigned char *blk, unsigned int blk_idx)
+{
+    unsigned int i;
+    hdmi_print(INF, EDID "blk%d raw data\n", blk_idx);
+    for(i = 0; i < 128; i++) {
+        printk("%02x", blk[i]);
+        if(((i+1) & 0x1f) == 0)     // print 32bytes a line
+            printk("\n");
+    }
+    printk("\n");
+}
+
+/*
+ * check EDID buf contains valid block numbers
+ */
+static unsigned int hdmitx_edid_check_valid_blocks(unsigned char *buf)
+{
+    unsigned int valid_blk_no = 0;
+    unsigned int i = 0, j = 0;
+    unsigned int tmp_chksum = 0;
+    for(j = 0; j < EDID_MAX_BLOCK; j++) {
+        for(i = 0; i < 128; i++) {
+            tmp_chksum += buf[i + j*128];
+        }
+        if(tmp_chksum !=0) {
+            valid_blk_no ++;
+            if((tmp_chksum & 0xff) == 0) {
+                hdmi_print(INF, EDID "check sum valid\n");
+            }
+            else {
+                hdmi_print(INF, EDID "check sum invalid\n");
+            }
+        }
+        tmp_chksum = 0;
+    }
+    return valid_blk_no;
+}
+
+/*
+ * suppose DDC read EDID two times successfully,
+ * then compare EDID_buf and EDID_buf1.
+ * if same, just print out EDID_buf raw data, else print out 2 buffers
+ */
+void hdmitx_edid_buf_compare_print(hdmitx_dev_t* hdmitx_device)
+{
+    unsigned int i = 0;
+    unsigned int err_no = 0;
+    unsigned char *buf0 = hdmitx_device->EDID_buf;
+    unsigned char *buf1 = hdmitx_device->EDID_buf1;
+    unsigned int valid_blk_no = 0;
+    unsigned int blk_idx = 0;
+
+    for(i = 0; i < EDID_MAX_BLOCK*128; i++) {
+        if(buf0[i] != buf1[i]) {
+            err_no ++;
+        }
+    }
+
+    if(err_no == 0) {
+        // calculate valid edid block numbers
+        valid_blk_no = hdmitx_edid_check_valid_blocks(buf0);
+
+        if(valid_blk_no == 0) {
+            hdmi_print(ERR, EDID "raw data are all zeroes\n");
+        }
+        else {
+            for(blk_idx = 0; blk_idx < valid_blk_no; blk_idx++) {
+                hdmitx_edid_blk_print(&buf0[blk_idx*128], blk_idx);
+            }
+        }
+    }
+    else {
+        hdmi_print(ERR, EDID "%d errors between two reading\n", err_no);
+        valid_blk_no = hdmitx_edid_check_valid_blocks(buf0);
+        for(blk_idx = 0; blk_idx < valid_blk_no; blk_idx++) {
+            hdmitx_edid_blk_print(&buf0[blk_idx*128], blk_idx);
+        }
+
+        valid_blk_no = hdmitx_edid_check_valid_blocks(buf1);
+        for(blk_idx = 0; blk_idx < valid_blk_no; blk_idx++) {
+            hdmitx_edid_blk_print(&buf1[blk_idx*128], blk_idx);
+        }
+    }
+}
+
+int hdmitx_edid_dump(hdmitx_dev_t* hdmitx_device, char* buffer, int buffer_len)
+{
+    int i,pos=0;
+    rx_cap_t* pRXCap = &(hdmitx_device->RXCap);
+
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Receiver Brand Name: %s\r\n", pRXCap->ReceiverBrandName);
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Receiver Product Name: %s\r\n", pRXCap->ReceiverProductName);
+
+    pos+=snprintf(buffer+pos, buffer_len-pos, "EDID block number: 0x%x\r\n",hdmitx_device->EDID_buf[0x7e]);
+
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Source Physical Address[a.b.c.d]: %x.%x.%x.%x\r\n",
+        hdmitx_device->hdmi_info.vsdb_phy_addr.a, hdmitx_device->hdmi_info.vsdb_phy_addr.b, hdmitx_device->hdmi_info.vsdb_phy_addr.c, hdmitx_device->hdmi_info.vsdb_phy_addr.d);
+
+    pos+=snprintf(buffer+pos, buffer_len-pos, "native Mode %x, VIC (native %d):\r\n",
+        pRXCap->native_Mode, pRXCap->native_VIC);
+
+    pos+=snprintf(buffer+pos, buffer_len-pos, "ColorDeepSupport %x, MaxTMDSClock %d\r\n",
+        pRXCap->ColorDeepSupport, pRXCap->Max_TMDS_Clock); 
+
+    for( i = 0 ; i < pRXCap->VIC_count ; i++ )
+    {
+        pos+=snprintf(buffer+pos, buffer_len-pos,"%d ", pRXCap->VIC[i]);
+    }
+    pos+=snprintf(buffer+pos, buffer_len-pos,"\r\n");
+    pos+=snprintf(buffer+pos, buffer_len-pos, "Audio {format, channel, freq, cce}\r\n");
+    for(i = 0; i< pRXCap->AUD_count; i++) {
+        pos+=snprintf(buffer+pos, buffer_len-pos, "{%d, %d, %x, %x}\r\n", pRXCap->RxAudioCap[i].audio_format_code,
+            pRXCap->RxAudioCap[i].channel_num_max, pRXCap->RxAudioCap[i].freq_cc, pRXCap->RxAudioCap[i].cc3);
+    }
+    pos+=snprintf(buffer+pos,buffer_len-pos,"Speaker Allocation: %x\r\n", pRXCap->RxSpeakerAllocation);
+    pos+=snprintf(buffer+pos,buffer_len-pos,"Vendor: %x\r\n", pRXCap->IEEEOUI);
+
+    pos+=snprintf(buffer+pos,buffer_len-pos,"Rx 3D Format Support List:\r\n{VIC FramePacking TopBottom SidebySide}\r\n");
+    for(i = 0 ; i < pRXCap->VIC_count; i++){
+        pos+=snprintf(buffer+pos,buffer_len-pos,"{ %d\t%d\t%d\t%d }\n", pRXCap->VIC[i], 
+                                                                   pRXCap->support_3d_format[pRXCap->VIC[i]].frame_packing,
+                                                                   pRXCap->support_3d_format[pRXCap->VIC[i]].top_and_bottom,
+                                                                   pRXCap->support_3d_format[pRXCap->VIC[i]].side_by_side);
+    }
+    return pos;        
+}    
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.c
new file mode 100644
index 00000000..3bb33431
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.c
@@ -0,0 +1,164 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/irq.h>
+#include <linux/types.h>
+#include <linux/input.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/slab.h>
+#include <linux/list.h>
+#include <linux/spinlock.h>
+#include <linux/spinlock_types.h>
+#include <linux/switch.h>
+#include <asm/uaccess.h>
+#include <mach/am_regs.h>
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include "hdmi_tx_hdcp.h"
+/*
+    hdmi_tx_hdcp.c
+    version 1.1
+*/
+
+static struct switch_dev hdcp_dev = {  // android ics switch device
+       .name = "hdcp",
+};
+
+// For most cases, we don't use HDCP
+// If using HDCP, need add follow command in boot/init.rc and recovery/boot/init.rc
+// write /sys/module/hdmitx/parameters/hdmi_output_force 0
+static int hdmi_output_force = 1;
+static int hdmi_authenticated = -1;
+static int hdmi_hdcp_process = 1;   // default hdcp is on, if aksv is 0, then disable
+
+// Notic: the HDCP key setting has been moved to uboot
+// On MBX project, it is too late for HDCP get from 
+// other devices
+
+/* verify ksv, 20 ones and 20 zeroes*/
+int hdcp_ksv_valid(unsigned char * dat)
+{
+    int i, j, one_num = 0;
+    for(i = 0; i < 5; i++){
+        for(j=0;j<8;j++) {
+            if((dat[i]>>j)&0x1) {
+                one_num++;
+            }
+        }
+    }
+    if(one_num == 0)
+        hdmi_print(INF, HDCP "no HDCP key available\n");
+    return (one_num == 20);
+}
+
+static struct timer_list hdcp_monitor_timer;
+static void hdcp_monitor_func(unsigned long arg)
+{
+    //static int hdcp_auth_flag = 0;
+    hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t* )hdcp_monitor_timer.data;
+    if((hdmitx_device->HWOp.Cntl) && (hdmitx_device->log & (HDMI_LOG_HDCP))){
+        hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HDCP_MONITOR, 1);
+    }
+
+    mod_timer(&hdcp_monitor_timer, jiffies + 2 * HZ);
+}
+
+static int hdmitx_hdcp_task(void *data)
+{
+    static int err_cnt = 0;
+    static int time_cnt = 0;
+    hdmitx_dev_t *hdmitx_device = (hdmitx_dev_t*)data;
+
+    init_timer(&hdcp_monitor_timer);
+    hdcp_monitor_timer.data = (ulong) data;
+    hdcp_monitor_timer.function = hdcp_monitor_func;
+    hdcp_monitor_timer.expires = jiffies + HZ;
+    add_timer(&hdcp_monitor_timer);
+
+    while(hdmitx_device->hpd_event != 0xff) {
+        if((hdmitx_device->output_blank_flag == 1) && (hdmitx_device->hpd_state == 1) && (hdmitx_device->cur_VIC != HDMI_Unkown)) {
+            err_cnt = 0;
+            time_cnt = 1;
+            hdmitx_device->output_blank_flag = 0;
+#ifdef CONFIG_AML_HDMI_TX_HDCP
+            hdmi_print(INF, HDCP "start hdcp\n");
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, AVMUTE_OFF, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_RESET_EDID, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_EDID_READ_DATA, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_RESET_HDCP, 0);
+            hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_HDCP_OP, HDCP_ON);
+            msleep(100);
+            while((hdmitx_device->hpd_state == 1) && (hdmitx_device->cur_VIC != HDMI_Unkown)) {
+                hdmi_authenticated = hdmitx_device->HWOp.CntlDDC(hdmitx_device, DDC_HDCP_GET_AUTH, 0);
+                switch_set_state(&hdcp_dev, hdmi_authenticated);
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_VIDEO_BLANK_OP, hdmi_authenticated ? VIDEO_UNBLANK: VIDEO_BLANK);
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_AUDIO_MUTE_OP, hdmi_authenticated ? AUDIO_UNMUTE : AUDIO_MUTE);
+                if( !hdmi_authenticated ) {
+                    err_cnt ++;
+                    if(err_cnt & (3 << time_cnt)) {
+                        time_cnt ++;
+                        hdmi_print(ERR, HDCP "authenticated failed\n");
+                    }
+                }
+                msleep(20);
+                if(hdmitx_device->output_blank_flag == 1)
+                    break;
+            }
+#else
+            hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+            hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_UNMUTE);
+            hdmitx_device->audio_step = 1;
+#endif
+        }
+        msleep_interruptible(100);
+    }
+
+    return 0;
+}
+
+static int __init hdmitx_hdcp_init(void)
+{
+    hdmitx_dev_t *hdmitx_device = get_hdmitx_device();
+
+    switch_dev_register(&hdcp_dev);
+
+    hdmitx_device->task_hdcp = kthread_run(hdmitx_hdcp_task, (void*)hdmitx_device, "kthread_hdcp");
+
+    return 0;
+}
+
+static void __exit hdmitx_hdcp_exit(void)
+{
+    switch_dev_unregister(&hdcp_dev);
+}
+
+
+MODULE_PARM_DESC(hdmi_authenticated, "\n hdmi_authenticated \n");
+module_param(hdmi_authenticated, int, S_IRUGO);
+
+MODULE_PARM_DESC(hdmi_hdcp_process, "\n hdmi_hdcp_process \n");
+module_param(hdmi_hdcp_process, int, 0664);
+
+MODULE_PARM_DESC(hdmi_output_force, "\n hdmi_output_force \n");
+module_param(hdmi_output_force, int, 0664);
+
+
+module_init(hdmitx_hdcp_init);
+//device_initcall_sync(hdmitx_hdcp_init);
+module_exit(hdmitx_hdcp_exit);
+MODULE_DESCRIPTION("AMLOGIC HDMI TX HDCP driver");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.h b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.h
new file mode 100644
index 00000000..eac0270f
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_hdcp.h
@@ -0,0 +1,17 @@
+#ifndef __HDMI_TX_HDCP_H
+#define __HDMI_TX_HDCP_H
+/*
+    hdmi_tx_hdcp.c
+    version 1.0
+*/
+
+// Notic: the HDCP key setting has been moved to uboot
+// On MBX project, it is too late for HDCP get from
+// other devices
+
+//int task_tx_key_setting(unsigned force_wrong);
+
+int hdcp_ksv_valid(unsigned char * dat);
+
+#endif
+
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c
new file mode 100644
index 00000000..7f24db9b
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_main.c
@@ -0,0 +1,1866 @@
+/*
+ * Amlogic HDMI Transmitter 2.0 Driver
+ * Copyright (C) 2014 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+#include <linux/switch.h>
+#include <linux/proc_fs.h>
+#include <asm/uaccess.h>
+#include <mach/am_regs.h>
+
+#include <linux/amlogic/osd/osd_dev.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+
+#include <plat/hdmi_config.h>
+#include "hdmi_tx_hdcp.h"
+
+#include <linux/input.h>
+#include <asm/irq.h>
+#include <asm/io.h>
+#include <linux/of.h>
+
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_cec.h>
+
+#define DEVICE_NAME "amhdmitx"
+#define HDMI_TX_COUNT 32
+#define HDMI_TX_POOL_NUM  6
+#define HDMI_TX_RESOURCE_NUM 4
+#define HDMI_TX_PWR_CTRL_NUM    6
+
+static dev_t hdmitx_id;
+static struct class *hdmitx_class;
+static struct device *hdmitx_dev;
+
+static int set_disp_mode_auto(void);
+const vinfo_t * hdmi_get_current_vinfo(void);
+extern void hdmitx_edid_ram_buffer_clear(hdmitx_dev_t*);
+
+struct hdmi_config_platform_data *hdmi_pdata;
+
+static hdmitx_dev_t hdmitx_device;
+static struct switch_dev sdev = {      // android ics switch device
+       .name = "hdmi",
+       };
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+static void hdmitx_early_suspend(struct early_suspend *h)
+{
+    const vinfo_t *info = hdmi_get_current_vinfo();
+    hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
+    if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0))
+        return;
+    phdmi->hpd_lock = 1;
+    phdmi->HWOp.Cntl((hdmitx_dev_t *)h->param, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_EARLY_SUSPEND);
+    phdmi->cur_VIC = HDMI_Unkown;
+    phdmi->output_blank_flag = 0;
+    phdmi->HWOp.CntlDDC(phdmi, DDC_HDCP_OP, HDCP_OFF);
+    phdmi->HWOp.CntlDDC(phdmi, DDC_HDCP_OP, DDC_RESET_HDCP);
+    phdmi->HWOp.CntlConfig(&hdmitx_device, CONF_CLR_AVI_PACKET, 0);
+    phdmi->HWOp.CntlConfig(&hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
+    hdmi_print(IMP, SYS "HDMITX: early suspend\n");
+}
+
+static void hdmitx_late_resume(struct early_suspend *h)
+{
+    const vinfo_t *info = hdmi_get_current_vinfo();
+    hdmitx_dev_t * phdmi = (hdmitx_dev_t *)h->param;
+    if (info && (strncmp(info->name, "panel", 5) == 0 || strncmp(info->name, "null", 4) == 0)) {
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+       return ;
+    } else {
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_BLANK);
+    }
+    phdmi->hpd_lock = 0;
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
+    hdmitx_device.internal_mode_change = 0;
+    set_disp_mode_auto();
+    pr_info("amhdmitx: late resume module %d\n", __LINE__);
+    phdmi->HWOp.Cntl((hdmitx_dev_t *)h->param, HDMITX_EARLY_SUSPEND_RESUME_CNTL, HDMITX_LATE_RESUME);
+    hdmi_print(INF, SYS "late resume\n");
+}
+
+static struct early_suspend hdmitx_early_suspend_handler = {
+    .level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 10,
+    .suspend = hdmitx_early_suspend,
+    .resume = hdmitx_late_resume,
+    .param = &hdmitx_device,
+};
+#endif
+
+//static HDMI_TX_INFO_t hdmi_info;
+#define INIT_FLAG_VDACOFF        0x1
+    /* unplug powerdown */
+#define INIT_FLAG_POWERDOWN      0x2
+
+#define INIT_FLAG_NOT_LOAD 0x80
+
+int hdmi_ch = 1;        //1: 2ch
+
+static unsigned char init_flag=0;
+static unsigned char init_powermode=0;
+#undef DISABLE_AUDIO
+unsigned char hdmi_audio_off_flag = 0;        //if set to 1, then HDMI will output no audio
+                                                //In KTV case, HDMI output Picture only, and Audio is driven by other sources.
+static int hpdmode = 1; /*
+                            0, do not unmux hpd when off or unplug ;
+                            1, unmux hpd when unplug;
+                            2, unmux hpd when unplug  or off;
+                        */
+#ifdef CONFIG_AM_TV_OUTPUT2
+static int force_vout_index = 0;
+#endif
+static int hdmi_prbs_mode = 0xffff; /* 0xffff=disable; 0=PRBS 11; 1=PRBS 15; 2=PRBS 7; 3=PRBS 31*/
+static int hdmi_480p_force_clk = 0; /* 200, 225, 250, 270 */
+
+static int debug_level = INF;     // 1: error  2: important  3: normal  4: detailed
+
+/*****************************
+*    hdmitx attr management :
+*    enable
+*    mode
+*    reg
+******************************/
+static void set_test_mode(void)
+{
+#ifdef ENABLE_TEST_MODE
+//when it is used as test source (PRBS and 20,22.5,25MHz)
+                if((hdmi_480p_force_clk)&&
+                   ((hdmitx_device.cur_VIC==HDMI_480p60)||
+                    (hdmitx_device.cur_VIC==HDMI_480p60_16x9)||
+                    (hdmitx_device.cur_VIC==HDMI_480i60)||
+                    (hdmitx_device.cur_VIC==HDMI_480i60_16x9)||
+                    (hdmitx_device.cur_VIC==HDMI_576p50)||
+                    (hdmitx_device.cur_VIC==HDMI_576p50_16x9)||
+                    (hdmitx_device.cur_VIC==HDMI_576i50)||
+                    (hdmitx_device.cur_VIC==HDMI_576i50_16x9))
+                    ){
+                    if(hdmitx_device.HWOp.Cntl){
+                        hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_FORCE_480P_CLK, hdmi_480p_force_clk);
+                    }
+                }
+                if(hdmi_prbs_mode != 0xffff){
+                    if(hdmitx_device.HWOp.Cntl){
+                        hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURN_ON_PRBS, hdmi_prbs_mode);
+                    }
+                }
+#endif
+
+}
+
+int get_cur_vout_index(void)
+/*
+return value: 1, vout; 2, vout2;
+*/
+{
+    int vout_index = 1;
+#ifdef CONFIG_AM_TV_OUTPUT2
+    if(force_vout_index){
+        vout_index = force_vout_index;
+    }
+    else{
+//VPU_VIU_VENC_MUX_CTRL
+// [ 3: 2] cntl_viu2_sel_venc. Select which one of the encI/P/T that VIU2 connects to:
+//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
+// [ 1: 0] cntl_viu1_sel_venc. Select which one of the encI/P/T that VIU1 connects to:
+//         0=No connection, 1=ENCI, 2=ENCP, 3=ENCT.
+        int viu2_sel = (aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)>>2)&0x3;
+        int viu1_sel = aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)&0x3;
+        if(((viu2_sel==1)||(viu2_sel==2))&&
+            (viu1_sel!=1)&&(viu1_sel!=2)){
+            vout_index = 2;
+        }
+    }
+#endif
+    return vout_index;
+}
+
+const vinfo_t * hdmi_get_current_vinfo(void)
+{
+    const vinfo_t *info;
+#ifdef CONFIG_AM_TV_OUTPUT2
+    if(get_cur_vout_index() == 2){
+        info = get_current_vinfo2();
+        if(info == NULL){ //add to fix problem when dual display is not enabled in UI
+            info = get_current_vinfo();
+        }
+    }
+    else{
+        info = get_current_vinfo();
+    }
+#else
+    info = get_current_vinfo();
+#endif
+    return info;
+}
+
+static  int  set_disp_mode(const char *mode)
+{
+    int ret=-1;
+    HDMI_Video_Codes_t vic;
+
+    vic = hdmitx_edid_get_VIC(&hdmitx_device, mode, 1);
+    if(strncmp(mode, "4k2k30hz", strlen("4k2k30hz")) == 0) {
+        vic = HDMI_4k2k_30;
+    }
+    else if(strncmp(mode, "4k2k25hz", strlen("4k2k25hz")) == 0) {
+        vic = HDMI_4k2k_25;
+    }
+    else if(strncmp(mode, "4k2k24hz", strlen("4k2k24hz")) == 0) {
+        vic = HDMI_4k2k_24;
+    }
+    else if(strncmp(mode, "4k2ksmpte", strlen("4k2ksmpte")) == 0) {
+        vic = HDMI_4k2k_smpte_24;
+    }
+    else if(strncmp(mode, "4k2k5G", strlen("4k2k5G")) == 0) {
+        vic = HDMI_3840x2160p50_16x9;
+    }
+    else {
+        //nothing
+    }
+
+    if(vic != HDMI_Unkown){
+        hdmitx_device.mux_hpd_if_pin_high_flag = 1;
+        if(hdmitx_device.vic_count == 0){
+               if(hdmitx_device.unplug_powerdown){
+                   return 0;
+                }
+            }
+        }
+
+    hdmitx_device.cur_VIC = HDMI_Unkown;
+    ret = hdmitx_set_display(&hdmitx_device, vic);
+    if(ret>=0){
+        hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AVMUTE_CNTL, AVMUTE_CLEAR);
+        hdmitx_device.cur_VIC = vic;
+        hdmitx_device.audio_param_update_flag = 1;
+        hdmitx_device.auth_process_timer = AUTH_PROCESS_TIME;
+        hdmitx_device.internal_mode_change = 0;
+        set_test_mode();
+    }
+
+    if(hdmitx_device.cur_VIC == HDMI_Unkown){
+        if(hpdmode == 2){
+            hdmitx_edid_clear(&hdmitx_device); /* edid will be read again when hpd is muxed and it is high */
+            hdmitx_device.mux_hpd_if_pin_high_flag = 0;
+        }
+        if(hdmitx_device.HWOp.Cntl){
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);
+        }
+    }
+
+    return ret;
+}
+
+static void hdmitx_pre_display_init(void)
+{
+    hdmitx_device.cur_VIC = HDMI_Unkown;
+    hdmitx_device.auth_process_timer = AUTH_PROCESS_TIME;
+    hdmitx_device.internal_mode_change = 1;
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_BLANK);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
+    //msleep(10);
+//    hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
+//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_MASKN_ENABLE);
+//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_CBUS_RST, 0);
+//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_IP_SW_RST, TX_SYS_SW_RST);
+    //msleep(50);
+//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_MASKN_DISABLE);
+//    hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_INTR_MASKN_CNTL, INTR_CLEAR);
+//    msleep(20);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_AVI_PACKET, 0);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
+    hdmi_print(DET);
+    hdmitx_device.internal_mode_change = 0;
+}
+
+static int set_disp_mode_auto(void)
+{
+    int ret=-1;
+    const vinfo_t *info = NULL;
+    unsigned char mode[16];
+    HDMI_Video_Codes_t vic = HDMI_Unkown;
+    // vic_ready got from IP
+    HDMI_Video_Codes_t vic_ready = hdmitx_device.HWOp.GetState(&hdmitx_device, STAT_VIDEO_VIC, 0);
+
+    memset(mode, 0, 10);
+
+    // if HDMI plug-out, directly return
+    if(!(hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_HPD_GPI_ST, 0))) {
+        hdmi_print(ERR, HPD "HPD deassert!\n");
+        hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
+        return -1;
+    }
+
+    // get current vinfo
+    info = hdmi_get_current_vinfo();
+    if(info == NULL) {
+        hdmi_print(ERR, VID "cann't get valid mode\n");
+        return -1;
+    }
+    else {
+        hdmi_print(IMP, VID "get current mode: %s\n", info->name);
+    }
+
+// If info->name equals to cvbs, then set mode to I mode to hdmi
+    if((strncmp(info->name, "480cvbs", 7) == 0) || (strncmp(info->name, "576cvbs", 7) == 0) ||
+       (strncmp(info->name, "panel", 5) == 0) || (strncmp(info->name, "null", 4) == 0)) {
+        hdmi_print(ERR, VID "%s not valid hdmi mode\n", info->name);
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_AVI_PACKET, 0);
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_CLR_VSDB_PACKET, 0);
+        hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
+        hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+        return -1;
+    }
+    else {
+        memcpy(mode, info->name, strlen(info->name));
+    }
+    hdmitx_device.mode420 = 0;      // default NOT mode420
+    //msleep(500);
+    vic = hdmitx_edid_get_VIC(&hdmitx_device, mode, 1);
+    if(strncmp(info->name, "4k2k30hz", strlen("4k2k30hz")) == 0) {
+        vic = HDMI_4k2k_30;
+    }
+    else if(strncmp(info->name, "4k2k25hz", strlen("4k2k25hz")) == 0) {
+        vic = HDMI_4k2k_25;
+    }
+    else if(strncmp(info->name, "4k2k24hz", strlen("4k2k24hz")) == 0) {
+        vic = HDMI_4k2k_24;
+    }
+    else if(strncmp(info->name, "4k2ksmpte", strlen("4k2ksmpte")) == 0) {
+        vic = HDMI_4k2k_smpte_24;
+    }
+    else if(strncmp(mode, "4k2k5G", strlen("4k2k5G")) == 0) {
+        vic = HDMI_3840x2160p50_16x9;
+    }
+    else if(strncmp(mode, "4k2k60hz", strlen("4k2k60hz")) == 0) {
+        vic = HDMI_3840x2160p60_16x9;
+    }
+    else if(strncmp(mode, "4k2k50hz", strlen("4k2k50hz")) == 0) {
+        vic = HDMI_3840x2160p50_16x9;
+    }
+    else {
+        //nothing
+    }
+    if(strstr(mode, "hz420") != NULL) {
+        hdmitx_device.mode420 = 1;
+    }
+    if((vic_ready != HDMI_Unkown) && (vic_ready == vic)) {
+        hdmi_print(IMP, SYS "[%s] ALREADY init VIC = %d\n", __func__, vic);
+#ifdef CONFIG_AML_HDMI_TX_CTS_DVI
+        if(hdmitx_device.RXCap.IEEEOUI == 0) {
+            // DVI case judgement. In uboot, directly output HDMI mode
+            hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_HDMI_DVI_MODE, DVI_MODE);
+            hdmi_print(IMP, SYS "change to DVI mode\n");
+        }
+#endif
+        hdmitx_device.cur_VIC = vic;
+        hdmitx_device.output_blank_flag = 1;
+        return 1;
+    }
+    else {
+        hdmitx_pre_display_init();
+    }
+
+    hdmitx_device.cur_VIC = HDMI_Unkown;
+    ret = hdmitx_set_display(&hdmitx_device, vic); //if vic is HDMI_Unkown, hdmitx_set_display will disable HDMI
+    if(ret>=0){
+        hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_AVMUTE_CNTL, AVMUTE_CLEAR);
+        hdmitx_device.cur_VIC = vic;
+        hdmitx_device.audio_param_update_flag = 1;
+        hdmitx_device.auth_process_timer = AUTH_PROCESS_TIME;
+        hdmitx_device.internal_mode_change = 0;
+        set_test_mode();
+    }
+    if(hdmitx_device.cur_VIC == HDMI_Unkown){
+        if(hpdmode==2){
+            hdmitx_edid_clear(&hdmitx_device); /* edid will be read again when hpd is muxed and it is high */
+            hdmitx_device.mux_hpd_if_pin_high_flag = 0;
+        }
+        // If current display is NOT panel, needn't TURNOFF_HDMIHW
+        if(strncmp(mode, "panel", 5) == 0){
+            hdmitx_device.HWOp.Cntl(&hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode==2)?1:0);
+        }
+    }
+    if(hdmitx_device.mode420) {
+        switch(hdmitx_device.cur_VIC) {
+        // Currently, only below formats support 420 mode
+        case HDMI_3840x2160p60_16x9:
+        case HDMI_3840x2160p50_16x9:
+        case HDMI_3840x1080p100hz:
+        case HDMI_3840x1080p120hz:
+        case HDMI_3840x540p200hz:
+        case HDMI_3840x540p240hz:
+            printk("configure mode420, VIC = %d\n", hdmitx_device.cur_VIC);
+            hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_CONF_MODE420, hdmitx_device.mode420);
+            break;
+        default:
+            hdmitx_device.mode420 = 0;
+            printk("mode420 only at VIC: %d\n", HDMI_3840x2160p60_16x9);
+        }
+    }
+    hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_CLK_DIV40, hdmitx_device.cur_VIC);
+    hdmitx_set_audio(&hdmitx_device, &(hdmitx_device.cur_audio_param), hdmi_ch);
+    hdmitx_device.output_blank_flag = 1;
+    return ret;
+}
+
+#if 0
+static unsigned int set_cec_code(const char * buf, size_t count)
+{
+    char tmpbuf[128];
+    int i=0;
+    //int j;
+    unsigned int cec_code;
+    //unsigned int value=0;
+
+    while((buf[i])&&(buf[i]!=',')&&(buf[i]!=' ')){
+        tmpbuf[i]=buf[i];
+        i++;
+    }
+    tmpbuf[i]=0;
+
+    cec_code=simple_strtoul(tmpbuf, NULL, 16);
+
+    input_event(remote_cec_dev, EV_KEY, cec_code,1);
+    input_event(remote_cec_dev, EV_KEY, cec_code,0);
+    input_sync(remote_cec_dev);
+    return cec_code;
+}
+#endif
+static unsigned char is_dispmode_valid_for_hdmi(void)
+{
+    HDMI_Video_Codes_t vic;
+    const vinfo_t *info = hdmi_get_current_vinfo();
+
+    vic = hdmitx_edid_get_VIC(&hdmitx_device, info->name, 1);
+
+    return (vic != HDMI_Unkown);
+}
+
+/*disp_mode attr*/
+static ssize_t show_disp_mode(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos=0;
+    pos+=snprintf(buf+pos, PAGE_SIZE, "VIC:%d\r\n", hdmitx_device.cur_VIC);
+    return pos;
+}
+
+static ssize_t store_disp_mode(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    set_disp_mode(buf);
+    return 16;
+}
+
+/*cec attr*/
+static ssize_t show_cec(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    ssize_t t = cec_usrcmd_get_global_info(buf);
+    return t;
+}
+
+static ssize_t store_cec(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    cec_usrcmd_set_dispatch(buf, count);
+    return count;
+}
+
+//static ssize_t show_cec(struct device * dev, struct device_attribute *attr, char * buf)
+//{
+//    ssize_t t = cec_usrcmd_get_global_info(buf);
+//    return t;
+//}
+
+static ssize_t show_cec_config(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos=0;
+    pos+=snprintf(buf+pos, PAGE_SIZE, "P_AO_DEBUG_REG0:0x%x\r\n", aml_read_reg32(P_AO_DEBUG_REG0));
+    return pos;
+}
+
+static ssize_t store_cec_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    cec_usrcmd_set_config(buf, count);
+    return count;
+}
+
+static ssize_t store_cec_lang_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    hdmi_print(INF, CEC "store_cec_lang_config\n");
+    //cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang = strtoul(buf, NULL, 16);
+    cec_usrcmd_set_lang_config(buf, count);
+    return count;
+}
+
+static ssize_t show_cec_lang_config(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos=0;
+    hdmi_print(INF, CEC "show_cec_lang_config\n");
+    pos+=snprintf(buf+pos, PAGE_SIZE, "%x\n",cec_global_info.cec_node_info[cec_global_info.my_node_index].menu_lang);
+    return pos;
+}
+
+/*aud_mode attr*/
+static ssize_t show_aud_mode(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    return 0;
+}
+
+static ssize_t store_aud_mode(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    //set_disp_mode(buf);
+    Hdmi_tx_audio_para_t* audio_param = &(hdmitx_device.cur_audio_param);
+    if(strncmp(buf, "32k", 3)==0){
+        audio_param->sample_rate = FS_32K;
+    }
+    else if(strncmp(buf, "44.1k", 5)==0){
+        audio_param->sample_rate = FS_44K1;
+    }
+    else if(strncmp(buf, "48k", 3)==0){
+        audio_param->sample_rate = FS_48K;
+    }
+    else{
+        hdmitx_device.force_audio_flag = 0;
+        return count;
+    }
+    audio_param->type = CT_PCM;
+    audio_param->channel_num = CC_2CH;
+    audio_param->sample_size = SS_16BITS;
+
+    hdmitx_device.audio_param_update_flag = 1;
+    hdmitx_device.force_audio_flag = 1;
+
+    return count;
+}
+
+/*edid attr*/
+static ssize_t show_edid(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    return hdmitx_edid_dump(&hdmitx_device, buf, PAGE_SIZE);
+}
+
+static ssize_t store_edid(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    if(buf[0]=='h'){
+        int i;
+        hdmi_print(INF, EDID "EDID hash value:\n");
+        for(i=0; i < 20; i++)
+            printk("%02x", hdmitx_device.EDID_hash[i]);
+        printk("\n");
+    }
+    // show singal EDID raw data
+    if ((buf[0] == '0') && ((buf[1] == 'x') || (buf[1] == 'X'))) {
+        unsigned long addr;
+        unsigned char idx, val;
+        addr = simple_strtoul(buf, NULL, 16);
+        if (addr > 0xff) {
+            printk("Invaild EDID Addr: 0x%x\n", (unsigned int)addr);
+            return 16;
+        }
+        idx = (unsigned char) addr;
+        val = hdmitx_device.EDID_buf[idx];
+        printk("EDID[0x%02x]=0x%02x\n", idx, val);
+    }
+
+    if(buf[0]=='d'){
+        int ii,jj;
+        int block_idx;
+        block_idx=simple_strtoul(buf+1,NULL,16);
+        if(block_idx<EDID_MAX_BLOCK){
+            for(ii=0;ii<8;ii++){
+                for(jj=0;jj<16;jj++){
+                    printk("%02x ",hdmitx_device.EDID_buf[block_idx*128+ii*16+jj]);
+                }
+                printk("\n");
+            }
+            printk("\n");
+        }
+    }
+    if(buf[0]=='e'){
+        int ii,jj;
+        int block_idx;
+        block_idx=simple_strtoul(buf+1,NULL,16);
+        if(block_idx<EDID_MAX_BLOCK){
+            for(ii=0;ii<8;ii++){
+                for(jj=0;jj<16;jj++){
+                    printk("%02x ",hdmitx_device.EDID_buf1[block_idx*128+ii*16+jj]);
+                }
+                printk("\n");
+            }
+            printk("\n");
+        }
+    }
+    return 16;
+}
+
+static ssize_t show_edid_info(struct device *dev, struct device_attribute *attr, char *buf)
+{
+    int edid_info_len = 256;
+    memcpy(buf, hdmitx_device.EDID_buf,edid_info_len);
+    return edid_info_len;
+}
+/*config attr*/
+static ssize_t show_config(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos=0;
+    unsigned char *aud_conf;
+    switch(hdmitx_device.tx_aud_cfg) {
+    case 0:
+        aud_conf = "off";
+        break;
+    case 1:
+        aud_conf = "on";
+        break;
+    case 2:
+        aud_conf = "auto";
+        break;
+    default:
+        aud_conf = "none";
+    }
+    pos += snprintf(buf+pos, PAGE_SIZE, "disp switch (force or edid): %s\r\n", (hdmitx_device.disp_switch_config==DISP_SWITCH_FORCE)?"force":"edid");
+    pos += snprintf(buf+pos, PAGE_SIZE, "audio config: %s\r\n", aud_conf);
+    pos += snprintf(buf+pos, PAGE_SIZE, "mode420: %s\r\n", hdmitx_device.mode420 ? "on" : "off");
+    return pos;
+}
+
+static ssize_t store_config(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    if(strncmp(buf, "force", 5)==0){
+        hdmitx_device.disp_switch_config=DISP_SWITCH_FORCE;
+    }
+    else if(strncmp(buf, "edid", 4)==0){
+        hdmitx_device.disp_switch_config=DISP_SWITCH_EDID;
+    }
+    else if(strncmp(buf, "mode420", 7) == 0) {
+        if(strncmp(buf+7, "on", 2) == 0) {
+            hdmitx_device.mode420 = 1;
+        }
+        if(strncmp(buf+7, "off", 3) == 0) {
+            hdmitx_device.mode420 = 0;
+        }
+    }
+    else if(strncmp(buf, "unplug_powerdown", 16) == 0){
+        if(buf[16] == '0'){
+            hdmitx_device.unplug_powerdown = 0;
+        }
+        else{
+            hdmitx_device.unplug_powerdown = 1;
+        }
+    }
+    else if(strncmp(buf, "3d", 2)==0){
+			// First, disable HDMI TMDS
+			hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
+			// Second, set 3D parameters
+        if(strncmp(buf+2, "tb", 2)==0){
+            hdmi_set_3d(&hdmitx_device, 6, 0);
+        }
+        else if(strncmp(buf+2, "lr", 2)==0){
+            int sub_sample_mode=0;
+            if(buf[2])
+                sub_sample_mode = simple_strtoul(buf+2,NULL,10);
+            hdmi_set_3d(&hdmitx_device, 8, sub_sample_mode); //side by side
+        }
+        else if(strncmp(buf+2, "off", 3)==0){
+            hdmi_set_3d(&hdmitx_device, 0xf, 0);
+        }
+				// Last, delay sometime and enable HDMI TMDS
+				msleep(20);
+				hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_ENABLE);
+    }
+    else if(strncmp(buf, "audio_", 6)==0) {
+        if(strncmp(buf+6, "off", 3) == 0) {
+            hdmitx_device.tx_aud_cfg = 0;
+            hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+            hdmi_print(IMP, AUD "configure off\n");
+        }
+        else if(strncmp(buf+6, "on", 2) == 0) {
+            hdmitx_device.tx_aud_cfg = 1;
+            hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_UNMUTE);
+            hdmi_print(IMP, AUD "configure on\n");
+        }
+        else if(strncmp(buf+6, "auto", 4) == 0) {
+            // auto mode. if sink doesn't support current audio format, then no audio output
+            hdmitx_device.tx_aud_cfg = 2;
+            hdmi_print(IMP, AUD "configure auto\n");
+        }
+        else {
+            hdmi_print(ERR, AUD "configure error\n");
+        }
+    }
+    return 16;
+}
+
+
+static ssize_t store_debug(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    hdmitx_device.HWOp.DebugFun(&hdmitx_device, buf);
+    return 16;
+}
+
+// support format lists
+const char* disp_mode_t[]={
+    "480i",
+    "480i_rpt",
+    "480p",
+    "480p_rpt",
+    "576i",
+    "576i_rpt",
+    "576p",
+    "576p_rpt",
+    "720p",
+    "1080i",
+    "1080p",
+    "720p50hz",
+    "1080i50hz",
+    "1080p50hz",
+    "1080p24hz",
+    "4k2k30hz",
+    "4k2k25hz",
+    "4k2k24hz",
+    "4k2ksmpte",
+    "4k1k120hz",
+    "4k1k100hz",
+    "4k05k240hz",
+    "4k05k200hz",
+    NULL
+};
+
+/**/
+static ssize_t show_disp_cap(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int i,pos=0;
+    const char* native_disp_mode = hdmitx_edid_get_native_VIC(&hdmitx_device);
+    HDMI_Video_Codes_t vic;
+    if(hdmitx_device.tv_no_edid){
+        pos += snprintf(buf+pos, PAGE_SIZE,"null edid\n");
+    }
+    else{
+        for(i=0; disp_mode_t[i]; i++){
+            vic = hdmitx_edid_get_VIC(&hdmitx_device, disp_mode_t[i], 0);
+            if( vic != HDMI_Unkown){
+                pos += snprintf(buf+pos, PAGE_SIZE,"%s",disp_mode_t[i]);
+                if(native_disp_mode&&(strcmp(native_disp_mode, disp_mode_t[i])==0)){
+                    pos += snprintf(buf+pos, PAGE_SIZE,"*\n");
+                }
+                else{
+                pos += snprintf(buf+pos, PAGE_SIZE,"\n");
+                }
+            }
+        }
+    }
+    return pos;
+}
+
+
+/**/
+static ssize_t show_disp_cap_3d(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int i,pos=0;
+    int j=0;
+    HDMI_Video_Codes_t vic;
+
+    for(i=0; disp_mode_t[i]; i++){
+        vic = hdmitx_edid_get_VIC(&hdmitx_device, disp_mode_t[i], 0);
+        if( vic == hdmitx_device.cur_VIC) {
+            for(j = 0; j < hdmitx_device.RXCap.VIC_count; j++) {
+                if(vic == hdmitx_device.RXCap.VIC[j]){
+                    break;
+                }
+            }
+            pos += snprintf(buf+pos, PAGE_SIZE,"%s ",disp_mode_t[i]);
+            if(hdmitx_device.RXCap.support_3d_format[hdmitx_device.RXCap.VIC[j]].frame_packing == 1) {
+                pos += snprintf(buf+pos, PAGE_SIZE, "FramePacking ");
+            }
+            if(hdmitx_device.RXCap.support_3d_format[hdmitx_device.RXCap.VIC[j]].top_and_bottom == 1) {
+                pos += snprintf(buf+pos, PAGE_SIZE, "TopBottom ");
+            }
+            if(hdmitx_device.RXCap.support_3d_format[hdmitx_device.RXCap.VIC[j]].side_by_side == 1) {
+                pos += snprintf(buf+pos, PAGE_SIZE, "SidebySide ");
+            }
+        }
+    }
+    pos += snprintf(buf+pos, PAGE_SIZE, "\r\n");
+
+    return pos;
+}
+
+/**/
+static ssize_t show_aud_cap(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int i,pos=0, j;
+    const char* aud_coding_type[] =  {"ReferToStreamHeader", "PCM", "AC-3", "MPEG1", "MP3", "MPEG2", "AAC", "DTS", "ATRAC",
+                "OneBitAudio", "Dobly_Digital+", "DTS-HD", "MAT", "DST", "WMA_Pro", "Reserved", NULL};
+    const char* aud_sampling_frequency[] = {"ReferToStreamHeader", "32", "44.1", "48", "88.2", "96", "176.4", "192", NULL};
+    const char* aud_sample_size[] = {"ReferToStreamHeader", "16", "20", "24", NULL};
+
+    rx_cap_t* pRXCap = &(hdmitx_device.RXCap);
+    pos += snprintf(buf + pos, PAGE_SIZE, "CodingType, MaxChannels, SamplingFrequency, SampleSize\n");
+    for(i = 0; i< pRXCap->AUD_count; i++) {
+        pos += snprintf(buf + pos, PAGE_SIZE, "%s, %d ch, ", aud_coding_type[pRXCap->RxAudioCap[i].audio_format_code],
+            pRXCap->RxAudioCap[i].channel_num_max + 1);
+        for(j = 0; j < 7; j++) {
+            if(pRXCap->RxAudioCap[i].freq_cc & (1 << j))
+                pos += snprintf(buf + pos, PAGE_SIZE, "%s/", aud_sampling_frequency[j+1]);
+        }
+        pos += snprintf(buf + pos - 1, PAGE_SIZE, " kHz, ");
+        for(j = 0; j < 3; j++) {
+            if(pRXCap->RxAudioCap[i].cc3 & (1 << j))
+                pos += snprintf(buf + pos, PAGE_SIZE, "%s/", aud_sample_size[j+1]);
+        }
+        pos += snprintf(buf + pos - 1, PAGE_SIZE, " bit\n");
+    }
+
+    return pos;
+}
+
+static ssize_t show_aud_ch(struct device * dev, struct device_attribute *attr, char * buf)
+{
+       int pos = 0;
+       pos += snprintf(buf + pos, PAGE_SIZE, "hdmi_channel = %d ch\n", hdmi_ch ? hdmi_ch + 1 : 0);
+       return pos;
+}
+
+static ssize_t store_aud_ch(struct device * dev, struct device_attribute *attr, const char * buf, size_t count)
+{
+    if(strncmp(buf, "6ch", 3) == 0){
+        hdmi_ch = 5;
+    }
+    else if(strncmp(buf, "8ch", 3) == 0){
+        hdmi_ch = 7;
+    }
+    else if(strncmp(buf, "2ch", 3) == 0){
+        hdmi_ch = 1;
+    }
+    else{
+        return count;
+    }
+
+    hdmitx_device.audio_param_update_flag = 1;
+    hdmitx_device.force_audio_flag = 1;
+
+    return count;
+}
+
+static ssize_t show_hdcp_ksv_info(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos = 0, i;
+    char aksv_buf[5];
+    char bksv_buf[5];
+
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_GET_AKSV, (unsigned int)aksv_buf);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_GET_BKSV, (unsigned int)bksv_buf);
+
+    pos+=snprintf(buf+pos, PAGE_SIZE, "AKSV: ");
+    for(i = 0;i < 5; i++) {
+        pos+=snprintf(buf+pos, PAGE_SIZE, "%02x", aksv_buf[i]);
+    }
+    pos+=snprintf(buf+pos, PAGE_SIZE, "  %s\r\n", hdcp_ksv_valid(aksv_buf) ? "Valid" : "Invalid");
+
+    pos+=snprintf(buf+pos, PAGE_SIZE, "BKSV: ");
+    for(i = 0;i < 5; i++) {
+        pos+=snprintf(buf+pos, PAGE_SIZE, "%02x", bksv_buf[i]);
+    }
+    pos+=snprintf(buf+pos, PAGE_SIZE, "  %s\r\n", hdcp_ksv_valid(bksv_buf) ? "Valid" : "Invalid");
+
+    return pos;
+}
+
+static ssize_t show_hpd_state(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos=0;
+
+    hdmitx_device.hpd_state = hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_HPD_GPI_ST, 0);
+    pos += snprintf(buf+pos, PAGE_SIZE,"%d", hdmitx_device.hpd_state);
+    return pos;
+}
+
+static ssize_t show_support_3d(struct device * dev, struct device_attribute *attr, char * buf)
+{
+    int pos=0;
+
+    pos += snprintf(buf+pos, PAGE_SIZE,"%d\r\n", hdmitx_device.RXCap.threeD_present);
+    return pos;
+}
+
+void hdmi_print(int dbg_lvl, const char *fmt, ...)
+{
+    va_list args;
+    if(dbg_lvl == OFF)
+        return ;
+    if(dbg_lvl <= debug_level) {
+        va_start(args, fmt);
+        vprintk(fmt, args);
+        va_end(args);
+    }
+}
+
+static DEVICE_ATTR(disp_mode, S_IWUSR | S_IRUGO | S_IWGRP, show_disp_mode, store_disp_mode);
+static DEVICE_ATTR(aud_mode, S_IWUSR | S_IRUGO, show_aud_mode, store_aud_mode);
+static DEVICE_ATTR(edid, S_IWUSR | S_IRUGO, show_edid, store_edid);
+static DEVICE_ATTR(edid_info, S_IWUSR | S_IRUGO, show_edid_info, NULL);
+static DEVICE_ATTR(config, S_IWUSR | S_IRUGO | S_IWGRP, show_config, store_config);
+static DEVICE_ATTR(debug, S_IWUSR | S_IRUGO, NULL, store_debug);
+static DEVICE_ATTR(disp_cap, S_IWUSR | S_IRUGO, show_disp_cap, NULL);
+static DEVICE_ATTR(aud_cap, S_IWUSR | S_IRUGO, show_aud_cap, NULL);
+static DEVICE_ATTR(aud_ch, S_IWUSR | S_IRUGO | S_IWGRP, show_aud_ch, store_aud_ch);
+static DEVICE_ATTR(disp_cap_3d, S_IWUSR | S_IRUGO, show_disp_cap_3d, NULL);
+static DEVICE_ATTR(hdcp_ksv_info, S_IWUSR | S_IRUGO, show_hdcp_ksv_info, NULL);
+static DEVICE_ATTR(hpd_state, S_IWUSR | S_IRUGO, show_hpd_state, NULL);
+static DEVICE_ATTR(support_3d, S_IWUSR | S_IRUGO, show_support_3d, NULL);
+static DEVICE_ATTR(cec, S_IWUSR | S_IRUGO, show_cec, store_cec);
+static DEVICE_ATTR(cec_config, S_IWUSR | S_IRUGO | S_IWGRP, show_cec_config, store_cec_config);
+//static DEVICE_ATTR(cec_config, S_IWUGO | S_IRUGO , NULL, store_cec_config);
+static DEVICE_ATTR(cec_lang_config, S_IWUSR | S_IRUGO | S_IWGRP, show_cec_lang_config, store_cec_lang_config);
+
+/*****************************
+*    hdmitx display client interface
+*
+******************************/
+static int hdmitx_notify_callback_v(struct notifier_block *block, unsigned long cmd , void *para)
+{
+    if(get_cur_vout_index()!=1)
+        return 0;
+
+    if (cmd != VOUT_EVENT_MODE_CHANGE)
+        return 0;
+    if(hdmitx_device.vic_count == 0){
+        if(is_dispmode_valid_for_hdmi()){
+            hdmitx_device.mux_hpd_if_pin_high_flag = 1;
+            if(hdmitx_device.unplug_powerdown){
+                      return 0;
+                  }
+            }
+    }
+
+    set_disp_mode_auto();
+
+    return 0;
+}
+
+#ifdef CONFIG_AM_TV_OUTPUT2
+static int hdmitx_notify_callback_v2(struct notifier_block *block, unsigned long cmd , void *para)
+{
+    if(get_cur_vout_index()!=2)
+        return 0;
+
+    if (cmd != VOUT_EVENT_MODE_CHANGE)
+        return 0;
+
+    if(hdmitx_device.vic_count == 0){
+        if(is_dispmode_valid_for_hdmi()){
+            hdmitx_device.mux_hpd_if_pin_high_flag = 1;
+            if(hdmitx_device.unplug_powerdown){
+                      return 0;
+                  }
+            }
+    }
+
+    set_disp_mode_auto();
+
+    return 0;
+}
+#endif
+
+static struct notifier_block hdmitx_notifier_nb_v = {
+    .notifier_call    = hdmitx_notify_callback_v,
+};
+
+#ifdef CONFIG_AM_TV_OUTPUT2
+static struct notifier_block hdmitx_notifier_nb_v2 = {
+    .notifier_call    = hdmitx_notify_callback_v2,
+};
+#endif
+
+// Refer to CEA-861-D Page 88
+#ifdef CONFIG_SND_SOC
+#define AOUT_EVENT_REFER_TO_STREAM_HEADER       0x0
+#define AOUT_EVENT_IEC_60958_PCM                0x1
+#define AOUT_EVENT_RAWDATA_AC_3                 0x2
+#define AOUT_EVENT_RAWDATA_MPEG1                0x3
+#define AOUT_EVENT_RAWDATA_MP3                  0x4
+#define AOUT_EVENT_RAWDATA_MPEG2                0x5
+#define AOUT_EVENT_RAWDATA_AAC                  0x6
+#define AOUT_EVENT_RAWDATA_DTS                  0x7
+#define AOUT_EVENT_RAWDATA_ATRAC                0x8
+#define AOUT_EVENT_RAWDATA_ONE_BIT_AUDIO        0x9
+#define AOUT_EVENT_RAWDATA_DOBLY_DIGITAL_PLUS   0xA
+#define AOUT_EVENT_RAWDATA_DTS_HD               0xB
+#define AOUT_EVENT_RAWDATA_MAT_MLP              0xC
+#define AOUT_EVENT_RAWDATA_DST                  0xD
+#define AOUT_EVENT_RAWDATA_WMA_PRO              0xE
+#include <linux/soundcard.h>
+#include <sound/core.h>
+#include <sound/pcm.h>
+#include <sound/initval.h>
+#include <sound/control.h>
+
+static struct rate_map_fs map_fs[] = {
+    {0,      FS_REFER_TO_STREAM},
+    {32000,  FS_32K},
+    {44100,  FS_44K1},
+    {48000,  FS_48K},
+    {88200,  FS_88K2},
+    {96000,  FS_96K},
+    {176400, FS_176K4},
+    {192000, FS_192K},
+};
+
+static audio_fs_t aud_samp_rate_map(unsigned int rate)
+{
+    int i = 0;
+
+    for(i = 0; i < ARRAY_SIZE(map_fs); i++) {
+        if(map_fs[i].rate == rate) {
+            hdmi_print(IMP, AUD "aout notify rate %d\n", rate);
+            return map_fs[i].fs;
+        }
+    }
+    hdmi_print(IMP, AUD "get FS_MAX\n");
+    return FS_MAX;
+}
+
+static unsigned char *aud_type_string[] = {
+    "CT_REFER_TO_STREAM",
+    "CT_PCM",
+    "CT_AC_3",
+    "CT_MPEG1",
+    "CT_MP3",
+    "CT_MPEG2",
+    "CT_AAC",
+    "CT_DTS",
+    "CT_ATRAC",
+    "CT_ONE_BIT_AUDIO",
+    "CT_DOLBY_D",
+    "CT_DTS_HD",
+    "CT_MAT",
+    "CT_DST",
+    "CT_WMA",
+    "CT_MAX",
+};
+
+static struct size_map_ss aud_size_map_ss[] = {
+    {0,     SS_REFER_TO_STREAM},
+    {16,    SS_16BITS},
+    {20,    SS_20BITS},
+    {24,    SS_24BITS},
+    {32,    SS_MAX},
+};
+
+static audio_sample_size_t aud_size_map(unsigned int bits)
+{
+    int i;
+
+    for(i = 0; i < ARRAY_SIZE(aud_size_map_ss); i ++) {
+        if(bits == aud_size_map_ss[i].sample_bits) {
+            hdmi_print(IMP, AUD "aout notify size %d\n", bits);
+            return aud_size_map_ss[i].ss;
+        }
+    }
+    hdmi_print(IMP, AUD "get SS_MAX\n");
+    return SS_MAX;
+}
+
+extern int aout_register_client(struct notifier_block * ) ;
+extern int aout_unregister_client(struct notifier_block * ) ;
+static int hdmitx_notify_callback_a(struct notifier_block *block, unsigned long cmd , void *para);
+struct notifier_block hdmitx_notifier_nb_a = {
+    .notifier_call    = hdmitx_notify_callback_a,
+};
+static int hdmitx_notify_callback_a(struct notifier_block *block, unsigned long cmd , void *para)
+{
+    int i, audio_check = 0;
+    rx_cap_t* pRXCap = &(hdmitx_device.RXCap);
+    struct snd_pcm_substream *substream =(struct snd_pcm_substream*)para;
+    Hdmi_tx_audio_para_t* audio_param = &(hdmitx_device.cur_audio_param);
+    audio_fs_t n_rate = aud_samp_rate_map(substream->runtime->rate);
+    audio_sample_size_t n_size = aud_size_map(substream->runtime->sample_bits);
+
+    hdmitx_device.audio_param_update_flag = 0;
+    hdmitx_device.audio_notify_flag = 0;
+
+    if(audio_param->sample_rate != n_rate) {
+        audio_param->sample_rate = n_rate;
+        hdmitx_device.audio_param_update_flag = 1;
+    }
+
+    if(audio_param->type != cmd) {
+        audio_param->type = cmd;
+        hdmi_print(INF, AUD "aout notify format %s\n", aud_type_string[audio_param->type]);
+        hdmitx_device.audio_param_update_flag = 1;
+    }
+
+    if(audio_param->sample_size != n_size) {
+        audio_param->sample_size = n_size;
+        hdmitx_device.audio_param_update_flag = 1;
+    }
+
+    if(audio_param->channel_num != (substream->runtime->channels - 1)) {
+        audio_param->channel_num = substream->runtime->channels - 1;
+        hdmitx_device.audio_param_update_flag = 1;
+    }
+    if(hdmitx_device.tx_aud_cfg == 2) {
+        hdmi_print(INF, AUD "auto mode\n");
+        // Detect whether Rx is support current audio format
+        for(i = 0; i < pRXCap->AUD_count; i++){
+            if(pRXCap->RxAudioCap[i].audio_format_code == cmd)
+            audio_check = 1;
+        }
+        if((!audio_check) && (cmd != AOUT_EVENT_IEC_60958_PCM)) {      // sink don't support current audio mode
+            printk("Sink not support this audio format %lu\n", cmd);
+            hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+            hdmitx_device.audio_param_update_flag = 0;
+        }
+    }
+    if(hdmitx_device.audio_param_update_flag == 0)
+        hdmi_print(INF, AUD "no update\n");
+    else
+        hdmitx_device.audio_notify_flag = 1;
+
+
+    if((!hdmi_audio_off_flag)&&(hdmitx_device.audio_param_update_flag)) {
+        if(hdmitx_device.hpd_state == 1) {     // plug-in & update audio param
+            hdmitx_set_audio(&hdmitx_device, &(hdmitx_device.cur_audio_param), hdmi_ch);
+	    if((hdmitx_device.audio_notify_flag == 1) || (hdmitx_device.audio_step == 1)) {
+                hdmitx_device.audio_notify_flag = 0;
+                hdmitx_device.audio_step = 0;
+#ifndef CONFIG_AML_HDMI_TX_HDCP
+                hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_UNMUTE);
+#endif
+            }
+            hdmitx_device.audio_param_update_flag = 0;
+            hdmi_print(INF, AUD "set audio param\n");
+        }
+    }
+
+
+    return 0;
+}
+#endif
+static DEFINE_MUTEX(setclk_mutex);
+void hdmitx_hpd_plugin_handler(struct work_struct *work)
+{
+    hdmitx_dev_t *hdev = container_of((struct delayed_work *)work, struct hdmi_tx_dev_s, work_hpd_plugin);
+
+    if(!(hdev->hdmitx_event & (HDMI_TX_HPD_PLUGIN)))
+        return;
+    printk("hdmitx: plugin\n");
+    mutex_lock(&setclk_mutex);
+    // start reading E-EDID
+    hdev->hpd_state = 1;
+
+    hdmitx_edid_ram_buffer_clear(hdev);
+    hdev->HWOp.CntlDDC(hdev, DDC_RESET_EDID, 0);
+    hdev->HWOp.CntlDDC(hdev, DDC_PIN_MUX_OP, PIN_MUX);
+    hdev->HWOp.CntlDDC(hdev, DDC_EDID_READ_DATA, 0);      // start reading edid frist time
+    hdev->HWOp.CntlDDC(hdev, DDC_EDID_GET_DATA, 0);
+    hdev->HWOp.CntlDDC(hdev, DDC_EDID_READ_DATA, 0);      // start reading edid second time
+    hdev->HWOp.CntlDDC(hdev, DDC_EDID_GET_DATA, 1);
+    hdev->HWOp.CntlDDC(hdev, DDC_PIN_MUX_OP, PIN_UNMUX);
+    // compare EDID_buf & EDID_buf1
+    hdmitx_edid_buf_compare_print(hdev);
+    hdmitx_edid_clear(hdev);
+    hdmitx_edid_parse(hdev);
+
+    set_disp_mode_auto();
+    hdmitx_set_audio(hdev, &(hdev->cur_audio_param), hdmi_ch);
+    switch_set_state(&sdev, 1);
+    cec_node_init(hdev);
+
+    hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGIN;
+    mutex_unlock(&setclk_mutex);
+}
+
+void hdmitx_hpd_plugout_handler(struct work_struct *work)
+{
+    hdmitx_dev_t *hdev = container_of((struct delayed_work *)work, struct hdmi_tx_dev_s, work_hpd_plugout);
+
+    if(!(hdev->hdmitx_event & (HDMI_TX_HPD_PLUGOUT)))
+        return;
+    mutex_lock(&setclk_mutex);
+    hdev->hpd_state = 0;
+    //hdev->HWOp.CntlConfig(hdev, CONF_CLR_AVI_PACKET, 0);
+    printk("hdmitx: plugout\n");
+    switch_set_state(&sdev, 0);
+    hdev->hdmitx_event &= ~HDMI_TX_HPD_PLUGOUT;
+    mutex_unlock(&setclk_mutex);
+}
+
+void hdmitx_internal_intr_handler(struct work_struct *work)
+{
+    hdmitx_dev_t *hdev = container_of((struct work_struct *)work, struct hdmi_tx_dev_s, work_internal_intr);
+
+    hdev->HWOp.DebugFun(hdev, "dumpintr");
+}
+
+/******************************
+*  hdmitx kernel task
+*******************************/
+
+static int hdmi_task_handle(void *data)
+{
+    hdmitx_dev_t* hdmitx_device = (hdmitx_dev_t*)data;
+
+    sdev.state = !!(hdmitx_device->HWOp.CntlMisc(hdmitx_device, MISC_HPD_GPI_ST, 0));
+    hdmitx_device->hpd_state = sdev.state;
+
+    //When init hdmi, clear the hdmitx module edid ram and edid buffer.
+    hdmitx_edid_ram_buffer_clear(hdmitx_device);
+
+    hdmitx_device->hdmi_wq = alloc_workqueue(DEVICE_NAME, WQ_HIGHPRI | WQ_CPU_INTENSIVE, 0);
+    INIT_DELAYED_WORK(&hdmitx_device->work_hpd_plugin, hdmitx_hpd_plugin_handler);
+    INIT_DELAYED_WORK(&hdmitx_device->work_hpd_plugout, hdmitx_hpd_plugout_handler);
+    INIT_WORK(&hdmitx_device->work_internal_intr, hdmitx_internal_intr_handler);
+
+    hdmitx_device->tx_aud_cfg = 1; // default audio configure is on
+    if(init_flag&INIT_FLAG_POWERDOWN){
+        hdmitx_device->HWOp.SetDispMode(hdmitx_device, NULL); //power down
+        hdmitx_device->unplug_powerdown=1;
+        hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_TURNOFF_HDMIHW, (hpdmode!=0)?1:0);
+    }
+    else{
+        hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_MUX_HPD, 0);
+    }
+    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_IP_INTR_MASN_RST, 0);
+    hdmitx_device->HWOp.Cntl(hdmitx_device, HDMITX_HWCMD_MUX_HPD_IF_PIN_HIGH, 0);
+
+    hdmitx_device->HWOp.SetupIRQ(hdmitx_device);
+    return 0;
+}
+
+/* Linux */
+/*****************************
+*    hdmitx driver file_operations
+*
+******************************/
+static int amhdmitx_open(struct inode *node, struct file *file)
+{
+    hdmitx_dev_t *hdmitx_in_devp;
+
+    /* Get the per-device structure that contains this cdev */
+    hdmitx_in_devp = container_of(node->i_cdev, hdmitx_dev_t, cdev);
+    file->private_data = hdmitx_in_devp;
+
+    return 0;
+
+}
+
+
+static int amhdmitx_release(struct inode *node, struct file *file)
+{
+    //hdmitx_dev_t *hdmitx_in_devp = file->private_data;
+
+    /* Reset file pointer */
+
+    /* Release some other fields */
+    /* ... */
+    return 0;
+}
+
+
+#if 0
+static int amhdmitx_ioctl(struct inode *node, struct file *file, unsigned int cmd,   unsigned long args)
+{
+    int   r = 0;
+    switch (cmd) {
+        default:
+            break;
+    }
+    return r;
+}
+#endif
+const static struct file_operations amhdmitx_fops = {
+    .owner    = THIS_MODULE,
+    .open     = amhdmitx_open,
+    .release  = amhdmitx_release,
+//    .ioctl    = amhdmitx_ioctl,
+};
+
+hdmitx_dev_t * get_hdmitx_device(void)
+{
+    return &hdmitx_device;
+}
+EXPORT_SYMBOL(get_hdmitx_device);
+
+static int get_dt_vend_init_data(struct device_node *np, struct vendor_info_data *vend)
+{
+    int ret;
+
+    ret = of_property_read_string(np, "vendor_name", (const char **)&(vend->vendor_name));
+    if(ret) {
+        hdmi_print(INF, SYS "not find vendor name\n");
+        return 1;
+    }
+
+    ret = of_property_read_u32(np, "vendor_id", &(vend->vendor_id));
+    if(ret) {
+        hdmi_print(INF, SYS "not find vendor id\n");
+        return 1;
+    }
+
+    ret = of_property_read_string(np, "product_desc", (const char **)&(vend->product_desc));
+    if(ret) {
+        hdmi_print(INF, SYS "not find product desc\n");
+        return 1;
+    }
+
+    ret = of_property_read_string(np, "cec_osd_string", (const char **)&(vend->cec_osd_string));
+    if(ret) {
+        hdmi_print(INF, SYS "not find cec osd string\n");
+        return 1;
+    }
+    return 0;
+}
+
+static int pwr_type_match(struct device_node *np, const char *str, int idx, struct hdmi_pwr_ctl *pwr, char* pwr_col)
+{
+    int i = 0;
+    int ret = 0;
+    int gpio_val;
+    struct pwr_ctl_var (*var)[HDMI_TX_PWR_CTRL_NUM] = (struct pwr_ctl_var (*)[HDMI_TX_PWR_CTRL_NUM])pwr;
+
+    const static char *pwr_types_id[] = {"none", "cpu", "axp202", NULL};     //match with dts file
+    while(pwr_types_id[i]) {
+        if(strcasecmp(pwr_types_id[i], str) == 0) {
+            ret = 1;
+            break;
+        }
+        i ++;
+    }
+    switch(i) {
+    case CPU_GPO:
+        var[idx]->type = CPU_GPO;
+        ret = of_property_read_string_index(np, pwr_col, 1, &str);
+        if(!ret) {
+            gpio_val = amlogic_gpio_name_map_num(str);
+            ret = amlogic_gpio_request(gpio_val, DEVICE_NAME);
+            if (!ret) {
+                var[idx]->var.gpo.pin = gpio_val;
+                ret = of_property_read_string_index(np, pwr_col, 2, &str);
+                if(!ret) {
+                    var[idx]->var.gpo.val = (strcmp(str, "H") == 0);
+                }
+            }
+        }
+        break;
+    case AXP202:
+        var[idx]->type = AXP202;
+// TODO later
+        break;
+    default:
+        var[idx]->type = NONE;
+    };
+    return ret;
+}
+
+static int get_dt_pwr_init_data(struct device_node *np, struct hdmi_pwr_ctl *pwr)
+{
+    int ret = 0;
+    int idx = 0;
+    const char *str = NULL;
+    char *hdmi_pwr_string[] = {"pwr_5v_on", "pwr_5v_off", "pwr_3v3_on", "pwr_3v3_off", "pwr_hpll_vdd_on", "pwr_hpll_vdd_off", NULL};    //match with dts file
+
+    while(hdmi_pwr_string[idx]) {
+        ret = of_property_read_string_index(np, hdmi_pwr_string[idx], 0, &str);
+        if(!ret) {
+            pwr_type_match(np, str, idx, pwr, hdmi_pwr_string[idx]);
+        }
+        idx++;
+    }
+
+    if(np != NULL) {
+	    ret = of_property_read_u32(np,"pwr_level",&pwr->pwr_level);
+    }
+#if 0
+    struct pwr_ctl_var (*var)[HDMI_TX_PWR_CTRL_NUM] = (struct pwr_ctl_var (*)[HDMI_TX_PWR_CTRL_NUM])pwr;
+    for(idx = 0; idx < HDMI_TX_PWR_CTRL_NUM; idx++) {
+        hdmi_print(INF, SYS "%d %d %d\n", var[idx]->type, var[idx]->var.gpo.pin, var[idx]->var.gpo.val);
+        return 1;
+    }
+#endif
+    return 0;
+}
+
+static void hdmitx_pwr_init(struct hdmi_pwr_ctl *ctl)
+{
+    if(ctl) {
+        if(ctl->pwr_5v_on.type == CPU_GPO) {
+            amlogic_gpio_direction_output(ctl->pwr_5v_on.var.gpo.pin, ctl->pwr_5v_on.var.gpo.val, DEVICE_NAME);
+        }
+        if(ctl->pwr_3v3_on.type == CPU_GPO) {
+            amlogic_gpio_direction_output(ctl->pwr_3v3_on.var.gpo.pin, ctl->pwr_3v3_on.var.gpo.val, DEVICE_NAME);
+        }
+        if(ctl->pwr_hpll_vdd_on.type == CPU_GPO) {
+            amlogic_gpio_direction_output(ctl->pwr_hpll_vdd_on.var.gpo.pin, ctl->pwr_hpll_vdd_on.var.gpo.val, DEVICE_NAME);
+        }
+    }
+}
+
+static int amhdmitx_probe(struct platform_device *pdev)
+{
+    extern struct switch_dev lang_dev;
+    int r,ret=0;
+
+#ifdef CONFIG_USE_OF
+    int psize, val;
+    phandle phandle;
+    struct device_node *init_data;
+#endif
+
+    hdmi_print(IMP, SYS "amhdmitx_probe\n");
+
+    r = alloc_chrdev_region(&hdmitx_id, 0, HDMI_TX_COUNT, DEVICE_NAME);
+    if (r < 0) {
+        hdmi_print(INF, SYS "Can't register major for amhdmitx device\n");
+        return r;
+    }
+
+    hdmitx_class = class_create(THIS_MODULE, DEVICE_NAME);
+    if (IS_ERR(hdmitx_class))
+    {
+        unregister_chrdev_region(hdmitx_id, HDMI_TX_COUNT);
+        return -1;
+        //return PTR_ERR(aoe_class);
+    }
+
+    hdmitx_device.unplug_powerdown=0;
+    hdmitx_device.vic_count=0;
+    hdmitx_device.auth_process_timer=0;
+    hdmitx_device.force_audio_flag=0;
+    hdmitx_device.tv_cec_support=0;
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+    register_early_suspend(&hdmitx_early_suspend_handler);
+#endif
+
+    if((init_flag&INIT_FLAG_POWERDOWN)&&(hpdmode==2)){
+        hdmitx_device.mux_hpd_if_pin_high_flag=0;
+    }
+    else{
+        hdmitx_device.mux_hpd_if_pin_high_flag=1;
+    }
+    hdmitx_device.audio_param_update_flag=0;
+    cdev_init(&(hdmitx_device.cdev), &amhdmitx_fops);
+    hdmitx_device.cdev.owner = THIS_MODULE;
+    cdev_add(&(hdmitx_device.cdev), hdmitx_id, HDMI_TX_COUNT);
+
+    //hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, "amhdmitx%d", 0);
+    hdmitx_dev = device_create(hdmitx_class, NULL, hdmitx_id, NULL, "amhdmitx%d", 0); //kernel>=2.6.27
+
+    ret=device_create_file(hdmitx_dev, &dev_attr_disp_mode);
+    ret=device_create_file(hdmitx_dev, &dev_attr_aud_mode);
+    ret=device_create_file(hdmitx_dev, &dev_attr_edid);
+    ret=device_create_file(hdmitx_dev, &dev_attr_edid_info);
+    ret=device_create_file(hdmitx_dev, &dev_attr_config);
+    ret=device_create_file(hdmitx_dev, &dev_attr_debug);
+    ret=device_create_file(hdmitx_dev, &dev_attr_disp_cap);
+    ret=device_create_file(hdmitx_dev, &dev_attr_disp_cap_3d);
+    ret=device_create_file(hdmitx_dev, &dev_attr_aud_cap);
+    ret=device_create_file(hdmitx_dev, &dev_attr_aud_ch);
+    ret=device_create_file(hdmitx_dev, &dev_attr_hdcp_ksv_info);
+    ret=device_create_file(hdmitx_dev, &dev_attr_hpd_state);
+    ret=device_create_file(hdmitx_dev, &dev_attr_support_3d);
+    ret=device_create_file(hdmitx_dev, &dev_attr_cec);
+    ret=device_create_file(hdmitx_dev, &dev_attr_cec_config);
+    ret=device_create_file(hdmitx_dev, &dev_attr_cec_lang_config);
+
+    if (hdmitx_dev == NULL) {
+        hdmi_print(ERR, SYS "device_create create error\n");
+        class_destroy(hdmitx_class);
+        r = -EEXIST;
+        return r;
+    }
+    vout_register_client(&hdmitx_notifier_nb_v);
+#ifdef CONFIG_AM_TV_OUTPUT2
+    vout2_register_client(&hdmitx_notifier_nb_v2);
+#endif
+#ifdef CONFIG_SND_SOC
+    aout_register_client(&hdmitx_notifier_nb_a);
+#endif
+#ifdef CONFIG_USE_OF
+    if(pdev->dev.of_node){
+        memset(&hdmitx_device.config_data, 0, sizeof(struct hdmi_config_platform_data));
+// Get physical setting data
+        ret = of_property_read_u32(pdev->dev.of_node, "phy-size", &psize);
+        if(!ret) {
+            hdmitx_device.config_data.phy_data = kzalloc(sizeof(struct hdmi_phy_set_data)*psize, GFP_KERNEL);
+            if(!hdmitx_device.config_data.phy_data) {
+                hdmi_print(INF, SYS "can not get phy_data mem\n");
+            }
+            else {
+                ret = of_property_read_u32_array(pdev->dev.of_node, "phy-data", (unsigned int *)(hdmitx_device.config_data.phy_data), (sizeof(struct hdmi_phy_set_data))*psize/sizeof(struct hdmi_phy_set_data*));
+                if(ret){
+                    hdmi_print(INF, SYS "not find match psize\n");
+                }
+            }
+        }
+// Get vendor information
+        ret = of_property_read_u32(pdev->dev.of_node,"vend-data",&val);
+        if(ret) {
+            hdmi_print(INF, SYS "not find match init-data\n");
+        }
+        if(ret == 0) {
+            phandle = val;
+            init_data = of_find_node_by_phandle(phandle);
+            if(!init_data) {
+                hdmi_print(INF, SYS "not find device node\n");
+            }
+            hdmitx_device.config_data.vend_data = kzalloc(sizeof(struct vendor_info_data), GFP_KERNEL);
+            if(!hdmitx_device.config_data.vend_data) {
+                hdmi_print(INF, SYS "can not get vend_data mem\n");
+            }
+            ret = get_dt_vend_init_data(init_data, hdmitx_device.config_data.vend_data);
+            if(ret) {
+                hdmi_print(INF, SYS "not find vend_init_data\n");
+            }
+        }
+// Get power control
+        ret = of_property_read_u32(pdev->dev.of_node,"pwr-ctrl", &val);
+        if(ret) {
+            hdmi_print(INF, SYS "not find match pwr-ctl\n");
+        }
+        if(ret == 0) {
+            phandle = val;
+            init_data = of_find_node_by_phandle(phandle);
+            if(!init_data) {
+                hdmi_print(INF, SYS "not find device node\n");
+            }
+            hdmitx_device.config_data.pwr_ctl = kzalloc((sizeof(struct hdmi_pwr_ctl)) * HDMI_TX_PWR_CTRL_NUM, GFP_KERNEL);
+            if(!hdmitx_device.config_data.pwr_ctl) {
+                hdmi_print(INF, SYS "can not get pwr_ctl mem\n");
+            }
+            memset(hdmitx_device.config_data.pwr_ctl, 0, sizeof(struct hdmi_pwr_ctl));
+            ret = get_dt_pwr_init_data(init_data, hdmitx_device.config_data.pwr_ctl);
+            if(ret) {
+                hdmi_print(INF, SYS "not find pwr_ctl\n");
+            }
+        }
+    }
+// open hdmi power
+    hdmitx_pwr_init(hdmitx_device.config_data.pwr_ctl);
+
+#else
+    hdmi_pdata = pdev->dev.platform_data;
+    if (!hdmi_pdata) {
+        hdmi_print(INF, SYS "not get platform data\n");
+        r = -ENOENT;
+    }
+    else{
+        hdmi_print(INF, SYS "get hdmi platform data\n");
+    }
+#endif
+    switch_dev_register(&sdev);
+    switch_dev_register(&lang_dev);
+
+    hdmitx_init_parameters(&hdmitx_device.hdmi_info);
+    HDMITX_Meson_Init(&hdmitx_device);
+    hdmitx_device.task = kthread_run(hdmi_task_handle, &hdmitx_device, "kthread_hdmi");
+
+    if (r < 0){
+        hdmi_print(INF, SYS "register switch dev failed\n");
+        return r;
+    }
+    return r;
+}
+
+static int amhdmitx_remove(struct platform_device *pdev)
+{
+    switch_dev_unregister(&sdev);
+
+    if(hdmitx_device.HWOp.UnInit){
+        hdmitx_device.HWOp.UnInit(&hdmitx_device);
+    }
+    hdmitx_device.hpd_event = 0xff;
+    kthread_stop(hdmitx_device.task);
+
+    vout_unregister_client(&hdmitx_notifier_nb_v);
+#ifdef CONFIG_AM_TV_OUTPUT2
+    vout2_unregister_client(&hdmitx_notifier_nb_v2);
+#endif
+#ifdef CONFIG_SND_SOC
+    aout_unregister_client(&hdmitx_notifier_nb_a);
+#endif
+    /* Remove the cdev */
+    device_remove_file(hdmitx_dev, &dev_attr_disp_mode);
+    device_remove_file(hdmitx_dev, &dev_attr_aud_mode);
+    device_remove_file(hdmitx_dev, &dev_attr_edid);
+    device_remove_file(hdmitx_dev, &dev_attr_edid_info);
+    device_remove_file(hdmitx_dev, &dev_attr_config);
+    device_remove_file(hdmitx_dev, &dev_attr_debug);
+    device_remove_file(hdmitx_dev, &dev_attr_disp_cap);
+    device_remove_file(hdmitx_dev, &dev_attr_disp_cap_3d);
+    device_remove_file(hdmitx_dev, &dev_attr_hpd_state);
+    device_remove_file(hdmitx_dev, &dev_attr_support_3d);
+    device_remove_file(hdmitx_dev, &dev_attr_cec);
+
+    cdev_del(&hdmitx_device.cdev);
+
+    device_destroy(hdmitx_class, hdmitx_id);
+
+    class_destroy(hdmitx_class);
+
+// TODO
+//    kfree(hdmi_pdata->phy_data);
+//    kfree(hdmi_pdata);
+
+    unregister_chrdev_region(hdmitx_id, HDMI_TX_COUNT);
+    return 0;
+}
+
+#ifdef CONFIG_PM
+static int amhdmitx_suspend(struct platform_device *pdev,pm_message_t state)
+{
+#if 0
+    pr_info("amhdmitx: hdmirx_suspend\n");
+    hdmitx_pre_display_init();
+    if(hdmi_pdata){
+        hdmi_pdata->hdmi_5v_ctrl ? hdmi_pdata->hdmi_5v_ctrl(0) : 0;
+        hdmi_pdata->hdmi_3v3_ctrl ? hdmi_pdata->hdmi_3v3_ctrl(1) : 0;   // prevent Voff leak current
+    }
+    if(hdmitx_device.HWOp.Cntl)
+        hdmitx_device.HWOp.CntlMisc(&hdmitx_device, MISC_TMDS_PHY_OP, TMDS_PHY_DISABLE);
+#endif
+    return 0;
+}
+
+static int amhdmitx_resume(struct platform_device *pdev)
+{
+#if 0
+    pr_info("amhdmitx: resume module\n");
+    if(hdmi_pdata){
+        hdmi_pdata->hdmi_5v_ctrl ? hdmi_pdata->hdmi_5v_ctrl(1) : 0;
+    }
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_VIDEO_BLANK_OP, VIDEO_UNBLANK);
+    hdmitx_device.HWOp.CntlConfig(&hdmitx_device, CONF_AUDIO_MUTE_OP, AUDIO_MUTE);
+    hdmitx_device.HWOp.CntlDDC(&hdmitx_device, DDC_HDCP_OP, HDCP_OFF);
+    hdmitx_device.internal_mode_change = 0;
+    set_disp_mode_auto();
+    pr_info("amhdmitx: resume module %d\n", __LINE__);
+#endif
+    return 0;
+}
+#endif
+
+#ifdef CONFIG_OF
+static const struct of_device_id meson_amhdmitx_dt_match[]={
+    {
+        .compatible     = "amlogic,amhdmitx",
+    },
+    {},
+};
+#else
+#define meson_amhdmitx_dt_match NULL
+#endif
+static struct platform_driver amhdmitx_driver = {
+    .probe      = amhdmitx_probe,
+    .remove     = amhdmitx_remove,
+#ifdef CONFIG_PM
+    .suspend    = amhdmitx_suspend,
+    .resume     = amhdmitx_resume,
+#endif
+    .driver     = {
+        .name   = DEVICE_NAME,
+            .owner    = THIS_MODULE,
+            .of_match_table = meson_amhdmitx_dt_match,
+    }
+};
+
+
+static int  __init amhdmitx_init(void)
+{
+    if(init_flag&INIT_FLAG_NOT_LOAD)
+        return 0;
+
+    hdmi_print(IMP, SYS "amhdmitx_init\n");
+    hdmi_print(IMP, SYS "Ver: %s\n", HDMITX_VER);
+
+    if (platform_driver_register(&amhdmitx_driver)) {
+        hdmi_print(ERR, SYS "failed to register amhdmitx module\n");
+        return -ENODEV;
+    }
+    return 0;
+}
+
+
+
+
+static void __exit amhdmitx_exit(void)
+{
+    hdmi_print(INF, SYS "amhdmitx_exit\n");
+    platform_driver_unregister(&amhdmitx_driver);
+
+    return ;
+}
+
+//module_init(amhdmitx_init);
+arch_initcall(amhdmitx_init);
+module_exit(amhdmitx_exit);
+
+MODULE_DESCRIPTION("AMLOGIC HDMI TX driver 2.0");
+MODULE_LICENSE("GPL");
+MODULE_VERSION("1.0.0");
+
+
+static char* next_token_ex(char* seperator, char *buf, unsigned size, unsigned offset, unsigned *token_len, unsigned *token_offset)
+{ /* besides characters defined in seperator, '\"' are used as seperator; and any characters in '\"' will not act as seperator */
+    char *pToken = NULL;
+    char last_seperator = 0;
+    char trans_char_flag = 0;
+    if(buf){
+        for (;offset<size;offset++){
+            int ii=0;
+            char ch;
+            if (buf[offset] == '\\'){
+                trans_char_flag = 1;
+                continue;
+            }
+            while(((ch=seperator[ii++])!=buf[offset])&&(ch)){
+            }
+            if (ch){
+                if (!pToken){
+                    continue;
+                }
+                else {
+                    if (last_seperator != '"'){
+                        *token_len = (unsigned)(buf + offset - pToken);
+                        *token_offset = offset;
+                        return pToken;
+                    }
+                }
+            }
+            else if (!pToken)
+            {
+                if (trans_char_flag&&(buf[offset] == '"'))
+                    last_seperator = buf[offset];
+                pToken = &buf[offset];
+            }
+            else if ((trans_char_flag&&(buf[offset] == '"'))&&(last_seperator == '"')){
+                *token_len = (unsigned)(buf + offset - pToken - 2);
+                *token_offset = offset + 1;
+                return pToken + 1;
+            }
+            trans_char_flag = 0;
+        }
+        if (pToken) {
+            *token_len = (unsigned)(buf + offset - pToken);
+            *token_offset = offset;
+        }
+    }
+    return pToken;
+}
+
+static  int __init hdmitx_boot_para_setup(char *s)
+{
+    char separator[]={' ',',',';',0x0};
+    char *token;
+    unsigned token_len, token_offset, offset=0;
+    int size=strlen(s);
+
+    do{
+        token=next_token_ex(separator, s, size, offset, &token_len, &token_offset);
+        if(token){
+            if((token_len==3) && (strncmp(token, "off", token_len)==0)){
+                init_flag|=INIT_FLAG_NOT_LOAD;
+            }
+            else if((token_len==7) && (strncmp(token, "vdacoff", token_len)==0)){
+                init_flag|=INIT_FLAG_VDACOFF;
+            }
+            else if((token_len==16) && (strncmp(token, "unplug_powerdown", token_len)==0)){
+                init_flag|=INIT_FLAG_POWERDOWN;
+            }
+            else if(strncmp(token, "pllmode1",  8)==0){
+                    /* use external xtal as source of hdmi pll */
+                hdmi_pll_mode = 1;
+            }
+            else if((token_len==7)&& (strncmp(token, "hpdmode", token_len)==0)){
+                hpdmode = simple_strtoul(token+7,NULL,10);
+            }
+            else if((token_len==3)&&(strncmp(token, "rgb", 3)==0)){
+                hdmitx_output_rgb();
+            }
+            else if(strncmp(token, "audpara", 7)==0){
+                int tmp;
+                tmp = simple_strtoul(token+7,NULL,10);
+                hdmi_print(INF, AUD "set hdmi aud_para %d\n", tmp);
+            }
+            else if(strncmp(token, "powermode", 9)==0){
+                int tmp;
+                tmp = simple_strtoul(token+9,NULL,10);
+                init_powermode=tmp|0x80;
+                hdmi_print(INF, SYS "set init powermode %d\n", tmp);
+            }
+            else if(strncmp(token, "audiooff", 8)==0){
+                hdmi_audio_off_flag = 1;
+                hdmi_print(INF, AUD "set no audio output\n");
+            }
+            else if(strncmp(token, "prbs", 4)==0){
+                hdmi_prbs_mode = simple_strtoul(token+4,NULL,16);
+                hdmi_print(INF, SYS "set prbs mode as %x always\n", hdmi_prbs_mode);
+            }
+            else if(strncmp(token, "480p_clk", 8)==0){
+                hdmi_480p_force_clk = simple_strtoul(token+8,NULL,10);
+                hdmi_print(INF, SYS "hdmi, set 480p mode clock as %dMHz always\n", hdmi_480p_force_clk);
+            }
+            else if(strncmp(token, "cec", 3)==0) {
+                unsigned int list = simple_strtoul(token+3,NULL,16);
+                if((list >= 0) && (list <= 0xf)) {
+                    hdmitx_device.cec_func_config = list;
+                    aml_write_reg32(P_AO_DEBUG_REG0, hdmitx_device.cec_func_config);         // save cec function list to AO_REG
+                }
+                hdmi_print(INF, CEC "Function List: %s, %s, %s, %s\n", (hdmitx_device.cec_func_config & (1 << CEC_FUNC_MSAK)) ? "enable" : "disable",
+                                                              (hdmitx_device.cec_func_config & (1 << ONE_TOUCH_PLAY_MASK)) ? "one touch play" : "",
+                                                              (hdmitx_device.cec_func_config & (1 << ONE_TOUCH_STANDBY_MASK)) ? "one touch standby" : "",
+                                                              (hdmitx_device.cec_func_config & (1 << AUTO_POWER_ON_MASK)) ? "auto power by tv" : ""
+                      );
+                hdmi_print(INF, CEC "HDMI aml_read_reg32(P_AO_DEBUG_REG0):0x%x\n",aml_read_reg32(P_AO_DEBUG_REG0));
+                hdmi_print(INF, CEC "HDMI hdmi_cec_func_config:0x%x\n",hdmitx_device.cec_func_config);
+            }
+        }
+        offset=token_offset;
+    }while(token);
+    return 0;
+}
+
+__setup("hdmitx=",hdmitx_boot_para_setup);
+
+#ifdef CONFIG_AM_TV_OUTPUT2
+MODULE_PARM_DESC(force_vout_index, "\n force_vout_index\n");
+module_param(force_vout_index, uint, 0664);
+#endif
+
+MODULE_PARM_DESC(hdmi_480p_force_clk, "\n hdmi_480p_force_clk \n");
+module_param(hdmi_480p_force_clk, int, 0664);
+
+MODULE_PARM_DESC(hdmi_prbs_mode, "\n hdmi_prbs_mode \n");
+module_param(hdmi_prbs_mode, int, 0664);
+
+MODULE_PARM_DESC(debug_level, "\n debug_level \n");
+module_param(debug_level, int, 0664);
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_scdc.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_scdc.c
new file mode 100644
index 00000000..8242ceed
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_scdc.c
@@ -0,0 +1 @@
+#include <linux/amlogic/hdmi_tx/hdmi_tx_scdc.h>
diff --git a/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_video.c b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_video.c
new file mode 100644
index 00000000..a0ba8e09
--- /dev/null
+++ b/drivers/amlogic/hdmi/hdmi_tx_2/hdmi_tx_video.c
@@ -0,0 +1,684 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/fs.h>
+#include <linux/init.h>
+#include <linux/device.h>
+#include <linux/mm.h>
+#include <linux/major.h>
+#include <linux/platform_device.h>
+#include <linux/mutex.h>
+#include <linux/cdev.h>
+
+#include <linux/amlogic/hdmi_tx/hdmi_info_global.h>
+#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
+
+static unsigned char hdmi_output_rgb = 0;
+static void hdmitx_set_spd_info(hdmitx_dev_t* hdmitx_device);
+static void hdmi_set_vend_spec_infofram(hdmitx_dev_t* hdmitx_device, HDMI_Video_Codes_t VideoCode);
+
+static Hdmi_tx_video_para_t hdmi_tx_video_params[] =
+{
+    {
+        .VIC            = HDMI_640x480p60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_480p60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_480p60_16x9,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_480p60_16x9_rpt,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_4_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_720p60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+#ifdef DOUBLE_CLK_720P_1080I
+        .repeat_time    = HDMI_2_TIMES_REPEAT,
+#else
+        .repeat_time    = NO_REPEAT,
+#endif
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080i60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+#ifdef DOUBLE_CLK_720P_1080I
+        .repeat_time    = HDMI_2_TIMES_REPEAT,
+#else
+        .repeat_time    = NO_REPEAT,
+#endif
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_480i60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_2_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_480i60_16x9,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_2_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_480i60_16x9_rpt,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_4_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1440x480p60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080p60,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_576p50,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_576p50_16x9,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_576p50_16x9_rpt,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_4_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_720p50,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080i50,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_576i50,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_2_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_4_3,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_576i50_16x9,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_2_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_576i50_16x9_rpt,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = HDMI_4_TIMES_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU601,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080p50,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080p24,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080p25,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_1080p30,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_4k2k_30,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_4k2k_25,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_4k2k_24,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_4k2k_smpte_24,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_3840x2160p50_16x9,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_3840x2160p60_16x9,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_3840x1080p100hz,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_3840x1080p120hz,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_3840x540p240hz,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+    {
+        .VIC            = HDMI_3840x540p200hz,
+        .color_prefer   = COLOR_SPACE_RGB444,
+        .color_depth    = COLOR_24BIT,
+        .bar_info       = B_BAR_VERT_HORIZ,
+        .repeat_time    = NO_REPEAT,
+        .aspect_ratio   = TV_ASPECT_RATIO_16_9,
+        .cc             = CC_ITU709,
+        .ss             = SS_SCAN_UNDER,
+        .sc             = SC_SCALE_HORIZ_VERT,
+    },
+};
+
+static Hdmi_tx_video_para_t *hdmi_get_video_param(HDMI_Video_Codes_t VideoCode)
+{
+    Hdmi_tx_video_para_t * video_param=NULL;
+    int  i;
+    int count=ARRAY_SIZE(hdmi_tx_video_params);
+    for(i=0;i<count;i++){
+        if(hdmi_tx_video_params[i].VIC == VideoCode){
+            break;
+        }
+    }
+    if(i<count){
+        video_param = &(hdmi_tx_video_params[i]);
+    }
+    return video_param;
+}
+
+static void hdmi_tx_construct_avi_packet(Hdmi_tx_video_para_t *video_param, char* AVI_DB)
+{
+    unsigned char color, bar_info, aspect_ratio, cc, ss, sc, ec = 0;
+    ss = video_param->ss;
+    bar_info = video_param->bar_info;
+    if(video_param->color == COLOR_SPACE_YUV444){
+        color = 2;
+    }
+    else if(video_param->color == COLOR_SPACE_YUV422){
+        color = 1;
+    }
+    else{ //(video_param->color == COLOR_SPACE_RGB444)
+        color = 0;
+    }
+    AVI_DB[0] = (ss) | (bar_info << 2) | (1<<4) | (color << 5);
+    //AVI_DB[0] = (1<<4) | (color << 5);
+
+    aspect_ratio = video_param->aspect_ratio;
+    cc = video_param->cc;
+//HDMI CT 7-24
+    //AVI_DB[1] = (aspect_ratio) | (aspect_ratio << 4) | (cc << 6);
+    AVI_DB[1] = 8 | (aspect_ratio << 4) | (cc << 6);
+
+    sc = video_param->sc;
+    if(video_param->cc == CC_ITU601)
+        ec = 0;
+    if(video_param->cc == CC_ITU709)
+        ec = 1;    // according to CEA-861-D, all other values are reserved
+    AVI_DB[2] = (sc) | (ec << 4);
+    //AVI_DB[2] = 0;
+
+    AVI_DB[3] = video_param->VIC;
+    if((video_param->VIC == HDMI_4k2k_30) || (video_param->VIC == HDMI_4k2k_25) || (video_param->VIC == HDMI_4k2k_24) || (video_param->VIC == HDMI_4k2k_smpte_24))
+        AVI_DB[3] = 0;      // HDMI Spec V1.4b P151
+
+    AVI_DB[4] = video_param->repeat_time;
+}
+
+/************************************
+*    hdmitx protocol level interface
+*************************************/
+
+void hdmitx_init_parameters(HDMI_TX_INFO_t *info)
+{
+    memset(info, 0, sizeof(HDMI_TX_INFO_t));
+
+    info->video_out_changing_flag = 1;
+
+    info->audio_flag = 1;
+    info->audio_info.type = CT_REFER_TO_STREAM;
+    info->audio_info.format = AF_I2S;
+    info->audio_info.fs = FS_44K1;
+    info->audio_info.ss = SS_16BITS;
+    info->audio_info.channels = CC_2CH;
+    info->audio_info.audio_mclk = MCLK_256_Fs;
+    info->audio_out_changing_flag = 1;
+
+    info->auto_hdcp_ri_flag = 1;     // If == 1, turn on Auto Ri Checking
+    info->hw_sha_calculator_flag = 1;    // If  == 1, use the HW SHA calculator, otherwise, use SW SHA calculator
+
+}
+
+//HDMI Identifier = 0x000c03
+//If not, treated as a DVI Device
+static int is_dvi_device(rx_cap_t* pRXCap)
+{
+    hdmitx_dev_t *hdmitx_device = container_of(pRXCap, struct hdmi_tx_dev_s, RXCap);
+
+#ifndef CONFIG_AML_HDMI_TX_CTS_DVI
+    hdmi_print(IMP, SYS "fixed HDMI mode output\n");
+    return 0;
+#endif
+    if(hdmitx_device->tv_no_edid)
+        return 0;
+
+    if(pRXCap->IEEEOUI != 0x000c03)
+        return 1;
+    else
+        return 0;
+}
+
+void hdmitx_output_rgb(void)
+{
+    hdmi_output_rgb = 1;
+}
+
+int hdmitx_set_display(hdmitx_dev_t* hdmitx_device, HDMI_Video_Codes_t VideoCode)
+{
+    Hdmi_tx_video_para_t *param;
+    HDMI_Video_Codes_t vic;
+    int i,ret=-1;
+    unsigned char AVI_DB[32];
+    unsigned char AVI_HB[32];
+    AVI_HB[0] = TYPE_AVI_INFOFRAMES ;
+    AVI_HB[1] = AVI_INFOFRAMES_VERSION ;
+    AVI_HB[2] = AVI_INFOFRAMES_LENGTH ;
+    for(i=0;i<32;i++){
+        AVI_DB[i]=0;
+    }
+//TODO
+
+    vic = hdmitx_device->HWOp.GetState(hdmitx_device, STAT_VIDEO_VIC, 0);
+    hdmi_print(IMP, SYS "already init VIC = %d  Now VIC = %d\n", vic, VideoCode);
+    if((vic != HDMI_Unkown) && (vic == VideoCode)) {
+        hdmitx_device->cur_VIC = vic;
+        return 1;;
+    }
+
+    param = hdmi_get_video_param(VideoCode);
+    hdmitx_device->cur_video_param = param;
+    if(param){
+        param->color = param->color_prefer;
+        if(hdmi_output_rgb){
+            param->color = COLOR_SPACE_RGB444;
+        }
+        else{
+//HDMI CT 7-24 Pixel Encoding - YCbCr to YCbCr Sink
+            switch(hdmitx_device->RXCap.native_Mode & 0x30)
+            {
+                case 0x20:    //bit5==1, then support YCBCR444 + RGB
+                case 0x30:
+                    param->color = COLOR_SPACE_YUV444;
+                    break;
+                case 0x10:    //bit4==1, then support YCBCR422 + RGB
+                    param->color = COLOR_SPACE_YUV422;
+                    break;
+                default:
+                    param->color = COLOR_SPACE_RGB444;
+            }
+        }
+        if(hdmitx_device->HWOp.SetDispMode(hdmitx_device, param)>=0){
+//HDMI CT 7-33 DVI Sink, no HDMI VSDB nor any other VSDB, No GB or DI expected
+//TMDS_MODE[hdmi_config]
+//0: DVI Mode       1: HDMI Mode
+            //if(hdmitx_device->hdmi_info.output_state==CABLE_PLUGIN_DVI_OUT)
+            if(is_dvi_device(&hdmitx_device->RXCap)) {
+                hdmi_print(1,"Sink is DVI device\n");
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_HDMI_DVI_MODE, DVI_MODE);        //todo ColorFormat
+            }
+            else {
+                hdmi_print(1,"Sink is HDMI device\n");
+                hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_HDMI_DVI_MODE, HDMI_MODE);
+            }
+//check system status by reading EDID_STATUS
+            switch(hdmitx_device->HWOp.CntlConfig(hdmitx_device, CONF_SYSTEM_ST, 0))
+            {
+                case 0:
+                    hdmi_print(1,"No sink attached\n");
+                    break;
+                case 1:
+                    hdmi_print(1,"Source reading EDID\n");
+                    break;
+                case 2:
+                    hdmi_print(1,"Source in DVI Mode\n");
+                    break;
+                case 3:
+                    hdmi_print(1,"Source in HDMI Mode\n");
+                    break;
+                default:
+                    hdmi_print(1,"EDID Status error\n");
+            }
+
+            hdmi_tx_construct_avi_packet(param, (char*)AVI_DB);
+
+            if((VideoCode == HDMI_4k2k_30) || (VideoCode == HDMI_4k2k_25) || (VideoCode == HDMI_4k2k_24) || (VideoCode == HDMI_4k2k_smpte_24)) {
+                hdmi_set_vend_spec_infofram(hdmitx_device, VideoCode);
+            }
+            else {
+                hdmi_set_vend_spec_infofram(hdmitx_device, 0);
+            }
+
+            hdmitx_device->HWOp.SetPacket(HDMI_PACKET_AVI, AVI_DB, AVI_HB);
+            ret = 0;
+        }
+    }
+    else{
+        if(hdmitx_device->HWOp.SetDispMode) {
+            hdmitx_device->HWOp.SetDispMode(hdmitx_device, NULL); //disable HDMI
+        }
+    }
+    hdmitx_set_spd_info(hdmitx_device);
+    return ret;
+}
+
+static void hdmi_set_vend_spec_infofram(hdmitx_dev_t* hdmitx_device, HDMI_Video_Codes_t VideoCode)
+{
+    int i;
+    unsigned char VEN_DB[6];
+    unsigned char VEN_HB[3];
+    VEN_HB[0] = 0x81;
+    VEN_HB[1] = 0x01;
+    VEN_HB[2] = 0x6;
+
+    for(i = 0; i < 0x6; i++){
+        VEN_DB[i] = 0;
+    }
+    VEN_DB[0] = 0x03;
+    VEN_DB[1] = 0x0c;
+    VEN_DB[2] = 0x00;
+
+    VEN_DB[3] = 0x20;         // 4k x 2k  Spec P156
+    if(VideoCode == 0) {       // For non-4kx2k mode setting
+        hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, NULL, VEN_HB);
+        return ;
+    }
+    if(VideoCode == HDMI_4k2k_30)
+        VEN_DB[4] = 0x1;
+    else if(VideoCode == HDMI_4k2k_25)
+        VEN_DB[4] = 0x2;
+    else if(VideoCode == HDMI_4k2k_24)
+        VEN_DB[4] = 0x3;
+    else if(VideoCode == HDMI_4k2k_smpte_24)
+        VEN_DB[4] = 0x4;
+    else {
+        // nothing
+    }
+    hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, VEN_DB, VEN_HB);
+}
+
+int hdmi_set_3d(hdmitx_dev_t* hdmitx_device, int type, unsigned int param)
+{
+    int i;
+    unsigned char VEN_DB[6];
+    unsigned char VEN_HB[3];
+    VEN_HB[0] = 0x81 ;
+    VEN_HB[1] = 0x01 ;
+    VEN_HB[2] = 0x6 ;
+    if(type==0xf){
+        hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, NULL, VEN_HB);
+    }
+    else{
+        for(i=0;i<0x6;i++){
+            VEN_DB[i]=0;
+        }
+        VEN_DB[0]=0x03;
+        VEN_DB[1]=0x0c;
+        VEN_DB[2]=0x00;
+
+        VEN_DB[3]=0x40;
+        VEN_DB[4]=type<<4;
+        VEN_DB[5]=param<<4;
+        hdmitx_device->HWOp.SetPacket(HDMI_PACKET_VEND, VEN_DB, VEN_HB);
+    }
+    return 0;
+
+}
+
+// Set Source Product Descriptor InfoFrame
+static void hdmitx_set_spd_info(hdmitx_dev_t* hdmitx_device)
+{
+    unsigned char SPD_DB[25] = {0x00};
+    unsigned char SPD_HB[3] = {0x83, 0x1, 0x19};
+    unsigned int len = 0;
+    struct vendor_info_data *vend_data;
+    if(hdmitx_device->config_data.vend_data) {
+        vend_data = hdmitx_device->config_data.vend_data;
+    }
+    else {
+        hdmi_print(INF, SYS "packet: can\'t get vendor data\n");
+        return;
+    }
+    if(vend_data->vendor_name) {
+        len = strlen(vend_data->vendor_name);
+        strncpy(&SPD_DB[0], vend_data->vendor_name, (len > 8) ? 8 : len);
+    }
+    if(vend_data->product_desc) {
+        len = strlen(vend_data->product_desc);
+        strncpy(&SPD_DB[8], vend_data->product_desc, (len > 16) ? 16 : len);
+    }
+    hdmitx_device->HWOp.SetPacket(HDMI_SOURCE_DESCRIPTION, SPD_DB, SPD_HB);
+}
+
