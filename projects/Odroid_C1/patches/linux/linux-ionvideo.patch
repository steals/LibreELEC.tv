diff --git a/drivers/amlogic/ion_dev/dev_ion.c b/drivers/amlogic/ion_dev/dev_ion.c
index 43d43109..2079f6c8 100755
--- a/drivers/amlogic/ion_dev/dev_ion.c
+++ b/drivers/amlogic/ion_dev/dev_ion.c
@@ -21,8 +21,6 @@
 #include <ion_priv.h>
 #include <linux/of.h>
 #include <linux/of_fdt.h>
-#include <linux/uaccess.h>
-#include "meson_ion.h"
 
 MODULE_DESCRIPTION("AMLOGIC ION driver");
 MODULE_LICENSE("GPL");
@@ -45,56 +43,6 @@ static struct ion_heap **heaps;
 static struct ion_platform_heap my_ion_heap[MAX_HEAP];
 
 static struct resource memobj;
-
-static int meson_ion_get_phys(struct ion_client *client, unsigned long arg)
-{
-	struct meson_phys_data data;
-	struct ion_handle *handle;
-	size_t len;
-	ion_phys_addr_t addr;
-	int ret;
-
-	if (copy_from_user(&data, (void __user *)arg,
-		sizeof(struct meson_phys_data))) {
-		return -EFAULT;
-	}
-	handle = ion_import_dma_buf(client, data.handle);
-	if (IS_ERR_OR_NULL(handle)) {
-		dprintk(0, "EINVAL, client=%p, share_fd=%d\n",
-			client, data.handle);
-		return PTR_ERR(handle);
-	}
-
-	ret = ion_phys(client, handle, &addr, (size_t *)&len);
-	dprintk(1, "ret=%d, phys=0x%lX\n", ret, addr);
-	if (ret < 0) {
-		dprintk(0, "meson_ion_get_phys error, ret=%d\n", ret);
-		return ret;
-	}
-	data.phys_addr = (unsigned int)addr;
-	data.size = (unsigned int)len;
-	if (copy_to_user((void __user *)arg, &data,
-		sizeof(struct meson_phys_data))) {
-		return -EFAULT;
-	}
-	return 0;
-}
-
-static long meson_custom_ioctl(
-	struct ion_client *client,
-	unsigned int cmd,
-	unsigned long arg)
-{
-	switch (cmd) {
-		case ION_IOC_MESON_PHYS_ADDR:
-			return meson_ion_get_phys(client, arg);
-		default:
-			return -ENOTTY;
-	}
-	return 0;
-}
-
-
 int dev_ion_probe(struct platform_device *pdev) {
     int err;
     int i;
@@ -117,8 +65,8 @@ int dev_ion_probe(struct platform_device *pdev) {
 	 name = of_get_property(of_node, "share-memory-name", NULL);
 	 if(!name)
 	 {
-        	printk("\ndev_ion memory resource undefined1.\n");
-        	return -EFAULT;
+		printk("\ndev_ion memory resource undefined1.\n");
+		return -EFAULT;
 	 }
 	 else
 	 {
@@ -126,7 +74,7 @@ int dev_ion_probe(struct platform_device *pdev) {
 		if(i<0)
 		{
 			printk("\ndev_ion memory resource undefined2.\n");
-        		return -EFAULT;
+			return -EFAULT;
 		}
 		name = of_get_property(of_node, "share-memory-offset", NULL);
 		if(name)
@@ -134,7 +82,7 @@ int dev_ion_probe(struct platform_device *pdev) {
 		else
 		{
 			printk("\ndev_ion memory resource undefined3.\n");
-        		return -EFAULT;
+			return -EFAULT;
 		}
 		name = of_get_property(of_node, "share-memory-size", NULL);
 		if(name)
@@ -142,19 +90,19 @@ int dev_ion_probe(struct platform_device *pdev) {
 		else
 		{
 			printk("\ndev_ion memory resource undefined4.\n");
-        		return -EFAULT;
+			return -EFAULT;
 		}
 
 
 		res->start = (phys_addr_t)get_reserve_block_addr(i)+offset;
-    		res->end = res->start+ size-1;
+		res->end = res->start+ size-1;
 
 	 }
     }
     else
     {
-    	res->start = (phys_addr_t)get_reserve_block_addr(i);
-    	res->end = res->start+ (phys_addr_t)get_reserve_block_size(i)-1;
+	res->start = (phys_addr_t)get_reserve_block_addr(i);
+	res->end = res->start+ (phys_addr_t)get_reserve_block_size(i)-1;
     }
 #endif
     if (res) {
@@ -166,7 +114,7 @@ int dev_ion_probe(struct platform_device *pdev) {
         my_ion_heap[1].size = res->end - res->start + 1;
     }
     heaps = kzalloc(sizeof(struct ion_heap *) * num_heaps, GFP_KERNEL);
-    idev = ion_device_create(meson_custom_ioctl);
+    idev = ion_device_create(NULL);
     if (IS_ERR_OR_NULL(idev)) {
         kfree(heaps);
         panic(0);
@@ -230,4 +178,3 @@ static void __exit ion_exit(void)
 
 module_init(ion_init);
 module_exit(ion_exit);
-
diff --git a/drivers/amlogic/ionvideo/Makefile b/drivers/amlogic/ionvideo/Makefile
index 68a61695..db6224ca 100755
--- a/drivers/amlogic/ionvideo/Makefile
+++ b/drivers/amlogic/ionvideo/Makefile
@@ -1,4 +1,2 @@
-EXTRA_AFLAGS=-mfloat-abi=softfp -mfpu=neon
-
 obj-$(CONFIG_VIDEOBUF2_ION) += videobuf2-ion.o
 obj-$(CONFIG_AMLOGIC_IONVIDEO) += ionvideo.o ppmgr2.o
diff --git a/drivers/amlogic/ionvideo/ion_priv.h b/drivers/amlogic/ionvideo/ion_priv.h
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/ionvideo/ionvideo.c b/drivers/amlogic/ionvideo/ionvideo.c
old mode 100644
new mode 100755
index 9866b8ea..46c5c16c
--- a/drivers/amlogic/ionvideo/ionvideo.c
+++ b/drivers/amlogic/ionvideo/ionvideo.c
@@ -7,6 +7,8 @@
  */
 #include "ionvideo.h"
 
+#define CREATE_TRACE_POINTS
+#include "trace/ionvideo.h"
 #define IONVIDEO_MODULE_NAME "ionvideo"
 
 #define IONVIDEO_VERSION "1.0"
@@ -18,6 +20,7 @@ static unsigned video_nr = 13;
 
 static u64 last_pts_us64 = 0;
 
+static int scaling_rate = 50;
 module_param(video_nr, uint, 0644);
 MODULE_PARM_DESC(video_nr, "videoX start number, 13 is autodetect");
 
@@ -41,6 +44,7 @@ static unsigned int skip_frames = 0;
 module_param(skip_frames, uint, 0664);
 MODULE_PARM_DESC(skip_frames, "skip frames");
 
+static struct ionvideo_dmaqueue* cur_dma_q = NULL;
 
 static const struct ionvideo_fmt formats[] = {
     {
@@ -141,14 +145,14 @@ EXPORT_SYMBOL(is_ionvideo_active);
 
 static void videoc_omx_compute_pts(struct ionvideo_dev *dev, struct vframe_s* vf) {
     if (dev->pts == 0) {
-        if (dev->receiver_register == 0) {
+        if (dev->is_omx_video_started == 0) {
             dev->pts = last_pts_us64 + (DUR2PTS(vf->duration)*100/9);
         }
     }
-    if (dev->receiver_register) {    
-        dev->receiver_register = 0;
+    if (dev->is_omx_video_started) {    
+        dev->is_omx_video_started = 0;
     }
-    last_pts_us64 = dev->pts;  
+    last_pts_us64 = dev->pts;
 }
 
 static int ionvideo_fillbuff(struct ionvideo_dev *dev, struct ionvideo_buffer *buf) {
@@ -162,12 +166,12 @@ static int ionvideo_fillbuff(struct ionvideo_dev *dev, struct ionvideo_buffer *b
         return -EAGAIN;
     }
     if (vf && dev->once_record == 1) {
-    	dev->once_record = 0;
-    	if ((vf->type & VIDTYPE_INTERLACE_BOTTOM) == 0x3) {
-    		dev->ppmgr2_dev.bottom_first = 1;
-    	} else {
-    		dev->ppmgr2_dev.bottom_first = 0;
-    	}
+	dev->once_record = 0;
+	if ((vf->type & VIDTYPE_INTERLACE_BOTTOM) == 0x3) {
+		dev->ppmgr2_dev.bottom_first = 1;
+	} else {
+		dev->ppmgr2_dev.bottom_first = 0;
+	}
     }
     if (freerun_mode == 0) {
         if ((vf->type & 0x1) == VIDTYPE_INTERLACE) {
@@ -191,6 +195,16 @@ static int ionvideo_fillbuff(struct ionvideo_dev *dev, struct ionvideo_buffer *b
                 dev->pts = vf->pts_us64;
         } else
             dev->pts = vf->pts_us64;
+
+        if (vf->width <= ((dev->width+31)&(~31))) //for omx AdaptivePlayback
+            dev->ppmgr2_dev.dst_width = vf->width;
+        if (vf->height <= dev->height)
+            dev->ppmgr2_dev.dst_height = vf->height;
+            
+        if((dev->ppmgr2_dev.dst_width >= 1920) &&(dev->ppmgr2_dev.dst_height >= 1080)&&(vf->type & VIDTYPE_INTERLACE)){
+			dev->ppmgr2_dev.dst_width = dev->ppmgr2_dev.dst_width*scaling_rate/100;
+			dev->ppmgr2_dev.dst_height = dev->ppmgr2_dev.dst_height*scaling_rate/100 ;
+		}
         ret = ppmgr2_process(vf, &dev->ppmgr2_dev, vb->v4l2_buf.index);
         if (ret) {
             vf_put(vf, RECEIVER_NAME);
@@ -200,14 +214,14 @@ static int ionvideo_fillbuff(struct ionvideo_dev *dev, struct ionvideo_buffer *b
         vf_put(vf, RECEIVER_NAME);
         buf->vb.v4l2_buf.timestamp.tv_sec = dev->pts >> 32;
         buf->vb.v4l2_buf.timestamp.tv_usec = dev->pts & 0xFFFFFFFF;
+        buf->vb.v4l2_buf.timecode.type = dev->ppmgr2_dev.dst_width;
+        buf->vb.v4l2_buf.timecode.flags = dev->ppmgr2_dev.dst_height;
     }
 //-------------------------------------------------------
     return 0;
 }
 
-static int ionvideo_size_changed(struct ionvideo_dev *dev, struct vframe_s* vf) {
-    int aw = vf->width;
-    int ah = vf->height;
+static int ionvideo_size_changed(struct ionvideo_dev *dev, int aw , int ah) {
 
     v4l_bound_align_image(&aw, 48, MAX_WIDTH, 5, &ah, 32, MAX_HEIGHT, 0, 0);
     dev->c_width = aw;
@@ -224,16 +238,30 @@ static void ionvideo_thread_tick(struct ionvideo_dev *dev) {
     struct ionvideo_buffer *buf;
     unsigned long flags = 0;
     struct vframe_s* vf;
+    static int vf_wait_cnt = 0;
 
+	int w ,h ;
     dprintk(dev, 4, "Thread tick\n");
-    /* video seekTo clear list */
 
+    if(!dev){
+		return;
+	}
     vf = vf_peek(RECEIVER_NAME);
     if (!vf) {
+        vf_wait_cnt++;
         msleep(5);
         return;
     }
-    if (freerun_mode == 0 && ionvideo_size_changed(dev, vf)) {
+    if ((vf->width >= 1920) && (vf->height >= 1080) && (vf->type & VIDTYPE_INTERLACE)) {
+		dev->ppmgr2_dev.dst_width = vf->width*scaling_rate/100;
+		dev->ppmgr2_dev.dst_height = vf->height*scaling_rate/100;
+		w = dev->ppmgr2_dev.dst_width;
+		h = dev->ppmgr2_dev.dst_height;
+	}else{
+		w = vf->width;
+		h = vf->height;
+	}
+    if (freerun_mode == 0 && ionvideo_size_changed(dev, w , h)) {
         msleep(10);
         return;
     }
@@ -241,19 +269,24 @@ static void ionvideo_thread_tick(struct ionvideo_dev *dev) {
     if (list_empty(&dma_q->active)) {
         dprintk(dev, 3, "No active queue to serve\n");
         spin_unlock_irqrestore(&dev->slock, flags);
-        msleep(5);
+        schedule_timeout_interruptible(msecs_to_jiffies(20));
         return;
     }
     buf = list_entry(dma_q->active.next, struct ionvideo_buffer, list);
     spin_unlock_irqrestore(&dev->slock, flags);
     /* Fill buffer */
+    trace_fillbuf(buf->vb.v4l2_buf.index, 1, vf_wait_cnt);
     if (ionvideo_fillbuff(dev, buf)) {
         return;
     }
+    trace_fillbuf(buf->vb.v4l2_buf.index, 0, vf_wait_cnt);
+    vf_wait_cnt = 0;
+
     spin_lock_irqsave(&dev->slock, flags);
     list_del(&buf->list);
     spin_unlock_irqrestore(&dev->slock, flags);
     vb2_buffer_done(&buf->vb, VB2_BUF_STATE_DONE);
+    dma_q->vb_ready++;
     dprintk(dev, 4, "[%p/%d] done\n", buf, buf->vb.v4l2_buf.index);
 }
 
@@ -302,6 +335,7 @@ static int ionvideo_thread(void *data) {
 
 static int ionvideo_start_generating(struct ionvideo_dev *dev) {
     struct ionvideo_dmaqueue *dma_q = &dev->vidq;
+    dev->is_omx_video_started = 1;
 
     dprintk(dev, 2, "%s\n", __func__);
 
@@ -309,8 +343,6 @@ static int ionvideo_start_generating(struct ionvideo_dev *dev) {
     dev->ms = 0;
     //dev->jiffies = jiffies;
 
-    dma_q->frame = 0;
-    //dma_q->ini_jiffies = jiffies;
     dma_q->kthread = kthread_run(ionvideo_thread, dev, dev->v4l2_dev.name);
 
     if (IS_ERR(dma_q->kthread)) {
@@ -430,7 +462,11 @@ static void buffer_queue(struct vb2_buffer *vb) {
 
 static int start_streaming(struct vb2_queue *vq, unsigned int count) {
     struct ionvideo_dev *dev = vb2_get_drv_priv(vq);
+    struct ionvideo_dmaqueue *dma_q = &dev->vidq;
+
+    cur_dma_q = dma_q;
     is_actived = 1;
+    dma_q->vb_ready = 0;
     dprintk(dev, 2, "%s\n", __func__);
     return ionvideo_start_generating(dev);
 }
@@ -438,6 +474,7 @@ static int start_streaming(struct vb2_queue *vq, unsigned int count) {
 /* abort streaming and wait for last buffer */
 static int stop_streaming(struct vb2_queue *vq) {
     struct ionvideo_dev *dev = vb2_get_drv_priv(vq);
+    cur_dma_q = NULL;
     is_actived = 0;
     dprintk(dev, 2, "%s\n", __func__);
     ionvideo_stop_generating(dev);
@@ -479,8 +516,8 @@ static int vidioc_open(struct file *file) {
     dev->once_record = 1;
     dev->ppmgr2_dev.bottom_first = 0;
     skip_frames = 0;
-    dprintk(dev, 2, "vidioc_open\n");
     printk("ionvideo open\n");
+    trace_onoffbuf(1);
     return v4l2_fh_open(file);
 }
 
@@ -495,6 +532,7 @@ static int vidioc_release(struct file *file) {
         dev->fd_num--;
     }
     dev->once_record = 0;
+    trace_onoffbuf(0);
     return vb2_fop_release(file);
 }
 
@@ -616,6 +654,7 @@ static int vidioc_enum_framesizes(struct file *file, void *fh, struct v4l2_frmsi
 
 static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p) {
     struct ionvideo_dev *dev = video_drvdata(file);
+    struct ionvideo_dmaqueue *dma_q = &dev->vidq;
     struct ppmgr2_device* ppmgr2_dev = &(dev->ppmgr2_dev);
     int ret = 0;
 
@@ -635,7 +674,8 @@ static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p) {
             return -ENOMEM;
         }
     }
-
+    wake_up_interruptible(&dma_q->wq);
+    trace_qdqbuf(p->index, 1, ret);
     return ret;
 }
 
@@ -649,46 +689,46 @@ static int vidioc_synchronization_dqbuf(struct file *file, void *priv, struct v4
     unsigned long flags;
 
     q = dev->vdev.queue;
-    if (dev->receiver_register) {  	 
-    	// clear the frame buffer queue  
-    	while(!list_empty(&q->done_list)) {
+    if (dev->receiver_register) {
+	// clear the frame buffer queue
+	while(!list_empty(&q->done_list)) {
 		ret = vb2_ioctl_dqbuf(file, priv, p);
 		if (ret) { return ret;}
 		ret = vb2_ioctl_qbuf(file, priv, p);
 		if (ret) { return ret;}
- 	}
-    	printk("init to clear the done list buffer.done\n");
-    	dev->receiver_register = 0;
-    	dev->is_video_started = 0;
+	}
+	printk("init to clear the done list buffer.done\n");
+	dev->receiver_register = 0;
+	dev->is_video_started = 0;
 	return -EAGAIN;
     } else{
-    	spin_lock_irqsave(&q->done_lock, flags);
-    	if (list_empty(&q->done_list)) {
-       	spin_unlock_irqrestore(&q->done_lock, flags);
-        	return -EAGAIN;
-    	}
-    	vb = list_first_entry(&q->done_list, struct vb2_buffer, done_entry);
-    	spin_unlock_irqrestore(&q->done_lock, flags);
-
-    	buf = container_of(vb, struct ionvideo_buffer, vb);
-    	if(dev->is_video_started == 0){
+	spin_lock_irqsave(&q->done_lock, flags);
+	if (list_empty(&q->done_list)) {
+	spin_unlock_irqrestore(&q->done_lock, flags);
+		return -EAGAIN;
+	}
+	vb = list_first_entry(&q->done_list, struct vb2_buffer, done_entry);
+	spin_unlock_irqrestore(&q->done_lock, flags);
+
+	buf = container_of(vb, struct ionvideo_buffer, vb);
+	if(dev->is_video_started == 0){
 		printk("Execute the VIDEO_START cmd. pts=%llx\n", buf->pts);
-        	tsync_avevent_locked(VIDEO_START, buf->pts ? buf->pts : timestamp_vpts_get());        
-        	d = 0;
-        	dev->is_video_started=1;
-    	}else{ 
-	    	if (buf->pts  == 0) {
-	       	buf->pts = timestamp_vpts_get() + DUR2PTS(buf->duration);
-	    	}      
+		tsync_avevent_locked(VIDEO_START, buf->pts ? buf->pts : timestamp_vpts_get());
+		d = 0;
+		dev->is_video_started=1;
+	}else{
+		if (buf->pts  == 0) {
+		buf->pts = timestamp_vpts_get() + DUR2PTS(buf->duration);
+		}
 
 		if (abs(timestamp_pcrscr_get() - buf->pts ) > tsync_vpts_discontinuity_margin()) {
-	        	tsync_avevent_locked(VIDEO_TSTAMP_DISCONTINUITY, buf->pts );
-	    	} 
+			tsync_avevent_locked(VIDEO_TSTAMP_DISCONTINUITY, buf->pts );
+		}
 		else{
 			timestamp_vpts_set(buf->pts);
 		}
-	    	d = (buf->pts - timestamp_pcrscr_get());
-    	}
+		d = (buf->pts - timestamp_pcrscr_get());
+	}
     }
 
     if (d > 450) {
@@ -701,15 +741,15 @@ static int vidioc_synchronization_dqbuf(struct file *file, void *priv, struct v4
 
 	     if (buf->pts  == 0) {
 		buf->pts = timestamp_vpts_get() + DUR2PTS(buf->duration);
-	     }      
+	     }
 
 	     if (abs(timestamp_pcrscr_get() - buf->pts ) > tsync_vpts_discontinuity_margin()) {
 		tsync_avevent_locked(VIDEO_TSTAMP_DISCONTINUITY, buf->pts );
-	     } 
+	     }
 	     else{
 		timestamp_vpts_set(buf->pts);
 	     }
-            
+
             if(list_empty(&q->done_list)) {
                 break;
             } else {
@@ -719,7 +759,7 @@ static int vidioc_synchronization_dqbuf(struct file *file, void *priv, struct v4
             }
         }
         dprintk(dev, 1, "s:%u\n", skip_frames);
-    } else {	 
+    } else {
         ret = vb2_ioctl_dqbuf(file, priv, p);
         if (ret) {
             return ret;
@@ -732,10 +772,19 @@ static int vidioc_synchronization_dqbuf(struct file *file, void *priv, struct v4
 }
 
 static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p){
+    struct ionvideo_dev *dev = video_drvdata(file);
+    struct ionvideo_dmaqueue *dma_q = &dev->vidq;
+    int ret = 0;
+
     if (freerun_mode == 0) {
         return vidioc_synchronization_dqbuf(file, priv, p);
     }
-    return vb2_ioctl_dqbuf(file, priv, p);
+    ret = vb2_ioctl_dqbuf(file, priv, p);
+    if (ret == 0) {
+        dma_q->vb_ready--;
+        trace_qdqbuf(p->index, 0, 0);
+    }
+    return ret;
 }
 
 #define NUM_INPUTS 10
@@ -841,10 +890,12 @@ static int video_receiver_event_fun(int type, void* data, void* private_data) {
 
     if (type == VFRAME_EVENT_PROVIDER_UNREG) {
         dev->receiver_register = 0;
+        dev->is_omx_video_started = 0;
         tsync_avevent(VIDEO_STOP, 0);
         printk("unreg:ionvideo\n");
     }else if (type == VFRAME_EVENT_PROVIDER_REG) {
         dev->receiver_register = 1;
+        dev->is_omx_video_started = 1;
         dev->ppmgr2_dev.interlaced_num = 0;
         printk("reg:ionvideo\n");
     }else if (type == VFRAME_EVENT_PROVIDER_QUREY_STATE) {
@@ -900,6 +951,7 @@ static int __init ionvideo_create_instance(int inst)
     /* init video dma queues */
     INIT_LIST_HEAD(&dev->vidq.active);
     init_waitqueue_head(&dev->vidq.wq);
+    dev->vidq.pdev = dev;
 
     vfd = &dev->vdev;
     *vfd = ionvideo_template;
@@ -934,17 +986,29 @@ free_dev:
     return ret;
 }
 
+static u32 buf_num_queue(struct vb2_queue *q)
+{
+    return atomic_read(&q->queued_count);
+}
+
 static ssize_t vframe_states_show(struct class *class, struct class_attribute* attr, char* buf)
 {
     int ret = 0;
     vframe_states_t states;
 //    unsigned long flags;
-	
+
     if (ionvideo_vf_get_states(&states) == 0) {
-        ret += sprintf(buf + ret, "vframe_pool_size=%d\n", states.vf_pool_size);
-        ret += sprintf(buf + ret, "vframe buf_free_num=%d\n", states.buf_free_num);
-        ret += sprintf(buf + ret, "vframe buf_recycle_num=%d\n", states.buf_recycle_num);
-        ret += sprintf(buf + ret, "vframe buf_avail_num=%d\n", states.buf_avail_num);
+        ret += sprintf(buf + ret, "codec buffer state:\n");
+        ret += sprintf(buf + ret, "\tvframe_pool_size=%d\n", states.vf_pool_size);
+        ret += sprintf(buf + ret, "\tvframe buf_free_num=%d\n", states.buf_free_num);
+        ret += sprintf(buf + ret, "\tvframe buf_recycle_num=%d\n", states.buf_recycle_num);
+        ret += sprintf(buf + ret, "\tvframe buf_avail_num=%d\n", states.buf_avail_num);
+        if (cur_dma_q) {
+            ret += sprintf(buf + ret, "ionv buffer state:\n");
+            ret += sprintf(buf + ret, "\t buffer number:%d\n", cur_dma_q->pdev->vb_vidq.num_buffers);
+            ret += sprintf(buf + ret, "\t buffer filled:%d\n", cur_dma_q->vb_ready);
+            ret += sprintf(buf + ret, "\t buffer in driver:%d\n", buf_num_queue(&cur_dma_q->pdev->vb_vidq));
+        }
     } else {
         ret += sprintf(buf + ret, "vframe no states\n");
     }
@@ -952,8 +1016,29 @@ static ssize_t vframe_states_show(struct class *class, struct class_attribute* a
     return ret;
 }
 
+static ssize_t scaling_rate_show(struct class *cla,struct class_attribute *attr,char *buf)
+{
+
+    return snprintf(buf,80,"current scaling rate is %d\n",scaling_rate);
+}
+
+static ssize_t scaling_rate_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    ssize_t size;
+    char *endp;
+
+    scaling_rate = simple_strtoul(buf, &endp, 0);
+    size = endp - buf;
+    return count;
+}
 static struct class_attribute ion_video_class_attrs[] = {
 	__ATTR_RO(vframe_states),
+    __ATTR(scaling_rate,
+           S_IRUGO | S_IWUSR,
+           scaling_rate_show,
+           scaling_rate_write),	
     __ATTR_NULL
 };
 static struct class ionvideo_class = {
@@ -997,7 +1082,7 @@ static int __init ionvideo_init(void)
 
     /* n_devs will reflect the actual number of allocated devices */
     n_devs = i;
-    
+
     return ret;
 }
 
diff --git a/drivers/amlogic/ionvideo/ionvideo.h b/drivers/amlogic/ionvideo/ionvideo.h
old mode 100644
new mode 100755
index 3f81ca09..470e8122
--- a/drivers/amlogic/ionvideo/ionvideo.h
+++ b/drivers/amlogic/ionvideo/ionvideo.h
@@ -42,9 +42,6 @@
 #define MAX_WIDTH 1920
 #define MAX_HEIGHT 1088
 
-#define PPMGR2_MAX_CANVAS 8
-#define PPMGR2_CANVAS_INDEX 0x70
-
 #define DUR2PTS(x) ((x) - ((x) >> 4))
 
 #define dprintk(dev, level, fmt, arg...)                    \
@@ -53,7 +50,7 @@
 #define ppmgr2_printk(level, fmt, arg...)                   \
     do {                                                    \
         if (get_ionvideo_debug() >= level)                  \
-            printk(KERN_DEBUG "ppmgr2-dev: " fmt, ## arg);  \
+            printk("ppmgr2-dev: " fmt, ## arg);  \
     } while (0)
 
 /* ------------------------------------------------------------------
@@ -84,8 +81,8 @@ struct ionvideo_dmaqueue {
     struct task_struct *kthread;
     wait_queue_head_t wq;
     /* Counters to control fps rate */
-    int frame;
-    int ini_jiffies;
+    int vb_ready;
+    struct ionvideo_dev* pdev;
 };
 
 struct ppmgr2_device {
@@ -140,6 +137,7 @@ struct ionvideo_dev {
     u8 is_video_started;
     u32 skip;
     int once_record;
+    u8 is_omx_video_started;
 };
 
 int is_ionvideo_active(void);
diff --git a/drivers/amlogic/ionvideo/ppmgr2.c b/drivers/amlogic/ionvideo/ppmgr2.c
old mode 100644
new mode 100755
index 53218035..0eeb5161
--- a/drivers/amlogic/ionvideo/ppmgr2.c
+++ b/drivers/amlogic/ionvideo/ppmgr2.c
@@ -261,6 +261,10 @@ int ppmgr2_canvas_config(struct ppmgr2_device *ppd, int dst_width, int dst_heigh
         ppmgr2_printk(1, "NULL physical address!\n");
         return -1;
     }
+    if (index >= PPMGR2_MAX_CANVAS) {
+        ppmgr2_printk(0, "canvas index too large! %d>=%d\n", index, PPMGR2_MAX_CANVAS);
+        return -1;
+    }
     ppd->ge2d_fmt = v4l_to_ge2d_format(dst_fmt);
     ppd->dst_width = dst_width;
     ppd->dst_height = dst_height;
@@ -346,7 +350,7 @@ int ppmgr2_process(struct vframe_s* vf, struct ppmgr2_device *ppd, int index) {
 //#ifdef GE2D_DEINTERLACE
     if (src_vf->type & VIDTYPE_INTERLACE) {
         if ((ppd->bottom_first && src_vf->type & 0x2) || (ppd->bottom_first == 0 && (src_vf->type & 0x2) == 0)) {
-        	return -EAGAIN;
+		return -EAGAIN;
         }
     }
 //#endif
diff --git a/drivers/amlogic/ionvideo/trace/ionvideo.h b/drivers/amlogic/ionvideo/trace/ionvideo.h
new file mode 100644
index 00000000..b671b8f5
--- /dev/null
+++ b/drivers/amlogic/ionvideo/trace/ionvideo.h
@@ -0,0 +1,74 @@
+#undef TRACE_SYSTEM
+#define TRACE_INCLUDE_PATH ../../drivers/amlogic/ionvideo/trace
+#define TRACE_SYSTEM ionvideo
+
+#if !defined(_TRACE_IONVIDEO_H) || defined(TRACE_HEADER_MULTI_READ)
+#define _TRACE_IONVIDEO_H
+
+#include "../ionvideo.h"
+#include <linux/tracepoint.h>
+
+TRACE_EVENT(qdqbuf,
+    TP_PROTO(int idx, int que, u64 ts),
+
+    TP_ARGS(idx, que, ts),
+
+    TP_STRUCT__entry(
+            __field(u32, idx)
+            __field(u32, que)
+            __field(u64, ts)
+    ),
+
+    TP_fast_assign(
+            __entry->idx = idx;
+            __entry->que = que;
+            __entry->ts = ts;
+    ),
+
+    TP_printk("%s: buf%d", __entry->que? "[Q]": "\t\t[D]",
+            __entry->idx)
+);
+
+TRACE_EVENT(fillbuf,
+    TP_PROTO(int idx, int begin, int vf_wait),
+
+    TP_ARGS(idx, begin, vf_wait),
+
+    TP_STRUCT__entry(
+            __field(u32, idx)
+            __field(u32, begin)
+            __field(u32, vf_wait)
+    ),
+
+    TP_fast_assign(
+            __entry->idx = idx;
+            __entry->begin = begin;
+            __entry->vf_wait = vf_wait;
+    ),
+
+    TP_printk("\t%s buf%d W:%d",
+                    __entry->begin?"[>>]":"[<<]",
+                    __entry->idx, __entry->vf_wait)
+);
+
+TRACE_EVENT(onoffbuf,
+    TP_PROTO(int que),
+
+    TP_ARGS(que),
+
+    TP_STRUCT__entry(
+            __field(u32, que)
+    ),
+
+    TP_fast_assign(
+            __entry->que = que;
+    ),
+
+    TP_printk("\t\t @[%s]@", __entry->que? "StreamON": "SteamOFF")
+);
+
+#endif /* if !defined(_TRACE_SYNC_H) || defined(TRACE_HEADER_MULTI_READ) */
+
+/* This part must be outside protection */
+#include <trace/define_trace.h>
+
diff --git a/drivers/amlogic/ionvideo/videobuf2-ion.c b/drivers/amlogic/ionvideo/videobuf2-ion.c
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/ionvideo/videobuf2-ion.h b/drivers/amlogic/ionvideo/videobuf2-ion.h
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/ppmgr/Makefile b/drivers/amlogic/ppmgr/Makefile
index cdded619..372ccba7 100755
--- a/drivers/amlogic/ppmgr/Makefile
+++ b/drivers/amlogic/ppmgr/Makefile
@@ -1,9 +1,8 @@
-ppmgr-objs = ppmgr_drv.o ppmgr_vpp.o 
-ppmgr3d-objs = ppmgr_3d.o
-    
-
-obj-$(CONFIG_POST_PROCESS_MANAGER) += ppmgr.o 
-obj-$(CONFIG_POST_PROCESS_MANAGER_3D_PROCESS) += ppmgr3d.o
-obj-$(CONFIG_POST_PROCESS_MANAGER_3D_PROCESS) += ppmgr_3d_tv.o 
-EXTRA_CFLAGS += -Iinclude/linux/ge2d/
-									
+ppmgr-objs = ppmgr_drv.o ppmgr_vpp.o
+ppmgr3d-objs = ppmgr_3d.o
+
+
+obj-$(CONFIG_POST_PROCESS_MANAGER) += ppmgr.o
+obj-$(CONFIG_POST_PROCESS_MANAGER_3D_PROCESS) += ppmgr3d.o
+obj-$(CONFIG_POST_PROCESS_MANAGER_3D_PROCESS) += ppmgr_3d_tv.o
+EXTRA_CFLAGS += -Iinclude/linux/ge2d/
diff --git a/drivers/amlogic/ppmgr/aml.dtd b/drivers/amlogic/ppmgr/aml.dtd
index 4c5b0e9e..f287299a 100755
--- a/drivers/amlogic/ppmgr/aml.dtd
+++ b/drivers/amlogic/ppmgr/aml.dtd
@@ -6,6 +6,6 @@
 		compatible = "amlogic,ppmgr";
 		dev_name = "ppmgr";
 		status = "okay";
-		reserve-memory = <0x03f00000>;		
+		reserve-memory = <0x03f00000>;
 	};
 #endif
\ No newline at end of file
diff --git a/drivers/amlogic/ppmgr/ppmgr_3d.c b/drivers/amlogic/ppmgr/ppmgr_3d.c
old mode 100644
new mode 100755
index b522a908..1eb34466
--- a/drivers/amlogic/ppmgr/ppmgr_3d.c
+++ b/drivers/amlogic/ppmgr/ppmgr_3d.c
@@ -1,2607 +1,2607 @@
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-#include <linux/timer.h>
-#include <linux/amlogic/vout/vinfo.h>
-#include <linux/amlogic/vout/vout_notify.h>
-#include <linux/platform_device.h>
-#include <linux/amlogic/amports/timestamp.h>
-#include <linux/amlogic/amports/ptsserv.h>
-#include <linux/amlogic/amports/canvas.h>
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/amports/vframe_provider.h>
-#include <linux/amlogic/amports/vfp.h>
-#include <mach/am_regs.h>
-#include <linux/amlogic/amlog.h>
-#include <linux/amlogic/ge2d/ge2d.h>
-#include <linux/amlogic/ge2d/ge2d_wq.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/semaphore.h>
-#include <linux/sched.h>
-#include "ppmgr_log.h"
-#include "ppmgr_pri.h"
-#include "ppmgr_dev.h"
-#include <linux/amlogic/ppmgr/ppmgr.h>
-#include <linux/amlogic/ppmgr/ppmgr_status.h>
-#include <linux/io.h>
-
-#define VF_POOL_SIZE 4
-
-static int cur_process_type =0;
-static int mask_canvas_index = -1;
-static int ppmgr_3d_clear_count = 0;
-
-typedef struct{
-    unsigned all_mode;
-    unsigned char mode;
-    unsigned char src_format;
-    unsigned char switch_flag;
-    unsigned char _3d_to_2d_use_frame;
-    unsigned char _2d_to_3d_type;
-    unsigned char double_type;
-    unsigned _2d_3d_control;
-    unsigned _2d_3d_control_value;
-    //unsigned direction; //0: 0 degree, 1: 90, 2: 180, 3:270
-}Process3d_t;
-
-typedef struct display_frame_s{
-    int frame_top;
-    int frame_left;
-    int frame_width;
-    int frame_height;
-    int content_top;
-    int content_left;
-    int content_width;
-    int content_height;
-}display_frame_t;
-
-extern void ppmgr_vf_put_dec(vframe_t *vf);
-extern u32 index2canvas(u32 index);
-extern vfq_t q_ready;
-extern vfq_t q_free;
-
-extern int get_bypass_mode(void);
-
-static Process3d_t _3d_process = {0};
-
-void Reset3Dclear(void)
-{
-    ppmgr_3d_clear_count = VF_POOL_SIZE;
-}
-
-void Set3DProcessPara(unsigned mode)
-{
-    if(_3d_process.all_mode != mode){
-        memset(&_3d_process,0,sizeof(Process3d_t));
-        _3d_process.all_mode = mode;
-        _3d_process.mode = mode & PPMGR_3D_PROCESS_MODE_MASK;
-        _3d_process.src_format = (mode & PPMGR_3D_PROCESS_SRC_FOMRAT_MASK)>>PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT;
-        _3d_process.switch_flag = (mode & PPMGR_3D_PROCESS_SWITCH_FLAG)?1:0;
-        _3d_process._3d_to_2d_use_frame = (mode & PPMGR_3D_PROCESS_3D_TO_2D_SRC_FRAME)?1:0;
-        _3d_process._2d_to_3d_type = (mode & PPMGR_3D_PROCESS_2D_TO_3D_MASK)>>PPMGR_3D_PROCESS_2D_TO_3D_SHIFT;
-        _3d_process.double_type = (mode & PPMGR_3D_PROCESS_DOUBLE_TYPE)>>PPMGR_3D_PROCESS_DOUBLE_TYPE_SHIFT;
-        _3d_process._2d_3d_control = (mode & PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_MASK)>>PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_SHIFT;
-        if(_3d_process._2d_3d_control>0){
-            _3d_process._2d_3d_control_value = (mode & PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_VALUE_MASK)>>PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_VAULE_SHIFT;
-            if((_3d_process.mode == PPMGR_3D_PROCESS_MODE_2D_TO_3D)&&(!_3d_process._2d_3d_control_value))
-                _3d_process._2d_3d_control_value = 0x10;
-        }else{
-            _3d_process._2d_3d_control_value = 0;
-            
-        }
-        //_3d_process.direction = (mode & PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK)>>PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_VAULE_SHIFT;
-        //printk("-- ppmgr 3d process 0x%x: mode:%d, src format:%d, switch flag:%d, 3d to 2d frame: %d,2d to 3d:%d, double type:%d, control mode: %d, control value: %d, rotate direction: %d,
-        //       _3d_process.all_mode,_3d_process.mode,_3d_process.src_format,_3d_process.switch_flag,
-        //       _3d_process._3d_to_2d_use_frame,_3d_process._2d_to_3d_type,_3d_process.double_type,
-        //       _3d_process._2d_3d_control,_3d_process._2d_3d_control_value,_3d_process.direction);
-    }
-}
-
-int get_mid_process_type(vframe_t* vf)
-{
-    int process_type = 0 ;
-    if(!vf){
-        process_type = TYPE_NONE ;
-        return process_type;
-    }
-
-    if(_3d_process.mode == PPMGR_3D_PROCESS_MODE_3D_ENABLE){
-        if(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_LR){
-            process_type = TYPE_3D_LR;
-        }else if(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB){
-            process_type = TYPE_3D_TB;
-        }else{  // auto mode or others
-            switch(vf->trans_fmt){
-                case TVIN_TFMT_3D_TB:
-                    process_type = TYPE_3D_TB;
-                    break;
-                case TVIN_TFMT_3D_FP:
-                    process_type = TYPE_3D_LR;
-                    break;
-                case TVIN_TFMT_3D_LRH_OLOR:
-                case TVIN_TFMT_3D_LRH_OLER:
-                case TVIN_TFMT_3D_LRH_ELOR:
-                case TVIN_TFMT_3D_LRH_ELER:
-                    process_type = TYPE_3D_LR;
-                    break;
-                default:
-                    process_type = TYPE_NONE;
-                    break;
-            }
-        }            
-    }else if(_3d_process.mode == PPMGR_3D_PROCESS_MODE_3D_TO_2D){
-        if(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_LR){
-            process_type = TYPE_3D_TO_2D_LR;
-        }else if(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB){
-            process_type = TYPE_3D_TO_2D_TB;
-        }else{  // auto mode or others
-            switch(vf->trans_fmt){
-                case TVIN_TFMT_3D_TB:
-                    process_type = TYPE_3D_TO_2D_TB;
-                    break;
-                case TVIN_TFMT_3D_FP:
-                    process_type = TYPE_3D_TO_2D_LR;
-                    break;
-                case TVIN_TFMT_3D_LRH_OLOR:
-                case TVIN_TFMT_3D_LRH_OLER:
-                case TVIN_TFMT_3D_LRH_ELOR:
-                case TVIN_TFMT_3D_LRH_ELER:
-                    process_type = TYPE_3D_TO_2D_LR;
-                    break;
-                default:
-                    process_type = TYPE_NONE;
-                    break;
-            }
-        }   
-    }else if(_3d_process.mode == PPMGR_3D_PROCESS_MODE_2D_TO_3D){
-        process_type = TYPE_2D_TO_3D;
-    }else{
-        process_type = TYPE_NONE;
-    }
-    return process_type;
-}
-
-int is_mid_local_source(vframe_t* vf)
-{
-    int ret = 0 ;
-    if(vf->type&VIDTYPE_VIU_422){
-        ret = 0;
-    }else{
-    	ret = 1;
-    }
-    return ret;
-}
-
-int is_mid_mvc_need_process(vframe_t* vf)
-{
-    int ret = 0 ;
-    int process_type = get_mid_process_type(vf);
-    switch(process_type){
-        //case TYPE_3D_LR:
-        case TYPE_3D_TO_2D_LR:
-            ret = 1;
-            break;
-        default:
-            break;
-    }
-    return ret;
-}
-
-static int is_vertical_sample_enable(vframe_t* vf)
-{
-    int ret = 0 ;
-    if((vf->type &VIDTYPE_INTERLACE_BOTTOM)||(vf->type &VIDTYPE_INTERLACE_TOP)){
-        ret = 1 ;
-    }
-    return ret;
-}
-
-
-static int get_input_format(vframe_t* vf)
-{
-    int format= GE2D_FORMAT_M24_YUV420;
-    if(vf->type&VIDTYPE_VIU_NV21)
-        format =  GE2D_FORMAT_M24_NV21;
-    else
-        format =  GE2D_FORMAT_M24_YUV420;
-    if(vf->type&VIDTYPE_VIU_422){
-        format =  GE2D_FORMAT_S16_YUV422;
-    }else{
-        if(is_vertical_sample_enable(vf)){
-            if(vf->type &VIDTYPE_INTERLACE_BOTTOM){
-                format =  format|(GE2D_FMT_M24_YUV420B & (3<<3));
-            }else if(vf->type &VIDTYPE_INTERLACE_TOP){
-                format =  format|(GE2D_FORMAT_M24_YUV420T & (3<<3));
-            }
-        }else{
-            if(vf->type&VIDTYPE_VIU_NV21)
-                format =  GE2D_FORMAT_M24_NV21;
-            else
-                format =  GE2D_FORMAT_M24_YUV420;
-        }
-    }
-    return format;
-}
-
-
-static int get_input_frame(vframe_t* vf , display_frame_t* frame)
-{
-    if(frame == NULL){
-        return -1;
-    }
-    if(vf->type & VIDTYPE_MVC){
-	frame->content_top = vf->left_eye.start_y   ;
-	frame->content_left = vf->left_eye.start_x ;
-	frame->content_width = vf->left_eye.width    ;
-	frame->content_height = vf->left_eye.height  ;
-	frame->frame_top =    vf->left_eye.start_y ;
-	frame->frame_left =   vf->left_eye.start_x;
-	frame->frame_width=   vf->left_eye.width ;
-	frame->frame_height = vf->left_eye.height;
-	return 0;
-    }
-/*tv in case , need detect the black bar*/
-    if((vf->prop.bbar.bottom)&&(vf->prop.bbar.right)
-      &&(vf->prop.bbar.right > vf->prop.bbar.left)
-      &&(vf->prop.bbar.bottom > vf->prop.bbar.top )){
-        switch(vf->trans_fmt){
-            case TVIN_TFMT_2D:
-                frame->content_top = vf->prop.bbar.top   ;
-                frame->content_left = vf->prop.bbar.left  ;
-                frame->content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
-                frame->content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
-                frame->frame_top =    0;
-                frame->frame_left =   0;
-                frame->frame_width=   vf->width;
-                frame->frame_height = vf->height;
-                break;
-            case TVIN_TFMT_3D_FP:
-                frame->content_top = vf->left_eye.start_y   ;
-                frame->content_left = vf->left_eye.start_x ;
-                frame->content_width = vf->left_eye.width    ;
-                frame->content_height = vf->left_eye.height  ;
-                frame->frame_top =    vf->left_eye.start_y ;
-                frame->frame_left =   vf->left_eye.start_x;
-                frame->frame_width=   vf->left_eye.width ;
-                frame->frame_height = vf->left_eye.height;
-                break;
-            default:
-                frame->content_top = vf->prop.bbar.top   ;
-                frame->content_left = vf->prop.bbar.left  ;
-                frame->content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
-                frame->content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
-                frame->frame_top =    0;
-                frame->frame_left =   0;
-                frame->frame_width=   vf->width;
-                frame->frame_height = vf->height;
-                break;
-        }
-//	    printk("full_frame: format  is %d , top is %d , left is %d , width is %d , height is %d\n",vf->trans_fmt ,frame->content_top ,frame->content_left,frame->content_width,frame->content_height);
-    }else{
-        switch(vf->trans_fmt){
-            case TVIN_TFMT_2D:
-                frame->content_top = 0  ;
-                frame->content_left = 0  ;
-                frame->content_width = vf->width;    ;
-                frame->content_height = vf->height;
-                frame->frame_top =    0;
-                frame->frame_left =   0;
-                frame->frame_width=   vf->width;
-                frame->frame_height = vf->height;
-                break;
-            case TVIN_TFMT_3D_FP:
-                frame->content_top = vf->left_eye.start_y   ;
-                frame->content_left = vf->left_eye.start_x ;
-                frame->content_width = vf->left_eye.width    ;
-                frame->content_height = vf->left_eye.height  ;
-                frame->frame_top =    vf->left_eye.start_y ;
-                frame->frame_left =   vf->left_eye.start_x;
-                frame->frame_width=   vf->left_eye.width ;
-                frame->frame_height = vf->left_eye.height;
-                break;
-            default:
-                frame->content_top = 0  ;
-                frame->content_left = 0  ;
-                frame->content_width = vf->width;
-                frame->content_height = vf->height;
-                frame->frame_top =    0;
-                frame->frame_left =   0;
-                frame->frame_width=   vf->width;
-                frame->frame_height = vf->height;
-                break;
-        }
-    }
-    return 0;
-}
-
-static int get_input_l_frame(vframe_t* vf , display_frame_t* frame)
-{
-    int content_top ,content_left ,content_width ,content_height;
-    if(frame == NULL){
-        return -1;
-    }
-    if(vf->type & VIDTYPE_MVC){
-	frame->content_top = vf->left_eye.start_y   ;
-	frame->content_left = vf->left_eye.start_x ;
-	frame->content_width = vf->left_eye.width    ;
-	frame->content_height = vf->left_eye.height  ;
-	frame->frame_top =    vf->left_eye.start_y;
-	frame->frame_left =   vf->left_eye.start_x;
-	frame->frame_width=   vf->left_eye.width;
-	frame->frame_height = vf->left_eye.height;
-	return 0;
-    }
-/*tv in case , need detect the black bar*/
-    if((vf->prop.bbar.bottom)&&(vf->prop.bbar.right)
-      &&(vf->prop.bbar.right > vf->prop.bbar.left)
-      &&(vf->prop.bbar.bottom > vf->prop.bbar.top )){
-        switch(vf->trans_fmt){
-            case TVIN_TFMT_2D:
-                content_top = vf->prop.bbar.top   ;
-                content_left = vf->prop.bbar.left  ;
-                content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
-                content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
-                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
-                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
-                    frame->content_top = content_top  ;
-                    frame->content_left = content_left ;
-                    frame->content_width = content_width    ;
-                    frame->content_height = content_height/2  ;
-                }else{
-                    frame->content_top = content_top  ;
-                    frame->content_left = content_left ;
-                    frame->content_width = content_width/2    ;
-                    frame->content_height = content_height  ;
-                }
-                frame->frame_top =    0;
-                frame->frame_left =   0;
-                frame->frame_width=   vf->width;
-                frame->frame_height = vf->height;
-                break;
-            case TVIN_TFMT_3D_FP:
-                frame->content_top = vf->left_eye.start_y   ;
-                frame->content_left = vf->left_eye.start_x ;
-                frame->content_width = vf->left_eye.width    ;
-                frame->content_height = vf->left_eye.height  ;
-                frame->frame_top =    vf->left_eye.start_y;
-                frame->frame_left =   vf->left_eye.start_x;
-                frame->frame_width=   vf->left_eye.width;
-                frame->frame_height = vf->left_eye.height;
-                break;
-            default:
-                content_top = vf->prop.bbar.top   ;
-                content_left = vf->prop.bbar.left  ;
-                content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
-                content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
-                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
-                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
-                    frame->content_top = content_top  ;
-                    frame->content_left = content_left ;
-                    frame->content_width = content_width    ;
-                    frame->content_height = content_height/2  ;
-                }else{
-                    frame->content_top = content_top  ;
-                    frame->content_left = content_left ;
-                    frame->content_width = content_width/2    ;
-                    frame->content_height = content_height  ;
-                }
-                frame->frame_top =    0;
-                frame->frame_left =   0;
-                frame->frame_width=   vf->width;
-                frame->frame_height = vf->height;
-                break;
-        }
-//	    printk("lframe: format  is %d , top is %d , left is %d , width is %d , height is %d\n",vf->trans_fmt ,frame->content_top ,frame->content_left,frame->content_width,frame->content_height);
-    }else{
-        switch(vf->trans_fmt){
-            case TVIN_TFMT_2D:
-                content_top = 0  ;
-                content_left = 0  ;
-                content_width = vf->width;    ;
-                content_height = vf->height;
-                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
-                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
-                    frame->content_top = content_top  ;
-                    frame->content_left = content_left ;
-                    frame->content_width = content_width    ;
-                    frame->content_height = content_height/2  ;
-                }else{
-                    frame->content_top = content_top  ;
-                    frame->content_left = content_left ;
-                    frame->content_width = content_width/2    ;
-                    frame->content_height = content_height  ;
-                }
-                frame->frame_top =    0;
-                frame->frame_left =   0;
-
-                frame->frame_width=   vf->width;
-                frame->frame_height = vf->height;
-                break;
-            case TVIN_TFMT_3D_FP:
-                frame->content_top = vf->left_eye.start_y   ;
-                frame->content_left = vf->left_eye.start_x ;
-                frame->content_width = vf->left_eye.width    ;
-                frame->content_height = vf->left_eye.height  ;
-                frame->frame_top =    vf->left_eye.start_y;
-                frame->frame_left =   vf->left_eye.start_x;
-                frame->frame_width=   vf->left_eye.width;
-                frame->frame_height = vf->left_eye.height;
-                break;
-            default:
-                content_top = 0  ;
-                content_left = 0  ;
-                content_width = vf->width;    ;
-                content_height = vf->height;
-                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
-                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
-                    frame->content_top = content_top  ;
-                    frame->content_left = content_left ;
-                    frame->content_width = content_width    ;
-                    frame->content_height = content_height/2  ;
-                }else{
-                    frame->content_top = content_top  ;
-                    frame->content_left = content_left ;
-                    frame->content_width = content_width/2    ;
-                    frame->content_height = content_height  ;
-                }
-                frame->frame_top =    0;
-                frame->frame_left =   0;
-                frame->frame_width=   vf->width;
-                frame->frame_height = vf->height;
-                break;
-        } 
-    }
-    return 0;
-}
-
-static int get_input_r_frame(vframe_t* vf , display_frame_t* frame)
-{
-    int content_top ,content_left ,content_width ,content_height;
-    if(frame == NULL){
-        return -1;
-    }
-    if(vf->type & VIDTYPE_MVC){
-        frame->content_top = vf->right_eye.start_y   ;
-        frame->content_left = vf->right_eye.start_x ;
-        frame->content_width = vf->right_eye.width    ;
-        frame->content_height = vf->right_eye.height  ;
-        frame->frame_top =    vf->right_eye.start_y;
-        frame->frame_left =   vf->right_eye.start_x;
-        frame->frame_width=   vf->right_eye.width;
-        frame->frame_height = vf->right_eye.height;
-        return 0;
-    }
-/*tv in case , need detect the black bar*/
-    if((vf->prop.bbar.bottom)&&(vf->prop.bbar.right)
-      &&(vf->prop.bbar.right > vf->prop.bbar.left)
-      &&(vf->prop.bbar.bottom > vf->prop.bbar.top )){
-        switch(vf->trans_fmt){
-            case TVIN_TFMT_2D:
-                content_top = vf->prop.bbar.top   ;
-                content_left = vf->prop.bbar.left  ;
-                content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
-                content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
-                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
-                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
-                    frame->content_top = content_top + content_height/2 ;
-                    frame->content_left = content_left ;
-                    frame->content_width = content_width    ;
-                    frame->content_height = content_height/2  ;
-                }else{
-                    frame->content_top = content_top  ;
-                    frame->content_left = content_width/2 + content_left ;
-                    frame->content_width = content_width/2    ;
-                    frame->content_height = content_height  ;
-                }
-                frame->frame_top = 0;
-                frame->frame_left = 0;
-                frame->frame_width= vf->width;
-                frame->frame_height = vf->height;
-                break;
-            case TVIN_TFMT_3D_FP:
-                frame->content_top = vf->right_eye.start_y   ;
-                frame->content_left = vf->right_eye.start_x ;
-                frame->content_width = vf->right_eye.width    ;
-                frame->content_height = vf->right_eye.height  ;
-                frame->frame_top =    vf->right_eye.start_y;
-                frame->frame_left =   vf->right_eye.start_x;
-                frame->frame_width=   vf->right_eye.width;
-                frame->frame_height = vf->right_eye.height;
-                break;
-            default:
-                content_top = vf->prop.bbar.top   ;
-                content_left = vf->prop.bbar.left  ;
-                content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
-                content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
-                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
-                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
-                    frame->content_top = content_top + content_height/2 ;
-                    frame->content_left = content_left ;
-                    frame->content_width = content_width    ;
-                    frame->content_height = content_height/2  ;
-                }else{
-                    frame->content_top = content_top  ;
-                    frame->content_left = content_width/2 + content_left ;
-                    frame->content_width = content_width/2    ;
-                    frame->content_height = content_height  ;
-                }
-                frame->frame_top = 0;
-                frame->frame_left = 0;
-                frame->frame_width= vf->width;
-                frame->frame_height = vf->height;
-                break;
-        }
-//		printk("rframe : format  is %d , top is %d , left is %d , width is %d , height is %d\n",vf->trans_fmt ,frame->content_top ,frame->content_left,frame->content_width,frame->content_height);
-    }else{
-        switch(vf->trans_fmt){
-            case TVIN_TFMT_2D:
-                content_top = 0  ;
-                content_left = 0  ;
-                content_width = vf->width;    ;
-                content_height = vf->height;
-                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
-                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
-                    frame->content_top = content_top + content_height/2 ;
-                    frame->content_left = content_left ;
-                    frame->content_width = content_width    ;
-                    frame->content_height = content_height/2  ;
-                }else{
-                    frame->content_top = content_top  ;
-                    frame->content_left = content_width/2 + content_left ;
-                    frame->content_width = content_width/2    ;
-                    frame->content_height = content_height  ;
-                }
-                frame->frame_top = 0;
-                frame->frame_left = 0;
-                frame->frame_width= vf->width;
-                frame->frame_height = vf->height;
-                break;
-            case TVIN_TFMT_3D_FP:
-                frame->content_top = vf->right_eye.start_y   ;
-                frame->content_left = vf->right_eye.start_x ;
-                frame->content_width = vf->right_eye.width    ;
-                frame->content_height = vf->right_eye.height  ;
-                frame->frame_top =    vf->right_eye.start_y;
-                frame->frame_left =   vf->right_eye.start_x;
-                frame->frame_width=   vf->right_eye.width;
-                frame->frame_height = vf->right_eye.height;
-                break;
-            default:
-                content_top = 0  ;
-                content_left = 0  ;
-                content_width = vf->width;    ;
-                content_height = vf->height;
-                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
-                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
-                    frame->content_top = content_top + content_height/2 ;
-                    frame->content_left = content_left ;
-                    frame->content_width = content_width    ;
-                    frame->content_height = content_height/2  ;
-                }else{
-                    frame->content_top = content_top  ;
-                    frame->content_left = content_width/2 + content_left ;
-                    frame->content_width = content_width/2    ;
-                    frame->content_height = content_height  ;
-                }
-                frame->frame_top = 0;
-                frame->frame_left = 0;
-                frame->frame_width= vf->width;
-                frame->frame_height = vf->height;
-                break;
-        }
-    }
-    return 0;
-}
-
-static int get_output_rect_after_ratio(vframe_t* vf ,int* top , int*left , int* width , int* height ,int in_width, int in_height, int output_width,int output_height,unsigned angle)
-{
-    int t = 0,l = 0,w = 0,h = 0;
-    int current_view_mode = 0 ;
-    int ar = 0x100;
-    unsigned char  doublemode = _3d_process.double_type;
-
-    w = output_width;
-    h = output_height;
-    if(doublemode == PPMGR_3D_PROCESS_DOUBLE_TYPE_HOR){
-        in_width = in_width<<1;
-    }else if(doublemode == PPMGR_3D_PROCESS_DOUBLE_TYPE_VER){
-        in_height = in_height<<1;
-    }
-    if (vf->ratio_control) {
-        ar = (vf->ratio_control >> DISP_RATIO_ASPECT_RATIO_BIT) & 0x3ff;
-        if(doublemode == PPMGR_3D_PROCESS_DOUBLE_TYPE_HOR){
-            ar = ar>>1;
-        }else if(doublemode == PPMGR_3D_PROCESS_DOUBLE_TYPE_VER){
-            ar = ar<<1;
-        }
-    }else{
-        ar = (in_height<<8)/in_width;
-    }
-    current_view_mode  = get_ppmgr_viewmode();
-    if(current_view_mode == VIEWMODE_NORMAL){
-        if(output_width>output_height){  //panel 1280*768 case
-            if(angle&1){
-                if((in_width*16) == (in_height*9)){
-                    current_view_mode = VIEWMODE_FULL;
-                }
-            }else{
-                if((in_width*9) == (in_height*16)){
-                    current_view_mode = VIEWMODE_FULL;
-                }
-            }
-        }else{                          //panel 800*1280 case
-            if(angle&1){
-                if((in_width*9) == (in_height*16)){
-                    current_view_mode = VIEWMODE_FULL;
-                }
-            }else{
-                if((in_width*16) == (in_height*9)){
-                    current_view_mode = VIEWMODE_FULL;
-                }
-            }
-        }   
-    }
-
-    switch(current_view_mode){
-        case VIEWMODE_4_3:
-            ar = 0xc0;
-            break;
-        case VIEWMODE_16_9:
-            ar = 0x90;
-            break;
-        case VIEWMODE_FULL:
-            *top = 0;
-            *left = 0;
-            *width = output_width;
-            *height = output_height;
-            return 0;
-        case VIEWMODE_1_1:
-            if(angle&1){
-                int swap = in_width;
-                in_width = in_height;
-                in_height = swap;
-            }
-            break;
-        case VIEWMODE_NORMAL:
-        default:
-            break;
-    }
-
-    if(angle&1)
-        ar = 0x10000/ar;
-    if ((ar * output_width) > (output_height << 8)) {
-        if((current_view_mode == VIEWMODE_1_1)&&(in_height<=output_height)){
-            l = (output_width - in_width)>>1;
-            t = (output_height - in_height)>>1;
-        }else{
-            w = (output_height << 8) / ar;
-            l = (output_width - w) / 2;
-        }
-    } else {
-        if((current_view_mode == VIEWMODE_1_1)&&(in_width<=output_width)){
-            l = (output_width - in_width)>>1;
-            t = (output_height - in_height)>>1;
-        }else{
-            h = (output_width * ar) >> 8;
-            t = (output_height - h) / 2;
-        }
-    }
-    l &= ~1;
-    t &= ~1;
-    w =  output_width - 2*l;
-    h  =  output_height - 2*t;
-    *top = t;
-    *left = l;
-    *width = w;
-    *height = h;
-    return 0;
-}
-
-/*******************************************************************/
-
-/*for decoder input processing
-    1. output window should 1:1 as source frame size
-    2. keep the frame ratio
-    3. input format should be YUV420 , output format should be YUV444
-*/
-static void process_none(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-	
-}
-
-//static int ratio_value = 10; // 0~255
-// for 90 degree and 270 degree, use interlace mode to output mix data.
-void process_2d_to_3d_ex(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config,unsigned angle)
-{
-    vframe_t *new_vf;
-    ppframe_t *pp_vf;
-    display_frame_t input_frame;
-    canvas_t cs0,cs1,cs2,cd;
-    int t,l,w,h;
-    int canvas_width = ppmgr_device.canvas_width;
-    int canvas_height = ppmgr_device.canvas_height;
-    unsigned char switch_flag = _3d_process.switch_flag;
-    int x_offset = 0, dir = 0;
-    unsigned scale_down = get_ppmgr_scaledown()+1;
-    int pic_struct = 0;
-
-    new_vf = vfq_pop(&q_free);
-    if(_3d_process._2d_3d_control == PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_LEFT_MOVE){
-        x_offset = _3d_process._2d_3d_control_value;
-    }else if(_3d_process._2d_3d_control == PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_RIGHT_MOVE){
-        x_offset = _3d_process._2d_3d_control_value;
-        dir = 1;
-    }else{
-        x_offset = 0;
-    }
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;
-
-    //int interlace_mode = vf->type & VIDTYPE_TYPEMASK;
-
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    new_vf->ratio_control = ((scale_down>1)?DISP_RATIO_FORCE_FULL_STRETCH:DISP_RATIO_FORCE_NORMALWIDE)|DISP_RATIO_FORCECONFIG;
-    new_vf->duration = vf->duration;
-    new_vf->duration_pulldown = vf->duration_pulldown;
-    new_vf->pts = vf->pts;
-    if(ppmgr_device.disp_width>ppmgr_device.disp_height)
-        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;        
-    else
-        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE;
-    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(pp_vf->index);
-
-    get_input_frame(vf,&input_frame);
-
-    new_vf->width= ppmgr_device.disp_width;
-    new_vf->height= ppmgr_device.disp_height;
-    
-    if(ppmgr_3d_clear_count>0){
-        //clear rect
-        memset(ge2d_config,0,sizeof(config_para_ex_t));
-        ge2d_config->alu_const_color= 0;//0x000000ff;
-        ge2d_config->bitmask_en  = 0;
-        ge2d_config->src1_gb_alpha = 0;//0xff;
-        ge2d_config->dst_xy_swap = 0;
-    
-        canvas_read(new_vf->canvas0Addr&0xff,&cd);
-        ge2d_config->src_planes[0].addr = cd.addr;
-        ge2d_config->src_planes[0].w = cd.width;
-        ge2d_config->src_planes[0].h = cd.height;
-        ge2d_config->dst_planes[0].addr = cd.addr;
-        ge2d_config->dst_planes[0].w = cd.width;
-        ge2d_config->dst_planes[0].h = cd.height;
-
-        ge2d_config->src_key.key_enable = 0;
-        ge2d_config->src_key.key_mask = 0;
-        ge2d_config->src_key.key_mode = 0;
-
-        ge2d_config->src_para.canvas_index=new_vf->canvas0Addr;
-        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->src_para.fill_color_en = 0;
-        ge2d_config->src_para.fill_mode = 0;
-        ge2d_config->src_para.x_rev = 0;
-        ge2d_config->src_para.y_rev = 0;
-        ge2d_config->src_para.color = 0;
-        ge2d_config->src_para.top = 0;
-        ge2d_config->src_para.left = 0;
-        ge2d_config->src_para.width = canvas_width;
-        ge2d_config->src_para.height = canvas_height;
-
-        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-
-        ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->dst_para.fill_color_en = 0;
-        ge2d_config->dst_para.fill_mode = 0;
-        ge2d_config->dst_para.x_rev = 0;
-        ge2d_config->dst_para.y_rev = 0;
-        ge2d_config->dst_para.color = 0;
-        ge2d_config->dst_para.top = 0;
-        ge2d_config->dst_para.left = 0;
-        ge2d_config->dst_para.width = canvas_width;
-        ge2d_config->dst_para.height = canvas_height;
-        
-        if(ge2d_context_config_ex(context,ge2d_config)<0) {
-            printk("++ge2d configing error.\n");
-            ppmgr_vf_put_dec(vf);
-            vfq_push(&q_free, new_vf);
-            return;
-        }
-        fillrect(context, 0, 0, canvas_width, canvas_height, 0x008080ff);
-        ppmgr_3d_clear_count--;        
-    }
-
-    if(vf->type & VIDTYPE_MVC){
-        pic_struct = (GE2D_FORMAT_M24_YUV420T & (3<<3));
-    }else{
-        pic_struct = 0;
-    }
-    /* data operating. */
-    memset(ge2d_config,0,sizeof(config_para_ex_t));
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_key.key_color = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    if(is_vertical_sample_enable(vf)){
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = vf->height/2;
-    }else{
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
-    }
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444|(switch_flag?(GE2D_FORMAT_M24_YUV420B & (3<<3)):(GE2D_FORMAT_M24_YUV420T & (3<<3)));
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = canvas_width;
-    ge2d_config->dst_para.height = canvas_height>>1;
-
-    if(angle==1){
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.x_rev = 1;
-    }else if(angle==2){
-        ge2d_config->dst_para.x_rev = 1;
-        ge2d_config->dst_para.y_rev=1;        
-    }else if(angle==3)  {
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.y_rev=1;
-    }
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
-
-    //printk("--first frame ex: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
-    //      input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height,
-    //      l,t,w,h,new_vf->width,new_vf->height);
-   
-    if(scale_down>1){
-        if(angle&1){
-            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
-            w = w/scale_down;
-        }else{
-            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
-            h = h/scale_down;
-        }
-    }
-
-    if(is_vertical_sample_enable(vf)){
-       stretchblt_noalpha(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height/2,
-           l,t/2,w,h/2);
-    }else{
-       stretchblt_noalpha(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,(pic_struct)?(input_frame.content_height/2):input_frame.content_height,
-           l,t/2,w,h/2);
-    }
-
-    /* data operating. */
-    memset(ge2d_config,0,sizeof(config_para_ex_t));
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_key.key_color = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    if(is_vertical_sample_enable(vf)){
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = vf->height/2;
-    }else{
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
-    }
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444|(switch_flag?(GE2D_FORMAT_M24_YUV420T & (3<<3)):(GE2D_FORMAT_M24_YUV420B & (3<<3)));
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = canvas_width;
-    ge2d_config->dst_para.height = canvas_height>>1;
-
-    if(angle==1){
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.x_rev = 1;
-    }else if(angle==2){
-        ge2d_config->dst_para.x_rev = 1;
-        ge2d_config->dst_para.y_rev=1;        
-    }else if(angle==3)  {
-
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.y_rev=1;
-    }
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
-
-    if(x_offset){     
-        if(angle&1){
-            int dst_h = 0;
-            if(dir){  //move down
-                if((t+x_offset+h)<=new_vf->height){ //only pan
-                    if(angle == 3){
-                        t = t - x_offset;
-                        t &= ~1;    
-                    }else{
-                        t = t + x_offset;
-                        t &= ~1;  
-                    }       
-                }else if((t+x_offset)<new_vf->height){  //need cut 
-                    t = t + x_offset;
-                    t &= ~1;
-                    dst_h = new_vf->height - t;
-                    input_frame.content_width = ((((input_frame.content_width*dst_h) <<8)+0x80)/h)>>8;
-                    h = dst_h;
-                    if(angle == 3){
-                        t = 0;
-                    }
-                }else{
-                    printk("++2d->3d error, out of range1.\n");
-                }
-            }else{//move up
-                if(t>=x_offset){ //only pan
-                    if(angle == 3){
-                        t = t + x_offset;
-                        t &= ~1;    
-                    }else{
-                        t = t - x_offset;
-                        t &= ~1;  
-                    }        
-                }else if((t+h)>x_offset){  //need cut 
-                    int src_w = 0, src_l = 0;
-                    t = 0;
-                    dst_h = h + t - x_offset;
-                    src_w = ((((input_frame.content_width*dst_h) <<8)+0x80)/h)>>8;
-                    h = dst_h;
-                    src_l = input_frame.content_left + input_frame.content_width - src_w;
-                    src_l &= ~1;
-                    input_frame.content_width = input_frame.content_width + input_frame.content_left - src_l;
-                    input_frame.content_left = src_l;
-                    if(angle == 3){
-                        t = t + x_offset;
-                    }
-                }else{
-                    printk("++2d->3d error, out of range2.\n");
-                }
-            }
-        }else{
-            int dst_w = 0;
-            if(dir){  //move right
-                if((l+x_offset+w)<=new_vf->width){ //only pan
-                    if((angle == 1)||(angle == 2)){
-                        l = l - x_offset;
-                        l &= ~1;    
-                    }else{
-                        l = l + x_offset;
-                        l &= ~1;  
-                    }       
-                }else if((l+x_offset)<new_vf->width){  //need cut 
-                    l = l + x_offset;
-                    l &= ~1;
-                    dst_w = new_vf->width - l;
-                    input_frame.content_width = ((((input_frame.content_width*dst_w) <<8)+0x80)/w)>>8;
-                    w = dst_w;
-                    if((angle == 1)||(angle == 2)){
-                        l = 0;
-                    }
-                }else{
-                    printk("++2d->3d error, out of range1.\n");
-                }
-            }else{//move left
-                if(l>=x_offset){ //only pan
-                    if((angle == 1)||(angle == 2)){
-                        l = l + x_offset;
-                        l &= ~1;    
-                    }else{
-                        l = l - x_offset;
-                        l &= ~1;  
-                    }        
-                }else if((l+w)>x_offset){  //need cut 
-                    int src_w = 0, src_l = 0;
-                    l = 0;
-                    dst_w = w + l - x_offset;
-                    src_w = ((((input_frame.content_width*dst_w) <<8)+0x80)/w)>>8;
-                    w = dst_w;
-                    src_l = input_frame.content_left + input_frame.content_width - src_w;
-                    src_l &= ~1;
-                    input_frame.content_width = input_frame.content_width + input_frame.content_left - src_l;
-                    input_frame.content_left = src_l;
-                    if((angle == 1)||(angle == 2)){
-                        l = l + x_offset;
-                    }
-                }else{
-                    printk("++2d->3d error, out of range2.\n");
-                }
-            }
-        }
-    }
-
-    if(scale_down>1){
-        if(angle&1){
-            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
-            w = w/scale_down;
-            new_vf->width = new_vf->width/scale_down;
-        }else{
-            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
-            h = h/scale_down;
-            new_vf->height = new_vf->height/scale_down;
-        }
-    }
-
-    if(is_vertical_sample_enable(vf)){
-       stretchblt_noalpha(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height/2,
-           l,t/2,w,h/2);
-    }else{
-       stretchblt_noalpha(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,(pic_struct)?(input_frame.content_height/2):input_frame.content_height,
-           l,t/2,w,h/2);
-    }
-
-    //printk("--second frame ex: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
-    //      input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height,
-    //      l,t,w,h,new_vf->width,new_vf->height);
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-}
-
-static void process_2d_to_3d(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config,unsigned angle)
-{
-    vframe_t *new_vf;
-    ppframe_t *pp_vf;
-    display_frame_t input_frame;
-    canvas_t cs0,cs1,cs2,cd,cm;
-    int t,l,w,h;
-    unsigned char switch_flag = _3d_process.switch_flag;
-    int x_offset = 0, dir = 0;
-    int canvas_width = ppmgr_device.canvas_width;
-    int canvas_height = ppmgr_device.canvas_height;
-    int scale_down = get_ppmgr_scaledown()+1;
-    int pic_struct = 0;
-
-    new_vf = vfq_pop(&q_free);
-    if(_3d_process._2d_3d_control == PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_LEFT_MOVE){
-        x_offset = _3d_process._2d_3d_control_value;
-    }else if(_3d_process._2d_3d_control == PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_RIGHT_MOVE){
-        x_offset = _3d_process._2d_3d_control_value;
-        dir = 1;
-    }else{
-        x_offset = 0;
-    }
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;
-
-    //int interlace_mode = vf->type & VIDTYPE_TYPEMASK;
-
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    new_vf->ratio_control = ((scale_down>1)?DISP_RATIO_FORCE_FULL_STRETCH:DISP_RATIO_FORCE_NORMALWIDE)|DISP_RATIO_FORCECONFIG;
-    new_vf->duration = vf->duration;
-    new_vf->duration_pulldown = vf->duration_pulldown;
-    new_vf->pts = vf->pts;
-    if(ppmgr_device.disp_width>ppmgr_device.disp_height)
-        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;        
-    else
-        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE;       
-    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(pp_vf->index);
-
-    get_input_frame(vf,&input_frame);
-
-    new_vf->width= ppmgr_device.disp_width;
-    new_vf->height= ppmgr_device.disp_height;
-
-    if(ppmgr_3d_clear_count>0){
-        //clear rect
-        memset(ge2d_config,0,sizeof(config_para_ex_t));
-        ge2d_config->alu_const_color= 0;//0x000000ff;
-        ge2d_config->bitmask_en  = 0;
-        ge2d_config->src1_gb_alpha = 0;//0xff;
-        ge2d_config->dst_xy_swap = 0;
-    
-        canvas_read(new_vf->canvas0Addr&0xff,&cd);
-        ge2d_config->src_planes[0].addr = cd.addr;
-        ge2d_config->src_planes[0].w = cd.width;
-        ge2d_config->src_planes[0].h = cd.height;
-        ge2d_config->dst_planes[0].addr = cd.addr;
-        ge2d_config->dst_planes[0].w = cd.width;
-        ge2d_config->dst_planes[0].h = cd.height;
-
-        ge2d_config->src_key.key_enable = 0;
-        ge2d_config->src_key.key_mask = 0;
-        ge2d_config->src_key.key_mode = 0;
-
-        ge2d_config->src_para.canvas_index=new_vf->canvas0Addr;
-        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->src_para.fill_color_en = 0;
-        ge2d_config->src_para.fill_mode = 0;
-        ge2d_config->src_para.x_rev = 0;
-        ge2d_config->src_para.y_rev = 0;
-        ge2d_config->src_para.color = 0;
-        ge2d_config->src_para.top = 0;
-        ge2d_config->src_para.left = 0;
-        ge2d_config->src_para.width = canvas_width;
-        ge2d_config->src_para.height = canvas_height;
-
-        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-
-        ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->dst_para.fill_color_en = 0;
-        ge2d_config->dst_para.fill_mode = 0;
-        ge2d_config->dst_para.x_rev = 0;
-        ge2d_config->dst_para.y_rev = 0;
-        ge2d_config->dst_para.color = 0;
-        ge2d_config->dst_para.top = 0;
-        ge2d_config->dst_para.left = 0;
-        ge2d_config->dst_para.width = canvas_width;
-        ge2d_config->dst_para.height = canvas_height;
-        
-        if(ge2d_context_config_ex(context,ge2d_config)<0) {
-            printk("++ge2d configing error.\n");
-            ppmgr_vf_put_dec(vf);
-            vfq_push(&q_free, new_vf);
-            return;
-        }
-        fillrect(context, 0, 0, canvas_width, canvas_height, 0x008080ff);
-        ppmgr_3d_clear_count--;        
-    }
-
-    if(vf->type & VIDTYPE_MVC){
-        pic_struct = (GE2D_FORMAT_M24_YUV420T & (3<<3));
-    }else{
-        pic_struct = 0;
-    }
-    /* data operating. */
-    memset(ge2d_config,0,sizeof(config_para_ex_t));
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-
-    canvas_read(mask_canvas_index,&cm);
-    ge2d_config->src2_planes[0].addr = cm.addr;
-    ge2d_config->src2_planes[0].w = cm.width;
-    ge2d_config->src2_planes[0].h = cm.height;
-
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_key.key_color = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    if(is_vertical_sample_enable(vf)){
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = vf->height/2;
-    }else{
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
-    }
-
-    ge2d_config->src2_key.key_enable = 1;
-    ge2d_config->src2_key.key_mask = 0x00ffffff;
-    ge2d_config->src2_key.key_mode = (switch_flag)?1:0;
-    ge2d_config->src2_key.key_color = 0xff000000;
-    ge2d_config->src2_para.canvas_index=mask_canvas_index;
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src2_para.format = GE2D_FORMAT_S8_Y;
-    ge2d_config->src2_para.fill_color_en = 0;
-    ge2d_config->src2_para.fill_mode = 0;
-    ge2d_config->src2_para.x_rev = 0;
-    ge2d_config->src2_para.y_rev = 0;
-    ge2d_config->src2_para.color = 0x00808000;
-    ge2d_config->src2_para.top = 0;
-    ge2d_config->src2_para.left = 0;
-    ge2d_config->src2_para.width = canvas_width;
-    ge2d_config->src2_para.height = canvas_height;
-
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = canvas_width;
-    ge2d_config->dst_para.height = canvas_height;
-
-    if(angle==1){
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.x_rev = 1;
-    }else if(angle==2){
-        ge2d_config->dst_para.x_rev = 1;
-        ge2d_config->dst_para.y_rev=1;        
-    }else if(angle==3)  {
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.y_rev=1;
-    }
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
-
-    //printk("--first frame: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
-    //      input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height,
-    //      l,t,w,h,new_vf->width,new_vf->height);
-    if(scale_down>1){
-        if(angle&1){
-            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
-            w = w/scale_down;
-        }else{
-            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
-            h = h/scale_down;
-        }
-    }
-
-    if(is_vertical_sample_enable(vf)){
-       blend(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height/2,
-           l,t,w,h,l,t,w,h,
-           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
-    }else{
-       blend(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,(pic_struct)?(input_frame.content_height/2):input_frame.content_height,
-           l,t,w,h,l,t,w,h,
-           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
-    }
-
-    /* data operating. */
-    memset(ge2d_config,0,sizeof(config_para_ex_t));
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-
-    canvas_read(mask_canvas_index,&cm);
-    ge2d_config->src2_planes[0].addr = cm.addr;
-    ge2d_config->src2_planes[0].w = cm.width;
-    ge2d_config->src2_planes[0].h = cm.height;
-
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_key.key_color = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    if(is_vertical_sample_enable(vf)){
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = vf->height/2;
-    }else{
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
-    }
-
-    ge2d_config->src2_key.key_enable = 1;
-    ge2d_config->src2_key.key_mask = 0x00ffffff;
-    ge2d_config->src2_key.key_mode = (switch_flag)?0:1;
-    ge2d_config->src2_key.key_color = 0xff000000;
-    ge2d_config->src2_para.canvas_index=mask_canvas_index;
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src2_para.format = GE2D_FORMAT_S8_Y;
-    ge2d_config->src2_para.fill_color_en = 0;
-    ge2d_config->src2_para.fill_mode = 0;
-    ge2d_config->src2_para.x_rev = 0;
-    ge2d_config->src2_para.y_rev = 0;
-    ge2d_config->src2_para.color = 0x00808000;
-    ge2d_config->src2_para.top = 0;
-    ge2d_config->src2_para.left = 0;
-    ge2d_config->src2_para.width = canvas_width;
-    ge2d_config->src2_para.height = canvas_height;
-
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = canvas_width;
-    ge2d_config->dst_para.height = canvas_height;
-
-    if(angle==1){
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.x_rev = 1;
-    }else if(angle==2){
-        ge2d_config->dst_para.x_rev = 1;
-        ge2d_config->dst_para.y_rev=1;        
-    }else if(angle==3)  {
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.y_rev=1;
-    }
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
-
-    if(x_offset){     
-        if(angle&1){
-            int dst_h = 0;
-            if(dir){  //move down
-                if((t+x_offset+h)<=new_vf->height){ //only pan
-                    if(angle == 3){
-                        t = t - x_offset;
-                        t &= ~1;    
-                    }else{
-                        t = t + x_offset;
-                        t &= ~1;  
-                    }       
-                }else if((t+x_offset)<new_vf->height){  //need cut 
-                    t = t + x_offset;
-                    t &= ~1;
-                    dst_h = new_vf->height - t;
-                    input_frame.content_width = ((((input_frame.content_width*dst_h) <<8)+0x80)/h)>>8;
-                    h = dst_h;
-                    if(angle == 3){
-                        t = 0;
-                    }
-                }else{
-                    printk("++2d->3d error, out of range1.\n");
-                }
-            }else{//move up
-                if(t>=x_offset){ //only pan
-                    if(angle == 3){
-                        t = t + x_offset;
-                        t &= ~1;    
-                    }else{
-                        t = t - x_offset;
-                        t &= ~1;  
-                    }        
-                }else if((t+h)>x_offset){  //need cut 
-                    int src_w = 0, src_l = 0;
-                    t = 0;
-                    dst_h = h + t - x_offset;
-                    src_w = ((((input_frame.content_width*dst_h) <<8)+0x80)/h)>>8;
-                    h = dst_h;
-                    src_l = input_frame.content_left + input_frame.content_width - src_w;
-                    src_l &= ~1;
-                    input_frame.content_width = input_frame.content_width + input_frame.content_left - src_l;
-                    input_frame.content_left = src_l;
-                    if(angle == 3){
-                        t = t + x_offset;
-                    }
-                }else{
-                    printk("++2d->3d error, out of range2.\n");
-                }
-            }
-        }else{
-            int dst_w = 0;
-            if(dir){  //move right
-                if((l+x_offset+w)<=new_vf->width){ //only pan
-                    if(angle == 2){
-                        l = l - x_offset;
-                        l &= ~1;    
-                    }else{
-                        l = l + x_offset;
-                        l &= ~1;  
-                    }       
-                }else if((l+x_offset)<new_vf->width){  //need cut 
-                    l = l + x_offset;
-                    l &= ~1;
-                    dst_w = new_vf->width - l;
-                    input_frame.content_width = ((((input_frame.content_width*dst_w) <<8)+0x80)/w)>>8;
-                    w = dst_w;
-                    if(angle == 2){
-                        l = 0;
-                    }
-                }else{
-                    printk("++2d->3d error, out of range1.\n");
-                }
-            }else{//move left
-                if(l>=x_offset){ //only pan
-                    if(angle == 2){
-                        l = l + x_offset;
-                        l &= ~1;    
-                    }else{
-                        l = l - x_offset;
-                        l &= ~1;  
-                    }        
-                }else if((l+w)>x_offset){  //need cut 
-                    int src_w = 0, src_l = 0;
-                    l = 0;
-                    dst_w = w + l - x_offset;
-                    src_w = ((((input_frame.content_width*dst_w) <<8)+0x80)/w)>>8;
-                    w = dst_w;
-                    src_l = input_frame.content_left + input_frame.content_width - src_w;
-                    src_l &= ~1;
-                    input_frame.content_width = input_frame.content_width + input_frame.content_left - src_l;
-                    input_frame.content_left = src_l;
-                    if(angle == 2){
-                        l = l + x_offset;
-                    }
-                }else{
-                    printk("++2d->3d error, out of range2.\n");
-                }
-            }
-        }
-    }
-
-    if(scale_down>1){
-        if(angle&1){
-            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
-            w = w/scale_down;
-            new_vf->width = new_vf->width/scale_down;
-        }else{
-            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
-            h = h/scale_down;
-            new_vf->height = new_vf->height/scale_down;
-        }
-    }
-
-    if(is_vertical_sample_enable(vf)){
-       blend(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height/2,
-           l,t,w,h,l,t,w,h,
-           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
-    }else{
-       blend(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,(pic_struct)?(input_frame.content_height/2):input_frame.content_height,
-           l,t,w,h,l,t,w,h,
-           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
-    }
-
-    //printk("--second frame: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
-    //      input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height,
-    //      l,t,w,h,new_vf->width,new_vf->height);
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-}
-
-/*for 3D video input processing
-    1. output window should 1:1 as video layer size
-    2. must adjust GE2D operation according with the frame ratio ,then clear ratio control flag
-    3. need generate two buffer from source frame
-    4. input format should be YUV422 , output format should be YUV444
-*/
-
-// for 90 degree and 270 degree, use interlace mode to output mix data.
-void process_3d_ex(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config,unsigned angle)
-{
-    vframe_t *new_vf;
-    ppframe_t *pp_vf;
-    display_frame_t l_frame,r_frame;
-    canvas_t cs0,cs1,cs2,cd;
-    int t,l,w,h;
-    unsigned char switch_flag = _3d_process.switch_flag;
-    int canvas_width = ppmgr_device.canvas_width;
-    int canvas_height = ppmgr_device.canvas_height;
-    int scale_down = get_ppmgr_scaledown()+1;    
-    int pic_struct = 0;
-	
-    new_vf = vfq_pop(&q_free);
-    if (unlikely((!new_vf) || (!vf)))
-        return;
-
-    //int interlace_mode = vf->type & VIDTYPE_TYPEMASK;
-
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    new_vf->ratio_control = ((scale_down>1)?DISP_RATIO_FORCE_FULL_STRETCH:DISP_RATIO_FORCE_NORMALWIDE)|DISP_RATIO_FORCECONFIG;
-    new_vf->duration = vf->duration;
-    new_vf->duration_pulldown = vf->duration_pulldown;
-    new_vf->pts = vf->pts;
-    if(ppmgr_device.disp_width>ppmgr_device.disp_height)
-        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;        
-    else
-        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE;
-    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(pp_vf->index);
-
-    //get_input_frame(vf,&input_frame);
-    get_input_l_frame(vf,&l_frame);
-    get_input_r_frame(vf,&r_frame);
-
-    new_vf->width= ppmgr_device.disp_width;
-    new_vf->height= ppmgr_device.disp_height;
-    
-    if(ppmgr_3d_clear_count>0){
-        //clear rect
-        memset(ge2d_config,0,sizeof(config_para_ex_t));
-        ge2d_config->alu_const_color= 0;//0x000000ff;
-        ge2d_config->bitmask_en  = 0;
-        ge2d_config->src1_gb_alpha = 0;//0xff;
-        ge2d_config->dst_xy_swap = 0;
-    
-        canvas_read(new_vf->canvas0Addr&0xff,&cd);
-        ge2d_config->src_planes[0].addr = cd.addr;
-        ge2d_config->src_planes[0].w = cd.width;
-        ge2d_config->src_planes[0].h = cd.height;
-        ge2d_config->dst_planes[0].addr = cd.addr;
-        ge2d_config->dst_planes[0].w = cd.width;
-        ge2d_config->dst_planes[0].h = cd.height;
-
-        ge2d_config->src_key.key_enable = 0;
-        ge2d_config->src_key.key_mask = 0;
-        ge2d_config->src_key.key_mode = 0;
-
-        ge2d_config->src_para.canvas_index=new_vf->canvas0Addr;
-        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->src_para.fill_color_en = 0;
-        ge2d_config->src_para.fill_mode = 0;
-        ge2d_config->src_para.x_rev = 0;
-        ge2d_config->src_para.y_rev = 0;
-        ge2d_config->src_para.color = 0;
-        ge2d_config->src_para.top = 0;
-        ge2d_config->src_para.left = 0;
-        ge2d_config->src_para.width = canvas_width;
-        ge2d_config->src_para.height = canvas_height;
-
-        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-
-        ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->dst_para.fill_color_en = 0;
-        ge2d_config->dst_para.fill_mode = 0;
-        ge2d_config->dst_para.x_rev = 0;
-        ge2d_config->dst_para.y_rev = 0;
-        ge2d_config->dst_para.color = 0;
-        ge2d_config->dst_para.top = 0;
-        ge2d_config->dst_para.left = 0;
-        ge2d_config->dst_para.width = canvas_width;
-        ge2d_config->dst_para.height = canvas_height;
-        
-        if(ge2d_context_config_ex(context,ge2d_config)<0) {
-            printk("++ge2d configing error.\n");
-            ppmgr_vf_put_dec(vf);
-            vfq_push(&q_free, new_vf);
-            return;
-        }
-        fillrect(context, 0, 0, canvas_width, canvas_height, 0x008080ff);
-        ppmgr_3d_clear_count--;
-    }
-
-    if(vf->type & VIDTYPE_MVC){
-        pic_struct = (GE2D_FORMAT_M24_YUV420T & (3<<3));
-    }else{
-        pic_struct = 0;
-    }
-    /* data operating. */
-    memset(ge2d_config,0,sizeof(config_para_ex_t));
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_key.key_color = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    if(is_vertical_sample_enable(vf)){
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = vf->height/2;
-    }else{
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
-    }
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444|(switch_flag?(GE2D_FORMAT_M24_YUV420B & (3<<3)):(GE2D_FORMAT_M24_YUV420T & (3<<3)));
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = canvas_width;
-    ge2d_config->dst_para.height = canvas_height>>1;
-
-    if(angle==1){
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.x_rev = 1;
-    }else if(angle==2){
-
-        ge2d_config->dst_para.x_rev = 1;
-        ge2d_config->dst_para.y_rev=1;        
-    }else if(angle==3)  {
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.y_rev=1;
-    }
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
-
-    if(scale_down>1){
-        if(angle&1){
-            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
-            w = w/scale_down;
-        }else{
-            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
-            h = h/scale_down;
-        }
-    }
-
-    //printk("--l frame ex: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
-    //      l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height,
-    //      l,t,w,h,new_vf->width,new_vf->height);
-
-    if(is_vertical_sample_enable(vf)){
-       stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height/2,
-           l,t/2,w,h/2);
-    }else{
-       stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,(pic_struct)?(l_frame.content_height/2):l_frame.content_height,
-           l,t/2,w,h/2);
-    }
-
-    if(vf->type & VIDTYPE_MVC){
-        pic_struct = (GE2D_FORMAT_M24_YUV420B & (3<<3));
-    }else{
-        pic_struct = 0;
-    }
-    /* data operating. */
-    memset(ge2d_config,0,sizeof(config_para_ex_t));
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas1Addr&0xff,&cs0);
-    canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_key.key_color = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas1Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    if(is_vertical_sample_enable(vf)){
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = vf->height/2;
-    }else{
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
-    }
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444|(switch_flag?(GE2D_FORMAT_M24_YUV420T & (3<<3)):(GE2D_FORMAT_M24_YUV420B & (3<<3)));
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = canvas_width;
-    ge2d_config->dst_para.height = canvas_height>>1;
-
-    if(angle==1){
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.x_rev = 1;
-    }else if(angle==2){
-        ge2d_config->dst_para.x_rev = 1;
-        ge2d_config->dst_para.y_rev=1;        
-    }else if(angle==3)  {
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.y_rev=1;
-    }
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
-
-    if(scale_down>1){
-        if(angle&1){
-            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
-            w = w/scale_down;
-            new_vf->width = new_vf->width/scale_down;
-        }else{
-            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
-            h = h/scale_down;
-            new_vf->height = new_vf->height/scale_down;
-        }
-    }
-
-    //printk("--r frame ex: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
-    //      r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height,
-    //      l,t,w,h,new_vf->width,new_vf->height);
-
-    if(is_vertical_sample_enable(vf)){
-       stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height/2,
-           l,t/2,w,h/2);
-    }else{
-       stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,(pic_struct)?(r_frame.content_height/2):r_frame.content_height,
-           l,t/2,w,h/2);
-    }
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-}
-
-void process_3d(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config,unsigned angle)
-{
-    vframe_t *new_vf;
-    ppframe_t *pp_vf;
-    display_frame_t l_frame,r_frame;
-    canvas_t cs0,cs1,cs2,cd,cm;
-    int t,l,w,h;
-    unsigned char  switch_flag = _3d_process.switch_flag;
-    int canvas_width = ppmgr_device.canvas_width;
-    int canvas_height = ppmgr_device.canvas_height;
-    int scale_down = get_ppmgr_scaledown()+1;    
-    int pic_struct = 0;
-
-    new_vf = vfq_pop(&q_free);
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;
-
-    //int interlace_mode = vf->type & VIDTYPE_TYPEMASK;
-
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    new_vf->ratio_control = ((scale_down>1)?DISP_RATIO_FORCE_FULL_STRETCH:DISP_RATIO_FORCE_NORMALWIDE)|DISP_RATIO_FORCECONFIG;
-    new_vf->duration = vf->duration;
-    new_vf->duration_pulldown = vf->duration_pulldown;
-    new_vf->pts = vf->pts;
-    if(ppmgr_device.disp_width>ppmgr_device.disp_height)
-        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;        
-    else
-        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE;
-    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(pp_vf->index);
-
-    //get_input_frame(vf,&input_frame);
-    get_input_l_frame(vf,&l_frame);
-    get_input_r_frame(vf,&r_frame);
-
-    new_vf->width= ppmgr_device.disp_width;
-    new_vf->height= ppmgr_device.disp_height;
-
-    if(ppmgr_3d_clear_count>0){
-        //clear rect
-        memset(ge2d_config,0,sizeof(config_para_ex_t));
-        ge2d_config->alu_const_color= 0;//0x000000ff;
-        ge2d_config->bitmask_en  = 0;
-        ge2d_config->src1_gb_alpha = 0;//0xff;
-        ge2d_config->dst_xy_swap = 0;
-    
-        canvas_read(new_vf->canvas0Addr&0xff,&cd);
-        ge2d_config->src_planes[0].addr = cd.addr;
-        ge2d_config->src_planes[0].w = cd.width;
-        ge2d_config->src_planes[0].h = cd.height;
-        ge2d_config->dst_planes[0].addr = cd.addr;
-        ge2d_config->dst_planes[0].w = cd.width;
-        ge2d_config->dst_planes[0].h = cd.height;
-
-        ge2d_config->src_key.key_enable = 0;
-        ge2d_config->src_key.key_mask = 0;
-        ge2d_config->src_key.key_mode = 0;
-
-        ge2d_config->src_para.canvas_index=new_vf->canvas0Addr;
-        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->src_para.fill_color_en = 0;
-        ge2d_config->src_para.fill_mode = 0;
-        ge2d_config->src_para.x_rev = 0;
-        ge2d_config->src_para.y_rev = 0;
-        ge2d_config->src_para.color = 0;
-        ge2d_config->src_para.top = 0;
-        ge2d_config->src_para.left = 0;
-        ge2d_config->src_para.width = canvas_width;
-        ge2d_config->src_para.height = canvas_height;
-
-        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-
-        ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->dst_para.fill_color_en = 0;
-        ge2d_config->dst_para.fill_mode = 0;
-        ge2d_config->dst_para.x_rev = 0;
-        ge2d_config->dst_para.y_rev = 0;
-        ge2d_config->dst_para.color = 0;
-        ge2d_config->dst_para.top = 0;
-        ge2d_config->dst_para.left = 0;
-        ge2d_config->dst_para.width = canvas_width;
-        ge2d_config->dst_para.height = canvas_height;
-        
-        if(ge2d_context_config_ex(context,ge2d_config)<0) {
-            printk("++ge2d configing error.\n");
-            ppmgr_vf_put_dec(vf);
-            vfq_push(&q_free, new_vf);
-            return;
-        }
-        fillrect(context, 0, 0, canvas_width, canvas_height, 0x008080ff);
-        ppmgr_3d_clear_count--;
-    }
-
-    /* data operating. */
-    if(vf->type & VIDTYPE_MVC){
-        pic_struct = (GE2D_FORMAT_M24_YUV420T & (3<<3));
-    }else{
-        pic_struct = 0;
-    }
-
-    memset(ge2d_config,0,sizeof(config_para_ex_t));
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-
-    canvas_read(mask_canvas_index,&cm);
-    ge2d_config->src2_planes[0].addr = cm.addr;
-    ge2d_config->src2_planes[0].w = cm.width;
-    ge2d_config->src2_planes[0].h = cm.height;
-
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_key.key_color = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    if(is_vertical_sample_enable(vf)){
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = vf->height/2;
-    }else{
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
-    }
-
-    ge2d_config->src2_key.key_enable = 1;
-    ge2d_config->src2_key.key_mask = 0x00ffffff;
-    ge2d_config->src2_key.key_mode = (switch_flag)?1:0;
-    ge2d_config->src2_key.key_color = 0xff000000;
-    ge2d_config->src2_para.canvas_index=mask_canvas_index;
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src2_para.format = GE2D_FORMAT_S8_Y;
-    ge2d_config->src2_para.fill_color_en = 0;
-    ge2d_config->src2_para.fill_mode = 0;
-    ge2d_config->src2_para.x_rev = 0;
-    ge2d_config->src2_para.y_rev = 0;
-    ge2d_config->src2_para.color = 0x00808000;
-    ge2d_config->src2_para.top = 0;
-    ge2d_config->src2_para.left = 0;
-    ge2d_config->src2_para.width = canvas_width;
-    ge2d_config->src2_para.height = canvas_height;
-
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = canvas_width;
-    ge2d_config->dst_para.height = canvas_height;
-
-    if(angle==1){
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.x_rev = 1;
-    }else if(angle==2){
-        ge2d_config->dst_para.x_rev = 1;
-        ge2d_config->dst_para.y_rev=1;        
-    }else if(angle==3)  {
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.y_rev=1;
-    }
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
-
-    if(scale_down>1){
-        if(angle&1){
-            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
-            w = w/scale_down;
-        }else{
-            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
-            h = h/scale_down;
-        }
-    }
-
-    //printk("--l frame: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
-    //      l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height,
-    //      l,t,w,h,new_vf->width,new_vf->height);
-
-    if(is_vertical_sample_enable(vf)){
-       blend(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height/2,
-           l,t,w,h,l,t,w,h,
-           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
-    }else{
-       blend(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,(pic_struct)?(l_frame.content_height/2):l_frame.content_height,
-           l,t,w,h,l,t,w,h,
-           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
-    }
-
-    if(vf->type & VIDTYPE_MVC){
-        pic_struct = (GE2D_FORMAT_M24_YUV420B & (3<<3));
-    }else{
-        pic_struct = 0;
-    }
-    /* data operating. */
-    memset(ge2d_config,0,sizeof(config_para_ex_t));
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas1Addr&0xff,&cs0);
-    canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-
-    canvas_read(mask_canvas_index,&cm);
-    ge2d_config->src2_planes[0].addr = cm.addr;
-    ge2d_config->src2_planes[0].w = cm.width;
-    ge2d_config->src2_planes[0].h = cm.height;
-
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_key.key_color = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas1Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    if(is_vertical_sample_enable(vf)){
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = vf->height/2;
-    }else{
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
-    }
-
-    ge2d_config->src2_key.key_enable = 1;
-    ge2d_config->src2_key.key_mask = 0x00ffffff;
-    ge2d_config->src2_key.key_mode = (switch_flag)?0:1;
-    ge2d_config->src2_key.key_color = 0xff000000;
-    ge2d_config->src2_para.canvas_index=mask_canvas_index;
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src2_para.format = GE2D_FORMAT_S8_Y;
-    ge2d_config->src2_para.fill_color_en = 0;
-    ge2d_config->src2_para.fill_mode = 0;
-    ge2d_config->src2_para.x_rev = 0;
-    ge2d_config->src2_para.y_rev = 0;
-    ge2d_config->src2_para.color = 0x00808000;
-    ge2d_config->src2_para.top = 0;
-    ge2d_config->src2_para.left = 0;
-    ge2d_config->src2_para.width = canvas_width;
-    ge2d_config->src2_para.height = canvas_height;
-
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = canvas_width;
-    ge2d_config->dst_para.height = canvas_height;
-
-    if(angle==1){
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.x_rev = 1;
-    }else if(angle==2){
-        ge2d_config->dst_para.x_rev = 1;
-        ge2d_config->dst_para.y_rev=1;        
-    }else if(angle==3)  {
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.y_rev=1;
-    }
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
-
-    if(scale_down>1){
-        if(angle&1){
-            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
-            w = w/scale_down;
-            new_vf->width = new_vf->width/scale_down;
-        }else{
-            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
-            h = h/scale_down;
-            new_vf->height = new_vf->height/scale_down;
-        }
-    }
-
-    //printk("--r frame: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
-    //      r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height,
-    //      l,t,w,h,new_vf->width,new_vf->height);
-
-    if(is_vertical_sample_enable(vf)){
-       blend(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height/2,
-           l,t,w,h,l,t,w,h,
-           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
-    }else{
-       blend(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,(pic_struct)?(r_frame.content_height/2):r_frame.content_height,
-           l,t,w,h,l,t,w,h,
-           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
-    }
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-}
-
-//void process_bt(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config,int swith_flag)
-//{
-//	
-//}
-
-static void process_field_depth(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-
-}
-
-void process_3d_to_2d(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-    vframe_t *new_vf;
-    ppframe_t *pp_vf;
-    //int index;
-    //display_frame_t input_frame ;
-    display_frame_t src_frame;
-    canvas_t cs0,cs1,cs2,cd;
-    int t,l,w,h;
-    unsigned char l_r = _3d_process._3d_to_2d_use_frame;
-    unsigned angle = get_ppmgr_direction3d();//_3d_process.direction;
-    int canvas_width = ppmgr_device.canvas_width;
-    int canvas_height = ppmgr_device.canvas_height;
-    int scale_down = get_ppmgr_scaledown()+1;   
-    int pic_struct = 0;
-
-    new_vf = vfq_pop(&q_free);
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;
-
-    //int interlace_mode = vf->type & VIDTYPE_TYPEMASK;
-
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    new_vf->ratio_control = ((scale_down>1)?DISP_RATIO_FORCE_FULL_STRETCH:DISP_RATIO_FORCE_NORMALWIDE)|DISP_RATIO_FORCECONFIG;
-    new_vf->duration = vf->duration;
-    new_vf->duration_pulldown = vf->duration_pulldown;
-    new_vf->pts = vf->pts;
-    //new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE;
-    new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;
-    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(pp_vf->index);
-
-    //get_input_frame(vf,&input_frame);
-    if(!l_r)
-        get_input_l_frame(vf,&src_frame);
-    else
-        get_input_r_frame(vf,&src_frame);
-
-    new_vf->width= ppmgr_device.disp_width;
-    new_vf->height= ppmgr_device.disp_height;
-
-    if(ppmgr_3d_clear_count>0){
-        //clear rect        
-        memset(ge2d_config,0,sizeof(config_para_ex_t));
-        ge2d_config->alu_const_color= 0;//0x000000ff;
-        ge2d_config->bitmask_en  = 0;
-        ge2d_config->src1_gb_alpha = 0;//0xff;
-        ge2d_config->dst_xy_swap = 0;
-    
-        canvas_read(new_vf->canvas0Addr&0xff,&cd);
-        ge2d_config->src_planes[0].addr = cd.addr;
-        ge2d_config->src_planes[0].w = cd.width;
-        ge2d_config->src_planes[0].h = cd.height;
-        ge2d_config->dst_planes[0].addr = cd.addr;
-        ge2d_config->dst_planes[0].w = cd.width;
-        ge2d_config->dst_planes[0].h = cd.height;
-
-        ge2d_config->src_key.key_enable = 0;
-        ge2d_config->src_key.key_mask = 0;
-        ge2d_config->src_key.key_mode = 0;
-
-        ge2d_config->src_para.canvas_index=new_vf->canvas0Addr;
-        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->src_para.fill_color_en = 0;
-        ge2d_config->src_para.fill_mode = 0;
-        ge2d_config->src_para.x_rev = 0;
-        ge2d_config->src_para.y_rev = 0;
-        ge2d_config->src_para.color = 0;
-        ge2d_config->src_para.top = 0;
-        ge2d_config->src_para.left = 0;
-        ge2d_config->src_para.width = canvas_width;
-        ge2d_config->src_para.height = canvas_height;
-
-        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-
-        ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->dst_para.fill_color_en = 0;
-        ge2d_config->dst_para.fill_mode = 0;
-        ge2d_config->dst_para.x_rev = 0;
-        ge2d_config->dst_para.y_rev = 0;
-        ge2d_config->dst_para.color = 0;
-        ge2d_config->dst_para.top = 0;
-        ge2d_config->dst_para.left = 0;
-        ge2d_config->dst_para.width = canvas_width;
-        ge2d_config->dst_para.height = canvas_height;
-        
-        if(ge2d_context_config_ex(context,ge2d_config)<0) {
-            printk("++ge2d configing error.\n");
-            ppmgr_vf_put_dec(vf);
-            vfq_push(&q_free, new_vf);
-            return;
-        }
-        fillrect(context, 0, 0, canvas_width, canvas_height, 0x008080ff);
-        ppmgr_3d_clear_count--;
-    }
-
-    if(vf->type & VIDTYPE_MVC){
-        pic_struct = (l_r)?(GE2D_FORMAT_M24_YUV420B & (3<<3)):(GE2D_FORMAT_M24_YUV420T & (3<<3));
-    }else{
-        pic_struct = 0;
-    }
-    /* data operating. */
-    memset(ge2d_config,0,sizeof(config_para_ex_t));
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    if(l_r){
-        canvas_read(vf->canvas1Addr&0xff,&cs0);
-        canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
-        canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
-    }else{
-        canvas_read(vf->canvas0Addr&0xff,&cs0);
-        canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-        canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    }
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_para.canvas_index=(l_r)?vf->canvas1Addr:vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    if(is_vertical_sample_enable(vf)){
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = vf->height/2;
-    }else{
-        ge2d_config->src_para.width = vf->width;
-        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
-    }
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = canvas_width;
-    ge2d_config->dst_para.height = canvas_height;
-
-    if(angle==1){
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.x_rev = 1;
-    }else if(angle==2){
-        ge2d_config->dst_para.x_rev = 1;
-        ge2d_config->dst_para.y_rev=1;        
-    }else if(angle==3)  {
-        ge2d_config->dst_xy_swap=1;
-        ge2d_config->dst_para.y_rev=1;
-    }
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
-
-    if(scale_down>1){
-        t = ((new_vf->height/scale_down) - (h/scale_down))/2;
-        h = h/scale_down;
-        new_vf->height = new_vf->height/scale_down;
-        l = ((new_vf->width/scale_down) - (w/scale_down))/2;
-        w = w/scale_down;
-        new_vf->width = new_vf->width/scale_down;
-    }
-
-    if(is_vertical_sample_enable(vf)){
-        stretchblt_noalpha(context, src_frame.content_left,src_frame.content_top,src_frame.content_width,src_frame.content_height/2,l,t,w,h);
-    }else{
-        stretchblt_noalpha(context, src_frame.content_left,src_frame.content_top,src_frame.content_width,(pic_struct)?(src_frame.content_height/2):src_frame.content_height,l,t,w,h);
-    }
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-}
-
-/********************************************************************/
-
-void ppmgr_vf_3d(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{  
-    display_frame_t input_frame ;
-    display_frame_t l_frame ,r_frame ;
-    canvas_t cd;
-    int cur_angle = 0;
-    int process_type = get_mid_process_type(vf);
-    cur_process_type = process_type;
-    get_input_frame(vf,&input_frame);
-    get_input_l_frame(vf,&l_frame);
-    get_input_r_frame(vf,&r_frame);
-
-
-    canvas_read(vf->canvas0Addr&0xff,&cd);
-    if(vf->type&VIDTYPE_VIU_422){
-         cd.width >>=1;
-    }
-    if(((input_frame.content_left +input_frame.content_width )> cd.width )
-      ||((input_frame.content_top +input_frame.content_height ) > cd.height )
-      ||((input_frame.frame_left +input_frame.frame_width )> cd.width )
-      ||((input_frame.frame_top +input_frame.frame_height ) > cd.height )){
-        ppmgr_vf_put_dec(vf);
-        printk("case 1: vdin canvas setting is not compatible with vframe!!!\n");
-        return ;
-
-    }
-
-    if(((l_frame.content_left +l_frame.content_width )> cd.width )
-      ||((l_frame.content_top +l_frame.content_height ) > cd.height )
-      ||((l_frame.frame_left +l_frame.frame_width )> cd.width )
-      ||((l_frame.frame_top +l_frame.frame_height ) > cd.height )){
-        ppmgr_vf_put_dec(vf);
-        printk("case 2: vdin canvas setting is not compatible with vframe!!!\n");
-        return ;
-    }
-
-    if(((r_frame.content_left +r_frame.content_width )> cd.width )
-      ||((r_frame.content_top +r_frame.content_height ) > cd.height )
-      ||((r_frame.frame_left +r_frame.frame_width )> cd.width )
-      ||((r_frame.frame_top +r_frame.frame_height ) > cd.height )){
-        ppmgr_vf_put_dec(vf);
-        printk("case 3:vdin canvas setting is not compatible with vframe!!!\n");
-        return ;
-    }
-    cur_angle = get_ppmgr_direction3d();//_3d_process.direction;
-    switch(process_type){
-        case TYPE_NONE:
- //           printk("process  none type\n");
-            process_none(vf,context,ge2d_config);
-            break;
-        case TYPE_2D_TO_3D:
- //           printk("process 2d to 3d type\n");
-            //if(_3d_process._2d_to_3d_type == PPMGR_3D_PROCESS_2D_TO_3D_NORMAL)
-            if(cur_angle&1)
-                process_2d_to_3d_ex(vf,context,ge2d_config,cur_angle);
-            else
-                process_2d_to_3d(vf,context,ge2d_config,cur_angle);
-            //else
-            //    process_field_depth(vf,context,ge2d_config);
-            break;
-        case TYPE_3D_LR:
-        case TYPE_3D_TB:
-            //printk("process  3d type\n");
-            if(cur_angle&1)
-                process_3d_ex(vf,context,ge2d_config,cur_angle);
-            else
-                process_3d(vf,context,ge2d_config,cur_angle);
-            break;
-        case TYPE_3D_TO_2D_LR:
-        case TYPE_3D_TO_2D_TB:
-//            printk("process  3d to 2d type\n");
-            process_3d_to_2d(vf,context,ge2d_config);
-            break;
-        default:
-            break;
-    }
-}
-
-int Init3DBuff(int canvas_id)
-{
-    void __iomem * mask_start = NULL;
-    unsigned char mask = 0xff;
-    canvas_t canvas_mask;	
-    int k = 0;
-    unsigned char *buff = NULL;
-
-    mask_canvas_index = canvas_id;
-    canvas_read(mask_canvas_index,&canvas_mask);
-    mask_start = ioremap_wc(canvas_mask.addr,canvas_mask.width*canvas_mask.height);
-    buff = (unsigned char*)mask_start;
-
-    while(k<canvas_mask.width*canvas_mask.height){
-        buff[k] = mask;
-        mask = ~mask;
-        k++;
-    }
-    iounmap(mask_start);
-    return 0;
-}
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/amports/timestamp.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vfp.h>
+#include <mach/am_regs.h>
+#include <linux/amlogic/amlog.h>
+#include <linux/amlogic/ge2d/ge2d.h>
+#include <linux/amlogic/ge2d/ge2d_wq.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/sched.h>
+#include "ppmgr_log.h"
+#include "ppmgr_pri.h"
+#include "ppmgr_dev.h"
+#include <linux/amlogic/ppmgr/ppmgr.h>
+#include <linux/amlogic/ppmgr/ppmgr_status.h>
+#include <linux/io.h>
+
+#define VF_POOL_SIZE 4
+
+static int cur_process_type =0;
+static int mask_canvas_index = -1;
+static int ppmgr_3d_clear_count = 0;
+
+typedef struct{
+    unsigned all_mode;
+    unsigned char mode;
+    unsigned char src_format;
+    unsigned char switch_flag;
+    unsigned char _3d_to_2d_use_frame;
+    unsigned char _2d_to_3d_type;
+    unsigned char double_type;
+    unsigned _2d_3d_control;
+    unsigned _2d_3d_control_value;
+    //unsigned direction; //0: 0 degree, 1: 90, 2: 180, 3:270
+}Process3d_t;
+
+typedef struct display_frame_s{
+    int frame_top;
+    int frame_left;
+    int frame_width;
+    int frame_height;
+    int content_top;
+    int content_left;
+    int content_width;
+    int content_height;
+}display_frame_t;
+
+extern void ppmgr_vf_put_dec(vframe_t *vf);
+extern u32 index2canvas(u32 index);
+extern vfq_t q_ready;
+extern vfq_t q_free;
+
+extern int get_bypass_mode(void);
+
+static Process3d_t _3d_process = {0};
+
+void Reset3Dclear(void)
+{
+    ppmgr_3d_clear_count = VF_POOL_SIZE;
+}
+
+void Set3DProcessPara(unsigned mode)
+{
+    if(_3d_process.all_mode != mode){
+        memset(&_3d_process,0,sizeof(Process3d_t));
+        _3d_process.all_mode = mode;
+        _3d_process.mode = mode & PPMGR_3D_PROCESS_MODE_MASK;
+        _3d_process.src_format = (mode & PPMGR_3D_PROCESS_SRC_FOMRAT_MASK)>>PPMGR_3D_PROCESS_SRC_FORMAT_SHIFT;
+        _3d_process.switch_flag = (mode & PPMGR_3D_PROCESS_SWITCH_FLAG)?1:0;
+        _3d_process._3d_to_2d_use_frame = (mode & PPMGR_3D_PROCESS_3D_TO_2D_SRC_FRAME)?1:0;
+        _3d_process._2d_to_3d_type = (mode & PPMGR_3D_PROCESS_2D_TO_3D_MASK)>>PPMGR_3D_PROCESS_2D_TO_3D_SHIFT;
+        _3d_process.double_type = (mode & PPMGR_3D_PROCESS_DOUBLE_TYPE)>>PPMGR_3D_PROCESS_DOUBLE_TYPE_SHIFT;
+        _3d_process._2d_3d_control = (mode & PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_MASK)>>PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_SHIFT;
+        if(_3d_process._2d_3d_control>0){
+            _3d_process._2d_3d_control_value = (mode & PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_VALUE_MASK)>>PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_VAULE_SHIFT;
+            if((_3d_process.mode == PPMGR_3D_PROCESS_MODE_2D_TO_3D)&&(!_3d_process._2d_3d_control_value))
+                _3d_process._2d_3d_control_value = 0x10;
+        }else{
+            _3d_process._2d_3d_control_value = 0;
+
+        }
+        //_3d_process.direction = (mode & PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK)>>PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_VAULE_SHIFT;
+        //printk("-- ppmgr 3d process 0x%x: mode:%d, src format:%d, switch flag:%d, 3d to 2d frame: %d,2d to 3d:%d, double type:%d, control mode: %d, control value: %d, rotate direction: %d,
+        //       _3d_process.all_mode,_3d_process.mode,_3d_process.src_format,_3d_process.switch_flag,
+        //       _3d_process._3d_to_2d_use_frame,_3d_process._2d_to_3d_type,_3d_process.double_type,
+        //       _3d_process._2d_3d_control,_3d_process._2d_3d_control_value,_3d_process.direction);
+    }
+}
+
+int get_mid_process_type(vframe_t* vf)
+{
+    int process_type = 0 ;
+    if(!vf){
+        process_type = TYPE_NONE ;
+        return process_type;
+    }
+
+    if(_3d_process.mode == PPMGR_3D_PROCESS_MODE_3D_ENABLE){
+        if(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_LR){
+            process_type = TYPE_3D_LR;
+        }else if(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB){
+            process_type = TYPE_3D_TB;
+        }else{  // auto mode or others
+            switch(vf->trans_fmt){
+                case TVIN_TFMT_3D_TB:
+                    process_type = TYPE_3D_TB;
+                    break;
+                case TVIN_TFMT_3D_FP:
+                    process_type = TYPE_3D_LR;
+                    break;
+                case TVIN_TFMT_3D_LRH_OLOR:
+                case TVIN_TFMT_3D_LRH_OLER:
+                case TVIN_TFMT_3D_LRH_ELOR:
+                case TVIN_TFMT_3D_LRH_ELER:
+                    process_type = TYPE_3D_LR;
+                    break;
+                default:
+                    process_type = TYPE_NONE;
+                    break;
+            }
+        }
+    }else if(_3d_process.mode == PPMGR_3D_PROCESS_MODE_3D_TO_2D){
+        if(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_LR){
+            process_type = TYPE_3D_TO_2D_LR;
+        }else if(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB){
+            process_type = TYPE_3D_TO_2D_TB;
+        }else{  // auto mode or others
+            switch(vf->trans_fmt){
+                case TVIN_TFMT_3D_TB:
+                    process_type = TYPE_3D_TO_2D_TB;
+                    break;
+                case TVIN_TFMT_3D_FP:
+                    process_type = TYPE_3D_TO_2D_LR;
+                    break;
+                case TVIN_TFMT_3D_LRH_OLOR:
+                case TVIN_TFMT_3D_LRH_OLER:
+                case TVIN_TFMT_3D_LRH_ELOR:
+                case TVIN_TFMT_3D_LRH_ELER:
+                    process_type = TYPE_3D_TO_2D_LR;
+                    break;
+                default:
+                    process_type = TYPE_NONE;
+                    break;
+            }
+        }
+    }else if(_3d_process.mode == PPMGR_3D_PROCESS_MODE_2D_TO_3D){
+        process_type = TYPE_2D_TO_3D;
+    }else{
+        process_type = TYPE_NONE;
+    }
+    return process_type;
+}
+
+int is_mid_local_source(vframe_t* vf)
+{
+    int ret = 0 ;
+    if(vf->type&VIDTYPE_VIU_422){
+        ret = 0;
+    }else{
+	ret = 1;
+    }
+    return ret;
+}
+
+int is_mid_mvc_need_process(vframe_t* vf)
+{
+    int ret = 0 ;
+    int process_type = get_mid_process_type(vf);
+    switch(process_type){
+        //case TYPE_3D_LR:
+        case TYPE_3D_TO_2D_LR:
+            ret = 1;
+            break;
+        default:
+            break;
+    }
+    return ret;
+}
+
+static int is_vertical_sample_enable(vframe_t* vf)
+{
+    int ret = 0 ;
+    if((vf->type &VIDTYPE_INTERLACE_BOTTOM)||(vf->type &VIDTYPE_INTERLACE_TOP)){
+        ret = 1 ;
+    }
+    return ret;
+}
+
+
+static int get_input_format(vframe_t* vf)
+{
+    int format= GE2D_FORMAT_M24_YUV420;
+    if(vf->type&VIDTYPE_VIU_NV21)
+        format =  GE2D_FORMAT_M24_NV21;
+    else
+        format =  GE2D_FORMAT_M24_YUV420;
+    if(vf->type&VIDTYPE_VIU_422){
+        format =  GE2D_FORMAT_S16_YUV422;
+    }else{
+        if(is_vertical_sample_enable(vf)){
+            if(vf->type &VIDTYPE_INTERLACE_BOTTOM){
+                format =  format|(GE2D_FMT_M24_YUV420B & (3<<3));
+            }else if(vf->type &VIDTYPE_INTERLACE_TOP){
+                format =  format|(GE2D_FORMAT_M24_YUV420T & (3<<3));
+            }
+        }else{
+            if(vf->type&VIDTYPE_VIU_NV21)
+                format =  GE2D_FORMAT_M24_NV21;
+            else
+                format =  GE2D_FORMAT_M24_YUV420;
+        }
+    }
+    return format;
+}
+
+
+static int get_input_frame(vframe_t* vf , display_frame_t* frame)
+{
+    if(frame == NULL){
+        return -1;
+    }
+    if(vf->type & VIDTYPE_MVC){
+	frame->content_top = vf->left_eye.start_y   ;
+	frame->content_left = vf->left_eye.start_x ;
+	frame->content_width = vf->left_eye.width    ;
+	frame->content_height = vf->left_eye.height  ;
+	frame->frame_top =    vf->left_eye.start_y ;
+	frame->frame_left =   vf->left_eye.start_x;
+	frame->frame_width=   vf->left_eye.width ;
+	frame->frame_height = vf->left_eye.height;
+	return 0;
+    }
+/*tv in case , need detect the black bar*/
+    if((vf->prop.bbar.bottom)&&(vf->prop.bbar.right)
+      &&(vf->prop.bbar.right > vf->prop.bbar.left)
+      &&(vf->prop.bbar.bottom > vf->prop.bbar.top )){
+        switch(vf->trans_fmt){
+            case TVIN_TFMT_2D:
+                frame->content_top = vf->prop.bbar.top   ;
+                frame->content_left = vf->prop.bbar.left  ;
+                frame->content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
+                frame->content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
+                frame->frame_top =    0;
+                frame->frame_left =   0;
+                frame->frame_width=   vf->width;
+                frame->frame_height = vf->height;
+                break;
+            case TVIN_TFMT_3D_FP:
+                frame->content_top = vf->left_eye.start_y   ;
+                frame->content_left = vf->left_eye.start_x ;
+                frame->content_width = vf->left_eye.width    ;
+                frame->content_height = vf->left_eye.height  ;
+                frame->frame_top =    vf->left_eye.start_y ;
+                frame->frame_left =   vf->left_eye.start_x;
+                frame->frame_width=   vf->left_eye.width ;
+                frame->frame_height = vf->left_eye.height;
+                break;
+            default:
+                frame->content_top = vf->prop.bbar.top   ;
+                frame->content_left = vf->prop.bbar.left  ;
+                frame->content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
+                frame->content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
+                frame->frame_top =    0;
+                frame->frame_left =   0;
+                frame->frame_width=   vf->width;
+                frame->frame_height = vf->height;
+                break;
+        }
+//	    printk("full_frame: format  is %d , top is %d , left is %d , width is %d , height is %d\n",vf->trans_fmt ,frame->content_top ,frame->content_left,frame->content_width,frame->content_height);
+    }else{
+        switch(vf->trans_fmt){
+            case TVIN_TFMT_2D:
+                frame->content_top = 0  ;
+                frame->content_left = 0  ;
+                frame->content_width = vf->width;    ;
+                frame->content_height = vf->height;
+                frame->frame_top =    0;
+                frame->frame_left =   0;
+                frame->frame_width=   vf->width;
+                frame->frame_height = vf->height;
+                break;
+            case TVIN_TFMT_3D_FP:
+                frame->content_top = vf->left_eye.start_y   ;
+                frame->content_left = vf->left_eye.start_x ;
+                frame->content_width = vf->left_eye.width    ;
+                frame->content_height = vf->left_eye.height  ;
+                frame->frame_top =    vf->left_eye.start_y ;
+                frame->frame_left =   vf->left_eye.start_x;
+                frame->frame_width=   vf->left_eye.width ;
+                frame->frame_height = vf->left_eye.height;
+                break;
+            default:
+                frame->content_top = 0  ;
+                frame->content_left = 0  ;
+                frame->content_width = vf->width;
+                frame->content_height = vf->height;
+                frame->frame_top =    0;
+                frame->frame_left =   0;
+                frame->frame_width=   vf->width;
+                frame->frame_height = vf->height;
+                break;
+        }
+    }
+    return 0;
+}
+
+static int get_input_l_frame(vframe_t* vf , display_frame_t* frame)
+{
+    int content_top ,content_left ,content_width ,content_height;
+    if(frame == NULL){
+        return -1;
+    }
+    if(vf->type & VIDTYPE_MVC){
+	frame->content_top = vf->left_eye.start_y   ;
+	frame->content_left = vf->left_eye.start_x ;
+	frame->content_width = vf->left_eye.width    ;
+	frame->content_height = vf->left_eye.height  ;
+	frame->frame_top =    vf->left_eye.start_y;
+	frame->frame_left =   vf->left_eye.start_x;
+	frame->frame_width=   vf->left_eye.width;
+	frame->frame_height = vf->left_eye.height;
+	return 0;
+    }
+/*tv in case , need detect the black bar*/
+    if((vf->prop.bbar.bottom)&&(vf->prop.bbar.right)
+      &&(vf->prop.bbar.right > vf->prop.bbar.left)
+      &&(vf->prop.bbar.bottom > vf->prop.bbar.top )){
+        switch(vf->trans_fmt){
+            case TVIN_TFMT_2D:
+                content_top = vf->prop.bbar.top   ;
+                content_left = vf->prop.bbar.left  ;
+                content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
+                content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
+                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
+                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
+                    frame->content_top = content_top  ;
+                    frame->content_left = content_left ;
+                    frame->content_width = content_width    ;
+                    frame->content_height = content_height/2  ;
+                }else{
+                    frame->content_top = content_top  ;
+                    frame->content_left = content_left ;
+                    frame->content_width = content_width/2    ;
+                    frame->content_height = content_height  ;
+                }
+                frame->frame_top =    0;
+                frame->frame_left =   0;
+                frame->frame_width=   vf->width;
+                frame->frame_height = vf->height;
+                break;
+            case TVIN_TFMT_3D_FP:
+                frame->content_top = vf->left_eye.start_y   ;
+                frame->content_left = vf->left_eye.start_x ;
+                frame->content_width = vf->left_eye.width    ;
+                frame->content_height = vf->left_eye.height  ;
+                frame->frame_top =    vf->left_eye.start_y;
+                frame->frame_left =   vf->left_eye.start_x;
+                frame->frame_width=   vf->left_eye.width;
+                frame->frame_height = vf->left_eye.height;
+                break;
+            default:
+                content_top = vf->prop.bbar.top   ;
+                content_left = vf->prop.bbar.left  ;
+                content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
+                content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
+                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
+                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
+                    frame->content_top = content_top  ;
+                    frame->content_left = content_left ;
+                    frame->content_width = content_width    ;
+                    frame->content_height = content_height/2  ;
+                }else{
+                    frame->content_top = content_top  ;
+                    frame->content_left = content_left ;
+                    frame->content_width = content_width/2    ;
+                    frame->content_height = content_height  ;
+                }
+                frame->frame_top =    0;
+                frame->frame_left =   0;
+                frame->frame_width=   vf->width;
+                frame->frame_height = vf->height;
+                break;
+        }
+//	    printk("lframe: format  is %d , top is %d , left is %d , width is %d , height is %d\n",vf->trans_fmt ,frame->content_top ,frame->content_left,frame->content_width,frame->content_height);
+    }else{
+        switch(vf->trans_fmt){
+            case TVIN_TFMT_2D:
+                content_top = 0  ;
+                content_left = 0  ;
+                content_width = vf->width;    ;
+                content_height = vf->height;
+                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
+                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
+                    frame->content_top = content_top  ;
+                    frame->content_left = content_left ;
+                    frame->content_width = content_width    ;
+                    frame->content_height = content_height/2  ;
+                }else{
+                    frame->content_top = content_top  ;
+                    frame->content_left = content_left ;
+                    frame->content_width = content_width/2    ;
+                    frame->content_height = content_height  ;
+                }
+                frame->frame_top =    0;
+                frame->frame_left =   0;
+
+                frame->frame_width=   vf->width;
+                frame->frame_height = vf->height;
+                break;
+            case TVIN_TFMT_3D_FP:
+                frame->content_top = vf->left_eye.start_y   ;
+                frame->content_left = vf->left_eye.start_x ;
+                frame->content_width = vf->left_eye.width    ;
+                frame->content_height = vf->left_eye.height  ;
+                frame->frame_top =    vf->left_eye.start_y;
+                frame->frame_left =   vf->left_eye.start_x;
+                frame->frame_width=   vf->left_eye.width;
+                frame->frame_height = vf->left_eye.height;
+                break;
+            default:
+                content_top = 0  ;
+                content_left = 0  ;
+                content_width = vf->width;    ;
+                content_height = vf->height;
+                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
+                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
+                    frame->content_top = content_top  ;
+                    frame->content_left = content_left ;
+                    frame->content_width = content_width    ;
+                    frame->content_height = content_height/2  ;
+                }else{
+                    frame->content_top = content_top  ;
+                    frame->content_left = content_left ;
+                    frame->content_width = content_width/2    ;
+                    frame->content_height = content_height  ;
+                }
+                frame->frame_top =    0;
+                frame->frame_left =   0;
+                frame->frame_width=   vf->width;
+                frame->frame_height = vf->height;
+                break;
+        }
+    }
+    return 0;
+}
+
+static int get_input_r_frame(vframe_t* vf , display_frame_t* frame)
+{
+    int content_top ,content_left ,content_width ,content_height;
+    if(frame == NULL){
+        return -1;
+    }
+    if(vf->type & VIDTYPE_MVC){
+        frame->content_top = vf->right_eye.start_y   ;
+        frame->content_left = vf->right_eye.start_x ;
+        frame->content_width = vf->right_eye.width    ;
+        frame->content_height = vf->right_eye.height  ;
+        frame->frame_top =    vf->right_eye.start_y;
+        frame->frame_left =   vf->right_eye.start_x;
+        frame->frame_width=   vf->right_eye.width;
+        frame->frame_height = vf->right_eye.height;
+        return 0;
+    }
+/*tv in case , need detect the black bar*/
+    if((vf->prop.bbar.bottom)&&(vf->prop.bbar.right)
+      &&(vf->prop.bbar.right > vf->prop.bbar.left)
+      &&(vf->prop.bbar.bottom > vf->prop.bbar.top )){
+        switch(vf->trans_fmt){
+            case TVIN_TFMT_2D:
+                content_top = vf->prop.bbar.top   ;
+                content_left = vf->prop.bbar.left  ;
+                content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
+                content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
+                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
+                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
+                    frame->content_top = content_top + content_height/2 ;
+                    frame->content_left = content_left ;
+                    frame->content_width = content_width    ;
+                    frame->content_height = content_height/2  ;
+                }else{
+                    frame->content_top = content_top  ;
+                    frame->content_left = content_width/2 + content_left ;
+                    frame->content_width = content_width/2    ;
+                    frame->content_height = content_height  ;
+                }
+                frame->frame_top = 0;
+                frame->frame_left = 0;
+                frame->frame_width= vf->width;
+                frame->frame_height = vf->height;
+                break;
+            case TVIN_TFMT_3D_FP:
+                frame->content_top = vf->right_eye.start_y   ;
+                frame->content_left = vf->right_eye.start_x ;
+                frame->content_width = vf->right_eye.width    ;
+                frame->content_height = vf->right_eye.height  ;
+                frame->frame_top =    vf->right_eye.start_y;
+                frame->frame_left =   vf->right_eye.start_x;
+                frame->frame_width=   vf->right_eye.width;
+                frame->frame_height = vf->right_eye.height;
+                break;
+            default:
+                content_top = vf->prop.bbar.top   ;
+                content_left = vf->prop.bbar.left  ;
+                content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
+                content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
+                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
+                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
+                    frame->content_top = content_top + content_height/2 ;
+                    frame->content_left = content_left ;
+                    frame->content_width = content_width    ;
+                    frame->content_height = content_height/2  ;
+                }else{
+                    frame->content_top = content_top  ;
+                    frame->content_left = content_width/2 + content_left ;
+                    frame->content_width = content_width/2    ;
+                    frame->content_height = content_height  ;
+                }
+                frame->frame_top = 0;
+                frame->frame_left = 0;
+                frame->frame_width= vf->width;
+                frame->frame_height = vf->height;
+                break;
+        }
+//		printk("rframe : format  is %d , top is %d , left is %d , width is %d , height is %d\n",vf->trans_fmt ,frame->content_top ,frame->content_left,frame->content_width,frame->content_height);
+    }else{
+        switch(vf->trans_fmt){
+            case TVIN_TFMT_2D:
+                content_top = 0  ;
+                content_left = 0  ;
+                content_width = vf->width;    ;
+                content_height = vf->height;
+                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
+                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
+                    frame->content_top = content_top + content_height/2 ;
+                    frame->content_left = content_left ;
+                    frame->content_width = content_width    ;
+                    frame->content_height = content_height/2  ;
+                }else{
+                    frame->content_top = content_top  ;
+                    frame->content_left = content_width/2 + content_left ;
+                    frame->content_width = content_width/2    ;
+                    frame->content_height = content_height  ;
+                }
+                frame->frame_top = 0;
+                frame->frame_left = 0;
+                frame->frame_width= vf->width;
+                frame->frame_height = vf->height;
+                break;
+            case TVIN_TFMT_3D_FP:
+                frame->content_top = vf->right_eye.start_y   ;
+                frame->content_left = vf->right_eye.start_x ;
+                frame->content_width = vf->right_eye.width    ;
+                frame->content_height = vf->right_eye.height  ;
+                frame->frame_top =    vf->right_eye.start_y;
+                frame->frame_left =   vf->right_eye.start_x;
+                frame->frame_width=   vf->right_eye.width;
+                frame->frame_height = vf->right_eye.height;
+                break;
+            default:
+                content_top = 0  ;
+                content_left = 0  ;
+                content_width = vf->width;    ;
+                content_height = vf->height;
+                if((cur_process_type == TYPE_3D_TB)||(cur_process_type == TYPE_3D_TO_2D_TB)
+                    ||(_3d_process.src_format == PPMGR_3D_PROCESS_SRC_FOMRAT_TB)){
+                    frame->content_top = content_top + content_height/2 ;
+                    frame->content_left = content_left ;
+                    frame->content_width = content_width    ;
+                    frame->content_height = content_height/2  ;
+                }else{
+                    frame->content_top = content_top  ;
+                    frame->content_left = content_width/2 + content_left ;
+                    frame->content_width = content_width/2    ;
+                    frame->content_height = content_height  ;
+                }
+                frame->frame_top = 0;
+                frame->frame_left = 0;
+                frame->frame_width= vf->width;
+                frame->frame_height = vf->height;
+                break;
+        }
+    }
+    return 0;
+}
+
+static int get_output_rect_after_ratio(vframe_t* vf ,int* top , int*left , int* width , int* height ,int in_width, int in_height, int output_width,int output_height,unsigned angle)
+{
+    int t = 0,l = 0,w = 0,h = 0;
+    int current_view_mode = 0 ;
+    int ar = 0x100;
+    unsigned char  doublemode = _3d_process.double_type;
+
+    w = output_width;
+    h = output_height;
+    if(doublemode == PPMGR_3D_PROCESS_DOUBLE_TYPE_HOR){
+        in_width = in_width<<1;
+    }else if(doublemode == PPMGR_3D_PROCESS_DOUBLE_TYPE_VER){
+        in_height = in_height<<1;
+    }
+    if (vf->ratio_control) {
+        ar = (vf->ratio_control >> DISP_RATIO_ASPECT_RATIO_BIT) & 0x3ff;
+        if(doublemode == PPMGR_3D_PROCESS_DOUBLE_TYPE_HOR){
+            ar = ar>>1;
+        }else if(doublemode == PPMGR_3D_PROCESS_DOUBLE_TYPE_VER){
+            ar = ar<<1;
+        }
+    }else{
+        ar = (in_height<<8)/in_width;
+    }
+    current_view_mode  = get_ppmgr_viewmode();
+    if(current_view_mode == VIEWMODE_NORMAL){
+        if(output_width>output_height){  //panel 1280*768 case
+            if(angle&1){
+                if((in_width*16) == (in_height*9)){
+                    current_view_mode = VIEWMODE_FULL;
+                }
+            }else{
+                if((in_width*9) == (in_height*16)){
+                    current_view_mode = VIEWMODE_FULL;
+                }
+            }
+        }else{                          //panel 800*1280 case
+            if(angle&1){
+                if((in_width*9) == (in_height*16)){
+                    current_view_mode = VIEWMODE_FULL;
+                }
+            }else{
+                if((in_width*16) == (in_height*9)){
+                    current_view_mode = VIEWMODE_FULL;
+                }
+            }
+        }
+    }
+
+    switch(current_view_mode){
+        case VIEWMODE_4_3:
+            ar = 0xc0;
+            break;
+        case VIEWMODE_16_9:
+            ar = 0x90;
+            break;
+        case VIEWMODE_FULL:
+            *top = 0;
+            *left = 0;
+            *width = output_width;
+            *height = output_height;
+            return 0;
+        case VIEWMODE_1_1:
+            if(angle&1){
+                int swap = in_width;
+                in_width = in_height;
+                in_height = swap;
+            }
+            break;
+        case VIEWMODE_NORMAL:
+        default:
+            break;
+    }
+
+    if(angle&1)
+        ar = 0x10000/ar;
+    if ((ar * output_width) > (output_height << 8)) {
+        if((current_view_mode == VIEWMODE_1_1)&&(in_height<=output_height)){
+            l = (output_width - in_width)>>1;
+            t = (output_height - in_height)>>1;
+        }else{
+            w = (output_height << 8) / ar;
+            l = (output_width - w) / 2;
+        }
+    } else {
+        if((current_view_mode == VIEWMODE_1_1)&&(in_width<=output_width)){
+            l = (output_width - in_width)>>1;
+            t = (output_height - in_height)>>1;
+        }else{
+            h = (output_width * ar) >> 8;
+            t = (output_height - h) / 2;
+        }
+    }
+    l &= ~1;
+    t &= ~1;
+    w =  output_width - 2*l;
+    h  =  output_height - 2*t;
+    *top = t;
+    *left = l;
+    *width = w;
+    *height = h;
+    return 0;
+}
+
+/*******************************************************************/
+
+/*for decoder input processing
+    1. output window should 1:1 as source frame size
+    2. keep the frame ratio
+    3. input format should be YUV420 , output format should be YUV444
+*/
+static void process_none(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+
+}
+
+//static int ratio_value = 10; // 0~255
+// for 90 degree and 270 degree, use interlace mode to output mix data.
+void process_2d_to_3d_ex(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config,unsigned angle)
+{
+    vframe_t *new_vf;
+    ppframe_t *pp_vf;
+    display_frame_t input_frame;
+    canvas_t cs0,cs1,cs2,cd;
+    int t,l,w,h;
+    int canvas_width = ppmgr_device.canvas_width;
+    int canvas_height = ppmgr_device.canvas_height;
+    unsigned char switch_flag = _3d_process.switch_flag;
+    int x_offset = 0, dir = 0;
+    unsigned scale_down = get_ppmgr_scaledown()+1;
+    int pic_struct = 0;
+
+    new_vf = vfq_pop(&q_free);
+    if(_3d_process._2d_3d_control == PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_LEFT_MOVE){
+        x_offset = _3d_process._2d_3d_control_value;
+    }else if(_3d_process._2d_3d_control == PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_RIGHT_MOVE){
+        x_offset = _3d_process._2d_3d_control_value;
+        dir = 1;
+    }else{
+        x_offset = 0;
+    }
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+
+    //int interlace_mode = vf->type & VIDTYPE_TYPEMASK;
+
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    new_vf->ratio_control = ((scale_down>1)?DISP_RATIO_FORCE_FULL_STRETCH:DISP_RATIO_FORCE_NORMALWIDE)|DISP_RATIO_FORCECONFIG;
+    new_vf->duration = vf->duration;
+    new_vf->duration_pulldown = vf->duration_pulldown;
+    new_vf->pts = vf->pts;
+    if(ppmgr_device.disp_width>ppmgr_device.disp_height)
+        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;
+    else
+        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE;
+    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(pp_vf->index);
+
+    get_input_frame(vf,&input_frame);
+
+    new_vf->width= ppmgr_device.disp_width;
+    new_vf->height= ppmgr_device.disp_height;
+
+    if(ppmgr_3d_clear_count>0){
+        //clear rect
+        memset(ge2d_config,0,sizeof(config_para_ex_t));
+        ge2d_config->alu_const_color= 0;//0x000000ff;
+        ge2d_config->bitmask_en  = 0;
+        ge2d_config->src1_gb_alpha = 0;//0xff;
+        ge2d_config->dst_xy_swap = 0;
+
+        canvas_read(new_vf->canvas0Addr&0xff,&cd);
+        ge2d_config->src_planes[0].addr = cd.addr;
+        ge2d_config->src_planes[0].w = cd.width;
+        ge2d_config->src_planes[0].h = cd.height;
+        ge2d_config->dst_planes[0].addr = cd.addr;
+        ge2d_config->dst_planes[0].w = cd.width;
+        ge2d_config->dst_planes[0].h = cd.height;
+
+        ge2d_config->src_key.key_enable = 0;
+        ge2d_config->src_key.key_mask = 0;
+        ge2d_config->src_key.key_mode = 0;
+
+        ge2d_config->src_para.canvas_index=new_vf->canvas0Addr;
+        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->src_para.fill_color_en = 0;
+        ge2d_config->src_para.fill_mode = 0;
+        ge2d_config->src_para.x_rev = 0;
+        ge2d_config->src_para.y_rev = 0;
+        ge2d_config->src_para.color = 0;
+        ge2d_config->src_para.top = 0;
+        ge2d_config->src_para.left = 0;
+        ge2d_config->src_para.width = canvas_width;
+        ge2d_config->src_para.height = canvas_height;
+
+        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+        ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->dst_para.fill_color_en = 0;
+        ge2d_config->dst_para.fill_mode = 0;
+        ge2d_config->dst_para.x_rev = 0;
+        ge2d_config->dst_para.y_rev = 0;
+        ge2d_config->dst_para.color = 0;
+        ge2d_config->dst_para.top = 0;
+        ge2d_config->dst_para.left = 0;
+        ge2d_config->dst_para.width = canvas_width;
+        ge2d_config->dst_para.height = canvas_height;
+
+        if(ge2d_context_config_ex(context,ge2d_config)<0) {
+            printk("++ge2d configing error.\n");
+            ppmgr_vf_put_dec(vf);
+            vfq_push(&q_free, new_vf);
+            return;
+        }
+        fillrect(context, 0, 0, canvas_width, canvas_height, 0x008080ff);
+        ppmgr_3d_clear_count--;
+    }
+
+    if(vf->type & VIDTYPE_MVC){
+        pic_struct = (GE2D_FORMAT_M24_YUV420T & (3<<3));
+    }else{
+        pic_struct = 0;
+    }
+    /* data operating. */
+    memset(ge2d_config,0,sizeof(config_para_ex_t));
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_key.key_color = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    if(is_vertical_sample_enable(vf)){
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = vf->height/2;
+    }else{
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
+    }
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444|(switch_flag?(GE2D_FORMAT_M24_YUV420B & (3<<3)):(GE2D_FORMAT_M24_YUV420T & (3<<3)));
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = canvas_width;
+    ge2d_config->dst_para.height = canvas_height>>1;
+
+    if(angle==1){
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.x_rev = 1;
+    }else if(angle==2){
+        ge2d_config->dst_para.x_rev = 1;
+        ge2d_config->dst_para.y_rev=1;
+    }else if(angle==3)  {
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.y_rev=1;
+    }
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
+
+    //printk("--first frame ex: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
+    //      input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height,
+    //      l,t,w,h,new_vf->width,new_vf->height);
+
+    if(scale_down>1){
+        if(angle&1){
+            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
+            w = w/scale_down;
+        }else{
+            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
+            h = h/scale_down;
+        }
+    }
+
+    if(is_vertical_sample_enable(vf)){
+       stretchblt_noalpha(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height/2,
+           l,t/2,w,h/2);
+    }else{
+       stretchblt_noalpha(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,(pic_struct)?(input_frame.content_height/2):input_frame.content_height,
+           l,t/2,w,h/2);
+    }
+
+    /* data operating. */
+    memset(ge2d_config,0,sizeof(config_para_ex_t));
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_key.key_color = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    if(is_vertical_sample_enable(vf)){
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = vf->height/2;
+    }else{
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
+    }
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444|(switch_flag?(GE2D_FORMAT_M24_YUV420T & (3<<3)):(GE2D_FORMAT_M24_YUV420B & (3<<3)));
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = canvas_width;
+    ge2d_config->dst_para.height = canvas_height>>1;
+
+    if(angle==1){
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.x_rev = 1;
+    }else if(angle==2){
+        ge2d_config->dst_para.x_rev = 1;
+        ge2d_config->dst_para.y_rev=1;
+    }else if(angle==3)  {
+
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.y_rev=1;
+    }
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
+
+    if(x_offset){
+        if(angle&1){
+            int dst_h = 0;
+            if(dir){  //move down
+                if((t+x_offset+h)<=new_vf->height){ //only pan
+                    if(angle == 3){
+                        t = t - x_offset;
+                        t &= ~1;
+                    }else{
+                        t = t + x_offset;
+                        t &= ~1;
+                    }
+                }else if((t+x_offset)<new_vf->height){  //need cut
+                    t = t + x_offset;
+                    t &= ~1;
+                    dst_h = new_vf->height - t;
+                    input_frame.content_width = ((((input_frame.content_width*dst_h) <<8)+0x80)/h)>>8;
+                    h = dst_h;
+                    if(angle == 3){
+                        t = 0;
+                    }
+                }else{
+                    printk("++2d->3d error, out of range1.\n");
+                }
+            }else{//move up
+                if(t>=x_offset){ //only pan
+                    if(angle == 3){
+                        t = t + x_offset;
+                        t &= ~1;
+                    }else{
+                        t = t - x_offset;
+                        t &= ~1;
+                    }
+                }else if((t+h)>x_offset){  //need cut
+                    int src_w = 0, src_l = 0;
+                    t = 0;
+                    dst_h = h + t - x_offset;
+                    src_w = ((((input_frame.content_width*dst_h) <<8)+0x80)/h)>>8;
+                    h = dst_h;
+                    src_l = input_frame.content_left + input_frame.content_width - src_w;
+                    src_l &= ~1;
+                    input_frame.content_width = input_frame.content_width + input_frame.content_left - src_l;
+                    input_frame.content_left = src_l;
+                    if(angle == 3){
+                        t = t + x_offset;
+                    }
+                }else{
+                    printk("++2d->3d error, out of range2.\n");
+                }
+            }
+        }else{
+            int dst_w = 0;
+            if(dir){  //move right
+                if((l+x_offset+w)<=new_vf->width){ //only pan
+                    if((angle == 1)||(angle == 2)){
+                        l = l - x_offset;
+                        l &= ~1;
+                    }else{
+                        l = l + x_offset;
+                        l &= ~1;
+                    }
+                }else if((l+x_offset)<new_vf->width){  //need cut
+                    l = l + x_offset;
+                    l &= ~1;
+                    dst_w = new_vf->width - l;
+                    input_frame.content_width = ((((input_frame.content_width*dst_w) <<8)+0x80)/w)>>8;
+                    w = dst_w;
+                    if((angle == 1)||(angle == 2)){
+                        l = 0;
+                    }
+                }else{
+                    printk("++2d->3d error, out of range1.\n");
+                }
+            }else{//move left
+                if(l>=x_offset){ //only pan
+                    if((angle == 1)||(angle == 2)){
+                        l = l + x_offset;
+                        l &= ~1;
+                    }else{
+                        l = l - x_offset;
+                        l &= ~1;
+                    }
+                }else if((l+w)>x_offset){  //need cut
+                    int src_w = 0, src_l = 0;
+                    l = 0;
+                    dst_w = w + l - x_offset;
+                    src_w = ((((input_frame.content_width*dst_w) <<8)+0x80)/w)>>8;
+                    w = dst_w;
+                    src_l = input_frame.content_left + input_frame.content_width - src_w;
+                    src_l &= ~1;
+                    input_frame.content_width = input_frame.content_width + input_frame.content_left - src_l;
+                    input_frame.content_left = src_l;
+                    if((angle == 1)||(angle == 2)){
+                        l = l + x_offset;
+                    }
+                }else{
+                    printk("++2d->3d error, out of range2.\n");
+                }
+            }
+        }
+    }
+
+    if(scale_down>1){
+        if(angle&1){
+            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
+            w = w/scale_down;
+            new_vf->width = new_vf->width/scale_down;
+        }else{
+            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
+            h = h/scale_down;
+            new_vf->height = new_vf->height/scale_down;
+        }
+    }
+
+    if(is_vertical_sample_enable(vf)){
+       stretchblt_noalpha(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height/2,
+           l,t/2,w,h/2);
+    }else{
+       stretchblt_noalpha(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,(pic_struct)?(input_frame.content_height/2):input_frame.content_height,
+           l,t/2,w,h/2);
+    }
+
+    //printk("--second frame ex: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
+    //      input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height,
+    //      l,t,w,h,new_vf->width,new_vf->height);
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+}
+
+static void process_2d_to_3d(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config,unsigned angle)
+{
+    vframe_t *new_vf;
+    ppframe_t *pp_vf;
+    display_frame_t input_frame;
+    canvas_t cs0,cs1,cs2,cd,cm;
+    int t,l,w,h;
+    unsigned char switch_flag = _3d_process.switch_flag;
+    int x_offset = 0, dir = 0;
+    int canvas_width = ppmgr_device.canvas_width;
+    int canvas_height = ppmgr_device.canvas_height;
+    int scale_down = get_ppmgr_scaledown()+1;
+    int pic_struct = 0;
+
+    new_vf = vfq_pop(&q_free);
+    if(_3d_process._2d_3d_control == PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_LEFT_MOVE){
+        x_offset = _3d_process._2d_3d_control_value;
+    }else if(_3d_process._2d_3d_control == PPMGR_3D_PROCESS_2D_TO_3D_CONTROL_RIGHT_MOVE){
+        x_offset = _3d_process._2d_3d_control_value;
+        dir = 1;
+    }else{
+        x_offset = 0;
+    }
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+
+    //int interlace_mode = vf->type & VIDTYPE_TYPEMASK;
+
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    new_vf->ratio_control = ((scale_down>1)?DISP_RATIO_FORCE_FULL_STRETCH:DISP_RATIO_FORCE_NORMALWIDE)|DISP_RATIO_FORCECONFIG;
+    new_vf->duration = vf->duration;
+    new_vf->duration_pulldown = vf->duration_pulldown;
+    new_vf->pts = vf->pts;
+    if(ppmgr_device.disp_width>ppmgr_device.disp_height)
+        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;
+    else
+        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE;
+    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(pp_vf->index);
+
+    get_input_frame(vf,&input_frame);
+
+    new_vf->width= ppmgr_device.disp_width;
+    new_vf->height= ppmgr_device.disp_height;
+
+    if(ppmgr_3d_clear_count>0){
+        //clear rect
+        memset(ge2d_config,0,sizeof(config_para_ex_t));
+        ge2d_config->alu_const_color= 0;//0x000000ff;
+        ge2d_config->bitmask_en  = 0;
+        ge2d_config->src1_gb_alpha = 0;//0xff;
+        ge2d_config->dst_xy_swap = 0;
+
+        canvas_read(new_vf->canvas0Addr&0xff,&cd);
+        ge2d_config->src_planes[0].addr = cd.addr;
+        ge2d_config->src_planes[0].w = cd.width;
+        ge2d_config->src_planes[0].h = cd.height;
+        ge2d_config->dst_planes[0].addr = cd.addr;
+        ge2d_config->dst_planes[0].w = cd.width;
+        ge2d_config->dst_planes[0].h = cd.height;
+
+        ge2d_config->src_key.key_enable = 0;
+        ge2d_config->src_key.key_mask = 0;
+        ge2d_config->src_key.key_mode = 0;
+
+        ge2d_config->src_para.canvas_index=new_vf->canvas0Addr;
+        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->src_para.fill_color_en = 0;
+        ge2d_config->src_para.fill_mode = 0;
+        ge2d_config->src_para.x_rev = 0;
+        ge2d_config->src_para.y_rev = 0;
+        ge2d_config->src_para.color = 0;
+        ge2d_config->src_para.top = 0;
+        ge2d_config->src_para.left = 0;
+        ge2d_config->src_para.width = canvas_width;
+        ge2d_config->src_para.height = canvas_height;
+
+        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+        ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->dst_para.fill_color_en = 0;
+        ge2d_config->dst_para.fill_mode = 0;
+        ge2d_config->dst_para.x_rev = 0;
+        ge2d_config->dst_para.y_rev = 0;
+        ge2d_config->dst_para.color = 0;
+        ge2d_config->dst_para.top = 0;
+        ge2d_config->dst_para.left = 0;
+        ge2d_config->dst_para.width = canvas_width;
+        ge2d_config->dst_para.height = canvas_height;
+
+        if(ge2d_context_config_ex(context,ge2d_config)<0) {
+            printk("++ge2d configing error.\n");
+            ppmgr_vf_put_dec(vf);
+            vfq_push(&q_free, new_vf);
+            return;
+        }
+        fillrect(context, 0, 0, canvas_width, canvas_height, 0x008080ff);
+        ppmgr_3d_clear_count--;
+    }
+
+    if(vf->type & VIDTYPE_MVC){
+        pic_struct = (GE2D_FORMAT_M24_YUV420T & (3<<3));
+    }else{
+        pic_struct = 0;
+    }
+    /* data operating. */
+    memset(ge2d_config,0,sizeof(config_para_ex_t));
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+
+    canvas_read(mask_canvas_index,&cm);
+    ge2d_config->src2_planes[0].addr = cm.addr;
+    ge2d_config->src2_planes[0].w = cm.width;
+    ge2d_config->src2_planes[0].h = cm.height;
+
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_key.key_color = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    if(is_vertical_sample_enable(vf)){
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = vf->height/2;
+    }else{
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
+    }
+
+    ge2d_config->src2_key.key_enable = 1;
+    ge2d_config->src2_key.key_mask = 0x00ffffff;
+    ge2d_config->src2_key.key_mode = (switch_flag)?1:0;
+    ge2d_config->src2_key.key_color = 0xff000000;
+    ge2d_config->src2_para.canvas_index=mask_canvas_index;
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src2_para.format = GE2D_FORMAT_S8_Y;
+    ge2d_config->src2_para.fill_color_en = 0;
+    ge2d_config->src2_para.fill_mode = 0;
+    ge2d_config->src2_para.x_rev = 0;
+    ge2d_config->src2_para.y_rev = 0;
+    ge2d_config->src2_para.color = 0x00808000;
+    ge2d_config->src2_para.top = 0;
+    ge2d_config->src2_para.left = 0;
+    ge2d_config->src2_para.width = canvas_width;
+    ge2d_config->src2_para.height = canvas_height;
+
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = canvas_width;
+    ge2d_config->dst_para.height = canvas_height;
+
+    if(angle==1){
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.x_rev = 1;
+    }else if(angle==2){
+        ge2d_config->dst_para.x_rev = 1;
+        ge2d_config->dst_para.y_rev=1;
+    }else if(angle==3)  {
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.y_rev=1;
+    }
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
+
+    //printk("--first frame: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
+    //      input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height,
+    //      l,t,w,h,new_vf->width,new_vf->height);
+    if(scale_down>1){
+        if(angle&1){
+            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
+            w = w/scale_down;
+        }else{
+            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
+            h = h/scale_down;
+        }
+    }
+
+    if(is_vertical_sample_enable(vf)){
+       blend(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height/2,
+           l,t,w,h,l,t,w,h,
+           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
+    }else{
+       blend(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,(pic_struct)?(input_frame.content_height/2):input_frame.content_height,
+           l,t,w,h,l,t,w,h,
+           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
+    }
+
+    /* data operating. */
+    memset(ge2d_config,0,sizeof(config_para_ex_t));
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+
+    canvas_read(mask_canvas_index,&cm);
+    ge2d_config->src2_planes[0].addr = cm.addr;
+    ge2d_config->src2_planes[0].w = cm.width;
+    ge2d_config->src2_planes[0].h = cm.height;
+
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_key.key_color = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    if(is_vertical_sample_enable(vf)){
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = vf->height/2;
+    }else{
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
+    }
+
+    ge2d_config->src2_key.key_enable = 1;
+    ge2d_config->src2_key.key_mask = 0x00ffffff;
+    ge2d_config->src2_key.key_mode = (switch_flag)?0:1;
+    ge2d_config->src2_key.key_color = 0xff000000;
+    ge2d_config->src2_para.canvas_index=mask_canvas_index;
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src2_para.format = GE2D_FORMAT_S8_Y;
+    ge2d_config->src2_para.fill_color_en = 0;
+    ge2d_config->src2_para.fill_mode = 0;
+    ge2d_config->src2_para.x_rev = 0;
+    ge2d_config->src2_para.y_rev = 0;
+    ge2d_config->src2_para.color = 0x00808000;
+    ge2d_config->src2_para.top = 0;
+    ge2d_config->src2_para.left = 0;
+    ge2d_config->src2_para.width = canvas_width;
+    ge2d_config->src2_para.height = canvas_height;
+
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = canvas_width;
+    ge2d_config->dst_para.height = canvas_height;
+
+    if(angle==1){
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.x_rev = 1;
+    }else if(angle==2){
+        ge2d_config->dst_para.x_rev = 1;
+        ge2d_config->dst_para.y_rev=1;
+    }else if(angle==3)  {
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.y_rev=1;
+    }
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
+
+    if(x_offset){
+        if(angle&1){
+            int dst_h = 0;
+            if(dir){  //move down
+                if((t+x_offset+h)<=new_vf->height){ //only pan
+                    if(angle == 3){
+                        t = t - x_offset;
+                        t &= ~1;
+                    }else{
+                        t = t + x_offset;
+                        t &= ~1;
+                    }
+                }else if((t+x_offset)<new_vf->height){  //need cut
+                    t = t + x_offset;
+                    t &= ~1;
+                    dst_h = new_vf->height - t;
+                    input_frame.content_width = ((((input_frame.content_width*dst_h) <<8)+0x80)/h)>>8;
+                    h = dst_h;
+                    if(angle == 3){
+                        t = 0;
+                    }
+                }else{
+                    printk("++2d->3d error, out of range1.\n");
+                }
+            }else{//move up
+                if(t>=x_offset){ //only pan
+                    if(angle == 3){
+                        t = t + x_offset;
+                        t &= ~1;
+                    }else{
+                        t = t - x_offset;
+                        t &= ~1;
+                    }
+                }else if((t+h)>x_offset){  //need cut
+                    int src_w = 0, src_l = 0;
+                    t = 0;
+                    dst_h = h + t - x_offset;
+                    src_w = ((((input_frame.content_width*dst_h) <<8)+0x80)/h)>>8;
+                    h = dst_h;
+                    src_l = input_frame.content_left + input_frame.content_width - src_w;
+                    src_l &= ~1;
+                    input_frame.content_width = input_frame.content_width + input_frame.content_left - src_l;
+                    input_frame.content_left = src_l;
+                    if(angle == 3){
+                        t = t + x_offset;
+                    }
+                }else{
+                    printk("++2d->3d error, out of range2.\n");
+                }
+            }
+        }else{
+            int dst_w = 0;
+            if(dir){  //move right
+                if((l+x_offset+w)<=new_vf->width){ //only pan
+                    if(angle == 2){
+                        l = l - x_offset;
+                        l &= ~1;
+                    }else{
+                        l = l + x_offset;
+                        l &= ~1;
+                    }
+                }else if((l+x_offset)<new_vf->width){  //need cut
+                    l = l + x_offset;
+                    l &= ~1;
+                    dst_w = new_vf->width - l;
+                    input_frame.content_width = ((((input_frame.content_width*dst_w) <<8)+0x80)/w)>>8;
+                    w = dst_w;
+                    if(angle == 2){
+                        l = 0;
+                    }
+                }else{
+                    printk("++2d->3d error, out of range1.\n");
+                }
+            }else{//move left
+                if(l>=x_offset){ //only pan
+                    if(angle == 2){
+                        l = l + x_offset;
+                        l &= ~1;
+                    }else{
+                        l = l - x_offset;
+                        l &= ~1;
+                    }
+                }else if((l+w)>x_offset){  //need cut
+                    int src_w = 0, src_l = 0;
+                    l = 0;
+                    dst_w = w + l - x_offset;
+                    src_w = ((((input_frame.content_width*dst_w) <<8)+0x80)/w)>>8;
+                    w = dst_w;
+                    src_l = input_frame.content_left + input_frame.content_width - src_w;
+                    src_l &= ~1;
+                    input_frame.content_width = input_frame.content_width + input_frame.content_left - src_l;
+                    input_frame.content_left = src_l;
+                    if(angle == 2){
+                        l = l + x_offset;
+                    }
+                }else{
+                    printk("++2d->3d error, out of range2.\n");
+                }
+            }
+        }
+    }
+
+    if(scale_down>1){
+        if(angle&1){
+            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
+            w = w/scale_down;
+            new_vf->width = new_vf->width/scale_down;
+        }else{
+            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
+            h = h/scale_down;
+            new_vf->height = new_vf->height/scale_down;
+        }
+    }
+
+    if(is_vertical_sample_enable(vf)){
+       blend(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height/2,
+           l,t,w,h,l,t,w,h,
+           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
+    }else{
+       blend(context,input_frame.content_left,input_frame.content_top,input_frame.content_width,(pic_struct)?(input_frame.content_height/2):input_frame.content_height,
+           l,t,w,h,l,t,w,h,
+           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
+    }
+
+    //printk("--second frame: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
+    //      input_frame.content_left,input_frame.content_top,input_frame.content_width,input_frame.content_height,
+    //      l,t,w,h,new_vf->width,new_vf->height);
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+}
+
+/*for 3D video input processing
+    1. output window should 1:1 as video layer size
+    2. must adjust GE2D operation according with the frame ratio ,then clear ratio control flag
+    3. need generate two buffer from source frame
+    4. input format should be YUV422 , output format should be YUV444
+*/
+
+// for 90 degree and 270 degree, use interlace mode to output mix data.
+void process_3d_ex(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config,unsigned angle)
+{
+    vframe_t *new_vf;
+    ppframe_t *pp_vf;
+    display_frame_t l_frame,r_frame;
+    canvas_t cs0,cs1,cs2,cd;
+    int t,l,w,h;
+    unsigned char switch_flag = _3d_process.switch_flag;
+    int canvas_width = ppmgr_device.canvas_width;
+    int canvas_height = ppmgr_device.canvas_height;
+    int scale_down = get_ppmgr_scaledown()+1;
+    int pic_struct = 0;
+
+    new_vf = vfq_pop(&q_free);
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+
+    //int interlace_mode = vf->type & VIDTYPE_TYPEMASK;
+
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    new_vf->ratio_control = ((scale_down>1)?DISP_RATIO_FORCE_FULL_STRETCH:DISP_RATIO_FORCE_NORMALWIDE)|DISP_RATIO_FORCECONFIG;
+    new_vf->duration = vf->duration;
+    new_vf->duration_pulldown = vf->duration_pulldown;
+    new_vf->pts = vf->pts;
+    if(ppmgr_device.disp_width>ppmgr_device.disp_height)
+        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;
+    else
+        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE;
+    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(pp_vf->index);
+
+    //get_input_frame(vf,&input_frame);
+    get_input_l_frame(vf,&l_frame);
+    get_input_r_frame(vf,&r_frame);
+
+    new_vf->width= ppmgr_device.disp_width;
+    new_vf->height= ppmgr_device.disp_height;
+
+    if(ppmgr_3d_clear_count>0){
+        //clear rect
+        memset(ge2d_config,0,sizeof(config_para_ex_t));
+        ge2d_config->alu_const_color= 0;//0x000000ff;
+        ge2d_config->bitmask_en  = 0;
+        ge2d_config->src1_gb_alpha = 0;//0xff;
+        ge2d_config->dst_xy_swap = 0;
+
+        canvas_read(new_vf->canvas0Addr&0xff,&cd);
+        ge2d_config->src_planes[0].addr = cd.addr;
+        ge2d_config->src_planes[0].w = cd.width;
+        ge2d_config->src_planes[0].h = cd.height;
+        ge2d_config->dst_planes[0].addr = cd.addr;
+        ge2d_config->dst_planes[0].w = cd.width;
+        ge2d_config->dst_planes[0].h = cd.height;
+
+        ge2d_config->src_key.key_enable = 0;
+        ge2d_config->src_key.key_mask = 0;
+        ge2d_config->src_key.key_mode = 0;
+
+        ge2d_config->src_para.canvas_index=new_vf->canvas0Addr;
+        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->src_para.fill_color_en = 0;
+        ge2d_config->src_para.fill_mode = 0;
+        ge2d_config->src_para.x_rev = 0;
+        ge2d_config->src_para.y_rev = 0;
+        ge2d_config->src_para.color = 0;
+        ge2d_config->src_para.top = 0;
+        ge2d_config->src_para.left = 0;
+        ge2d_config->src_para.width = canvas_width;
+        ge2d_config->src_para.height = canvas_height;
+
+        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+        ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->dst_para.fill_color_en = 0;
+        ge2d_config->dst_para.fill_mode = 0;
+        ge2d_config->dst_para.x_rev = 0;
+        ge2d_config->dst_para.y_rev = 0;
+        ge2d_config->dst_para.color = 0;
+        ge2d_config->dst_para.top = 0;
+        ge2d_config->dst_para.left = 0;
+        ge2d_config->dst_para.width = canvas_width;
+        ge2d_config->dst_para.height = canvas_height;
+
+        if(ge2d_context_config_ex(context,ge2d_config)<0) {
+            printk("++ge2d configing error.\n");
+            ppmgr_vf_put_dec(vf);
+            vfq_push(&q_free, new_vf);
+            return;
+        }
+        fillrect(context, 0, 0, canvas_width, canvas_height, 0x008080ff);
+        ppmgr_3d_clear_count--;
+    }
+
+    if(vf->type & VIDTYPE_MVC){
+        pic_struct = (GE2D_FORMAT_M24_YUV420T & (3<<3));
+    }else{
+        pic_struct = 0;
+    }
+    /* data operating. */
+    memset(ge2d_config,0,sizeof(config_para_ex_t));
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_key.key_color = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    if(is_vertical_sample_enable(vf)){
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = vf->height/2;
+    }else{
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
+    }
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444|(switch_flag?(GE2D_FORMAT_M24_YUV420B & (3<<3)):(GE2D_FORMAT_M24_YUV420T & (3<<3)));
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = canvas_width;
+    ge2d_config->dst_para.height = canvas_height>>1;
+
+    if(angle==1){
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.x_rev = 1;
+    }else if(angle==2){
+
+        ge2d_config->dst_para.x_rev = 1;
+        ge2d_config->dst_para.y_rev=1;
+    }else if(angle==3)  {
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.y_rev=1;
+    }
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
+
+    if(scale_down>1){
+        if(angle&1){
+            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
+            w = w/scale_down;
+        }else{
+            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
+            h = h/scale_down;
+        }
+    }
+
+    //printk("--l frame ex: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
+    //      l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height,
+    //      l,t,w,h,new_vf->width,new_vf->height);
+
+    if(is_vertical_sample_enable(vf)){
+       stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height/2,
+           l,t/2,w,h/2);
+    }else{
+       stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,(pic_struct)?(l_frame.content_height/2):l_frame.content_height,
+           l,t/2,w,h/2);
+    }
+
+    if(vf->type & VIDTYPE_MVC){
+        pic_struct = (GE2D_FORMAT_M24_YUV420B & (3<<3));
+    }else{
+        pic_struct = 0;
+    }
+    /* data operating. */
+    memset(ge2d_config,0,sizeof(config_para_ex_t));
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas1Addr&0xff,&cs0);
+    canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_key.key_color = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas1Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    if(is_vertical_sample_enable(vf)){
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = vf->height/2;
+    }else{
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
+    }
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444|(switch_flag?(GE2D_FORMAT_M24_YUV420T & (3<<3)):(GE2D_FORMAT_M24_YUV420B & (3<<3)));
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = canvas_width;
+    ge2d_config->dst_para.height = canvas_height>>1;
+
+    if(angle==1){
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.x_rev = 1;
+    }else if(angle==2){
+        ge2d_config->dst_para.x_rev = 1;
+        ge2d_config->dst_para.y_rev=1;
+    }else if(angle==3)  {
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.y_rev=1;
+    }
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
+
+    if(scale_down>1){
+        if(angle&1){
+            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
+            w = w/scale_down;
+            new_vf->width = new_vf->width/scale_down;
+        }else{
+            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
+            h = h/scale_down;
+            new_vf->height = new_vf->height/scale_down;
+        }
+    }
+
+    //printk("--r frame ex: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
+    //      r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height,
+    //      l,t,w,h,new_vf->width,new_vf->height);
+
+    if(is_vertical_sample_enable(vf)){
+       stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height/2,
+           l,t/2,w,h/2);
+    }else{
+       stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,(pic_struct)?(r_frame.content_height/2):r_frame.content_height,
+           l,t/2,w,h/2);
+    }
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+}
+
+void process_3d(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config,unsigned angle)
+{
+    vframe_t *new_vf;
+    ppframe_t *pp_vf;
+    display_frame_t l_frame,r_frame;
+    canvas_t cs0,cs1,cs2,cd,cm;
+    int t,l,w,h;
+    unsigned char  switch_flag = _3d_process.switch_flag;
+    int canvas_width = ppmgr_device.canvas_width;
+    int canvas_height = ppmgr_device.canvas_height;
+    int scale_down = get_ppmgr_scaledown()+1;
+    int pic_struct = 0;
+
+    new_vf = vfq_pop(&q_free);
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+
+    //int interlace_mode = vf->type & VIDTYPE_TYPEMASK;
+
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    new_vf->ratio_control = ((scale_down>1)?DISP_RATIO_FORCE_FULL_STRETCH:DISP_RATIO_FORCE_NORMALWIDE)|DISP_RATIO_FORCECONFIG;
+    new_vf->duration = vf->duration;
+    new_vf->duration_pulldown = vf->duration_pulldown;
+    new_vf->pts = vf->pts;
+    if(ppmgr_device.disp_width>ppmgr_device.disp_height)
+        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;
+    else
+        new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE;
+    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(pp_vf->index);
+
+    //get_input_frame(vf,&input_frame);
+    get_input_l_frame(vf,&l_frame);
+    get_input_r_frame(vf,&r_frame);
+
+    new_vf->width= ppmgr_device.disp_width;
+    new_vf->height= ppmgr_device.disp_height;
+
+    if(ppmgr_3d_clear_count>0){
+        //clear rect
+        memset(ge2d_config,0,sizeof(config_para_ex_t));
+        ge2d_config->alu_const_color= 0;//0x000000ff;
+        ge2d_config->bitmask_en  = 0;
+        ge2d_config->src1_gb_alpha = 0;//0xff;
+        ge2d_config->dst_xy_swap = 0;
+
+        canvas_read(new_vf->canvas0Addr&0xff,&cd);
+        ge2d_config->src_planes[0].addr = cd.addr;
+        ge2d_config->src_planes[0].w = cd.width;
+        ge2d_config->src_planes[0].h = cd.height;
+        ge2d_config->dst_planes[0].addr = cd.addr;
+        ge2d_config->dst_planes[0].w = cd.width;
+        ge2d_config->dst_planes[0].h = cd.height;
+
+        ge2d_config->src_key.key_enable = 0;
+        ge2d_config->src_key.key_mask = 0;
+        ge2d_config->src_key.key_mode = 0;
+
+        ge2d_config->src_para.canvas_index=new_vf->canvas0Addr;
+        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->src_para.fill_color_en = 0;
+        ge2d_config->src_para.fill_mode = 0;
+        ge2d_config->src_para.x_rev = 0;
+        ge2d_config->src_para.y_rev = 0;
+        ge2d_config->src_para.color = 0;
+        ge2d_config->src_para.top = 0;
+        ge2d_config->src_para.left = 0;
+        ge2d_config->src_para.width = canvas_width;
+        ge2d_config->src_para.height = canvas_height;
+
+        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+        ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->dst_para.fill_color_en = 0;
+        ge2d_config->dst_para.fill_mode = 0;
+        ge2d_config->dst_para.x_rev = 0;
+        ge2d_config->dst_para.y_rev = 0;
+        ge2d_config->dst_para.color = 0;
+        ge2d_config->dst_para.top = 0;
+        ge2d_config->dst_para.left = 0;
+        ge2d_config->dst_para.width = canvas_width;
+        ge2d_config->dst_para.height = canvas_height;
+
+        if(ge2d_context_config_ex(context,ge2d_config)<0) {
+            printk("++ge2d configing error.\n");
+            ppmgr_vf_put_dec(vf);
+            vfq_push(&q_free, new_vf);
+            return;
+        }
+        fillrect(context, 0, 0, canvas_width, canvas_height, 0x008080ff);
+        ppmgr_3d_clear_count--;
+    }
+
+    /* data operating. */
+    if(vf->type & VIDTYPE_MVC){
+        pic_struct = (GE2D_FORMAT_M24_YUV420T & (3<<3));
+    }else{
+        pic_struct = 0;
+    }
+
+    memset(ge2d_config,0,sizeof(config_para_ex_t));
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+
+    canvas_read(mask_canvas_index,&cm);
+    ge2d_config->src2_planes[0].addr = cm.addr;
+    ge2d_config->src2_planes[0].w = cm.width;
+    ge2d_config->src2_planes[0].h = cm.height;
+
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_key.key_color = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    if(is_vertical_sample_enable(vf)){
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = vf->height/2;
+    }else{
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
+    }
+
+    ge2d_config->src2_key.key_enable = 1;
+    ge2d_config->src2_key.key_mask = 0x00ffffff;
+    ge2d_config->src2_key.key_mode = (switch_flag)?1:0;
+    ge2d_config->src2_key.key_color = 0xff000000;
+    ge2d_config->src2_para.canvas_index=mask_canvas_index;
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src2_para.format = GE2D_FORMAT_S8_Y;
+    ge2d_config->src2_para.fill_color_en = 0;
+    ge2d_config->src2_para.fill_mode = 0;
+    ge2d_config->src2_para.x_rev = 0;
+    ge2d_config->src2_para.y_rev = 0;
+    ge2d_config->src2_para.color = 0x00808000;
+    ge2d_config->src2_para.top = 0;
+    ge2d_config->src2_para.left = 0;
+    ge2d_config->src2_para.width = canvas_width;
+    ge2d_config->src2_para.height = canvas_height;
+
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = canvas_width;
+    ge2d_config->dst_para.height = canvas_height;
+
+    if(angle==1){
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.x_rev = 1;
+    }else if(angle==2){
+        ge2d_config->dst_para.x_rev = 1;
+        ge2d_config->dst_para.y_rev=1;
+    }else if(angle==3)  {
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.y_rev=1;
+    }
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
+
+    if(scale_down>1){
+        if(angle&1){
+            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
+            w = w/scale_down;
+        }else{
+            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
+            h = h/scale_down;
+        }
+    }
+
+    //printk("--l frame: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
+    //      l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height,
+    //      l,t,w,h,new_vf->width,new_vf->height);
+
+    if(is_vertical_sample_enable(vf)){
+       blend(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height/2,
+           l,t,w,h,l,t,w,h,
+           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
+    }else{
+       blend(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,(pic_struct)?(l_frame.content_height/2):l_frame.content_height,
+           l,t,w,h,l,t,w,h,
+           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
+    }
+
+    if(vf->type & VIDTYPE_MVC){
+        pic_struct = (GE2D_FORMAT_M24_YUV420B & (3<<3));
+    }else{
+        pic_struct = 0;
+    }
+    /* data operating. */
+    memset(ge2d_config,0,sizeof(config_para_ex_t));
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas1Addr&0xff,&cs0);
+    canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+
+    canvas_read(mask_canvas_index,&cm);
+    ge2d_config->src2_planes[0].addr = cm.addr;
+    ge2d_config->src2_planes[0].w = cm.width;
+    ge2d_config->src2_planes[0].h = cm.height;
+
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_key.key_color = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas1Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    if(is_vertical_sample_enable(vf)){
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = vf->height/2;
+    }else{
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
+    }
+
+    ge2d_config->src2_key.key_enable = 1;
+    ge2d_config->src2_key.key_mask = 0x00ffffff;
+    ge2d_config->src2_key.key_mode = (switch_flag)?0:1;
+    ge2d_config->src2_key.key_color = 0xff000000;
+    ge2d_config->src2_para.canvas_index=mask_canvas_index;
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src2_para.format = GE2D_FORMAT_S8_Y;
+    ge2d_config->src2_para.fill_color_en = 0;
+    ge2d_config->src2_para.fill_mode = 0;
+    ge2d_config->src2_para.x_rev = 0;
+    ge2d_config->src2_para.y_rev = 0;
+    ge2d_config->src2_para.color = 0x00808000;
+    ge2d_config->src2_para.top = 0;
+    ge2d_config->src2_para.left = 0;
+    ge2d_config->src2_para.width = canvas_width;
+    ge2d_config->src2_para.height = canvas_height;
+
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = canvas_width;
+    ge2d_config->dst_para.height = canvas_height;
+
+    if(angle==1){
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.x_rev = 1;
+    }else if(angle==2){
+        ge2d_config->dst_para.x_rev = 1;
+        ge2d_config->dst_para.y_rev=1;
+    }else if(angle==3)  {
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.y_rev=1;
+    }
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
+
+    if(scale_down>1){
+        if(angle&1){
+            l = ((new_vf->width/scale_down) - (w/scale_down))/2;
+            w = w/scale_down;
+            new_vf->width = new_vf->width/scale_down;
+        }else{
+            t = ((new_vf->height/scale_down) - (h/scale_down))/2;
+            h = h/scale_down;
+            new_vf->height = new_vf->height/scale_down;
+        }
+    }
+
+    //printk("--r frame: %d,%d,%d,%d.out put:%d,%d,%d,%d. frame size: %d,%d.\n",
+    //      r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height,
+    //      l,t,w,h,new_vf->width,new_vf->height);
+
+    if(is_vertical_sample_enable(vf)){
+       blend(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height/2,
+           l,t,w,h,l,t,w,h,
+           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
+    }else{
+       blend(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,(pic_struct)?(r_frame.content_height/2):r_frame.content_height,
+           l,t,w,h,l,t,w,h,
+           blendop(OPERATION_ADD,COLOR_FACTOR_ONE,COLOR_FACTOR_ZERO,OPERATION_ADD,ALPHA_FACTOR_ZERO,ALPHA_FACTOR_ZERO));
+    }
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+}
+
+//void process_bt(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config,int swith_flag)
+//{
+//
+//}
+
+static void process_field_depth(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+
+}
+
+void process_3d_to_2d(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+    vframe_t *new_vf;
+    ppframe_t *pp_vf;
+    //int index;
+    //display_frame_t input_frame ;
+    display_frame_t src_frame;
+    canvas_t cs0,cs1,cs2,cd;
+    int t,l,w,h;
+    unsigned char l_r = _3d_process._3d_to_2d_use_frame;
+    unsigned angle = get_ppmgr_direction3d();//_3d_process.direction;
+    int canvas_width = ppmgr_device.canvas_width;
+    int canvas_height = ppmgr_device.canvas_height;
+    int scale_down = get_ppmgr_scaledown()+1;
+    int pic_struct = 0;
+
+    new_vf = vfq_pop(&q_free);
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+
+    //int interlace_mode = vf->type & VIDTYPE_TYPEMASK;
+
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    new_vf->ratio_control = ((scale_down>1)?DISP_RATIO_FORCE_FULL_STRETCH:DISP_RATIO_FORCE_NORMALWIDE)|DISP_RATIO_FORCECONFIG;
+    new_vf->duration = vf->duration;
+    new_vf->duration_pulldown = vf->duration_pulldown;
+    new_vf->pts = vf->pts;
+    //new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE;
+    new_vf->type = VIDTYPE_VIU_444 | VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;
+    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(pp_vf->index);
+
+    //get_input_frame(vf,&input_frame);
+    if(!l_r)
+        get_input_l_frame(vf,&src_frame);
+    else
+        get_input_r_frame(vf,&src_frame);
+
+    new_vf->width= ppmgr_device.disp_width;
+    new_vf->height= ppmgr_device.disp_height;
+
+    if(ppmgr_3d_clear_count>0){
+        //clear rect
+        memset(ge2d_config,0,sizeof(config_para_ex_t));
+        ge2d_config->alu_const_color= 0;//0x000000ff;
+        ge2d_config->bitmask_en  = 0;
+        ge2d_config->src1_gb_alpha = 0;//0xff;
+        ge2d_config->dst_xy_swap = 0;
+
+        canvas_read(new_vf->canvas0Addr&0xff,&cd);
+        ge2d_config->src_planes[0].addr = cd.addr;
+        ge2d_config->src_planes[0].w = cd.width;
+        ge2d_config->src_planes[0].h = cd.height;
+        ge2d_config->dst_planes[0].addr = cd.addr;
+        ge2d_config->dst_planes[0].w = cd.width;
+        ge2d_config->dst_planes[0].h = cd.height;
+
+        ge2d_config->src_key.key_enable = 0;
+        ge2d_config->src_key.key_mask = 0;
+        ge2d_config->src_key.key_mode = 0;
+
+        ge2d_config->src_para.canvas_index=new_vf->canvas0Addr;
+        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->src_para.fill_color_en = 0;
+        ge2d_config->src_para.fill_mode = 0;
+        ge2d_config->src_para.x_rev = 0;
+        ge2d_config->src_para.y_rev = 0;
+        ge2d_config->src_para.color = 0;
+        ge2d_config->src_para.top = 0;
+        ge2d_config->src_para.left = 0;
+        ge2d_config->src_para.width = canvas_width;
+        ge2d_config->src_para.height = canvas_height;
+
+        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+        ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->dst_para.fill_color_en = 0;
+        ge2d_config->dst_para.fill_mode = 0;
+        ge2d_config->dst_para.x_rev = 0;
+        ge2d_config->dst_para.y_rev = 0;
+        ge2d_config->dst_para.color = 0;
+        ge2d_config->dst_para.top = 0;
+        ge2d_config->dst_para.left = 0;
+        ge2d_config->dst_para.width = canvas_width;
+        ge2d_config->dst_para.height = canvas_height;
+
+        if(ge2d_context_config_ex(context,ge2d_config)<0) {
+            printk("++ge2d configing error.\n");
+            ppmgr_vf_put_dec(vf);
+            vfq_push(&q_free, new_vf);
+            return;
+        }
+        fillrect(context, 0, 0, canvas_width, canvas_height, 0x008080ff);
+        ppmgr_3d_clear_count--;
+    }
+
+    if(vf->type & VIDTYPE_MVC){
+        pic_struct = (l_r)?(GE2D_FORMAT_M24_YUV420B & (3<<3)):(GE2D_FORMAT_M24_YUV420T & (3<<3));
+    }else{
+        pic_struct = 0;
+    }
+    /* data operating. */
+    memset(ge2d_config,0,sizeof(config_para_ex_t));
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    if(l_r){
+        canvas_read(vf->canvas1Addr&0xff,&cs0);
+        canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
+        canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
+    }else{
+        canvas_read(vf->canvas0Addr&0xff,&cs0);
+        canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+        canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    }
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_para.canvas_index=(l_r)?vf->canvas1Addr:vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf)|pic_struct;
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    if(is_vertical_sample_enable(vf)){
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = vf->height/2;
+    }else{
+        ge2d_config->src_para.width = vf->width;
+        ge2d_config->src_para.height = (pic_struct)?(vf->height/2):vf->height;
+    }
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = canvas_width;
+    ge2d_config->dst_para.height = canvas_height;
+
+    if(angle==1){
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.x_rev = 1;
+    }else if(angle==2){
+        ge2d_config->dst_para.x_rev = 1;
+        ge2d_config->dst_para.y_rev=1;
+    }else if(angle==3)  {
+        ge2d_config->dst_xy_swap=1;
+        ge2d_config->dst_para.y_rev=1;
+    }
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+    get_output_rect_after_ratio(vf,&t,&l,&w,&h,vf->width,vf->height,new_vf->width,new_vf->height,angle);
+
+    if(scale_down>1){
+        t = ((new_vf->height/scale_down) - (h/scale_down))/2;
+        h = h/scale_down;
+        new_vf->height = new_vf->height/scale_down;
+        l = ((new_vf->width/scale_down) - (w/scale_down))/2;
+        w = w/scale_down;
+        new_vf->width = new_vf->width/scale_down;
+    }
+
+    if(is_vertical_sample_enable(vf)){
+        stretchblt_noalpha(context, src_frame.content_left,src_frame.content_top,src_frame.content_width,src_frame.content_height/2,l,t,w,h);
+    }else{
+        stretchblt_noalpha(context, src_frame.content_left,src_frame.content_top,src_frame.content_width,(pic_struct)?(src_frame.content_height/2):src_frame.content_height,l,t,w,h);
+    }
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+}
+
+/********************************************************************/
+
+void ppmgr_vf_3d(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+    display_frame_t input_frame ;
+    display_frame_t l_frame ,r_frame ;
+    canvas_t cd;
+    int cur_angle = 0;
+    int process_type = get_mid_process_type(vf);
+    cur_process_type = process_type;
+    get_input_frame(vf,&input_frame);
+    get_input_l_frame(vf,&l_frame);
+    get_input_r_frame(vf,&r_frame);
+
+
+    canvas_read(vf->canvas0Addr&0xff,&cd);
+    if(vf->type&VIDTYPE_VIU_422){
+         cd.width >>=1;
+    }
+    if(((input_frame.content_left +input_frame.content_width )> cd.width )
+      ||((input_frame.content_top +input_frame.content_height ) > cd.height )
+      ||((input_frame.frame_left +input_frame.frame_width )> cd.width )
+      ||((input_frame.frame_top +input_frame.frame_height ) > cd.height )){
+        ppmgr_vf_put_dec(vf);
+        printk("case 1: vdin canvas setting is not compatible with vframe!!!\n");
+        return ;
+
+    }
+
+    if(((l_frame.content_left +l_frame.content_width )> cd.width )
+      ||((l_frame.content_top +l_frame.content_height ) > cd.height )
+      ||((l_frame.frame_left +l_frame.frame_width )> cd.width )
+      ||((l_frame.frame_top +l_frame.frame_height ) > cd.height )){
+        ppmgr_vf_put_dec(vf);
+        printk("case 2: vdin canvas setting is not compatible with vframe!!!\n");
+        return ;
+    }
+
+    if(((r_frame.content_left +r_frame.content_width )> cd.width )
+      ||((r_frame.content_top +r_frame.content_height ) > cd.height )
+      ||((r_frame.frame_left +r_frame.frame_width )> cd.width )
+      ||((r_frame.frame_top +r_frame.frame_height ) > cd.height )){
+        ppmgr_vf_put_dec(vf);
+        printk("case 3:vdin canvas setting is not compatible with vframe!!!\n");
+        return ;
+    }
+    cur_angle = get_ppmgr_direction3d();//_3d_process.direction;
+    switch(process_type){
+        case TYPE_NONE:
+ //           printk("process  none type\n");
+            process_none(vf,context,ge2d_config);
+            break;
+        case TYPE_2D_TO_3D:
+ //           printk("process 2d to 3d type\n");
+            //if(_3d_process._2d_to_3d_type == PPMGR_3D_PROCESS_2D_TO_3D_NORMAL)
+            if(cur_angle&1)
+                process_2d_to_3d_ex(vf,context,ge2d_config,cur_angle);
+            else
+                process_2d_to_3d(vf,context,ge2d_config,cur_angle);
+            //else
+            //    process_field_depth(vf,context,ge2d_config);
+            break;
+        case TYPE_3D_LR:
+        case TYPE_3D_TB:
+            //printk("process  3d type\n");
+            if(cur_angle&1)
+                process_3d_ex(vf,context,ge2d_config,cur_angle);
+            else
+                process_3d(vf,context,ge2d_config,cur_angle);
+            break;
+        case TYPE_3D_TO_2D_LR:
+        case TYPE_3D_TO_2D_TB:
+//            printk("process  3d to 2d type\n");
+            process_3d_to_2d(vf,context,ge2d_config);
+            break;
+        default:
+            break;
+    }
+}
+
+int Init3DBuff(int canvas_id)
+{
+    void __iomem * mask_start = NULL;
+    unsigned char mask = 0xff;
+    canvas_t canvas_mask;
+    int k = 0;
+    unsigned char *buff = NULL;
+
+    mask_canvas_index = canvas_id;
+    canvas_read(mask_canvas_index,&canvas_mask);
+    mask_start = ioremap_wc(canvas_mask.addr,canvas_mask.width*canvas_mask.height);
+    buff = (unsigned char*)mask_start;
+
+    while(k<canvas_mask.width*canvas_mask.height){
+        buff[k] = mask;
+        mask = ~mask;
+        k++;
+    }
+    iounmap(mask_start);
+    return 0;
+}
diff --git a/drivers/amlogic/ppmgr/ppmgr_3d_tv.c b/drivers/amlogic/ppmgr/ppmgr_3d_tv.c
old mode 100644
new mode 100755
index 999b3e33..b08c8667
--- a/drivers/amlogic/ppmgr/ppmgr_3d_tv.c
+++ b/drivers/amlogic/ppmgr/ppmgr_3d_tv.c
@@ -1,3373 +1,3373 @@
-#include <linux/kernel.h>
-#include <linux/types.h>
-#include <linux/errno.h>
-#include <linux/interrupt.h>
-#include <linux/timer.h>
-#include <linux/amlogic/vout/vinfo.h>
-#include <linux/amlogic/vout/vout_notify.h>
-#include <linux/platform_device.h>
-#include <linux/amlogic/amports/timestamp.h>
-#include <linux/amlogic/amports/ptsserv.h>
-#include <linux/amlogic/amports/canvas.h>
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/amports/vframe_provider.h>
-#include <linux/amlogic/amports/vfp.h>
-#include <mach/am_regs.h>
-#include <linux/amlogic/amlog.h>
-#include <linux/amlogic/ge2d/ge2d.h>
-#include <linux/amlogic/ge2d/ge2d_wq.h>
-#include <linux/kthread.h>
-#include <linux/delay.h>
-#include <linux/semaphore.h>
-#include <linux/sched.h>
-#include "ppmgr_log.h"
-#include "ppmgr_pri.h"
-#include "ppmgr_dev.h"
-#include <linux/amlogic/ppmgr/ppmgr.h>
-#include <linux/amlogic/ppmgr/ppmgr_status.h>
-#include <linux/io.h>
-#define RECEIVER_NAME "ppmgr"
-#define PROVIDER_NAME   "ppmgr"
-#define VF_POOL_SIZE 4
-extern vfq_t q_ready;
-extern vfq_t q_free;
-typedef struct display_frame_s{
-    int frame_top;
-    int frame_left;
-    int frame_width;
-    int frame_height;
-    int content_top;
-    int content_left;
-    int content_width;
-    int content_height;
-}display_frame_t;
-
-extern int get_ppmgr_vertical_sample(void);
-extern int get_ppmgr_scale_width(void);
-extern int get_ppmgr_view_mode(void);
-extern u32 index2canvas(u32 index);
-extern void ppmgr_vf_put_dec(vframe_t *vf);
-static inline u32 index2canvas_0(u32 index)
-{
-    const u32 canvas_tab[4] = {
-        PPMGR_DOUBLE_CANVAS_INDEX+0, PPMGR_DOUBLE_CANVAS_INDEX+1, PPMGR_DOUBLE_CANVAS_INDEX+2, PPMGR_DOUBLE_CANVAS_INDEX+3
-    };
-    return canvas_tab[index];
-}
-static inline u32 index2canvas_1(u32 index)
-{
-    const u32 canvas_tab[4] = {
-        PPMGR_DOUBLE_CANVAS_INDEX+4, PPMGR_DOUBLE_CANVAS_INDEX+5, PPMGR_DOUBLE_CANVAS_INDEX+6, PPMGR_DOUBLE_CANVAS_INDEX+7
-    };
-    return canvas_tab[index];
-}
-
-static void window_clear_3D(ge2d_context_t *context, config_para_ex_t* ge2d_config,int index ,int l ,int t ,int w ,int h);
-static int cur_process_type =0;
-extern int ppmgr_cutwin_top ;
-extern int ppmgr_cutwin_left ;
-extern frame_info_t frame_info;
-int get_tv_process_type(vframe_t* vf)
-{
-    int process_type = 0 ;
-    int status = get_ppmgr_status();
-    if(!vf){
-        process_type = TYPE_NONE ;
-        return process_type;
-    }
-    if(status & MODE_3D_ENABLE){
-        if(status & MODE_LR_SWITCH){
-            process_type = TYPE_LR_SWITCH ;
-        }else if(status & MODE_FIELD_DEPTH){
-            process_type = TYPE_FILED_DEPTH ;
-        }else if(status & MODE_3D_TO_2D_L){
-            process_type = TYPE_3D_TO_2D_L ;
-        }else if(status & MODE_3D_TO_2D_R){
-            process_type = TYPE_3D_TO_2D_R ;
-        }else{
-            if(status & MODE_LR){
-                process_type = TYPE_LR;
-            }
-            if(status & MODE_BT){
-                process_type = TYPE_BT;
-            }
-            if(status &MODE_2D_TO_3D){
-                process_type  =TYPE_2D_TO_3D;
-            }
-            /*3D auto mode*/
-            if(status &MODE_AUTO){
-				switch(vf->trans_fmt){
-					case TVIN_TFMT_3D_TB:
-					process_type = TYPE_BT;
-					break;
-					case TVIN_TFMT_3D_FP:
-					process_type = TYPE_LR;
-					break;
-					case TVIN_TFMT_3D_LRH_OLOR :
-					case TVIN_TFMT_3D_LRH_OLER :
-					case TVIN_TFMT_3D_LRH_ELOR :
-					case TVIN_TFMT_3D_LRH_ELER :
-					process_type = TYPE_LR;
-					break;
-					default:
-					process_type = TYPE_NONE ;
-					break;
-				}
-			}
-        }
-    }else{
-        process_type = TYPE_NONE;
-    }
-    return process_type;
-}
-
-int is_need_cut_window_support(vframe_t* vf)
-{
-	int ret = 0;
-#if 1
-	if(vf->type&VIDTYPE_VIU_422){
-		ret  = 1;
-	}
-#else
-	ret = 1;
-#endif
-	return ret ;
-}
-
-int is_mvc_need_process(vframe_t* vf)
-{
-	int ret = 0 ;
-	int process_type = cur_process_type;
-	switch(process_type){
-        //case TYPE_LR_SWITCH:
-        case TYPE_3D_TO_2D_L:
-        case TYPE_3D_TO_2D_R:
-            ret = 1;
-            break;
-        default:
-            break;
-	}
-	return ret;
-}
-/*1 local player ; 2 1080P frame ; 3 user enablesetting */
-static int is_vertical_sample_enable(vframe_t* vf)
-{
-	int ret = 0 ;
-	int process_type = cur_process_type;
-	int status = get_ppmgr_status();
-	if(get_ppmgr_vertical_sample()){
-		if((process_type == TYPE_LR )
-		||((process_type == TYPE_LR_SWITCH )&&(!(status &BT_FORMAT_INDICATOR)))
-		||(process_type == TYPE_2D_TO_3D )){
-		 	if(!(vf->type&VIDTYPE_VIU_422)){
-		 		if((vf->width > 1280)&&(vf->height > 720)){
-		 			ret = 1 ;
-		 		}
-		 	}
-		}
-	}
-	if((!(status &BT_FORMAT_INDICATOR))&&(process_type !=TYPE_BT)){
-	if((vf->type &VIDTYPE_INTERLACE_BOTTOM)||(vf->type &VIDTYPE_INTERLACE_TOP)){
-		ret = 1 ;
-	}
-	}
-	return ret;
-}
-
-
-int is_local_source(vframe_t* vf)
-{
-	int ret = 0 ;
-    if(vf->type&VIDTYPE_VIU_422){
-        ret = 0;
-    }else{
-    	ret = 1;
-    }
-    return ret;
-}
-static int get_input_format(vframe_t* vf)
-{
-    int format= GE2D_FORMAT_M24_YUV420;
-    if(vf->type&VIDTYPE_VIU_422){
-        format =  GE2D_FORMAT_S16_YUV422;
-    }else if(vf->type&VIDTYPE_VIU_NV21){
-    	if(is_vertical_sample_enable(vf)){
-	    	 if(vf->type &VIDTYPE_INTERLACE_BOTTOM){
-	    	 	format =  GE2D_FORMAT_M24_NV21|(GE2D_FORMAT_M24_NV21B & (3<<3));
-	    	 	}else if(vf->type &VIDTYPE_INTERLACE_TOP){
-	    	 	format =  GE2D_FORMAT_M24_NV21|(GE2D_FORMAT_M24_NV21T & (3<<3));
-	    	 }else{
-	        	format =  GE2D_FORMAT_M24_NV21;
-	    	 }     	
-    	}else{
-    		 format =  GE2D_FORMAT_M24_NV21;
-    	}    	
-    }else{
-    	 if(is_vertical_sample_enable(vf)){
-    	 	if(vf->type &VIDTYPE_INTERLACE_BOTTOM){
-    	 		format =  GE2D_FORMAT_M24_YUV420|(GE2D_FMT_M24_YUV420B & (3<<3));
-    	 	}else if(vf->type &VIDTYPE_INTERLACE_TOP){
-    	 	format =  GE2D_FORMAT_M24_YUV420|(GE2D_FORMAT_M24_YUV420T & (3<<3));
-    	 }else{
-    	 		format =  GE2D_FORMAT_M24_YUV420|(GE2D_FORMAT_M24_YUV420T & (3<<3));
-    	 	}
-    	 }else{
-        	format =  GE2D_FORMAT_M24_YUV420;
-    	 }
-    }
-    return format;
-}
-
-int get_input_frame(vframe_t* vf , display_frame_t* frame)
-{
-    if(frame == NULL){
-        return -1;
-    }
-    if(vf->type & VIDTYPE_MVC){
-	frame->content_top = vf->left_eye.start_y   ;
-	frame->content_left = vf->left_eye.start_x ;
-	frame->content_width = vf->left_eye.width    ;
-	frame->content_height = vf->left_eye.height  ;
-	frame->frame_top =    vf->left_eye.start_y ;
-	frame->frame_left =   vf->left_eye.start_x;
-	frame->frame_width=   vf->left_eye.width ;
-	frame->frame_height = vf->left_eye.height;
-	return 0;
-    }
-/*tv in case , need detect the black bar*/
-	if((vf->prop.bbar.bottom)&&(vf->prop.bbar.right)
-	&&(vf->prop.bbar.right > vf->prop.bbar.left)
-	&&(vf->prop.bbar.bottom > vf->prop.bbar.top )){
-		switch(vf->trans_fmt){
-			case 	TVIN_TFMT_2D:
-			frame->content_top = vf->prop.bbar.top   ;
-			frame->content_left = vf->prop.bbar.left  ;
-			frame->content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
-			frame->content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
-			frame->frame_top =    0;
-			frame->frame_left =   0;
-			frame->frame_width=   vf->width;
-			frame->frame_height = vf->height;
-			break;
-			case TVIN_TFMT_3D_FP:
-			case TVIN_TFMT_3D_LRH_OLER:
-			case TVIN_TFMT_3D_TB:
-			frame->content_top = vf->left_eye.start_y   ;
-			frame->content_left = vf->left_eye.start_x ;
-			frame->content_width = vf->left_eye.width    ;
-			frame->content_height = vf->left_eye.height  ;
-			frame->frame_top =    vf->left_eye.start_y ;
-			frame->frame_left =   vf->left_eye.start_x;
-			frame->frame_width=   vf->left_eye.width ;
-			frame->frame_height = vf->left_eye.height;
-			break;
-			default:
-			frame->content_top = vf->prop.bbar.top   ;
-			frame->content_left = vf->prop.bbar.left  ;
-			frame->content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
-			frame->content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
-			frame->frame_top =    0;
-			frame->frame_left =   0;
-			frame->frame_width=   vf->width;
-			frame->frame_height = vf->height;
-			break;
-		}
-//	    printk("full_frame: format  is %d , top is %d , left is %d , width is %d , height is %d\n",vf->trans_fmt ,frame->content_top ,frame->content_left,frame->content_width,frame->content_height);
-	}else{
-		switch(vf->trans_fmt){
-			case 	TVIN_TFMT_2D:
-			frame->content_top = 0  ;
-			frame->content_left = 0  ;
-			frame->content_width = vf->width;    ;
-			frame->content_height = vf->height;
-			frame->frame_top =    0;
-			frame->frame_left =   0;
-			frame->frame_width=   vf->width;
-			frame->frame_height = vf->height;
-			break;
-			case TVIN_TFMT_3D_FP:
-			case TVIN_TFMT_3D_LRH_OLER:
-			case TVIN_TFMT_3D_TB:
-			frame->content_top = vf->left_eye.start_y   ;
-			frame->content_left = vf->left_eye.start_x ;
-			frame->content_width = vf->left_eye.width    ;
-			frame->content_height = vf->left_eye.height  ;
-			frame->frame_top =    vf->left_eye.start_y ;
-			frame->frame_left =   vf->left_eye.start_x;
-			frame->frame_width=   vf->left_eye.width ;
-			frame->frame_height = vf->left_eye.height;
-			break;
-			default:
-			frame->content_top = 0  ;
-			frame->content_left = 0  ;
-			frame->content_width = vf->width;
-			frame->content_height = vf->height;
-			frame->frame_top =    0;
-			frame->frame_left =   0;
-			frame->frame_width=   vf->width;
-			frame->frame_height = vf->height;
-			break;
-		}
-	}
-	return 0;
-}
-
-static int get_input_l_frame(vframe_t* vf , display_frame_t* frame)
-{
-    int content_top ,content_left ,content_width ,content_height;
-    int status = get_ppmgr_status();
-    if(frame == NULL){
-        return -1;
-    }
-    if(vf->type & VIDTYPE_MVC){
-	frame->content_top = vf->left_eye.start_y   ;
-	frame->content_left = vf->left_eye.start_x ;
-	frame->content_width = vf->left_eye.width    ;
-	frame->content_height = vf->left_eye.height  ;
-	frame->frame_top =    vf->left_eye.start_y;
-	frame->frame_left =   vf->left_eye.start_x;
-	frame->frame_width=   vf->left_eye.width;
-	frame->frame_height = vf->left_eye.height;
-	return 0;
-    }
-/*tv in case , need detect the black bar*/
-	if((vf->prop.bbar.bottom)&&(vf->prop.bbar.right)
-	&&(vf->prop.bbar.right > vf->prop.bbar.left)
-	&&(vf->prop.bbar.bottom > vf->prop.bbar.top )){
-		switch(vf->trans_fmt){
-			case 	TVIN_TFMT_2D:
-			content_top = vf->prop.bbar.top   ;
-			content_left = vf->prop.bbar.left  ;
-			content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
-			content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
-
-			if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
-				if(is_need_cut_window_support(vf)){
-					if(content_top >= ppmgr_cutwin_top ){
-						frame->content_top = content_top  ;
-						frame->content_height = content_height/2  ;
-					}else{
-						frame->content_top = ppmgr_cutwin_top ;
-						frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
-					}
-					if(content_left >= ppmgr_cutwin_left ){
-						frame->content_left = content_left  ;
-						frame->content_width = content_width ;
-					}else{
-						frame->content_left = ppmgr_cutwin_left ;
-						frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
-					}
-
-				}else{
-				frame->content_top = content_top  ;
-				frame->content_left = content_left ;
-				frame->content_width = content_width    ;
-				frame->content_height = content_height/2  ;
-				}
-			}else{
-				if(is_need_cut_window_support(vf)){
-					if(content_top >= ppmgr_cutwin_top ){
-						frame->content_top = content_top  ;
-						frame->content_height = content_height  ;
-					}else{
-						frame->content_top = ppmgr_cutwin_top ;
-						frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
-					}
-					if(content_left >= ppmgr_cutwin_left ){
-						frame->content_left = content_left  ;
-						frame->content_width = content_width/2 ;
-					}else{
-						frame->content_left = ppmgr_cutwin_left ;
-						frame->content_width = content_width/2 - 2* (ppmgr_cutwin_left - content_left);
-					}
-			}else{
-				frame->content_top = content_top  ;
-				frame->content_left = content_left ;
-				frame->content_width = content_width/2    ;
-				frame->content_height = content_height  ;
-			}
-			}
-			frame->frame_top =    0;
-			frame->frame_left =   0;
-			frame->frame_width=   vf->width;
-			frame->frame_height = vf->height;
-			break;
-			case TVIN_TFMT_3D_FP:
-			case TVIN_TFMT_3D_LRH_OLER:
-			case TVIN_TFMT_3D_TB:
-				frame->content_top = vf->left_eye.start_y   ;
-				frame->content_left = vf->left_eye.start_x ;
-				frame->content_width = vf->left_eye.width    ;
-				frame->content_height = vf->left_eye.height  ;
-				frame->frame_top =    vf->left_eye.start_y;
-				frame->frame_left =   vf->left_eye.start_x;
-				frame->frame_width=   vf->left_eye.width;
-				frame->frame_height = vf->left_eye.height;
-				break;
-			default:
-				content_top = vf->prop.bbar.top   ;
-				content_left = vf->prop.bbar.left  ;
-				content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
-				content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
-				if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
-					if(is_need_cut_window_support(vf)){
-						if(content_top >= ppmgr_cutwin_top ){
-							frame->content_top = content_top  ;
-							frame->content_height = content_height/2  ;
-						}else{
-							frame->content_top = ppmgr_cutwin_top ;
-							frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
-						}
-						if(content_left >= ppmgr_cutwin_left ){
-							frame->content_left = content_left  ;
-							frame->content_width = content_width ;
-						}else{
-							frame->content_left = ppmgr_cutwin_left ;
-							frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
-						}
-
-					}else{
-					frame->content_top = content_top  ;
-					frame->content_left = content_left ;
-					frame->content_width = content_width    ;
-					frame->content_height = content_height/2  ;
-					}
-				}else{
-					if(is_need_cut_window_support(vf)){
-						if(content_top >= ppmgr_cutwin_top ){
-							frame->content_top = content_top  ;
-							frame->content_height = content_height  ;
-						}else{
-							frame->content_top = ppmgr_cutwin_top ;
-							frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
-						}
-						if(content_left >= ppmgr_cutwin_left ){
-							frame->content_left = content_left  ;
-							frame->content_width = content_width/2 ;
-						}else{
-							frame->content_left = ppmgr_cutwin_left ;
-							frame->content_width = content_width/2 - 2* (ppmgr_cutwin_left - content_left);
-						}
-				}else{
-					frame->content_top = content_top  ;
-					frame->content_left = content_left ;
-					frame->content_width = content_width/2    ;
-					frame->content_height = content_height  ;
-				}
-				}
-				frame->frame_top =    0;
-				frame->frame_left =   0;
-				frame->frame_width=   vf->width;
-				frame->frame_height = vf->height;
-				break;
-		}
-//	    printk("lframe: format  is %d , top is %d , left is %d , width is %d , height is %d\n",vf->trans_fmt ,frame->content_top ,frame->content_left,frame->content_width,frame->content_height);
-	}else{
-		switch(vf->trans_fmt){
-			case 	TVIN_TFMT_2D:
-			content_top = 0  ;
-			content_left = 0  ;
-			content_width = vf->width;    ;
-			content_height = vf->height;
-			if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
-				if(is_need_cut_window_support(vf)){
-					if(content_top >= ppmgr_cutwin_top ){
-						frame->content_top = content_top  ;
-						frame->content_height = content_height/2  ;
-					}else{
-						frame->content_top = ppmgr_cutwin_top ;
-						frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
-					}
-					if(content_left >= ppmgr_cutwin_left ){
-						frame->content_left = content_left  ;
-						frame->content_width = content_width ;
-					}else{
-						frame->content_left = ppmgr_cutwin_left ;
-						frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
-					}
-
-				}else{
-				frame->content_top = content_top  ;
-				frame->content_left = content_left ;
-				frame->content_width = content_width    ;
-				frame->content_height = content_height/2  ;
-				}
-			}else{
-				if(is_need_cut_window_support(vf)){
-					if(content_top >= ppmgr_cutwin_top ){
-						frame->content_top = content_top  ;
-						frame->content_height = content_height  ;
-					}else{
-						frame->content_top = ppmgr_cutwin_top ;
-						frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
-					}
-					if(content_left >= ppmgr_cutwin_left ){
-						frame->content_left = content_left  ;
-						frame->content_width = content_width/2 ;
-					}else{
-						frame->content_left = ppmgr_cutwin_left ;
-						frame->content_width = content_width/2 - 2* (ppmgr_cutwin_left - content_left);
-					}
-			}else{
-				frame->content_top = content_top  ;
-				frame->content_left = content_left ;
-				frame->content_width = content_width/2    ;
-				frame->content_height = content_height  ;
-			}
-			}
-			frame->frame_top =    0;
-			frame->frame_left =   0;
-			frame->frame_width=   vf->width;
-			frame->frame_height = vf->height;
-			break;
-			case TVIN_TFMT_3D_FP:
-			case TVIN_TFMT_3D_LRH_OLER:
-			case TVIN_TFMT_3D_TB:
-				frame->content_top = vf->left_eye.start_y   ;
-				frame->content_left = vf->left_eye.start_x ;
-				frame->content_width = vf->left_eye.width    ;
-				frame->content_height = vf->left_eye.height  ;
-				frame->frame_top =    vf->left_eye.start_y;
-				frame->frame_left =   vf->left_eye.start_x;
-				frame->frame_width=   vf->left_eye.width;
-				frame->frame_height = vf->left_eye.height;
-				break;
-			default:
-				content_top = 0  ;
-				content_left = 0  ;
-				content_width = vf->width;    ;
-				content_height = vf->height;
-				if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
-					if(is_need_cut_window_support(vf)){
-						if(content_top >= ppmgr_cutwin_top ){
-							frame->content_top = content_top  ;
-							frame->content_height = content_height/2  ;
-						}else{
-							frame->content_top = ppmgr_cutwin_top ;
-							frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
-						}
-						if(content_left >= ppmgr_cutwin_left ){
-							frame->content_left = content_left  ;
-							frame->content_width = content_width ;
-						}else{
-							frame->content_left = ppmgr_cutwin_left ;
-							frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
-						}
-
-					}else{
-					frame->content_top = content_top  ;
-					frame->content_left = content_left ;
-					frame->content_width = content_width    ;
-					frame->content_height = content_height/2  ;
-					}
-				}else{
-					if(is_need_cut_window_support(vf)){
-						if(content_top >= ppmgr_cutwin_top ){
-							frame->content_top = content_top  ;
-							frame->content_height = content_height  ;
-						}else{
-							frame->content_top = ppmgr_cutwin_top ;
-							frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
-						}
-						if(content_left >= ppmgr_cutwin_left ){
-							frame->content_left = content_left  ;
-							frame->content_width = content_width/2 ;
-						}else{
-							frame->content_left = ppmgr_cutwin_left ;
-							frame->content_width = content_width/2 - 2* (ppmgr_cutwin_left - content_left);
-						}
-				}else{
-					frame->content_top = content_top  ;
-					frame->content_left = content_left ;
-					frame->content_width = content_width/2    ;
-					frame->content_height = content_height  ;
-				}
-				}
-				frame->frame_top =    0;
-				frame->frame_left =   0;
-				frame->frame_width=   vf->width;
-				frame->frame_height = vf->height;
-				break;
-		}
-	}
-
-	return 0;
-}
-
-
-
-static int get_input_r_frame(vframe_t* vf , display_frame_t* frame)
-{
-    int content_top ,content_left ,content_width ,content_height;
-    int status = get_ppmgr_status();
-    if(frame == NULL){
-        return -1;
-    }
-    if(vf->type & VIDTYPE_MVC){
-	frame->content_top = vf->right_eye.start_y   ;
-	frame->content_left = vf->right_eye.start_x ;
-	frame->content_width = vf->right_eye.width    ;
-	frame->content_height = vf->right_eye.height  ;
-	frame->frame_top =    vf->right_eye.start_y;
-	frame->frame_left =   vf->right_eye.start_x;
-	frame->frame_width=   vf->right_eye.width;
-	frame->frame_height = vf->right_eye.height;
-	return 0;
-    }
-/*tv in case , need detect the black bar*/
-	if((vf->prop.bbar.bottom)&&(vf->prop.bbar.right)
-	&&(vf->prop.bbar.right > vf->prop.bbar.left)
-	&&(vf->prop.bbar.bottom > vf->prop.bbar.top )){
-		switch(vf->trans_fmt){
-			case 	TVIN_TFMT_2D:
-				content_top = vf->prop.bbar.top   ;
-				content_left = vf->prop.bbar.left  ;
-				content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
-				content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
-
-				if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
-					if(is_need_cut_window_support(vf)){
-						if(content_top >= ppmgr_cutwin_top ){
-							frame->content_top = content_top + content_height/2   ;
-							frame->content_height = content_height/2  ;
-						}else{
-							frame->content_top = vf->height/2 + (ppmgr_cutwin_top - content_top);
-							frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
-						}
-						if(content_left >= ppmgr_cutwin_left ){
-							frame->content_left = content_left  ;
-							frame->content_width = content_width ;
-						}else{
-							frame->content_left = ppmgr_cutwin_left ;
-							frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
-						}
-
-					}else{
-					frame->content_top = content_top + content_height/2 ;
-					frame->content_left = content_left ;
-					frame->content_width = content_width    ;
-					frame->content_height = content_height/2  ;
-					}
-				}else{
-					if(is_need_cut_window_support(vf)){
-						if(content_top >= ppmgr_cutwin_top ){
-							frame->content_top = content_top  ;
-							frame->content_height = content_height  ;
-						}else{
-							frame->content_top = ppmgr_cutwin_top ;
-							frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
-						}
-						if(content_left >= ppmgr_cutwin_left ){
-							frame->content_left = content_width/2 + content_left  ;
-							frame->content_width = content_width/2 ;
-						}else{
-							frame->content_left = vf->width/2  +  (ppmgr_cutwin_left - content_left) ;
-							frame->content_width = content_width/2 - 2 *(ppmgr_cutwin_left - content_left);
-						}
-				}else{
-					frame->content_top = content_top  ;
-					frame->content_left = content_width/2 + content_left ;
-					frame->content_width = content_width/2    ;
-					frame->content_height = content_height  ;
-				}
-				}
-				frame->frame_top = 0;
-				frame->frame_left = 0;
-				frame->frame_width= vf->width;
-				frame->frame_height = vf->height;
-				break;
-			case TVIN_TFMT_3D_FP:
-			case TVIN_TFMT_3D_LRH_OLER:
-			case TVIN_TFMT_3D_TB:
-				frame->content_top = vf->right_eye.start_y   ;
-				frame->content_left = vf->right_eye.start_x ;
-				frame->content_width = vf->right_eye.width    ;
-				frame->content_height = vf->right_eye.height  ;
-				frame->frame_top =    vf->right_eye.start_y;
-				frame->frame_left =   vf->right_eye.start_x;
-				frame->frame_width=   vf->right_eye.width;
-				frame->frame_height = vf->right_eye.height;
-				break;
-			default:
-				content_top = vf->prop.bbar.top   ;
-				content_left = vf->prop.bbar.left  ;
-				content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
-				content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
-				if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
-					if(is_need_cut_window_support(vf)){
-						if(content_top >= ppmgr_cutwin_top ){
-							frame->content_top = content_top + content_height/2   ;
-							frame->content_height = content_height/2  ;
-						}else{
-							frame->content_top = vf->height/2 + (ppmgr_cutwin_top - content_top);
-							frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
-						}
-						if(content_left >= ppmgr_cutwin_left ){
-							frame->content_left = content_left  ;
-							frame->content_width = content_width ;
-						}else{
-							frame->content_left = ppmgr_cutwin_left ;
-							frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
-						}
-
-					}else{
-					frame->content_top = content_top + content_height/2 ;
-					frame->content_left = content_left ;
-					frame->content_width = content_width    ;
-					frame->content_height = content_height/2  ;
-					}
-				}else{
-					if(is_need_cut_window_support(vf)){
-						if(content_top >= ppmgr_cutwin_top ){
-							frame->content_top = content_top  ;
-							frame->content_height = content_height  ;
-						}else{
-							frame->content_top = ppmgr_cutwin_top ;
-							frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
-						}
-						if(content_left >= ppmgr_cutwin_left ){
-							frame->content_left = content_width/2 + content_left  ;
-							frame->content_width = content_width/2 ;
-						}else{
-							frame->content_left = vf->width/2  +  (ppmgr_cutwin_left - content_left) ;
-							frame->content_width = content_width/2 - 2 *(ppmgr_cutwin_left - content_left);
-						}
-				}else{
-					frame->content_top = content_top  ;
-					frame->content_left = content_width/2 + content_left ;
-					frame->content_width = content_width/2    ;
-					frame->content_height = content_height  ;
-				}
-				}
-				frame->frame_top = 0;
-				frame->frame_left = 0;
-				frame->frame_width= vf->width;
-				frame->frame_height = vf->height;
-				break;
-		}
-//		printk("rframe : format  is %d , top is %d , left is %d , width is %d , height is %d\n",vf->trans_fmt ,frame->content_top ,frame->content_left,frame->content_width,frame->content_height);
-	}else{
-		switch(vf->trans_fmt){
-			case 	TVIN_TFMT_2D:
-			content_top = 0  ;
-			content_left = 0  ;
-			content_width = vf->width;    ;
-			content_height = vf->height;
-			if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
-					if(is_need_cut_window_support(vf)){
-						if(content_top >= ppmgr_cutwin_top ){
-							frame->content_top = content_top + content_height/2   ;
-							frame->content_height = content_height/2  ;
-						}else{
-							frame->content_top = vf->height/2 + (ppmgr_cutwin_top - content_top);
-							frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
-						}
-						if(content_left >= ppmgr_cutwin_left ){
-							frame->content_left = content_left  ;
-							frame->content_width = content_width ;
-						}else{
-							frame->content_left = ppmgr_cutwin_left ;
-							frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
-						}
-
-					}else{
-				frame->content_top = content_top + content_height/2 ;
-				frame->content_left = content_left ;
-				frame->content_width = content_width    ;
-				frame->content_height = content_height/2  ;
-					}
-				}else{
-					if(is_need_cut_window_support(vf)){
-						if(content_top >= ppmgr_cutwin_top ){
-							frame->content_top = content_top  ;
-							frame->content_height = content_height  ;
-						}else{
-							frame->content_top = ppmgr_cutwin_top ;
-							frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
-						}
-						if(content_left >= ppmgr_cutwin_left ){
-							frame->content_left = content_width/2 + content_left  ;
-							frame->content_width = content_width/2 ;
-						}else{
-							frame->content_left = vf->width/2  +  (ppmgr_cutwin_left - content_left) ;
-							frame->content_width = content_width/2 - 2 *(ppmgr_cutwin_left - content_left);
-						}
-			}else{
-				frame->content_top = content_top  ;
-				frame->content_left = content_width/2 + content_left ;
-				frame->content_width = content_width/2    ;
-				frame->content_height = content_height  ;
-			}
-				}
-				frame->frame_top = 0;
-				frame->frame_left = 0;
-				frame->frame_width= vf->width;
-				frame->frame_height = vf->height;
-
-			break;
-			case TVIN_TFMT_3D_FP:
-			case TVIN_TFMT_3D_LRH_OLER:
-			case TVIN_TFMT_3D_TB:
-				frame->content_top = vf->right_eye.start_y   ;
-				frame->content_left = vf->right_eye.start_x ;
-				frame->content_width = vf->right_eye.width    ;
-				frame->content_height = vf->right_eye.height  ;
-				frame->frame_top =    vf->right_eye.start_y;
-				frame->frame_left =   vf->right_eye.start_x;
-				frame->frame_width=   vf->right_eye.width;
-				frame->frame_height = vf->right_eye.height;
-				break;
-			default:
-				content_top = 0  ;
-				content_left = 0  ;
-				content_width = vf->width;    ;
-				content_height = vf->height;
-				if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
-					if(is_need_cut_window_support(vf)){
-						if(content_top >= ppmgr_cutwin_top ){
-							frame->content_top = content_top + content_height/2   ;
-							frame->content_height = content_height/2  ;
-						}else{
-							frame->content_top = vf->height/2 + (ppmgr_cutwin_top - content_top);
-							frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
-						}
-						if(content_left >= ppmgr_cutwin_left ){
-							frame->content_left = content_left  ;
-							frame->content_width = content_width ;
-						}else{
-							frame->content_left = ppmgr_cutwin_left ;
-							frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
-						}
-
-					}else{
-					frame->content_top = content_top + content_height/2 ;
-					frame->content_left = content_left ;
-					frame->content_width = content_width    ;
-					frame->content_height = content_height/2  ;
-					}
-				}else{
-					if(is_need_cut_window_support(vf)){
-						if(content_top >= ppmgr_cutwin_top ){
-							frame->content_top = content_top  ;
-							frame->content_height = content_height  ;
-						}else{
-							frame->content_top = ppmgr_cutwin_top ;
-							frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
-						}
-						if(content_left >= ppmgr_cutwin_left ){
-							frame->content_left = content_width/2 + content_left  ;
-							frame->content_width = content_width/2 ;
-						}else{
-							frame->content_left = vf->width/2  +  (ppmgr_cutwin_left - content_left) ;
-							frame->content_width = content_width/2 - 2 *(ppmgr_cutwin_left - content_left);
-						}
-				}else{
-					frame->content_top = content_top  ;
-					frame->content_left = content_width/2 + content_left ;
-					frame->content_width = content_width/2    ;
-					frame->content_height = content_height  ;
-				}
-				}
-				frame->frame_top = 0;
-				frame->frame_left = 0;
-				frame->frame_width= vf->width;
-				frame->frame_height = vf->height;
-				break;
-		}
-	}
-	return 0;
-}
-
-
-
-static int get_output_format(int flag)
-{
-    return frame_info.format;
-}
-
-static int get_output_width(int flag)
-{
-    const vinfo_t *vinfo;
-    vinfo = get_current_vinfo();
-    switch(flag){
-        case 0:
-        case 2:
-            return frame_info.width;
-            break;
-        case 1:
-            return vinfo->width;
-            break;
-        default:
-            break;
-    }
-    return 0;
-}
-void x_offset_adjust(vframe_t* vf , int* offset , int screen_width ,int v_screen_width )
-{
-	int ww;
-	int ll = *offset;
-	int trick_mode =0 ;
-
-	ww = screen_width ;
-
-//	if(current_view_mode == VIEWMODE_4_3){
-//		return;
-//	}
-//	printk("pre offset is %d \n" , *offset);
-	query_video_status(0 , &trick_mode) ;
-    if(trick_mode){
-    	return;
-    }
-	if((vf->width < 960)||((vf->type&VIDTYPE_VIU_422)&&(cur_process_type !=TYPE_2D_TO_3D))||(ww <= v_screen_width)){
-		return;
-	}
-	if(vf->width <= 1280){
-		v_screen_width  = 1280;
-	}
-	*offset=  (((v_screen_width << 16)/ww)*ll) >>16;
-
-//	printk("after offset is %d \n" , *offset);
-}
-
-
-
-void axis_h_adjust(vframe_t* vf , int* left ,  int* width , int* screen_width ,int v_screen_width )
-{
-	int l,w ,ww;
-	int trick_mode =0 ;
-
-	ww = *screen_width ;
-
-	query_video_status(0 , &trick_mode) ;
-    if(trick_mode){
-    	return;
-    }
-	if(((vf->type&VIDTYPE_VIU_422)&&(cur_process_type !=TYPE_2D_TO_3D))||(ww <= v_screen_width)){
-		return;
-	}
-	if(vf->width <= 1280){
-		v_screen_width  = 1280;
-	}
-	l = *left ;
-	w =*width;
-	*left=  (((v_screen_width << 16)/ww)*l) >>16;
-	*width = (((v_screen_width << 16)/ww)*w) >> 16;
-	*width = (*width + 1)&(~1);
-	*screen_width = v_screen_width ;
-}
-
-int get_output_height(int flag)
-{
-    const vinfo_t *vinfo;
-    vinfo = get_current_vinfo();
-    switch(flag){
-        case 0:
-        case 2:
-            return frame_info.height;
-            break;
-        case 1:
-            return vinfo->height;
-            break;
-        default:
-            break;
-    }
-    return frame_info.height;
-}
-
-static int get_output_rect_after_ratio(vframe_t* vf ,int* top , int*left , int* width , int* height ,int in_width, int in_height, int output_width,int output_height)
-{
-    int t,l,w,h;
-    int current_view_mode = 0 ;
-    w = output_width;
-    h = output_height;
-    t = 0 ;
-    l = 0;
-    current_view_mode  = get_ppmgr_view_mode();
-    switch(current_view_mode){
-    	case VIEWMODE_4_3:
-    	//vf->ratio_control = ((3 <<8)/4) << DISP_RATIO_ASPECT_RATIO_BIT;
-    	vf->ratio_control = (0xc0 << DISP_RATIO_ASPECT_RATIO_BIT);
-    	break;
-    	case VIEWMODE_16_9:
-    	//vf->ratio_control = ((9 << 8)/16) << DISP_RATIO_ASPECT_RATIO_BIT ;
-    	vf->ratio_control = (0x90 << DISP_RATIO_ASPECT_RATIO_BIT) ;
-    	break;
-    	case VIEWMODE_NORMAL:
-    	default:
-    	break;
-    }
-
-    if (vf->ratio_control) {
-        int ar = (vf->ratio_control >> DISP_RATIO_ASPECT_RATIO_BIT) & 0x3ff;
-        if ((ar * output_width) > (output_height << 8)) {
-            w = (output_height << 8) / ar;
-            l = (output_width - w) / 2;
-        } else {
-            h = (output_width * ar) >> 8;
-            t = (output_height - h) / 2;
-        }
-    } else {
-        if ((in_height * output_width) > (output_height *in_width)) {
-            w = (output_height * in_width) / in_height;
-            l = (output_width - w) / 2;
-        } else {
-            h = output_width * in_height / in_width;
-            t = (output_height - h) / 2;
-        }
-    }
-    l &= ~1;
-    t &= ~1;
-    w =  output_width - 2*l;
-    h  =  output_height - 2*t;
-    *top = t;
-    *left = l;
-    *width = w;
-    *height = h;
-    return 0;
-}
-
-
-int get_2d_output_rect_after_ratio(int* top , int*left , int* width , int* height ,int in_width, int in_height, int screen_width,int screen_height)
-{
-    int ww,hh;
-    int current_view_mode = 0 ;
-
-    ww = in_width;
-    hh = in_height;
-#if 0
-    if(ww * screen_height   > hh* screen_width){
-    	hh = (((ww * screen_height ) << 8)/screen_width) >> 8;
-    }else{
-    	ww = (((screen_width * hh) << 8) /screen_height) >> 8 ;
-    }
-#else
-	ww = screen_width;
-	hh = screen_height;
-#endif
-    current_view_mode  = get_ppmgr_view_mode();
-    switch(current_view_mode){
-    	case VIEWMODE_4_3:
-		*top = 0;
-		*left = ww >>3;
-		*width = (ww*3) >>2  ;
-		*height = hh;
-
-    	break;
-    	case VIEWMODE_16_9:
-		*top = 0;
-		*left = 0;
-		*width = ww ;
-		*height = hh;
-    	break;
-    	case VIEWMODE_NORMAL:
-    	default:
-		*top = 0;
-		*left = 0;
-		*width =  in_width ;
-		*height = in_height;
-    	break;
-    }
-
-    return 0;
-}
-
-/*for decoder input processing
-    1. output window should 1:1 as source frame size
-    2. keep the frame ratio
-    3. input format should be YUV420 , output format should be YUV444
-*/
-static void process_none(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-    vframe_t* new_vf;
-    ppframe_t *pp_vf;
-    
-    int index;
-    display_frame_t input_frame ;
-    display_frame_t l_frame ,r_frame ;
-    canvas_t cs0,cs1,cs2,cd;
-    //new_vf = &vfpool[fill_ptr];
-    new_vf = vfq_pop(&q_free);
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;  
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    memcpy(new_vf , vf, sizeof(vframe_t));
-    get_input_frame(vf,&input_frame);
-    get_input_l_frame(vf,&l_frame);
-    get_input_r_frame(vf,&r_frame);
-    new_vf->width= input_frame.frame_width;
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-	    new_vf->height= input_frame.frame_height;
-	}else{
-		new_vf->height= input_frame.frame_height <<1;
-	}
-    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
-    new_vf->mode_3d_enable = 0 ;
-    //new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
-    index = pp_vf->index;
-    if(index < 0){
-        printk("======decoder is full\n");
-        //return -1;
-    }
-    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(index);
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top =    0;
-    ge2d_config->src_para.left =   0;
-    ge2d_config->src_para.width =  vf->width;
-    ge2d_config->src_para.height = vf->height;
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = new_vf->width;
-    ge2d_config->dst_para.height = new_vf->height;
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-//    stretchblt_noalpha(context,input_frame.content_left,input_frame.content_top,input_frame.content_width ,input_frame.content_height,0,0,new_vf->width,new_vf->height);
-stretchblt_noalpha(context,input_frame.frame_left,input_frame.frame_top,input_frame.frame_width ,input_frame.frame_height,0,0,new_vf->width,new_vf->height);
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-}
-
-static int ratio_value = 10; // 0~255
-static void process_2d_to_3d(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-    vframe_t* new_vf;
-    ppframe_t *pp_vf;
-    int index;
-    display_frame_t input_frame ;
-    int t,l,w,h,w1,h1,w2,h2;
-    canvas_t cs0,cs1,cs2,cd;
-    unsigned x_offset = 0, y_offset = 0;
-    unsigned cut_w = 0,cut_h = 0;
-    new_vf = vfq_pop(&q_free);
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;  
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    memcpy(new_vf , vf, sizeof(vframe_t));
-    get_input_frame(vf,&input_frame);
-
-
-//    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
-    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
-    new_vf->mode_3d_enable = 1 ;
-    index = pp_vf->index;
-    if(index < 0){
-        printk("======decoder is full\n");
-        //return -1;
-    }
-
-    cut_w = (((input_frame.frame_width<<8) + 0x80) * ratio_value)>>16;
-    cut_h = (((input_frame.frame_height<<8) + 0x80) * ratio_value)>>16;
-    x_offset = cut_w>>1;
-    x_offset = x_offset & 0xfffffffe;
-    y_offset = cut_h>>1;
-    y_offset = y_offset & 0xfffffffe;
-
-    new_vf->canvas0Addr = index2canvas_0(index);
-    new_vf->canvas1Addr = index2canvas_1(index);
-//ROUND_1:
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    ge2d_config->src_para.width = vf->width;
-    ge2d_config->src_para.height = vf->height;
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    w1 = input_frame.frame_width;
-    h1 = input_frame.frame_height ;
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-    //w2 = vf->width ;
-    //h2 = vf->height;
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
-	}else{
-	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
-	}
-		t >>=1;
-		h >>=1;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2;
-
- //   printk("t:%d l:%d w:%d h%d \n",t,l,w,h);
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-//    stretchblt_noalpha(context,0,0,vf->width/2,vf->height,t,l,w,h);
-//   stretchblt_noalpha(context,0,0,vf->width,vf->height,l,t,w,h);
-    stretchblt_noalpha(context,input_frame.frame_left,input_frame.frame_top,input_frame.frame_width ,input_frame.frame_height,l,t,w,h);
-
-//ROUND_2:
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas1Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = y_offset;
-    ge2d_config->src_para.left = x_offset;
-    ge2d_config->src_para.width = vf->width-cut_w;
-    ge2d_config->src_para.height = vf->height-cut_h;
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    w1 = input_frame.frame_width;
-    h1 = input_frame.frame_height ;
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-    //w2 = vf->width ;
-    //h2 = vf->height;
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
-	}else{
-	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
-	}
-		t >>=1;
-		h >>=1;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2;
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-//    stretchblt_noalpha(context,0,vf->width/2,vf->width/2,vf->height,t,l,w,h);
-//    stretchblt_noalpha(context, x_offset, y_offset, vf->width-cut_w,vf->height-cut_h,l,t,w,h);
-
-   stretchblt_noalpha(context,input_frame.frame_left + x_offset,input_frame.frame_top + y_offset,input_frame.frame_width -cut_w ,input_frame.frame_height-cut_h,l,t,w,h);
-    new_vf->width = w2;
-    new_vf->height = h2 ;
-    new_vf->ratio_control = 0;
-
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-    return;
-}
-
-void process_2d_to_3d_switch(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-    vframe_t* new_vf;
-    ppframe_t *pp_vf;
-    int index;
-    int t,l,w,h,w1,h1,w2,h2;
-    canvas_t cs0,cs1,cs2,cd;
-    unsigned x_offset = 0, y_offset = 0;
-    unsigned cut_w = 0,cut_h = 0;
-
-    new_vf = vfq_pop(&q_free);
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;  
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    memcpy(new_vf , vf, sizeof(vframe_t));
-//    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
-    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
-    index = pp_vf->index;
-    if(index < 0){
-        printk("======decoder is full\n");
-        //return -1;
-    }
-
-    cut_w = (((vf->width<<8) + 0x80) * ratio_value)>>16;
-    cut_h = (((vf->height<<8) + 0x80) * ratio_value)>>16;
-    x_offset = cut_w>>1;
-    x_offset = x_offset & 0xfffffffe;
-    y_offset = cut_h>>1;
-    y_offset = y_offset & 0xfffffffe;
-
-    new_vf->canvas0Addr = index2canvas_0(index);
-    new_vf->canvas1Addr = index2canvas_1(index);
-//ROUND_1:
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = y_offset;
-    ge2d_config->src_para.left = x_offset;
-    ge2d_config->src_para.width = vf->width-cut_w;
-    ge2d_config->src_para.height = vf->height-cut_h;
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    w1 = vf->width;
-    h1 = vf->height ;
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-    //w2 = vf->width ;
-    //h2 = vf->height;
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
-	}else{
-	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
-	}
-		t >>=1;
-		h >>=1;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2;
-
- //   printk("t:%d l:%d w:%d h%d \n",t,l,w,h);
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-//    stretchblt_noalpha(context,0,0,vf->width/2,vf->height,t,l,w,h);
-    stretchblt_noalpha(context, x_offset, y_offset, vf->width-cut_w,vf->height-cut_h,l,t,w,h);
-
-//ROUND_2:
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas1Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = y_offset;
-    ge2d_config->src_para.left = x_offset;
-    ge2d_config->src_para.width = vf->width-cut_w;
-    ge2d_config->src_para.height = vf->height-cut_h;
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    w1 = vf->width;
-    h1 = vf->height ;
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-    //w2 = vf->width ;
-    //h2 = vf->height;
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
-	}else{
-	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
-	}
-		t >>=1;
-		h >>=1;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2;
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-//    stretchblt_noalpha(context,0,vf->width/2,vf->width/2,vf->height,t,l,w,h);
-    stretchblt_noalpha(context,0,0,vf->width,vf->height,l,t,w,h);
-    new_vf->width = w2;
-    new_vf->height = h2 ;
-    new_vf->ratio_control = 0;
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-}
-
-/*for 3D video input processing
-    1. output window should 1:1 as video layer size
-    2. must adjust GE2D operation according with the frame ratio ,then clear ratio control flag
-    3. need generate two buffer from source frame
-    4. input format should be YUV422 , output format should be YUV444
-*/
-void process_lr(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-    vframe_t* new_vf;
-    ppframe_t *pp_vf;
-    int index;
-    display_frame_t input_frame ;
-    display_frame_t l_frame ,r_frame ;
-    int t,l,w,h,w1,h1,w2,h2;
-    canvas_t cs0,cs1,cs2,cd;
-    new_vf = vfq_pop(&q_free);
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;  
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    memcpy(new_vf , vf, sizeof(vframe_t));
-    get_input_frame(vf,&input_frame);
-    get_input_l_frame(vf,&l_frame);
-    get_input_r_frame(vf,&r_frame);
-    new_vf->width= input_frame.content_width;
-    new_vf->height= input_frame.content_height;
-
-    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
-    new_vf->mode_3d_enable = 1;
-    index = pp_vf->index;
-    if(index < 0){
-        printk("======decoder is full\n");
-        //return -1;
-    }
-    new_vf->canvas0Addr = index2canvas_0(index);
-    new_vf->canvas1Addr = index2canvas_1(index);
-//ROUND_1:
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-
-//    printk("canvas 0 is %d , width is %d , height is %d \n" ,vf->canvas0Addr ,cs0.width,  cs0.height ) ;
-	ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-	ge2d_config->src_para.format = get_input_format(vf);
-	ge2d_config->src_para.fill_color_en = 0;
-	ge2d_config->src_para.fill_mode = 0;
-	ge2d_config->src_para.x_rev = 0;
-	ge2d_config->src_para.y_rev = 0;
-	ge2d_config->src_para.color = 0xffffffff;
-	ge2d_config->src_para.top = 0;
-	ge2d_config->src_para.left = 0;
-	ge2d_config->src_para.width = vf->width;
-	if(is_vertical_sample_enable(vf)){
-		ge2d_config->src_para.height = vf->height/2;
-	}else{
-		ge2d_config->src_para.height = vf->height;
-	}
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    w1 = input_frame.content_width;
-    h1 = input_frame.content_height ;
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
-	}else{
-	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
-	}
-		t >>=1;
-		h >>=1;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2/2;
-
-//    printk("t:%d l:%d w:%d h%d w2:%d h2:%d\n",t,l,w,h,w2,h2);
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-//    stretchblt_noalpha(context,0,0,vf->width/2,vf->height,t,l,w,h);
-	    axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
-	if(is_vertical_sample_enable(vf)){
-    		stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height/2,l,t,w,h);
-	}else{
-		stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height,l,t,w,h);
-	}
-//ROUND_2:
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas1Addr&0xff,&cs0);
-    canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas1Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-
-    ge2d_config->src_para.canvas_index=vf->canvas1Addr;
-
-//    printk("canvas 1 is %d , width is %d , height is %d \n" ,vf->canvas1Addr ,cs0.width,  cs0.height ) ;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    ge2d_config->src_para.width = vf->width;
-    if(is_vertical_sample_enable(vf)){
-    		ge2d_config->src_para.height = vf->height/2;
-	}else{
-		ge2d_config->src_para.height = vf->height ;
-	}
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    w1 = input_frame.content_width;
-    h1 = input_frame.content_height ;
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
-	}else{
-	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
-	}
-		t >>=1;
-		h >>=1;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2/2;
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-//    stretchblt_noalpha(context,vf->width/2 ,0,vf->width/2,vf->height,l,t,w,h);
-	axis_h_adjust(vf , &l ,  &w , &w2 , get_ppmgr_scale_width() );
-	if(is_vertical_sample_enable(vf)){
-    		stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height/2,l,t,w,h);
-	}else{
-		stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height ,l,t,w,h);
-	}
-    new_vf->width =  w2;
-    new_vf->height = h2 ;
-    new_vf->ratio_control = 0;
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-}
-
-void process_bt(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-    vframe_t* new_vf;
-    ppframe_t *pp_vf;
-    int index;
-    display_frame_t input_frame ;
-    display_frame_t l_frame ,r_frame ;
-    int t,l,w,h,w1,h1,w2,h2;
-    canvas_t cs0,cs1,cs2,cd;
-    new_vf = vfq_pop(&q_free);
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;  
+#include <linux/kernel.h>
+#include <linux/types.h>
+#include <linux/errno.h>
+#include <linux/interrupt.h>
+#include <linux/timer.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/amports/timestamp.h>
+#include <linux/amlogic/amports/ptsserv.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vfp.h>
+#include <mach/am_regs.h>
+#include <linux/amlogic/amlog.h>
+#include <linux/amlogic/ge2d/ge2d.h>
+#include <linux/amlogic/ge2d/ge2d_wq.h>
+#include <linux/kthread.h>
+#include <linux/delay.h>
+#include <linux/semaphore.h>
+#include <linux/sched.h>
+#include "ppmgr_log.h"
+#include "ppmgr_pri.h"
+#include "ppmgr_dev.h"
+#include <linux/amlogic/ppmgr/ppmgr.h>
+#include <linux/amlogic/ppmgr/ppmgr_status.h>
+#include <linux/io.h>
+#define RECEIVER_NAME "ppmgr"
+#define PROVIDER_NAME   "ppmgr"
+#define VF_POOL_SIZE 4
+extern vfq_t q_ready;
+extern vfq_t q_free;
+typedef struct display_frame_s{
+    int frame_top;
+    int frame_left;
+    int frame_width;
+    int frame_height;
+    int content_top;
+    int content_left;
+    int content_width;
+    int content_height;
+}display_frame_t;
+
+extern int get_ppmgr_vertical_sample(void);
+extern int get_ppmgr_scale_width(void);
+extern int get_ppmgr_view_mode(void);
+extern u32 index2canvas(u32 index);
+extern void ppmgr_vf_put_dec(vframe_t *vf);
+static inline u32 index2canvas_0(u32 index)
+{
+    const u32 canvas_tab[4] = {
+        PPMGR_DOUBLE_CANVAS_INDEX+0, PPMGR_DOUBLE_CANVAS_INDEX+1, PPMGR_DOUBLE_CANVAS_INDEX+2, PPMGR_DOUBLE_CANVAS_INDEX+3
+    };
+    return canvas_tab[index];
+}
+static inline u32 index2canvas_1(u32 index)
+{
+    const u32 canvas_tab[4] = {
+        PPMGR_DOUBLE_CANVAS_INDEX+4, PPMGR_DOUBLE_CANVAS_INDEX+5, PPMGR_DOUBLE_CANVAS_INDEX+6, PPMGR_DOUBLE_CANVAS_INDEX+7
+    };
+    return canvas_tab[index];
+}
+
+static void window_clear_3D(ge2d_context_t *context, config_para_ex_t* ge2d_config,int index ,int l ,int t ,int w ,int h);
+static int cur_process_type =0;
+extern int ppmgr_cutwin_top ;
+extern int ppmgr_cutwin_left ;
+extern frame_info_t frame_info;
+int get_tv_process_type(vframe_t* vf)
+{
+    int process_type = 0 ;
+    int status = get_ppmgr_status();
+    if(!vf){
+        process_type = TYPE_NONE ;
+        return process_type;
+    }
+    if(status & MODE_3D_ENABLE){
+        if(status & MODE_LR_SWITCH){
+            process_type = TYPE_LR_SWITCH ;
+        }else if(status & MODE_FIELD_DEPTH){
+            process_type = TYPE_FILED_DEPTH ;
+        }else if(status & MODE_3D_TO_2D_L){
+            process_type = TYPE_3D_TO_2D_L ;
+        }else if(status & MODE_3D_TO_2D_R){
+            process_type = TYPE_3D_TO_2D_R ;
+        }else{
+            if(status & MODE_LR){
+                process_type = TYPE_LR;
+            }
+            if(status & MODE_BT){
+                process_type = TYPE_BT;
+            }
+            if(status &MODE_2D_TO_3D){
+                process_type  =TYPE_2D_TO_3D;
+            }
+            /*3D auto mode*/
+            if(status &MODE_AUTO){
+				switch(vf->trans_fmt){
+					case TVIN_TFMT_3D_TB:
+					process_type = TYPE_BT;
+					break;
+					case TVIN_TFMT_3D_FP:
+					process_type = TYPE_LR;
+					break;
+					case TVIN_TFMT_3D_LRH_OLOR :
+					case TVIN_TFMT_3D_LRH_OLER :
+					case TVIN_TFMT_3D_LRH_ELOR :
+					case TVIN_TFMT_3D_LRH_ELER :
+					process_type = TYPE_LR;
+					break;
+					default:
+					process_type = TYPE_NONE ;
+					break;
+				}
+			}
+        }
+    }else{
+        process_type = TYPE_NONE;
+    }
+    return process_type;
+}
+
+int is_need_cut_window_support(vframe_t* vf)
+{
+	int ret = 0;
+#if 1
+	if(vf->type&VIDTYPE_VIU_422){
+		ret  = 1;
+	}
+#else
+	ret = 1;
+#endif
+	return ret ;
+}
+
+int is_mvc_need_process(vframe_t* vf)
+{
+	int ret = 0 ;
+	int process_type = cur_process_type;
+	switch(process_type){
+        //case TYPE_LR_SWITCH:
+        case TYPE_3D_TO_2D_L:
+        case TYPE_3D_TO_2D_R:
+            ret = 1;
+            break;
+        default:
+            break;
+	}
+	return ret;
+}
+/*1 local player ; 2 1080P frame ; 3 user enablesetting */
+static int is_vertical_sample_enable(vframe_t* vf)
+{
+	int ret = 0 ;
+	int process_type = cur_process_type;
+	int status = get_ppmgr_status();
+	if(get_ppmgr_vertical_sample()){
+		if((process_type == TYPE_LR )
+		||((process_type == TYPE_LR_SWITCH )&&(!(status &BT_FORMAT_INDICATOR)))
+		||(process_type == TYPE_2D_TO_3D )){
+			if(!(vf->type&VIDTYPE_VIU_422)){
+				if((vf->width > 1280)&&(vf->height > 720)){
+					ret = 1 ;
+				}
+			}
+		}
+	}
+	if((!(status &BT_FORMAT_INDICATOR))&&(process_type !=TYPE_BT)){
+	if((vf->type &VIDTYPE_INTERLACE_BOTTOM)||(vf->type &VIDTYPE_INTERLACE_TOP)){
+		ret = 1 ;
+	}
+	}
+	return ret;
+}
+
+
+int is_local_source(vframe_t* vf)
+{
+	int ret = 0 ;
+    if(vf->type&VIDTYPE_VIU_422){
+        ret = 0;
+    }else{
+	ret = 1;
+    }
+    return ret;
+}
+static int get_input_format(vframe_t* vf)
+{
+    int format= GE2D_FORMAT_M24_YUV420;
+    if(vf->type&VIDTYPE_VIU_422){
+        format =  GE2D_FORMAT_S16_YUV422;
+    }else if(vf->type&VIDTYPE_VIU_NV21){
+	if(is_vertical_sample_enable(vf)){
+		 if(vf->type &VIDTYPE_INTERLACE_BOTTOM){
+			format =  GE2D_FORMAT_M24_NV21|(GE2D_FORMAT_M24_NV21B & (3<<3));
+			}else if(vf->type &VIDTYPE_INTERLACE_TOP){
+			format =  GE2D_FORMAT_M24_NV21|(GE2D_FORMAT_M24_NV21T & (3<<3));
+		 }else{
+			format =  GE2D_FORMAT_M24_NV21;
+		 }
+	}else{
+		 format =  GE2D_FORMAT_M24_NV21;
+	}
+    }else{
+	 if(is_vertical_sample_enable(vf)){
+		if(vf->type &VIDTYPE_INTERLACE_BOTTOM){
+			format =  GE2D_FORMAT_M24_YUV420|(GE2D_FMT_M24_YUV420B & (3<<3));
+		}else if(vf->type &VIDTYPE_INTERLACE_TOP){
+		format =  GE2D_FORMAT_M24_YUV420|(GE2D_FORMAT_M24_YUV420T & (3<<3));
+	 }else{
+			format =  GE2D_FORMAT_M24_YUV420|(GE2D_FORMAT_M24_YUV420T & (3<<3));
+		}
+	 }else{
+		format =  GE2D_FORMAT_M24_YUV420;
+	 }
+    }
+    return format;
+}
+
+int get_input_frame(vframe_t* vf , display_frame_t* frame)
+{
+    if(frame == NULL){
+        return -1;
+    }
+    if(vf->type & VIDTYPE_MVC){
+	frame->content_top = vf->left_eye.start_y   ;
+	frame->content_left = vf->left_eye.start_x ;
+	frame->content_width = vf->left_eye.width    ;
+	frame->content_height = vf->left_eye.height  ;
+	frame->frame_top =    vf->left_eye.start_y ;
+	frame->frame_left =   vf->left_eye.start_x;
+	frame->frame_width=   vf->left_eye.width ;
+	frame->frame_height = vf->left_eye.height;
+	return 0;
+    }
+/*tv in case , need detect the black bar*/
+	if((vf->prop.bbar.bottom)&&(vf->prop.bbar.right)
+	&&(vf->prop.bbar.right > vf->prop.bbar.left)
+	&&(vf->prop.bbar.bottom > vf->prop.bbar.top )){
+		switch(vf->trans_fmt){
+			case 	TVIN_TFMT_2D:
+			frame->content_top = vf->prop.bbar.top   ;
+			frame->content_left = vf->prop.bbar.left  ;
+			frame->content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
+			frame->content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
+			frame->frame_top =    0;
+			frame->frame_left =   0;
+			frame->frame_width=   vf->width;
+			frame->frame_height = vf->height;
+			break;
+			case TVIN_TFMT_3D_FP:
+			case TVIN_TFMT_3D_LRH_OLER:
+			case TVIN_TFMT_3D_TB:
+			frame->content_top = vf->left_eye.start_y   ;
+			frame->content_left = vf->left_eye.start_x ;
+			frame->content_width = vf->left_eye.width    ;
+			frame->content_height = vf->left_eye.height  ;
+			frame->frame_top =    vf->left_eye.start_y ;
+			frame->frame_left =   vf->left_eye.start_x;
+			frame->frame_width=   vf->left_eye.width ;
+			frame->frame_height = vf->left_eye.height;
+			break;
+			default:
+			frame->content_top = vf->prop.bbar.top   ;
+			frame->content_left = vf->prop.bbar.left  ;
+			frame->content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
+			frame->content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
+			frame->frame_top =    0;
+			frame->frame_left =   0;
+			frame->frame_width=   vf->width;
+			frame->frame_height = vf->height;
+			break;
+		}
+//	    printk("full_frame: format  is %d , top is %d , left is %d , width is %d , height is %d\n",vf->trans_fmt ,frame->content_top ,frame->content_left,frame->content_width,frame->content_height);
+	}else{
+		switch(vf->trans_fmt){
+			case 	TVIN_TFMT_2D:
+			frame->content_top = 0  ;
+			frame->content_left = 0  ;
+			frame->content_width = vf->width;    ;
+			frame->content_height = vf->height;
+			frame->frame_top =    0;
+			frame->frame_left =   0;
+			frame->frame_width=   vf->width;
+			frame->frame_height = vf->height;
+			break;
+			case TVIN_TFMT_3D_FP:
+			case TVIN_TFMT_3D_LRH_OLER:
+			case TVIN_TFMT_3D_TB:
+			frame->content_top = vf->left_eye.start_y   ;
+			frame->content_left = vf->left_eye.start_x ;
+			frame->content_width = vf->left_eye.width    ;
+			frame->content_height = vf->left_eye.height  ;
+			frame->frame_top =    vf->left_eye.start_y ;
+			frame->frame_left =   vf->left_eye.start_x;
+			frame->frame_width=   vf->left_eye.width ;
+			frame->frame_height = vf->left_eye.height;
+			break;
+			default:
+			frame->content_top = 0  ;
+			frame->content_left = 0  ;
+			frame->content_width = vf->width;
+			frame->content_height = vf->height;
+			frame->frame_top =    0;
+			frame->frame_left =   0;
+			frame->frame_width=   vf->width;
+			frame->frame_height = vf->height;
+			break;
+		}
+	}
+	return 0;
+}
+
+static int get_input_l_frame(vframe_t* vf , display_frame_t* frame)
+{
+    int content_top ,content_left ,content_width ,content_height;
+    int status = get_ppmgr_status();
+    if(frame == NULL){
+        return -1;
+    }
+    if(vf->type & VIDTYPE_MVC){
+	frame->content_top = vf->left_eye.start_y   ;
+	frame->content_left = vf->left_eye.start_x ;
+	frame->content_width = vf->left_eye.width    ;
+	frame->content_height = vf->left_eye.height  ;
+	frame->frame_top =    vf->left_eye.start_y;
+	frame->frame_left =   vf->left_eye.start_x;
+	frame->frame_width=   vf->left_eye.width;
+	frame->frame_height = vf->left_eye.height;
+	return 0;
+    }
+/*tv in case , need detect the black bar*/
+	if((vf->prop.bbar.bottom)&&(vf->prop.bbar.right)
+	&&(vf->prop.bbar.right > vf->prop.bbar.left)
+	&&(vf->prop.bbar.bottom > vf->prop.bbar.top )){
+		switch(vf->trans_fmt){
+			case 	TVIN_TFMT_2D:
+			content_top = vf->prop.bbar.top   ;
+			content_left = vf->prop.bbar.left  ;
+			content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
+			content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
+
+			if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
+				if(is_need_cut_window_support(vf)){
+					if(content_top >= ppmgr_cutwin_top ){
+						frame->content_top = content_top  ;
+						frame->content_height = content_height/2  ;
+					}else{
+						frame->content_top = ppmgr_cutwin_top ;
+						frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
+					}
+					if(content_left >= ppmgr_cutwin_left ){
+						frame->content_left = content_left  ;
+						frame->content_width = content_width ;
+					}else{
+						frame->content_left = ppmgr_cutwin_left ;
+						frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
+					}
+
+				}else{
+				frame->content_top = content_top  ;
+				frame->content_left = content_left ;
+				frame->content_width = content_width    ;
+				frame->content_height = content_height/2  ;
+				}
+			}else{
+				if(is_need_cut_window_support(vf)){
+					if(content_top >= ppmgr_cutwin_top ){
+						frame->content_top = content_top  ;
+						frame->content_height = content_height  ;
+					}else{
+						frame->content_top = ppmgr_cutwin_top ;
+						frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
+					}
+					if(content_left >= ppmgr_cutwin_left ){
+						frame->content_left = content_left  ;
+						frame->content_width = content_width/2 ;
+					}else{
+						frame->content_left = ppmgr_cutwin_left ;
+						frame->content_width = content_width/2 - 2* (ppmgr_cutwin_left - content_left);
+					}
+			}else{
+				frame->content_top = content_top  ;
+				frame->content_left = content_left ;
+				frame->content_width = content_width/2    ;
+				frame->content_height = content_height  ;
+			}
+			}
+			frame->frame_top =    0;
+			frame->frame_left =   0;
+			frame->frame_width=   vf->width;
+			frame->frame_height = vf->height;
+			break;
+			case TVIN_TFMT_3D_FP:
+			case TVIN_TFMT_3D_LRH_OLER:
+			case TVIN_TFMT_3D_TB:
+				frame->content_top = vf->left_eye.start_y   ;
+				frame->content_left = vf->left_eye.start_x ;
+				frame->content_width = vf->left_eye.width    ;
+				frame->content_height = vf->left_eye.height  ;
+				frame->frame_top =    vf->left_eye.start_y;
+				frame->frame_left =   vf->left_eye.start_x;
+				frame->frame_width=   vf->left_eye.width;
+				frame->frame_height = vf->left_eye.height;
+				break;
+			default:
+				content_top = vf->prop.bbar.top   ;
+				content_left = vf->prop.bbar.left  ;
+				content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
+				content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
+				if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
+					if(is_need_cut_window_support(vf)){
+						if(content_top >= ppmgr_cutwin_top ){
+							frame->content_top = content_top  ;
+							frame->content_height = content_height/2  ;
+						}else{
+							frame->content_top = ppmgr_cutwin_top ;
+							frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
+						}
+						if(content_left >= ppmgr_cutwin_left ){
+							frame->content_left = content_left  ;
+							frame->content_width = content_width ;
+						}else{
+							frame->content_left = ppmgr_cutwin_left ;
+							frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
+						}
+
+					}else{
+					frame->content_top = content_top  ;
+					frame->content_left = content_left ;
+					frame->content_width = content_width    ;
+					frame->content_height = content_height/2  ;
+					}
+				}else{
+					if(is_need_cut_window_support(vf)){
+						if(content_top >= ppmgr_cutwin_top ){
+							frame->content_top = content_top  ;
+							frame->content_height = content_height  ;
+						}else{
+							frame->content_top = ppmgr_cutwin_top ;
+							frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
+						}
+						if(content_left >= ppmgr_cutwin_left ){
+							frame->content_left = content_left  ;
+							frame->content_width = content_width/2 ;
+						}else{
+							frame->content_left = ppmgr_cutwin_left ;
+							frame->content_width = content_width/2 - 2* (ppmgr_cutwin_left - content_left);
+						}
+				}else{
+					frame->content_top = content_top  ;
+					frame->content_left = content_left ;
+					frame->content_width = content_width/2    ;
+					frame->content_height = content_height  ;
+				}
+				}
+				frame->frame_top =    0;
+				frame->frame_left =   0;
+				frame->frame_width=   vf->width;
+				frame->frame_height = vf->height;
+				break;
+		}
+//	    printk("lframe: format  is %d , top is %d , left is %d , width is %d , height is %d\n",vf->trans_fmt ,frame->content_top ,frame->content_left,frame->content_width,frame->content_height);
+	}else{
+		switch(vf->trans_fmt){
+			case 	TVIN_TFMT_2D:
+			content_top = 0  ;
+			content_left = 0  ;
+			content_width = vf->width;    ;
+			content_height = vf->height;
+			if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
+				if(is_need_cut_window_support(vf)){
+					if(content_top >= ppmgr_cutwin_top ){
+						frame->content_top = content_top  ;
+						frame->content_height = content_height/2  ;
+					}else{
+						frame->content_top = ppmgr_cutwin_top ;
+						frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
+					}
+					if(content_left >= ppmgr_cutwin_left ){
+						frame->content_left = content_left  ;
+						frame->content_width = content_width ;
+					}else{
+						frame->content_left = ppmgr_cutwin_left ;
+						frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
+					}
+
+				}else{
+				frame->content_top = content_top  ;
+				frame->content_left = content_left ;
+				frame->content_width = content_width    ;
+				frame->content_height = content_height/2  ;
+				}
+			}else{
+				if(is_need_cut_window_support(vf)){
+					if(content_top >= ppmgr_cutwin_top ){
+						frame->content_top = content_top  ;
+						frame->content_height = content_height  ;
+					}else{
+						frame->content_top = ppmgr_cutwin_top ;
+						frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
+					}
+					if(content_left >= ppmgr_cutwin_left ){
+						frame->content_left = content_left  ;
+						frame->content_width = content_width/2 ;
+					}else{
+						frame->content_left = ppmgr_cutwin_left ;
+						frame->content_width = content_width/2 - 2* (ppmgr_cutwin_left - content_left);
+					}
+			}else{
+				frame->content_top = content_top  ;
+				frame->content_left = content_left ;
+				frame->content_width = content_width/2    ;
+				frame->content_height = content_height  ;
+			}
+			}
+			frame->frame_top =    0;
+			frame->frame_left =   0;
+			frame->frame_width=   vf->width;
+			frame->frame_height = vf->height;
+			break;
+			case TVIN_TFMT_3D_FP:
+			case TVIN_TFMT_3D_LRH_OLER:
+			case TVIN_TFMT_3D_TB:
+				frame->content_top = vf->left_eye.start_y   ;
+				frame->content_left = vf->left_eye.start_x ;
+				frame->content_width = vf->left_eye.width    ;
+				frame->content_height = vf->left_eye.height  ;
+				frame->frame_top =    vf->left_eye.start_y;
+				frame->frame_left =   vf->left_eye.start_x;
+				frame->frame_width=   vf->left_eye.width;
+				frame->frame_height = vf->left_eye.height;
+				break;
+			default:
+				content_top = 0  ;
+				content_left = 0  ;
+				content_width = vf->width;    ;
+				content_height = vf->height;
+				if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
+					if(is_need_cut_window_support(vf)){
+						if(content_top >= ppmgr_cutwin_top ){
+							frame->content_top = content_top  ;
+							frame->content_height = content_height/2  ;
+						}else{
+							frame->content_top = ppmgr_cutwin_top ;
+							frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
+						}
+						if(content_left >= ppmgr_cutwin_left ){
+							frame->content_left = content_left  ;
+							frame->content_width = content_width ;
+						}else{
+							frame->content_left = ppmgr_cutwin_left ;
+							frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
+						}
+
+					}else{
+					frame->content_top = content_top  ;
+					frame->content_left = content_left ;
+					frame->content_width = content_width    ;
+					frame->content_height = content_height/2  ;
+					}
+				}else{
+					if(is_need_cut_window_support(vf)){
+						if(content_top >= ppmgr_cutwin_top ){
+							frame->content_top = content_top  ;
+							frame->content_height = content_height  ;
+						}else{
+							frame->content_top = ppmgr_cutwin_top ;
+							frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
+						}
+						if(content_left >= ppmgr_cutwin_left ){
+							frame->content_left = content_left  ;
+							frame->content_width = content_width/2 ;
+						}else{
+							frame->content_left = ppmgr_cutwin_left ;
+							frame->content_width = content_width/2 - 2* (ppmgr_cutwin_left - content_left);
+						}
+				}else{
+					frame->content_top = content_top  ;
+					frame->content_left = content_left ;
+					frame->content_width = content_width/2    ;
+					frame->content_height = content_height  ;
+				}
+				}
+				frame->frame_top =    0;
+				frame->frame_left =   0;
+				frame->frame_width=   vf->width;
+				frame->frame_height = vf->height;
+				break;
+		}
+	}
+
+	return 0;
+}
+
+
+
+static int get_input_r_frame(vframe_t* vf , display_frame_t* frame)
+{
+    int content_top ,content_left ,content_width ,content_height;
+    int status = get_ppmgr_status();
+    if(frame == NULL){
+        return -1;
+    }
+    if(vf->type & VIDTYPE_MVC){
+	frame->content_top = vf->right_eye.start_y   ;
+	frame->content_left = vf->right_eye.start_x ;
+	frame->content_width = vf->right_eye.width    ;
+	frame->content_height = vf->right_eye.height  ;
+	frame->frame_top =    vf->right_eye.start_y;
+	frame->frame_left =   vf->right_eye.start_x;
+	frame->frame_width=   vf->right_eye.width;
+	frame->frame_height = vf->right_eye.height;
+	return 0;
+    }
+/*tv in case , need detect the black bar*/
+	if((vf->prop.bbar.bottom)&&(vf->prop.bbar.right)
+	&&(vf->prop.bbar.right > vf->prop.bbar.left)
+	&&(vf->prop.bbar.bottom > vf->prop.bbar.top )){
+		switch(vf->trans_fmt){
+			case 	TVIN_TFMT_2D:
+				content_top = vf->prop.bbar.top   ;
+				content_left = vf->prop.bbar.left  ;
+				content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
+				content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
+
+				if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
+					if(is_need_cut_window_support(vf)){
+						if(content_top >= ppmgr_cutwin_top ){
+							frame->content_top = content_top + content_height/2   ;
+							frame->content_height = content_height/2  ;
+						}else{
+							frame->content_top = vf->height/2 + (ppmgr_cutwin_top - content_top);
+							frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
+						}
+						if(content_left >= ppmgr_cutwin_left ){
+							frame->content_left = content_left  ;
+							frame->content_width = content_width ;
+						}else{
+							frame->content_left = ppmgr_cutwin_left ;
+							frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
+						}
+
+					}else{
+					frame->content_top = content_top + content_height/2 ;
+					frame->content_left = content_left ;
+					frame->content_width = content_width    ;
+					frame->content_height = content_height/2  ;
+					}
+				}else{
+					if(is_need_cut_window_support(vf)){
+						if(content_top >= ppmgr_cutwin_top ){
+							frame->content_top = content_top  ;
+							frame->content_height = content_height  ;
+						}else{
+							frame->content_top = ppmgr_cutwin_top ;
+							frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
+						}
+						if(content_left >= ppmgr_cutwin_left ){
+							frame->content_left = content_width/2 + content_left  ;
+							frame->content_width = content_width/2 ;
+						}else{
+							frame->content_left = vf->width/2  +  (ppmgr_cutwin_left - content_left) ;
+							frame->content_width = content_width/2 - 2 *(ppmgr_cutwin_left - content_left);
+						}
+				}else{
+					frame->content_top = content_top  ;
+					frame->content_left = content_width/2 + content_left ;
+					frame->content_width = content_width/2    ;
+					frame->content_height = content_height  ;
+				}
+				}
+				frame->frame_top = 0;
+				frame->frame_left = 0;
+				frame->frame_width= vf->width;
+				frame->frame_height = vf->height;
+				break;
+			case TVIN_TFMT_3D_FP:
+			case TVIN_TFMT_3D_LRH_OLER:
+			case TVIN_TFMT_3D_TB:
+				frame->content_top = vf->right_eye.start_y   ;
+				frame->content_left = vf->right_eye.start_x ;
+				frame->content_width = vf->right_eye.width    ;
+				frame->content_height = vf->right_eye.height  ;
+				frame->frame_top =    vf->right_eye.start_y;
+				frame->frame_left =   vf->right_eye.start_x;
+				frame->frame_width=   vf->right_eye.width;
+				frame->frame_height = vf->right_eye.height;
+				break;
+			default:
+				content_top = vf->prop.bbar.top   ;
+				content_left = vf->prop.bbar.left  ;
+				content_width = vf->prop.bbar.right - vf->prop.bbar.left    ;
+				content_height = vf->prop.bbar.bottom - vf->prop.bbar.top  ;
+				if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
+					if(is_need_cut_window_support(vf)){
+						if(content_top >= ppmgr_cutwin_top ){
+							frame->content_top = content_top + content_height/2   ;
+							frame->content_height = content_height/2  ;
+						}else{
+							frame->content_top = vf->height/2 + (ppmgr_cutwin_top - content_top);
+							frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
+						}
+						if(content_left >= ppmgr_cutwin_left ){
+							frame->content_left = content_left  ;
+							frame->content_width = content_width ;
+						}else{
+							frame->content_left = ppmgr_cutwin_left ;
+							frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
+						}
+
+					}else{
+					frame->content_top = content_top + content_height/2 ;
+					frame->content_left = content_left ;
+					frame->content_width = content_width    ;
+					frame->content_height = content_height/2  ;
+					}
+				}else{
+					if(is_need_cut_window_support(vf)){
+						if(content_top >= ppmgr_cutwin_top ){
+							frame->content_top = content_top  ;
+							frame->content_height = content_height  ;
+						}else{
+							frame->content_top = ppmgr_cutwin_top ;
+							frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
+						}
+						if(content_left >= ppmgr_cutwin_left ){
+							frame->content_left = content_width/2 + content_left  ;
+							frame->content_width = content_width/2 ;
+						}else{
+							frame->content_left = vf->width/2  +  (ppmgr_cutwin_left - content_left) ;
+							frame->content_width = content_width/2 - 2 *(ppmgr_cutwin_left - content_left);
+						}
+				}else{
+					frame->content_top = content_top  ;
+					frame->content_left = content_width/2 + content_left ;
+					frame->content_width = content_width/2    ;
+					frame->content_height = content_height  ;
+				}
+				}
+				frame->frame_top = 0;
+				frame->frame_left = 0;
+				frame->frame_width= vf->width;
+				frame->frame_height = vf->height;
+				break;
+		}
+//		printk("rframe : format  is %d , top is %d , left is %d , width is %d , height is %d\n",vf->trans_fmt ,frame->content_top ,frame->content_left,frame->content_width,frame->content_height);
+	}else{
+		switch(vf->trans_fmt){
+			case 	TVIN_TFMT_2D:
+			content_top = 0  ;
+			content_left = 0  ;
+			content_width = vf->width;    ;
+			content_height = vf->height;
+			if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
+					if(is_need_cut_window_support(vf)){
+						if(content_top >= ppmgr_cutwin_top ){
+							frame->content_top = content_top + content_height/2   ;
+							frame->content_height = content_height/2  ;
+						}else{
+							frame->content_top = vf->height/2 + (ppmgr_cutwin_top - content_top);
+							frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
+						}
+						if(content_left >= ppmgr_cutwin_left ){
+							frame->content_left = content_left  ;
+							frame->content_width = content_width ;
+						}else{
+							frame->content_left = ppmgr_cutwin_left ;
+							frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
+						}
+
+					}else{
+				frame->content_top = content_top + content_height/2 ;
+				frame->content_left = content_left ;
+				frame->content_width = content_width    ;
+				frame->content_height = content_height/2  ;
+					}
+				}else{
+					if(is_need_cut_window_support(vf)){
+						if(content_top >= ppmgr_cutwin_top ){
+							frame->content_top = content_top  ;
+							frame->content_height = content_height  ;
+						}else{
+							frame->content_top = ppmgr_cutwin_top ;
+							frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
+						}
+						if(content_left >= ppmgr_cutwin_left ){
+							frame->content_left = content_width/2 + content_left  ;
+							frame->content_width = content_width/2 ;
+						}else{
+							frame->content_left = vf->width/2  +  (ppmgr_cutwin_left - content_left) ;
+							frame->content_width = content_width/2 - 2 *(ppmgr_cutwin_left - content_left);
+						}
+			}else{
+				frame->content_top = content_top  ;
+				frame->content_left = content_width/2 + content_left ;
+				frame->content_width = content_width/2    ;
+				frame->content_height = content_height  ;
+			}
+				}
+				frame->frame_top = 0;
+				frame->frame_left = 0;
+				frame->frame_width= vf->width;
+				frame->frame_height = vf->height;
+
+			break;
+			case TVIN_TFMT_3D_FP:
+			case TVIN_TFMT_3D_LRH_OLER:
+			case TVIN_TFMT_3D_TB:
+				frame->content_top = vf->right_eye.start_y   ;
+				frame->content_left = vf->right_eye.start_x ;
+				frame->content_width = vf->right_eye.width    ;
+				frame->content_height = vf->right_eye.height  ;
+				frame->frame_top =    vf->right_eye.start_y;
+				frame->frame_left =   vf->right_eye.start_x;
+				frame->frame_width=   vf->right_eye.width;
+				frame->frame_height = vf->right_eye.height;
+				break;
+			default:
+				content_top = 0  ;
+				content_left = 0  ;
+				content_width = vf->width;    ;
+				content_height = vf->height;
+				if((cur_process_type == TYPE_BT)||(status &BT_FORMAT_INDICATOR)){
+					if(is_need_cut_window_support(vf)){
+						if(content_top >= ppmgr_cutwin_top ){
+							frame->content_top = content_top + content_height/2   ;
+							frame->content_height = content_height/2  ;
+						}else{
+							frame->content_top = vf->height/2 + (ppmgr_cutwin_top - content_top);
+							frame->content_height = content_height/2 - 2* (ppmgr_cutwin_top - content_top);
+						}
+						if(content_left >= ppmgr_cutwin_left ){
+							frame->content_left = content_left  ;
+							frame->content_width = content_width ;
+						}else{
+							frame->content_left = ppmgr_cutwin_left ;
+							frame->content_width = vf->width - 2*ppmgr_cutwin_left ;
+						}
+
+					}else{
+					frame->content_top = content_top + content_height/2 ;
+					frame->content_left = content_left ;
+					frame->content_width = content_width    ;
+					frame->content_height = content_height/2  ;
+					}
+				}else{
+					if(is_need_cut_window_support(vf)){
+						if(content_top >= ppmgr_cutwin_top ){
+							frame->content_top = content_top  ;
+							frame->content_height = content_height  ;
+						}else{
+							frame->content_top = ppmgr_cutwin_top ;
+							frame->content_height = vf->height - 2*ppmgr_cutwin_top ;;
+						}
+						if(content_left >= ppmgr_cutwin_left ){
+							frame->content_left = content_width/2 + content_left  ;
+							frame->content_width = content_width/2 ;
+						}else{
+							frame->content_left = vf->width/2  +  (ppmgr_cutwin_left - content_left) ;
+							frame->content_width = content_width/2 - 2 *(ppmgr_cutwin_left - content_left);
+						}
+				}else{
+					frame->content_top = content_top  ;
+					frame->content_left = content_width/2 + content_left ;
+					frame->content_width = content_width/2    ;
+					frame->content_height = content_height  ;
+				}
+				}
+				frame->frame_top = 0;
+				frame->frame_left = 0;
+				frame->frame_width= vf->width;
+				frame->frame_height = vf->height;
+				break;
+		}
+	}
+	return 0;
+}
+
+
+
+static int get_output_format(int flag)
+{
+    return frame_info.format;
+}
+
+static int get_output_width(int flag)
+{
+    const vinfo_t *vinfo;
+    vinfo = get_current_vinfo();
+    switch(flag){
+        case 0:
+        case 2:
+            return frame_info.width;
+            break;
+        case 1:
+            return vinfo->width;
+            break;
+        default:
+            break;
+    }
+    return 0;
+}
+void x_offset_adjust(vframe_t* vf , int* offset , int screen_width ,int v_screen_width )
+{
+	int ww;
+	int ll = *offset;
+	int trick_mode =0 ;
+
+	ww = screen_width ;
+
+//	if(current_view_mode == VIEWMODE_4_3){
+//		return;
+//	}
+//	printk("pre offset is %d \n" , *offset);
+	query_video_status(0 , &trick_mode) ;
+    if(trick_mode){
+	return;
+    }
+	if((vf->width < 960)||((vf->type&VIDTYPE_VIU_422)&&(cur_process_type !=TYPE_2D_TO_3D))||(ww <= v_screen_width)){
+		return;
+	}
+	if(vf->width <= 1280){
+		v_screen_width  = 1280;
+	}
+	*offset=  (((v_screen_width << 16)/ww)*ll) >>16;
+
+//	printk("after offset is %d \n" , *offset);
+}
+
+
+
+void axis_h_adjust(vframe_t* vf , int* left ,  int* width , int* screen_width ,int v_screen_width )
+{
+	int l,w ,ww;
+	int trick_mode =0 ;
+
+	ww = *screen_width ;
+
+	query_video_status(0 , &trick_mode) ;
+    if(trick_mode){
+	return;
+    }
+	if(((vf->type&VIDTYPE_VIU_422)&&(cur_process_type !=TYPE_2D_TO_3D))||(ww <= v_screen_width)){
+		return;
+	}
+	if(vf->width <= 1280){
+		v_screen_width  = 1280;
+	}
+	l = *left ;
+	w =*width;
+	*left=  (((v_screen_width << 16)/ww)*l) >>16;
+	*width = (((v_screen_width << 16)/ww)*w) >> 16;
+	*width = (*width + 1)&(~1);
+	*screen_width = v_screen_width ;
+}
+
+int get_output_height(int flag)
+{
+    const vinfo_t *vinfo;
+    vinfo = get_current_vinfo();
+    switch(flag){
+        case 0:
+        case 2:
+            return frame_info.height;
+            break;
+        case 1:
+            return vinfo->height;
+            break;
+        default:
+            break;
+    }
+    return frame_info.height;
+}
+
+static int get_output_rect_after_ratio(vframe_t* vf ,int* top , int*left , int* width , int* height ,int in_width, int in_height, int output_width,int output_height)
+{
+    int t,l,w,h;
+    int current_view_mode = 0 ;
+    w = output_width;
+    h = output_height;
+    t = 0 ;
+    l = 0;
+    current_view_mode  = get_ppmgr_view_mode();
+    switch(current_view_mode){
+	case VIEWMODE_4_3:
+	//vf->ratio_control = ((3 <<8)/4) << DISP_RATIO_ASPECT_RATIO_BIT;
+	vf->ratio_control = (0xc0 << DISP_RATIO_ASPECT_RATIO_BIT);
+	break;
+	case VIEWMODE_16_9:
+	//vf->ratio_control = ((9 << 8)/16) << DISP_RATIO_ASPECT_RATIO_BIT ;
+	vf->ratio_control = (0x90 << DISP_RATIO_ASPECT_RATIO_BIT) ;
+	break;
+	case VIEWMODE_NORMAL:
+	default:
+	break;
+    }
+
+    if (vf->ratio_control) {
+        int ar = (vf->ratio_control >> DISP_RATIO_ASPECT_RATIO_BIT) & 0x3ff;
+        if ((ar * output_width) > (output_height << 8)) {
+            w = (output_height << 8) / ar;
+            l = (output_width - w) / 2;
+        } else {
+            h = (output_width * ar) >> 8;
+            t = (output_height - h) / 2;
+        }
+    } else {
+        if ((in_height * output_width) > (output_height *in_width)) {
+            w = (output_height * in_width) / in_height;
+            l = (output_width - w) / 2;
+        } else {
+            h = output_width * in_height / in_width;
+            t = (output_height - h) / 2;
+        }
+    }
+    l &= ~1;
+    t &= ~1;
+    w =  output_width - 2*l;
+    h  =  output_height - 2*t;
+    *top = t;
+    *left = l;
+    *width = w;
+    *height = h;
+    return 0;
+}
+
+
+int get_2d_output_rect_after_ratio(int* top , int*left , int* width , int* height ,int in_width, int in_height, int screen_width,int screen_height)
+{
+    int ww,hh;
+    int current_view_mode = 0 ;
+
+    ww = in_width;
+    hh = in_height;
+#if 0
+    if(ww * screen_height   > hh* screen_width){
+	hh = (((ww * screen_height ) << 8)/screen_width) >> 8;
+    }else{
+	ww = (((screen_width * hh) << 8) /screen_height) >> 8 ;
+    }
+#else
+	ww = screen_width;
+	hh = screen_height;
+#endif
+    current_view_mode  = get_ppmgr_view_mode();
+    switch(current_view_mode){
+	case VIEWMODE_4_3:
+		*top = 0;
+		*left = ww >>3;
+		*width = (ww*3) >>2  ;
+		*height = hh;
+
+	break;
+	case VIEWMODE_16_9:
+		*top = 0;
+		*left = 0;
+		*width = ww ;
+		*height = hh;
+	break;
+	case VIEWMODE_NORMAL:
+	default:
+		*top = 0;
+		*left = 0;
+		*width =  in_width ;
+		*height = in_height;
+	break;
+    }
+
+    return 0;
+}
+
+/*for decoder input processing
+    1. output window should 1:1 as source frame size
+    2. keep the frame ratio
+    3. input format should be YUV420 , output format should be YUV444
+*/
+static void process_none(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+    vframe_t* new_vf;
+    ppframe_t *pp_vf;
+
+    int index;
+    display_frame_t input_frame ;
+    display_frame_t l_frame ,r_frame ;
+    canvas_t cs0,cs1,cs2,cd;
+    //new_vf = &vfpool[fill_ptr];
+    new_vf = vfq_pop(&q_free);
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    memcpy(new_vf , vf, sizeof(vframe_t));
+    get_input_frame(vf,&input_frame);
+    get_input_l_frame(vf,&l_frame);
+    get_input_r_frame(vf,&r_frame);
+    new_vf->width= input_frame.frame_width;
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+	    new_vf->height= input_frame.frame_height;
+	}else{
+		new_vf->height= input_frame.frame_height <<1;
+	}
+    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
+    new_vf->mode_3d_enable = 0 ;
+    //new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
+    index = pp_vf->index;
+    if(index < 0){
+        printk("======decoder is full\n");
+        //return -1;
+    }
+    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(index);
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top =    0;
+    ge2d_config->src_para.left =   0;
+    ge2d_config->src_para.width =  vf->width;
+    ge2d_config->src_para.height = vf->height;
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = new_vf->width;
+    ge2d_config->dst_para.height = new_vf->height;
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+//    stretchblt_noalpha(context,input_frame.content_left,input_frame.content_top,input_frame.content_width ,input_frame.content_height,0,0,new_vf->width,new_vf->height);
+stretchblt_noalpha(context,input_frame.frame_left,input_frame.frame_top,input_frame.frame_width ,input_frame.frame_height,0,0,new_vf->width,new_vf->height);
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+}
+
+static int ratio_value = 10; // 0~255
+static void process_2d_to_3d(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+    vframe_t* new_vf;
+    ppframe_t *pp_vf;
+    int index;
+    display_frame_t input_frame ;
+    int t,l,w,h,w1,h1,w2,h2;
+    canvas_t cs0,cs1,cs2,cd;
+    unsigned x_offset = 0, y_offset = 0;
+    unsigned cut_w = 0,cut_h = 0;
+    new_vf = vfq_pop(&q_free);
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    memcpy(new_vf , vf, sizeof(vframe_t));
+    get_input_frame(vf,&input_frame);
+
+
+//    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
+    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
+    new_vf->mode_3d_enable = 1 ;
+    index = pp_vf->index;
+    if(index < 0){
+        printk("======decoder is full\n");
+        //return -1;
+    }
+
+    cut_w = (((input_frame.frame_width<<8) + 0x80) * ratio_value)>>16;
+    cut_h = (((input_frame.frame_height<<8) + 0x80) * ratio_value)>>16;
+    x_offset = cut_w>>1;
+    x_offset = x_offset & 0xfffffffe;
+    y_offset = cut_h>>1;
+    y_offset = y_offset & 0xfffffffe;
+
+    new_vf->canvas0Addr = index2canvas_0(index);
+    new_vf->canvas1Addr = index2canvas_1(index);
+//ROUND_1:
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = vf->width;
+    ge2d_config->src_para.height = vf->height;
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    w1 = input_frame.frame_width;
+    h1 = input_frame.frame_height ;
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+    //w2 = vf->width ;
+    //h2 = vf->height;
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
+	}else{
+	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
+	}
+		t >>=1;
+		h >>=1;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2;
+
+ //   printk("t:%d l:%d w:%d h%d \n",t,l,w,h);
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+//    stretchblt_noalpha(context,0,0,vf->width/2,vf->height,t,l,w,h);
+//   stretchblt_noalpha(context,0,0,vf->width,vf->height,l,t,w,h);
+    stretchblt_noalpha(context,input_frame.frame_left,input_frame.frame_top,input_frame.frame_width ,input_frame.frame_height,l,t,w,h);
+
+//ROUND_2:
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas1Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = y_offset;
+    ge2d_config->src_para.left = x_offset;
+    ge2d_config->src_para.width = vf->width-cut_w;
+    ge2d_config->src_para.height = vf->height-cut_h;
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    w1 = input_frame.frame_width;
+    h1 = input_frame.frame_height ;
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+    //w2 = vf->width ;
+    //h2 = vf->height;
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
+	}else{
+	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
+	}
+		t >>=1;
+		h >>=1;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2;
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+//    stretchblt_noalpha(context,0,vf->width/2,vf->width/2,vf->height,t,l,w,h);
+//    stretchblt_noalpha(context, x_offset, y_offset, vf->width-cut_w,vf->height-cut_h,l,t,w,h);
+
+   stretchblt_noalpha(context,input_frame.frame_left + x_offset,input_frame.frame_top + y_offset,input_frame.frame_width -cut_w ,input_frame.frame_height-cut_h,l,t,w,h);
+    new_vf->width = w2;
+    new_vf->height = h2 ;
+    new_vf->ratio_control = 0;
+
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+    return;
+}
+
+void process_2d_to_3d_switch(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+    vframe_t* new_vf;
+    ppframe_t *pp_vf;
+    int index;
+    int t,l,w,h,w1,h1,w2,h2;
+    canvas_t cs0,cs1,cs2,cd;
+    unsigned x_offset = 0, y_offset = 0;
+    unsigned cut_w = 0,cut_h = 0;
+
+    new_vf = vfq_pop(&q_free);
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
     pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    memcpy(new_vf , vf, sizeof(vframe_t));
-    get_input_frame(vf,&input_frame);
-    get_input_l_frame(vf,&l_frame);
-    get_input_r_frame(vf,&r_frame);
-    new_vf->width= input_frame.content_width;
-    new_vf->height= input_frame.content_height;
-
-    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
-    new_vf->mode_3d_enable = 1 ;
-    index = pp_vf->index;
-    if(index < 0){
-        printk("======decoder is full\n");
-        //return -1;
-    }
-    new_vf->canvas0Addr = index2canvas_0(index);
-    new_vf->canvas1Addr = index2canvas_1(index);
-//ROUND_1:
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    ge2d_config->src_para.width = vf->width;
-	if(is_vertical_sample_enable(vf)){
-		ge2d_config->src_para.height = vf->height/2;
-	}else{
-		ge2d_config->src_para.height = vf->height;
-	}
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    w1 = input_frame.content_width;
-    h1 = input_frame.content_height ;
-#if 1
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-#else
-    w2 = vf->width ;
-    h2 = vf->height;
-#endif
-
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
-	}else{
-	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
-	}
-		t >>=1;
-		h >>=1;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2;
-
-//    printk("t:%d l:%d w:%d h%d \n",t,l,w,h);
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
- //   stretchblt_noalpha(context,0,0,vf->width,vf->height/2,l,t,w,h);
-
- //   stretchblt_noalpha(context,0,input_frame.content_top,input_frame.frame_width,input_frame.content_height/2,l,t,w,h);
- 	axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
-	 if(is_vertical_sample_enable(vf)){
-	 	stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height/2,l,t,w,h);
-	}else{
-	 	stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height,l,t,w,h);
-	}
-
-//ROUND_2:
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas1Addr&0xff,&cs0);
-    canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas1Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-
-    ge2d_config->src_para.canvas_index=vf->canvas1Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    ge2d_config->src_para.width = vf->width;
-	if(is_vertical_sample_enable(vf)){
-		ge2d_config->src_para.height = vf->height/2;
-	}else{
-		ge2d_config->src_para.height = vf->height;
-	}
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    w1 = input_frame.content_width;
-    h1 = input_frame.content_height ;
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
-	}else{
-	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
-	}
-		t >>=1;
-		h >>=1;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2;
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-//    stretchblt_noalpha(context,0 ,vf->height/2,vf->width,vf->height/2,l,t,w,h);
-//   stretchblt_noalpha(context,0,input_frame.frame_height/2,input_frame.frame_width,input_frame.content_height/2,l,t,w,h);
-    axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
-    if(is_vertical_sample_enable(vf)){
-		stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height/2,l,t,w,h);
-	}else{
-		stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height,l,t,w,h);
-	}
-    new_vf->width = w2;
-    new_vf->height = h2 ;
-    new_vf->ratio_control = 0;
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-}
-
-void process_lr_switch(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-#if 0
-    vframe_t* new_vf;
-    int index;
-    display_frame_t input_frame ;
-    display_frame_t l_frame ,r_frame ;
-    canvas_t cs0,cs1,cs2,cd;
-    new_vf = &vfpool[fill_ptr];
-    memcpy(new_vf , vf, sizeof(vframe_t));
-    get_input_frame(vf,&input_frame);
-    get_input_l_frame(vf,&l_frame);
-    get_input_r_frame(vf,&r_frame);
-    new_vf->width= input_frame.frame_width;
-    new_vf->height= input_frame.frame_height;
-
-    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
-    index = pp_vf->index;
-    if(index < 0){
-        printk("======decoder is full\n");
-        //return -1;
-    }
-    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(index);
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    ge2d_config->src_para.width = vf->width;
-    ge2d_config->src_para.height = vf->height;
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = new_vf->width;
-    ge2d_config->dst_para.height = new_vf->height;
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-//    stretchblt_noalpha(context,0,0,vf->width/2,vf->height,new_vf->width/2,0,new_vf->width/2,new_vf->height);
-
-    stretchblt_noalpha(context,input_frame.content_left,0,input_frame.content_width/2,input_frame.content_height, new_vf->width/2,0,input_frame.content_width/2 ,input_frame.frame_height);
-
-ROUND2:
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
- //   stretchblt_noalpha(context,vf->width/2 ,0,vf->width/2,vf->height,0,0,new_vf->width/2,new_vf->height);
-
-    stretchblt_noalpha(context,input_frame.frame_width/2,0,input_frame.content_width/2,input_frame.content_height, input_frame.content_left,0,input_frame.content_width/2 ,input_frame.frame_height);
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-#else
-    vframe_t* new_vf;
-    ppframe_t *pp_vf;
-    int index;
-    display_frame_t input_frame ;
-    display_frame_t l_frame ,r_frame ;
-    int t,l,w,h,w1,h1,w2,h2;
-    canvas_t cs0,cs1,cs2,cd;
-    new_vf = vfq_pop(&q_free);
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;  
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    memcpy(new_vf , vf, sizeof(vframe_t));
-    get_input_frame(vf,&input_frame);
-    get_input_l_frame(vf,&l_frame);
-    get_input_r_frame(vf,&r_frame);
-    new_vf->width= input_frame.content_width;
-    new_vf->height= input_frame.content_height;
-
-    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
-    new_vf->mode_3d_enable = 1 ;
-    index = pp_vf->index;
-    if(index < 0){
-        printk("======decoder is full\n");
-        //return -1;
-    }
-    new_vf->canvas0Addr = index2canvas_0(index);
-    new_vf->canvas1Addr = index2canvas_1(index);
-//ROUND_1:
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    ge2d_config->src_para.width = vf->width;
-	if(is_vertical_sample_enable(vf)){
-		ge2d_config->src_para.height = vf->height/2;
-	}else{
-    ge2d_config->src_para.height = vf->height;
-	}
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    w1 = input_frame.content_width;
-    h1 = input_frame.content_height ;
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-
-
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
-	}else{
-	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
-	}
-		t >>=1;
-		h >>=1;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2;
-
- //   printk("t:%d l:%d w:%d h%d \n",t,l,w,h);
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-//    stretchblt_noalpha(context,0,0,vf->width/2,vf->height,t,l,w,h);
-
-	axis_h_adjust(vf , &l ,  &w , &w2 , get_ppmgr_scale_width() );
-	if(is_vertical_sample_enable(vf)){
-    		stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height/2,l,t,w,h);
-	}else{
-stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height,l,t,w,h);
-	}
-
-//ROUND_2:
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas1Addr&0xff,&cs0);
-    canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas1Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-
-    ge2d_config->src_para.canvas_index=vf->canvas1Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    ge2d_config->src_para.width = vf->width;
-    if(is_vertical_sample_enable(vf)){
-    		ge2d_config->src_para.height = vf->height/2;
-	}else{
-    ge2d_config->src_para.height = vf->height;
-	}
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    w1 = input_frame.content_width;
-    h1 = input_frame.content_height ;
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
-	}else{
-	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
-	}
-		t >>=1;
-		h >>=1;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2;
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-//    stretchblt_noalpha(context,vf->width/2 ,0,vf->width/2,vf->height,l,t,w,h);
-	    axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
-	if(is_vertical_sample_enable(vf)){
-    		stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height/2,l,t,w,h);
-	}else{
-	stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height,l,t,w,h);
-	}
-    new_vf->width = w2;
-    new_vf->height = h2 ;
-    new_vf->height = h2 ;
-    new_vf->ratio_control = 0;
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-
-#endif
-}
-
-extern int get_depth(void);
-
-static int x_phase = 2048; // >0: image move to left. <0: image move to right, 0~7 is phase value, 8-30 is offset
-static void process_field_depth(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-    vframe_t* new_vf;
-    ppframe_t *pp_vf;
-    int index;
-    display_frame_t input_frame ;
-    int t,l,w,h,w1,h1,w2,h2;
-    int ll , tt ,ww , hh;
-    int src_l , src_t, src_w ,src_h , dst_l,dst_t,dst_w , dst_h;
-    int x_offset = 0;
-    int type = 0 ;
-    unsigned cur_phase = 0;
-    unsigned cut_w = 0;
-    unsigned temp_w = 0;
-    canvas_t cs0,cs1,cs2,cd;
-    new_vf = vfq_pop(&q_free);
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;  
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    memcpy(new_vf , vf, sizeof(vframe_t));
-    get_input_frame(vf,&input_frame);
-//    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
-    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
-    new_vf->mode_3d_enable = 1 ;
-    index = pp_vf->index;
-    if(index < 0){
-        printk("======decoder is full\n");
-        //return -1;
-    }
-    x_phase = get_depth();
-
-//    if(x_phase<0){
-//        x_offset = -(((unsigned)x_phase&0xfffffff)>>8);
-//        cur_phase = x_phase&0xff;
-//        if(cur_phase){
-//            x_offset--;
-//            cur_phase = 0x100-cur_phase;
-//        }
-//        cut_w = -x_offset;
-//    }else if(x_phase>0){
-//        x_offset = ((x_phase&0xfffffff)>>8);
-//        cur_phase = x_phase&0xff;
-//        cut_w = x_offset;
-//    }
-
-	if(x_phase & 0x10000000){
-		type  = 0 ;
-	}else{
-		type =  1;
-	}
-
-
-    new_vf->canvas0Addr = index2canvas_0(index);
-    new_vf->canvas1Addr = index2canvas_1(index);
-//ROUND_1:
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    ge2d_config->src_para.width = vf->width;
-	if(is_vertical_sample_enable(vf)){
-		ge2d_config->src_para.height = vf->height/2;
-	}else{
-		ge2d_config->src_para.height = vf->height;
-	}
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-
-    if(is_need_cut_window_support(vf)){
-    	w1 = input_frame.frame_width - 2*ppmgr_cutwin_left ;
-    	h1 = input_frame.frame_height - 2*ppmgr_cutwin_top;
-    }else{
-    w1 = input_frame.frame_width;
-    h1 = input_frame.frame_height ;
-    }
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
-	}else{
-	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
-	}
-		t >>=1;
-		h >>=1;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2/2;
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-    x_phase  &= 0xfffffff;
-    x_offset_adjust(vf , &x_phase,w2 ,get_ppmgr_scale_width());
-
-	x_offset = ((x_phase&0xfffffff)>>8);
-	x_offset &= ~1;
-	cur_phase = x_phase&0xff;
-	cut_w = x_offset;
-
-	axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
-
-	if(is_need_cut_window_support(vf)){
-		ll = input_frame.frame_left + ppmgr_cutwin_left ;
-		tt = input_frame.frame_top + ppmgr_cutwin_top;
-		ww = input_frame.frame_width - 2*ppmgr_cutwin_left ;
-		hh = input_frame.frame_height - 2*ppmgr_cutwin_top;
-	}else{
-		ll = input_frame.frame_left ;
-		tt = input_frame.frame_top;
-		ww = input_frame.frame_width;
-		hh = input_frame.frame_height;
-	}
-	if(is_vertical_sample_enable(vf)){
-		stretchblt_noalpha(context,ll,tt,ww ,hh/2,l,t,w,h);
-	}else{
-		stretchblt_noalpha(context,ll,tt,ww ,hh,l,t,w,h);
-	}
-
-//ROUND_2:
-    /* data operating. */
-  //  if(w1 >= 1280 ){
-  if (0){
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas1Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    ge2d_config->src_para.width = vf->width;
-    ge2d_config->src_para.height = vf->height;
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    w1 = input_frame.frame_width;
-    h1 = input_frame.frame_height ;
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-
-    temp_w = (input_frame.frame_width-cut_w)*w2/w1;
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
-	}else{
-	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
-	}
-		t >>=1;
-		h >>=1;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2/2;
-    if(ge2d_config->hf_init_phase){
-        ge2d_config->hf_rpt_num = 1;
-        ge2d_config->hf_init_phase = cur_phase<<16;
-    }
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-   stretchblt_noalpha(context,(x_offset<0)?0:(input_frame.frame_left+x_offset) ,input_frame.frame_top,input_frame.frame_width - cut_w ,input_frame.frame_height,(x_offset<0)?(l+w2-temp_w):l,t,temp_w,h);
-}else{
-    ge2d_config->src_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    ge2d_config->src_para.width = w2;
-    ge2d_config->src_para.height = h2/2;
-
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-
-    ge2d_config->src_planes[0].addr = cd.addr;
-    ge2d_config->src_planes[0].w = cd.width;
-    ge2d_config->src_planes[0].h = cd.height;
-
-    canvas_read(new_vf->canvas1Addr&0xff,&cd);
-
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    if(type == 0){
-	    src_t = 0;
-	    src_l =  x_offset;
-	    src_w = (w2- x_offset);
-	    src_h = h2/2;
-
-	    dst_t = 0 ;
-	    dst_l = 0;
-	    dst_w = src_w;
-	    dst_h = h2/2;
-	}else{
-	    src_t = 0;
-	    src_l =  0;
-	    src_w =(w2- x_offset);
-	    src_h = h2/2;
-
-	    dst_t = 0 ;
-	    dst_l = x_offset ;
-	    dst_w = src_w;
-	    dst_h = h2/2;
-	}
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = w2;
-    ge2d_config->dst_para.height = h2/2;
-    if(ge2d_config->hf_init_phase){
-        ge2d_config->hf_rpt_num = 1;
-        ge2d_config->hf_init_phase = cur_phase<<16;
-    }
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-   stretchblt_noalpha(context,src_l , src_t, src_w ,src_h , dst_l,dst_t,dst_w , dst_h);
-
-   if(type == 0){
-	    src_t = 0;
-	    src_l =  0;
-	    src_w =  x_offset;
-	    src_h = h2/2;
-
-	    dst_t = 0 ;
-	    dst_l = w2 - x_offset;
-	    dst_w = x_offset;
-	    dst_h = h2/2;
-
-	}else{
-	    src_t = 0;
-	    src_l =  w2 - x_offset;
-	    src_w =  x_offset;
-	    src_h = h2/2;
-
-	    dst_t = 0 ;
-	    dst_l = 0 ;
-	    dst_w = x_offset;
-	    dst_h = h2/2;
-	}
-	if(src_w > 0){
-		window_clear_3D(context ,ge2d_config ,new_vf->canvas0Addr , src_l ,src_t ,src_w ,src_h);
-		window_clear_3D(context ,ge2d_config ,new_vf->canvas1Addr , dst_l ,dst_t ,dst_w ,dst_h);
-}
-}
-    new_vf->width = w2;
-    new_vf->height = h2 ;
-    new_vf->ratio_control = 0;
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-    return;
-}
-
-void process_3d_to_2d_l(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-    vframe_t* new_vf;
-    ppframe_t *pp_vf;
-    int index;
-    display_frame_t input_frame ;
-    display_frame_t l_frame ,r_frame ;
-    canvas_t cs0,cs1,cs2,cd;
-    int t,l,w,h,w1,h1,w2,h2;
-    new_vf = vfq_pop(&q_free);
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;  
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    memcpy(new_vf , vf, sizeof(vframe_t));
-    get_input_frame(vf,&input_frame);
-    get_input_l_frame(vf,&l_frame);
-    get_input_r_frame(vf,&r_frame);
-
-    new_vf->width= input_frame.content_width;
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-	    new_vf->height= input_frame.content_height;
-	}else{
-		new_vf->height= input_frame.content_height <<1;
-	}
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    if(is_need_cut_window_support(vf)){
-    	w1 = input_frame.frame_width - 2*ppmgr_cutwin_left ;
-    	h1 = input_frame.frame_height - 2*ppmgr_cutwin_top;
-    }else{
-    w1 = new_vf->width;
-    h1 = new_vf->height ;
-    }
-
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-    get_2d_output_rect_after_ratio(&t,&l,&w,&h,w1,h1,w2,h2);
-    new_vf->width  = w + 2*l ;
-    new_vf->height = h + 2*t;
-    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
-    new_vf->mode_3d_enable = 0 ;
-    //new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
-    index = pp_vf->index;
-    if(index < 0){
-        printk("======decoder is full\n");
-        //return -1;
-    }
-    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(index);
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    if(is_vertical_sample_enable(vf)){
-	    ge2d_config->src_para.width = vf->width;
-	    ge2d_config->src_para.height = vf->height/2;
-	}else{
-    ge2d_config->src_para.width = vf->width;
-    ge2d_config->src_para.height = vf->height;
-	}
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = new_vf->width;
-    ge2d_config->dst_para.height = new_vf->height;
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-    axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
-    if(is_vertical_sample_enable(vf)){
-    	stretchblt_noalpha(context, l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height/2,l,t,w,h);
-	}else{
-    stretchblt_noalpha(context, l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height,l,t,w,h);
-	}
-
-    new_vf->width = w2 ;
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-}
-
-void process_3d_to_2d_r(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-    vframe_t* new_vf;
-    ppframe_t *pp_vf;
-    int index;
-    display_frame_t input_frame ;
-    display_frame_t l_frame ,r_frame ;
-    canvas_t cs0,cs1,cs2,cd;
-    int t,l,w,h,w1,h1,w2,h2;
-    new_vf = vfq_pop(&q_free);
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;  
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    memcpy(new_vf , vf, sizeof(vframe_t));
-    get_input_frame(vf,&input_frame);
-    get_input_l_frame(vf,&l_frame);
-    get_input_r_frame(vf,&r_frame);
-    new_vf->width= input_frame.content_width;
-	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
-		new_vf->height= input_frame.content_height;
-	}else{
-		new_vf->height= input_frame.content_height <<1;
-	}
-    t = 0;
-    l = 0;
-    w = 0;
-    h = 0;
-    if(is_need_cut_window_support(vf)){
-    	w1 = input_frame.frame_width - 2*ppmgr_cutwin_left ;
-    	h1 = input_frame.frame_height - 2*ppmgr_cutwin_top;
-    }else{
-    w1 = new_vf->width;
-    h1 = new_vf->height ;
-    }
-    w2 = get_output_width(1) ;
-    h2 = get_output_height(1);
-    get_2d_output_rect_after_ratio(&t,&l,&w,&h,w1,h1,w2,h2);
-    new_vf->width  = w + 2*l ;
-    new_vf->height = h + 2*t;
-    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
-    new_vf->mode_3d_enable = 0 ;
-    //new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
-    index = pp_vf->index;
-    if(index < 0){
-        printk("======decoder is full\n");
-        //return -1;
-    }
-    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(index);
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas1Addr&0xff,&cs0);
-    canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas1Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = get_input_format(vf);
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    if(is_vertical_sample_enable(vf)){
-	    ge2d_config->src_para.width = vf->width;
-	    ge2d_config->src_para.height = vf->height/2;
-	}else{
-    ge2d_config->src_para.width = vf->width;
-    ge2d_config->src_para.height = vf->height;
-	}
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = new_vf->width;
-    ge2d_config->dst_para.height = new_vf->height;
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-
-    axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
-    if(is_vertical_sample_enable(vf)){
-    	stretchblt_noalpha(context, r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height/2,l,t,w,h);
-	}else{
-    stretchblt_noalpha(context, r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height,l,t,w,h);
-	}
-    new_vf->width = w2 ;
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-}
-
-/*for camera input processing*/
-void process_camera_input(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-    vframe_t* new_vf;
-    ppframe_t *pp_vf;
-    int index;
-    canvas_t cs0,cs1,cs2,cd;
-    new_vf = vfq_pop(&q_free);
-
-    if (unlikely((!new_vf) || (!vf)))
-        return;  
-    pp_vf = to_ppframe(new_vf);
-    pp_vf->dec_frame = NULL;
-    memcpy(new_vf , vf, sizeof(vframe_t));
- //   new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
-    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
-    new_vf->mode_3d_enable = 0 ;
-    new_vf->width = get_output_width(2);
-    new_vf->height = get_output_height(2);
-
-    index = pp_vf->index;
-    if(index < 0){
-        printk("======decoder is full\n");
-        //return -1;
-    }
-    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(index);
-
-    /* data operating. */
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    canvas_read(vf->canvas0Addr&0xff,&cs0);
-    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
-    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
-    ge2d_config->src_planes[0].addr = cs0.addr;
-    ge2d_config->src_planes[0].w = cs0.width;
-    ge2d_config->src_planes[0].h = cs0.height;
-    ge2d_config->src_planes[1].addr = cs1.addr;
-    ge2d_config->src_planes[1].w = cs1.width;
-    ge2d_config->src_planes[1].h = cs1.height;
-    ge2d_config->src_planes[2].addr = cs2.addr;
-    ge2d_config->src_planes[2].w = cs2.width;
-    ge2d_config->src_planes[2].h = cs2.height;
-    canvas_read(new_vf->canvas0Addr&0xff,&cd);
-    ge2d_config->dst_planes[0].addr = cd.addr;
-    ge2d_config->dst_planes[0].w = cd.width;
-    ge2d_config->dst_planes[0].h = cd.height;
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = GE2D_FORMAT_M24_YUV420;
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0xffffffff;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    ge2d_config->src_para.width = vf->width;
-    ge2d_config->src_para.height = vf->height;
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.format = get_output_format(0);
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = new_vf->width;
-    ge2d_config->dst_para.height = new_vf->height;
-
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-    stretchblt_noalpha(context,0,0,vf->width,vf->height,0,0,new_vf->width,new_vf->height);
-
-    ppmgr_vf_put_dec(vf);
-    vfq_push(&q_ready, new_vf);
-}
-
-static void buffer_clear_2D(ge2d_context_t *context, config_para_ex_t* ge2d_config,int index)
-{
-    int i ,t,l,w,h1,h2;
-    int current_view_mode;
-
-    t = 0;
-    l = 0;
-    //w = get_output_width(1) ;
-    //h = get_output_height(1);
-    w = 1920 ;
-    h1 = 1088;
-    h2 = 544;
-
-	current_view_mode  = get_ppmgr_view_mode();
-    for (i = 0; i < VF_POOL_SIZE; i++){
-    	if((index >= 0)&&(index != i)){
-    		continue;
-    	}
-    	if((index >=0 )&&(current_view_mode == VIEWMODE_4_3)){
-    		w = 240;
-    	}
-        ge2d_config->alu_const_color= 0;//0x000000ff;
-        ge2d_config->bitmask_en  = 0;
-        ge2d_config->src1_gb_alpha = 0;//0xff;
-        ge2d_config->dst_xy_swap = 0;
-
-        ge2d_config->src_key.key_enable = 0;
-        ge2d_config->src_key.key_mask = 0;
-        ge2d_config->src_key.key_mode = 0;
-
-        ge2d_config->src_para.canvas_index=PPMGR_CANVAS_INDEX + i;
-        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->src_para.fill_color_en = 0;
-        ge2d_config->src_para.fill_mode = 0;
-        ge2d_config->src_para.x_rev = 0;
-        ge2d_config->src_para.y_rev = 0;
-        ge2d_config->src_para.color = 0;
-        ge2d_config->src_para.top = 0;
-        ge2d_config->src_para.left = 0;
-        ge2d_config->src_para.width = w;
-        ge2d_config->src_para.height = h1;
-
-        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->dst_para.canvas_index=PPMGR_CANVAS_INDEX + i;
-        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->dst_para.fill_color_en = 0;
-        ge2d_config->dst_para.fill_mode = 0;
-        ge2d_config->dst_para.x_rev = 0;
-        ge2d_config->dst_para.y_rev = 0;
-        ge2d_config->dst_para.color = 0;
-
-
-        ge2d_config->dst_para.top = 0;
-        ge2d_config->dst_para.left = 0;
-        ge2d_config->dst_para.width = w;
-        ge2d_config->dst_para.height = h1;
-        if(ge2d_context_config_ex(context,ge2d_config)<0) {
-            printk("++ge2d configing error.\n");
-            return;
-        }
-        fillrect(context ,l,t,w,h1,0x00808000 )    ;
-    }
-}
-
-static void buffer_clear_3D(ge2d_context_t *context, config_para_ex_t* ge2d_config,int index)
-{
-    int i ,t,l,w,h1,h2;
-    t = 0;
-    l = 0;
-    w = 1920 ;
-    h1 = 1088;
-    h2 = 544;
-    for (i = 0; i < VF_POOL_SIZE; i++){
-    	if((index >= 0)&&(index != i)){
-    		continue;
-    	}
-        ge2d_config->alu_const_color= 0;//0x000000ff;
-        ge2d_config->bitmask_en  = 0;
-        ge2d_config->src1_gb_alpha = 0;//0xff;
-        ge2d_config->dst_xy_swap = 0;
-
-        ge2d_config->src_key.key_enable = 0;
-        ge2d_config->src_key.key_mask = 0;
-        ge2d_config->src_key.key_mode = 0;
-        ge2d_config->src_para.canvas_index=PPMGR_DOUBLE_CANVAS_INDEX + i;
-        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->src_para.fill_color_en = 0;
-        ge2d_config->src_para.fill_mode = 0;
-        ge2d_config->src_para.x_rev = 0;
-        ge2d_config->src_para.y_rev = 0;
-        ge2d_config->src_para.color = 0;
-        ge2d_config->src_para.top = 0;
-        ge2d_config->src_para.left = 0;
-        ge2d_config->src_para.width = w;
-        ge2d_config->src_para.height = h2;
-
-        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-        ge2d_config->dst_para.canvas_index=PPMGR_DOUBLE_CANVAS_INDEX +  i;
-        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-        ge2d_config->dst_para.fill_color_en = 0;
-        ge2d_config->dst_para.fill_mode = 0;
-        ge2d_config->dst_para.x_rev = 0;
-        ge2d_config->dst_para.y_rev = 0;
-        ge2d_config->dst_para.color = 0;
-
-
-        ge2d_config->dst_para.top = 0;
-        ge2d_config->dst_para.left = 0;
-        ge2d_config->dst_para.width = w;
-        ge2d_config->dst_para.height = h2;
-        if(ge2d_context_config_ex(context,ge2d_config)<0) {
-            printk("++ge2d configing error.\n");
-            return;
-        }
-        fillrect(context ,l,t,w,h2,0x00808000 )    ;
-
-       ge2d_config->src_para.canvas_index=PPMGR_DOUBLE_CANVAS_INDEX + 4 + i;
-        ge2d_config->dst_para.canvas_index=PPMGR_DOUBLE_CANVAS_INDEX + 4 + i;
-        if(ge2d_context_config_ex(context,ge2d_config)<0) {
-            printk("++ge2d configing error.\n");
-            return;
-        }
-        fillrect(context ,l,t,w,h2,0x00808000 )    ;
-    }
-}
-
-static void window_clear_3D(ge2d_context_t *context, config_para_ex_t* ge2d_config,int index ,int l ,int t ,int w ,int h)
-{
-    ge2d_config->alu_const_color= 0;//0x000000ff;
-    ge2d_config->bitmask_en  = 0;
-    ge2d_config->src1_gb_alpha = 0;//0xff;
-    ge2d_config->dst_xy_swap = 0;
-
-    ge2d_config->src_key.key_enable = 0;
-    ge2d_config->src_key.key_mask = 0;
-    ge2d_config->src_key.key_mode = 0;
-    ge2d_config->src_para.canvas_index=  index;
-    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->src_para.fill_color_en = 0;
-    ge2d_config->src_para.fill_mode = 0;
-    ge2d_config->src_para.x_rev = 0;
-    ge2d_config->src_para.y_rev = 0;
-    ge2d_config->src_para.color = 0;
-    ge2d_config->src_para.top = 0;
-    ge2d_config->src_para.left = 0;
-    ge2d_config->src_para.width = 1920;
-    ge2d_config->src_para.height = 544;
-
-    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
-    ge2d_config->dst_para.canvas_index= index;
-    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
-
-    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
-    ge2d_config->dst_para.fill_color_en = 0;
-    ge2d_config->dst_para.fill_mode = 0;
-    ge2d_config->dst_para.x_rev = 0;
-    ge2d_config->dst_para.y_rev = 0;
-    ge2d_config->dst_para.color = 0;
-
-
-    ge2d_config->dst_para.top = 0;
-    ge2d_config->dst_para.left = 0;
-    ge2d_config->dst_para.width = 1920;
-    ge2d_config->dst_para.height = 544;
-    if(ge2d_context_config_ex(context,ge2d_config)<0) {
-        printk("++ge2d configing error.\n");
-        return;
-    }
-    fillrect(context ,l,t,w,h,0x00808000 )    ;
-}
-void ppmgr_buffer_clear(ge2d_context_t *context, config_para_ex_t* ge2d_config)
-{
-    switch(cur_process_type){
-    	case TYPE_NONE:
-    	case TYPE_3D_TO_2D_L:
-    	case TYPE_3D_TO_2D_R:
-    	buffer_clear_2D(context ,ge2d_config , -1)	;
-    	break;
-
-    	case TYPE_2D_TO_3D:
-    	case TYPE_LR:
-    	case TYPE_BT:
-    	case TYPE_LR_SWITCH:
-    	case TYPE_FILED_DEPTH:
-    	buffer_clear_3D(context ,ge2d_config, -1)	;
-    	break;
-    	default:
-    	break;
-    }
-}
-
-void ppmgr_index_clear(ge2d_context_t *context, config_para_ex_t* ge2d_config ,int index)
-{
-    switch(cur_process_type){
-    	case TYPE_NONE:
-    	case TYPE_3D_TO_2D_L:
-    	case TYPE_3D_TO_2D_R:
-    	buffer_clear_2D(context ,ge2d_config,index)	;
-    	break;
-
-    	case TYPE_2D_TO_3D:
-    	case TYPE_LR:
-    	case TYPE_BT:
-    	case TYPE_LR_SWITCH:
-    	case TYPE_FILED_DEPTH:
-    	buffer_clear_3D(context ,ge2d_config,index)	;
-    	break;
-    	default:
-    	break;
-    }
-}
-
-
-
-
-void ppmgr_vf_3d_tv(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
-{
-    display_frame_t input_frame ;
-    display_frame_t l_frame ,r_frame ;
-    canvas_t cd;
-    int process_type = get_tv_process_type(vf);
-    cur_process_type = process_type;    
-    get_input_frame(vf,&input_frame);
-    get_input_l_frame(vf,&l_frame);
-    get_input_r_frame(vf,&r_frame);
-
-     canvas_read(vf->canvas0Addr&0xff,&cd);
-    if(vf->type&VIDTYPE_VIU_422){
-         cd.width >>=1;
-    }
-    if(((input_frame.content_left +input_frame.content_width )> cd.width )
-     ||((input_frame.content_top +input_frame.content_height ) > cd.height )
-     ||((input_frame.frame_left +input_frame.frame_width )> cd.width )
-     ||((input_frame.frame_top +input_frame.frame_height ) > cd.height )){
-    ppmgr_vf_put_dec(vf);
-		printk("case 1: vdin canvas setting is not compatible with vframe!!!\n");
-		return ;
-    }
-
-    if(((l_frame.content_left +l_frame.content_width )> cd.width )
-     ||((l_frame.content_top +l_frame.content_height ) > cd.height )
-     ||((l_frame.frame_left +l_frame.frame_width )> cd.width )
-     ||((l_frame.frame_top +l_frame.frame_height ) > cd.height )){
-    ppmgr_vf_put_dec(vf);
-		printk("case 2: vdin canvas setting is not compatible with vframe!!!\n");
-		return ;
-    }
-
-    if(((r_frame.content_left +r_frame.content_width )> cd.width )
-     ||((r_frame.content_top +r_frame.content_height ) > cd.height )
-     ||((r_frame.frame_left +r_frame.frame_width )> cd.width )
-     ||((r_frame.frame_top +r_frame.frame_height ) > cd.height )){
-    ppmgr_vf_put_dec(vf);
-		printk("case 3:vdin canvas setting is not compatible with vframe!!!\n");
-		return ;
-    }
-    switch(process_type){
-        case TYPE_NONE           :
- //           printk("process  none type\n");
-// 		enable_vscaler();
-            process_none(vf,context,ge2d_config);
-            break;
-        case TYPE_2D_TO_3D       :
- //           printk("process 2d to 3d type\n");
-  //          process_2d_to_3d(vf,context,ge2d_config);
-            //process_none(vf,context,ge2d_config);
- //           disable_vscaler();
-            process_field_depth(vf,context,ge2d_config);
-            break;
-        case TYPE_LR             :
- //           printk("process  lr type\n");
-// 		disable_vscaler();
-            process_lr(vf,context,ge2d_config);
-            break;
-        case TYPE_BT             :
- //           printk("process  bt type\n");
-// 		disable_vscaler();
-            process_bt(vf,context,ge2d_config);
-            break;
-        case TYPE_LR_SWITCH      :
- //           printk("process  lr switch type\n");
-// 		disable_vscaler();
-            process_lr_switch(vf,context,ge2d_config);
-            break;
-        case TYPE_FILED_DEPTH    :
-//            printk("process field depth type\n");
- //           process_2d_to_3d(vf,context,ge2d_config);
-// 		disable_vscaler();
-            process_field_depth(vf,context,ge2d_config);
-            //process_none(vf,context,ge2d_config);
-            break;
-        case TYPE_3D_TO_2D_L     :
-//            printk("process  3d to 2d l type\n");
-//		enable_vscaler();
-            process_3d_to_2d_l(vf,context,ge2d_config);
-            break;
-        case TYPE_3D_TO_2D_R     :
-//        	enable_vscaler();
- //           printk("process  3d to  2d r type\n");
-            process_3d_to_2d_r(vf,context,ge2d_config);
-            break;
-        default:
-        break;
-    }
+    pp_vf->dec_frame = NULL;
+    memcpy(new_vf , vf, sizeof(vframe_t));
+//    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
+    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
+    index = pp_vf->index;
+    if(index < 0){
+        printk("======decoder is full\n");
+        //return -1;
+    }
+
+    cut_w = (((vf->width<<8) + 0x80) * ratio_value)>>16;
+    cut_h = (((vf->height<<8) + 0x80) * ratio_value)>>16;
+    x_offset = cut_w>>1;
+    x_offset = x_offset & 0xfffffffe;
+    y_offset = cut_h>>1;
+    y_offset = y_offset & 0xfffffffe;
+
+    new_vf->canvas0Addr = index2canvas_0(index);
+    new_vf->canvas1Addr = index2canvas_1(index);
+//ROUND_1:
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = y_offset;
+    ge2d_config->src_para.left = x_offset;
+    ge2d_config->src_para.width = vf->width-cut_w;
+    ge2d_config->src_para.height = vf->height-cut_h;
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    w1 = vf->width;
+    h1 = vf->height ;
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+    //w2 = vf->width ;
+    //h2 = vf->height;
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
+	}else{
+	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
+	}
+		t >>=1;
+		h >>=1;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2;
+
+ //   printk("t:%d l:%d w:%d h%d \n",t,l,w,h);
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+//    stretchblt_noalpha(context,0,0,vf->width/2,vf->height,t,l,w,h);
+    stretchblt_noalpha(context, x_offset, y_offset, vf->width-cut_w,vf->height-cut_h,l,t,w,h);
+
+//ROUND_2:
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas1Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = y_offset;
+    ge2d_config->src_para.left = x_offset;
+    ge2d_config->src_para.width = vf->width-cut_w;
+    ge2d_config->src_para.height = vf->height-cut_h;
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    w1 = vf->width;
+    h1 = vf->height ;
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+    //w2 = vf->width ;
+    //h2 = vf->height;
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
+	}else{
+	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
+	}
+		t >>=1;
+		h >>=1;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2;
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+//    stretchblt_noalpha(context,0,vf->width/2,vf->width/2,vf->height,t,l,w,h);
+    stretchblt_noalpha(context,0,0,vf->width,vf->height,l,t,w,h);
+    new_vf->width = w2;
+    new_vf->height = h2 ;
+    new_vf->ratio_control = 0;
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+}
+
+/*for 3D video input processing
+    1. output window should 1:1 as video layer size
+    2. must adjust GE2D operation according with the frame ratio ,then clear ratio control flag
+    3. need generate two buffer from source frame
+    4. input format should be YUV422 , output format should be YUV444
+*/
+void process_lr(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+    vframe_t* new_vf;
+    ppframe_t *pp_vf;
+    int index;
+    display_frame_t input_frame ;
+    display_frame_t l_frame ,r_frame ;
+    int t,l,w,h,w1,h1,w2,h2;
+    canvas_t cs0,cs1,cs2,cd;
+    new_vf = vfq_pop(&q_free);
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    memcpy(new_vf , vf, sizeof(vframe_t));
+    get_input_frame(vf,&input_frame);
+    get_input_l_frame(vf,&l_frame);
+    get_input_r_frame(vf,&r_frame);
+    new_vf->width= input_frame.content_width;
+    new_vf->height= input_frame.content_height;
+
+    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
+    new_vf->mode_3d_enable = 1;
+    index = pp_vf->index;
+    if(index < 0){
+        printk("======decoder is full\n");
+        //return -1;
+    }
+    new_vf->canvas0Addr = index2canvas_0(index);
+    new_vf->canvas1Addr = index2canvas_1(index);
+//ROUND_1:
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+
+//    printk("canvas 0 is %d , width is %d , height is %d \n" ,vf->canvas0Addr ,cs0.width,  cs0.height ) ;
+	ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+	ge2d_config->src_para.format = get_input_format(vf);
+	ge2d_config->src_para.fill_color_en = 0;
+	ge2d_config->src_para.fill_mode = 0;
+	ge2d_config->src_para.x_rev = 0;
+	ge2d_config->src_para.y_rev = 0;
+	ge2d_config->src_para.color = 0xffffffff;
+	ge2d_config->src_para.top = 0;
+	ge2d_config->src_para.left = 0;
+	ge2d_config->src_para.width = vf->width;
+	if(is_vertical_sample_enable(vf)){
+		ge2d_config->src_para.height = vf->height/2;
+	}else{
+		ge2d_config->src_para.height = vf->height;
+	}
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    w1 = input_frame.content_width;
+    h1 = input_frame.content_height ;
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
+	}else{
+	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
+	}
+		t >>=1;
+		h >>=1;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2/2;
+
+//    printk("t:%d l:%d w:%d h%d w2:%d h2:%d\n",t,l,w,h,w2,h2);
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+//    stretchblt_noalpha(context,0,0,vf->width/2,vf->height,t,l,w,h);
+	    axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
+	if(is_vertical_sample_enable(vf)){
+		stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height/2,l,t,w,h);
+	}else{
+		stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height,l,t,w,h);
+	}
+//ROUND_2:
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas1Addr&0xff,&cs0);
+    canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas1Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+
+    ge2d_config->src_para.canvas_index=vf->canvas1Addr;
+
+//    printk("canvas 1 is %d , width is %d , height is %d \n" ,vf->canvas1Addr ,cs0.width,  cs0.height ) ;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = vf->width;
+    if(is_vertical_sample_enable(vf)){
+		ge2d_config->src_para.height = vf->height/2;
+	}else{
+		ge2d_config->src_para.height = vf->height ;
+	}
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    w1 = input_frame.content_width;
+    h1 = input_frame.content_height ;
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
+	}else{
+	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
+	}
+		t >>=1;
+		h >>=1;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2/2;
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+//    stretchblt_noalpha(context,vf->width/2 ,0,vf->width/2,vf->height,l,t,w,h);
+	axis_h_adjust(vf , &l ,  &w , &w2 , get_ppmgr_scale_width() );
+	if(is_vertical_sample_enable(vf)){
+		stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height/2,l,t,w,h);
+	}else{
+		stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height ,l,t,w,h);
+	}
+    new_vf->width =  w2;
+    new_vf->height = h2 ;
+    new_vf->ratio_control = 0;
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+}
+
+void process_bt(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+    vframe_t* new_vf;
+    ppframe_t *pp_vf;
+    int index;
+    display_frame_t input_frame ;
+    display_frame_t l_frame ,r_frame ;
+    int t,l,w,h,w1,h1,w2,h2;
+    canvas_t cs0,cs1,cs2,cd;
+    new_vf = vfq_pop(&q_free);
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    memcpy(new_vf , vf, sizeof(vframe_t));
+    get_input_frame(vf,&input_frame);
+    get_input_l_frame(vf,&l_frame);
+    get_input_r_frame(vf,&r_frame);
+    new_vf->width= input_frame.content_width;
+    new_vf->height= input_frame.content_height;
+
+    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
+    new_vf->mode_3d_enable = 1 ;
+    index = pp_vf->index;
+    if(index < 0){
+        printk("======decoder is full\n");
+        //return -1;
+    }
+    new_vf->canvas0Addr = index2canvas_0(index);
+    new_vf->canvas1Addr = index2canvas_1(index);
+//ROUND_1:
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = vf->width;
+	if(is_vertical_sample_enable(vf)){
+		ge2d_config->src_para.height = vf->height/2;
+	}else{
+		ge2d_config->src_para.height = vf->height;
+	}
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    w1 = input_frame.content_width;
+    h1 = input_frame.content_height ;
+#if 1
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+#else
+    w2 = vf->width ;
+    h2 = vf->height;
+#endif
+
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
+	}else{
+	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
+	}
+		t >>=1;
+		h >>=1;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2;
+
+//    printk("t:%d l:%d w:%d h%d \n",t,l,w,h);
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+ //   stretchblt_noalpha(context,0,0,vf->width,vf->height/2,l,t,w,h);
+
+ //   stretchblt_noalpha(context,0,input_frame.content_top,input_frame.frame_width,input_frame.content_height/2,l,t,w,h);
+	axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
+	 if(is_vertical_sample_enable(vf)){
+		stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height/2,l,t,w,h);
+	}else{
+		stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height,l,t,w,h);
+	}
+
+//ROUND_2:
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas1Addr&0xff,&cs0);
+    canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas1Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+
+    ge2d_config->src_para.canvas_index=vf->canvas1Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = vf->width;
+	if(is_vertical_sample_enable(vf)){
+		ge2d_config->src_para.height = vf->height/2;
+	}else{
+		ge2d_config->src_para.height = vf->height;
+	}
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    w1 = input_frame.content_width;
+    h1 = input_frame.content_height ;
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
+	}else{
+	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
+	}
+		t >>=1;
+		h >>=1;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2;
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+//    stretchblt_noalpha(context,0 ,vf->height/2,vf->width,vf->height/2,l,t,w,h);
+//   stretchblt_noalpha(context,0,input_frame.frame_height/2,input_frame.frame_width,input_frame.content_height/2,l,t,w,h);
+    axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
+    if(is_vertical_sample_enable(vf)){
+		stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height/2,l,t,w,h);
+	}else{
+		stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height,l,t,w,h);
+	}
+    new_vf->width = w2;
+    new_vf->height = h2 ;
+    new_vf->ratio_control = 0;
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+}
+
+void process_lr_switch(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+#if 0
+    vframe_t* new_vf;
+    int index;
+    display_frame_t input_frame ;
+    display_frame_t l_frame ,r_frame ;
+    canvas_t cs0,cs1,cs2,cd;
+    new_vf = &vfpool[fill_ptr];
+    memcpy(new_vf , vf, sizeof(vframe_t));
+    get_input_frame(vf,&input_frame);
+    get_input_l_frame(vf,&l_frame);
+    get_input_r_frame(vf,&r_frame);
+    new_vf->width= input_frame.frame_width;
+    new_vf->height= input_frame.frame_height;
+
+    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
+    index = pp_vf->index;
+    if(index < 0){
+        printk("======decoder is full\n");
+        //return -1;
+    }
+    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(index);
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = vf->width;
+    ge2d_config->src_para.height = vf->height;
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = new_vf->width;
+    ge2d_config->dst_para.height = new_vf->height;
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+//    stretchblt_noalpha(context,0,0,vf->width/2,vf->height,new_vf->width/2,0,new_vf->width/2,new_vf->height);
+
+    stretchblt_noalpha(context,input_frame.content_left,0,input_frame.content_width/2,input_frame.content_height, new_vf->width/2,0,input_frame.content_width/2 ,input_frame.frame_height);
+
+ROUND2:
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+ //   stretchblt_noalpha(context,vf->width/2 ,0,vf->width/2,vf->height,0,0,new_vf->width/2,new_vf->height);
+
+    stretchblt_noalpha(context,input_frame.frame_width/2,0,input_frame.content_width/2,input_frame.content_height, input_frame.content_left,0,input_frame.content_width/2 ,input_frame.frame_height);
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+#else
+    vframe_t* new_vf;
+    ppframe_t *pp_vf;
+    int index;
+    display_frame_t input_frame ;
+    display_frame_t l_frame ,r_frame ;
+    int t,l,w,h,w1,h1,w2,h2;
+    canvas_t cs0,cs1,cs2,cd;
+    new_vf = vfq_pop(&q_free);
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    memcpy(new_vf , vf, sizeof(vframe_t));
+    get_input_frame(vf,&input_frame);
+    get_input_l_frame(vf,&l_frame);
+    get_input_r_frame(vf,&r_frame);
+    new_vf->width= input_frame.content_width;
+    new_vf->height= input_frame.content_height;
+
+    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
+    new_vf->mode_3d_enable = 1 ;
+    index = pp_vf->index;
+    if(index < 0){
+        printk("======decoder is full\n");
+        //return -1;
+    }
+    new_vf->canvas0Addr = index2canvas_0(index);
+    new_vf->canvas1Addr = index2canvas_1(index);
+//ROUND_1:
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = vf->width;
+	if(is_vertical_sample_enable(vf)){
+		ge2d_config->src_para.height = vf->height/2;
+	}else{
+    ge2d_config->src_para.height = vf->height;
+	}
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    w1 = input_frame.content_width;
+    h1 = input_frame.content_height ;
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+
+
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
+	}else{
+	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
+	}
+		t >>=1;
+		h >>=1;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2;
+
+ //   printk("t:%d l:%d w:%d h%d \n",t,l,w,h);
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+//    stretchblt_noalpha(context,0,0,vf->width/2,vf->height,t,l,w,h);
+
+	axis_h_adjust(vf , &l ,  &w , &w2 , get_ppmgr_scale_width() );
+	if(is_vertical_sample_enable(vf)){
+		stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height/2,l,t,w,h);
+	}else{
+stretchblt_noalpha(context,r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height,l,t,w,h);
+	}
+
+//ROUND_2:
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas1Addr&0xff,&cs0);
+    canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas1Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+
+    ge2d_config->src_para.canvas_index=vf->canvas1Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = vf->width;
+    if(is_vertical_sample_enable(vf)){
+		ge2d_config->src_para.height = vf->height/2;
+	}else{
+    ge2d_config->src_para.height = vf->height;
+	}
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    w1 = input_frame.content_width;
+    h1 = input_frame.content_height ;
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
+	}else{
+	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
+	}
+		t >>=1;
+		h >>=1;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2;
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+//    stretchblt_noalpha(context,vf->width/2 ,0,vf->width/2,vf->height,l,t,w,h);
+	    axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
+	if(is_vertical_sample_enable(vf)){
+		stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height/2,l,t,w,h);
+	}else{
+	stretchblt_noalpha(context,l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height,l,t,w,h);
+	}
+    new_vf->width = w2;
+    new_vf->height = h2 ;
+    new_vf->height = h2 ;
+    new_vf->ratio_control = 0;
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+
+#endif
+}
+
+extern int get_depth(void);
+
+static int x_phase = 2048; // >0: image move to left. <0: image move to right, 0~7 is phase value, 8-30 is offset
+static void process_field_depth(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+    vframe_t* new_vf;
+    ppframe_t *pp_vf;
+    int index;
+    display_frame_t input_frame ;
+    int t,l,w,h,w1,h1,w2,h2;
+    int ll , tt ,ww , hh;
+    int src_l , src_t, src_w ,src_h , dst_l,dst_t,dst_w , dst_h;
+    int x_offset = 0;
+    int type = 0 ;
+    unsigned cur_phase = 0;
+    unsigned cut_w = 0;
+    unsigned temp_w = 0;
+    canvas_t cs0,cs1,cs2,cd;
+    new_vf = vfq_pop(&q_free);
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    memcpy(new_vf , vf, sizeof(vframe_t));
+    get_input_frame(vf,&input_frame);
+//    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
+    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
+    new_vf->mode_3d_enable = 1 ;
+    index = pp_vf->index;
+    if(index < 0){
+        printk("======decoder is full\n");
+        //return -1;
+    }
+    x_phase = get_depth();
+
+//    if(x_phase<0){
+//        x_offset = -(((unsigned)x_phase&0xfffffff)>>8);
+//        cur_phase = x_phase&0xff;
+//        if(cur_phase){
+//            x_offset--;
+//            cur_phase = 0x100-cur_phase;
+//        }
+//        cut_w = -x_offset;
+//    }else if(x_phase>0){
+//        x_offset = ((x_phase&0xfffffff)>>8);
+//        cur_phase = x_phase&0xff;
+//        cut_w = x_offset;
+//    }
+
+	if(x_phase & 0x10000000){
+		type  = 0 ;
+	}else{
+		type =  1;
+	}
+
+
+    new_vf->canvas0Addr = index2canvas_0(index);
+    new_vf->canvas1Addr = index2canvas_1(index);
+//ROUND_1:
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = vf->width;
+	if(is_vertical_sample_enable(vf)){
+		ge2d_config->src_para.height = vf->height/2;
+	}else{
+		ge2d_config->src_para.height = vf->height;
+	}
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+
+    if(is_need_cut_window_support(vf)){
+	w1 = input_frame.frame_width - 2*ppmgr_cutwin_left ;
+	h1 = input_frame.frame_height - 2*ppmgr_cutwin_top;
+    }else{
+    w1 = input_frame.frame_width;
+    h1 = input_frame.frame_height ;
+    }
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
+	}else{
+	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
+	}
+		t >>=1;
+		h >>=1;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2/2;
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+    x_phase  &= 0xfffffff;
+    x_offset_adjust(vf , &x_phase,w2 ,get_ppmgr_scale_width());
+
+	x_offset = ((x_phase&0xfffffff)>>8);
+	x_offset &= ~1;
+	cur_phase = x_phase&0xff;
+	cut_w = x_offset;
+
+	axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
+
+	if(is_need_cut_window_support(vf)){
+		ll = input_frame.frame_left + ppmgr_cutwin_left ;
+		tt = input_frame.frame_top + ppmgr_cutwin_top;
+		ww = input_frame.frame_width - 2*ppmgr_cutwin_left ;
+		hh = input_frame.frame_height - 2*ppmgr_cutwin_top;
+	}else{
+		ll = input_frame.frame_left ;
+		tt = input_frame.frame_top;
+		ww = input_frame.frame_width;
+		hh = input_frame.frame_height;
+	}
+	if(is_vertical_sample_enable(vf)){
+		stretchblt_noalpha(context,ll,tt,ww ,hh/2,l,t,w,h);
+	}else{
+		stretchblt_noalpha(context,ll,tt,ww ,hh,l,t,w,h);
+	}
+
+//ROUND_2:
+    /* data operating. */
+  //  if(w1 >= 1280 ){
+  if (0){
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas1Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = vf->width;
+    ge2d_config->src_para.height = vf->height;
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    w1 = input_frame.frame_width;
+    h1 = input_frame.frame_height ;
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+
+    temp_w = (input_frame.frame_width-cut_w)*w2/w1;
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,h1,w2,h2);
+	}else{
+	      get_output_rect_after_ratio(vf,&t,&l,&w,&h,w1,2*h1,w2,h2);
+	}
+		t >>=1;
+		h >>=1;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2/2;
+    if(ge2d_config->hf_init_phase){
+        ge2d_config->hf_rpt_num = 1;
+        ge2d_config->hf_init_phase = cur_phase<<16;
+    }
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+   stretchblt_noalpha(context,(x_offset<0)?0:(input_frame.frame_left+x_offset) ,input_frame.frame_top,input_frame.frame_width - cut_w ,input_frame.frame_height,(x_offset<0)?(l+w2-temp_w):l,t,temp_w,h);
+}else{
+    ge2d_config->src_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = w2;
+    ge2d_config->src_para.height = h2/2;
+
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+
+    ge2d_config->src_planes[0].addr = cd.addr;
+    ge2d_config->src_planes[0].w = cd.width;
+    ge2d_config->src_planes[0].h = cd.height;
+
+    canvas_read(new_vf->canvas1Addr&0xff,&cd);
+
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas1Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    if(type == 0){
+	    src_t = 0;
+	    src_l =  x_offset;
+	    src_w = (w2- x_offset);
+	    src_h = h2/2;
+
+	    dst_t = 0 ;
+	    dst_l = 0;
+	    dst_w = src_w;
+	    dst_h = h2/2;
+	}else{
+	    src_t = 0;
+	    src_l =  0;
+	    src_w =(w2- x_offset);
+	    src_h = h2/2;
+
+	    dst_t = 0 ;
+	    dst_l = x_offset ;
+	    dst_w = src_w;
+	    dst_h = h2/2;
+	}
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = w2;
+    ge2d_config->dst_para.height = h2/2;
+    if(ge2d_config->hf_init_phase){
+        ge2d_config->hf_rpt_num = 1;
+        ge2d_config->hf_init_phase = cur_phase<<16;
+    }
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+   stretchblt_noalpha(context,src_l , src_t, src_w ,src_h , dst_l,dst_t,dst_w , dst_h);
+
+   if(type == 0){
+	    src_t = 0;
+	    src_l =  0;
+	    src_w =  x_offset;
+	    src_h = h2/2;
+
+	    dst_t = 0 ;
+	    dst_l = w2 - x_offset;
+	    dst_w = x_offset;
+	    dst_h = h2/2;
+
+	}else{
+	    src_t = 0;
+	    src_l =  w2 - x_offset;
+	    src_w =  x_offset;
+	    src_h = h2/2;
+
+	    dst_t = 0 ;
+	    dst_l = 0 ;
+	    dst_w = x_offset;
+	    dst_h = h2/2;
+	}
+	if(src_w > 0){
+		window_clear_3D(context ,ge2d_config ,new_vf->canvas0Addr , src_l ,src_t ,src_w ,src_h);
+		window_clear_3D(context ,ge2d_config ,new_vf->canvas1Addr , dst_l ,dst_t ,dst_w ,dst_h);
+}
+}
+    new_vf->width = w2;
+    new_vf->height = h2 ;
+    new_vf->ratio_control = 0;
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+    return;
+}
+
+void process_3d_to_2d_l(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+    vframe_t* new_vf;
+    ppframe_t *pp_vf;
+    int index;
+    display_frame_t input_frame ;
+    display_frame_t l_frame ,r_frame ;
+    canvas_t cs0,cs1,cs2,cd;
+    int t,l,w,h,w1,h1,w2,h2;
+    new_vf = vfq_pop(&q_free);
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    memcpy(new_vf , vf, sizeof(vframe_t));
+    get_input_frame(vf,&input_frame);
+    get_input_l_frame(vf,&l_frame);
+    get_input_r_frame(vf,&r_frame);
+
+    new_vf->width= input_frame.content_width;
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+	    new_vf->height= input_frame.content_height;
+	}else{
+		new_vf->height= input_frame.content_height <<1;
+	}
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    if(is_need_cut_window_support(vf)){
+	w1 = input_frame.frame_width - 2*ppmgr_cutwin_left ;
+	h1 = input_frame.frame_height - 2*ppmgr_cutwin_top;
+    }else{
+    w1 = new_vf->width;
+    h1 = new_vf->height ;
+    }
+
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+    get_2d_output_rect_after_ratio(&t,&l,&w,&h,w1,h1,w2,h2);
+    new_vf->width  = w + 2*l ;
+    new_vf->height = h + 2*t;
+    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
+    new_vf->mode_3d_enable = 0 ;
+    //new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
+    index = pp_vf->index;
+    if(index < 0){
+        printk("======decoder is full\n");
+        //return -1;
+    }
+    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(index);
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    if(is_vertical_sample_enable(vf)){
+	    ge2d_config->src_para.width = vf->width;
+	    ge2d_config->src_para.height = vf->height/2;
+	}else{
+    ge2d_config->src_para.width = vf->width;
+    ge2d_config->src_para.height = vf->height;
+	}
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = new_vf->width;
+    ge2d_config->dst_para.height = new_vf->height;
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+    axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
+    if(is_vertical_sample_enable(vf)){
+	stretchblt_noalpha(context, l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height/2,l,t,w,h);
+	}else{
+    stretchblt_noalpha(context, l_frame.content_left,l_frame.content_top,l_frame.content_width,l_frame.content_height,l,t,w,h);
+	}
+
+    new_vf->width = w2 ;
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+}
+
+void process_3d_to_2d_r(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+    vframe_t* new_vf;
+    ppframe_t *pp_vf;
+    int index;
+    display_frame_t input_frame ;
+    display_frame_t l_frame ,r_frame ;
+    canvas_t cs0,cs1,cs2,cd;
+    int t,l,w,h,w1,h1,w2,h2;
+    new_vf = vfq_pop(&q_free);
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    memcpy(new_vf , vf, sizeof(vframe_t));
+    get_input_frame(vf,&input_frame);
+    get_input_l_frame(vf,&l_frame);
+    get_input_r_frame(vf,&r_frame);
+    new_vf->width= input_frame.content_width;
+	if(!(vf->type & VIDTYPE_PRE_INTERLACE)){
+		new_vf->height= input_frame.content_height;
+	}else{
+		new_vf->height= input_frame.content_height <<1;
+	}
+    t = 0;
+    l = 0;
+    w = 0;
+    h = 0;
+    if(is_need_cut_window_support(vf)){
+	w1 = input_frame.frame_width - 2*ppmgr_cutwin_left ;
+	h1 = input_frame.frame_height - 2*ppmgr_cutwin_top;
+    }else{
+    w1 = new_vf->width;
+    h1 = new_vf->height ;
+    }
+    w2 = get_output_width(1) ;
+    h2 = get_output_height(1);
+    get_2d_output_rect_after_ratio(&t,&l,&w,&h,w1,h1,w2,h2);
+    new_vf->width  = w + 2*l ;
+    new_vf->height = h + 2*t;
+    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
+    new_vf->mode_3d_enable = 0 ;
+    //new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
+    index = pp_vf->index;
+    if(index < 0){
+        printk("======decoder is full\n");
+        //return -1;
+    }
+    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(index);
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas1Addr&0xff,&cs0);
+    canvas_read((vf->canvas1Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas1Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas1Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = get_input_format(vf);
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    if(is_vertical_sample_enable(vf)){
+	    ge2d_config->src_para.width = vf->width;
+	    ge2d_config->src_para.height = vf->height/2;
+	}else{
+    ge2d_config->src_para.width = vf->width;
+    ge2d_config->src_para.height = vf->height;
+	}
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = new_vf->width;
+    ge2d_config->dst_para.height = new_vf->height;
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+
+    axis_h_adjust(vf, &l ,  &w , &w2 ,  get_ppmgr_scale_width() );
+    if(is_vertical_sample_enable(vf)){
+	stretchblt_noalpha(context, r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height/2,l,t,w,h);
+	}else{
+    stretchblt_noalpha(context, r_frame.content_left,r_frame.content_top,r_frame.content_width,r_frame.content_height,l,t,w,h);
+	}
+    new_vf->width = w2 ;
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+}
+
+/*for camera input processing*/
+void process_camera_input(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+    vframe_t* new_vf;
+    ppframe_t *pp_vf;
+    int index;
+    canvas_t cs0,cs1,cs2,cd;
+    new_vf = vfq_pop(&q_free);
+
+    if (unlikely((!new_vf) || (!vf)))
+        return;
+    pp_vf = to_ppframe(new_vf);
+    pp_vf->dec_frame = NULL;
+    memcpy(new_vf , vf, sizeof(vframe_t));
+ //   new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE | VIDTYPE_VIU_FIELD;/*vf->type;*/
+    new_vf->type = VIDTYPE_VIU_444|VIDTYPE_VIU_SINGLE_PLANE |  VIDTYPE_PROGRESSIVE ;
+    new_vf->mode_3d_enable = 0 ;
+    new_vf->width = get_output_width(2);
+    new_vf->height = get_output_height(2);
+
+    index = pp_vf->index;
+    if(index < 0){
+        printk("======decoder is full\n");
+        //return -1;
+    }
+    new_vf->canvas0Addr = new_vf->canvas1Addr = index2canvas(index);
+
+    /* data operating. */
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    canvas_read(vf->canvas0Addr&0xff,&cs0);
+    canvas_read((vf->canvas0Addr>>8)&0xff,&cs1);
+    canvas_read((vf->canvas0Addr>>16)&0xff,&cs2);
+    ge2d_config->src_planes[0].addr = cs0.addr;
+    ge2d_config->src_planes[0].w = cs0.width;
+    ge2d_config->src_planes[0].h = cs0.height;
+    ge2d_config->src_planes[1].addr = cs1.addr;
+    ge2d_config->src_planes[1].w = cs1.width;
+    ge2d_config->src_planes[1].h = cs1.height;
+    ge2d_config->src_planes[2].addr = cs2.addr;
+    ge2d_config->src_planes[2].w = cs2.width;
+    ge2d_config->src_planes[2].h = cs2.height;
+    canvas_read(new_vf->canvas0Addr&0xff,&cd);
+    ge2d_config->dst_planes[0].addr = cd.addr;
+    ge2d_config->dst_planes[0].w = cd.width;
+    ge2d_config->dst_planes[0].h = cd.height;
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_para.canvas_index=vf->canvas0Addr;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = GE2D_FORMAT_M24_YUV420;
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0xffffffff;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = vf->width;
+    ge2d_config->src_para.height = vf->height;
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index=new_vf->canvas0Addr;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.format = get_output_format(0);
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = new_vf->width;
+    ge2d_config->dst_para.height = new_vf->height;
+
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+    stretchblt_noalpha(context,0,0,vf->width,vf->height,0,0,new_vf->width,new_vf->height);
+
+    ppmgr_vf_put_dec(vf);
+    vfq_push(&q_ready, new_vf);
+}
+
+static void buffer_clear_2D(ge2d_context_t *context, config_para_ex_t* ge2d_config,int index)
+{
+    int i ,t,l,w,h1,h2;
+    int current_view_mode;
+
+    t = 0;
+    l = 0;
+    //w = get_output_width(1) ;
+    //h = get_output_height(1);
+    w = 1920 ;
+    h1 = 1088;
+    h2 = 544;
+
+	current_view_mode  = get_ppmgr_view_mode();
+    for (i = 0; i < VF_POOL_SIZE; i++){
+	if((index >= 0)&&(index != i)){
+		continue;
+	}
+	if((index >=0 )&&(current_view_mode == VIEWMODE_4_3)){
+		w = 240;
+	}
+        ge2d_config->alu_const_color= 0;//0x000000ff;
+        ge2d_config->bitmask_en  = 0;
+        ge2d_config->src1_gb_alpha = 0;//0xff;
+        ge2d_config->dst_xy_swap = 0;
+
+        ge2d_config->src_key.key_enable = 0;
+        ge2d_config->src_key.key_mask = 0;
+        ge2d_config->src_key.key_mode = 0;
+
+        ge2d_config->src_para.canvas_index=PPMGR_CANVAS_INDEX + i;
+        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->src_para.fill_color_en = 0;
+        ge2d_config->src_para.fill_mode = 0;
+        ge2d_config->src_para.x_rev = 0;
+        ge2d_config->src_para.y_rev = 0;
+        ge2d_config->src_para.color = 0;
+        ge2d_config->src_para.top = 0;
+        ge2d_config->src_para.left = 0;
+        ge2d_config->src_para.width = w;
+        ge2d_config->src_para.height = h1;
+
+        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->dst_para.canvas_index=PPMGR_CANVAS_INDEX + i;
+        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->dst_para.fill_color_en = 0;
+        ge2d_config->dst_para.fill_mode = 0;
+        ge2d_config->dst_para.x_rev = 0;
+        ge2d_config->dst_para.y_rev = 0;
+        ge2d_config->dst_para.color = 0;
+
+
+        ge2d_config->dst_para.top = 0;
+        ge2d_config->dst_para.left = 0;
+        ge2d_config->dst_para.width = w;
+        ge2d_config->dst_para.height = h1;
+        if(ge2d_context_config_ex(context,ge2d_config)<0) {
+            printk("++ge2d configing error.\n");
+            return;
+        }
+        fillrect(context ,l,t,w,h1,0x00808000 )    ;
+    }
+}
+
+static void buffer_clear_3D(ge2d_context_t *context, config_para_ex_t* ge2d_config,int index)
+{
+    int i ,t,l,w,h1,h2;
+    t = 0;
+    l = 0;
+    w = 1920 ;
+    h1 = 1088;
+    h2 = 544;
+    for (i = 0; i < VF_POOL_SIZE; i++){
+	if((index >= 0)&&(index != i)){
+		continue;
+	}
+        ge2d_config->alu_const_color= 0;//0x000000ff;
+        ge2d_config->bitmask_en  = 0;
+        ge2d_config->src1_gb_alpha = 0;//0xff;
+        ge2d_config->dst_xy_swap = 0;
+
+        ge2d_config->src_key.key_enable = 0;
+        ge2d_config->src_key.key_mask = 0;
+        ge2d_config->src_key.key_mode = 0;
+        ge2d_config->src_para.canvas_index=PPMGR_DOUBLE_CANVAS_INDEX + i;
+        ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->src_para.fill_color_en = 0;
+        ge2d_config->src_para.fill_mode = 0;
+        ge2d_config->src_para.x_rev = 0;
+        ge2d_config->src_para.y_rev = 0;
+        ge2d_config->src_para.color = 0;
+        ge2d_config->src_para.top = 0;
+        ge2d_config->src_para.left = 0;
+        ge2d_config->src_para.width = w;
+        ge2d_config->src_para.height = h2;
+
+        ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+        ge2d_config->dst_para.canvas_index=PPMGR_DOUBLE_CANVAS_INDEX +  i;
+        ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+        ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+        ge2d_config->dst_para.fill_color_en = 0;
+        ge2d_config->dst_para.fill_mode = 0;
+        ge2d_config->dst_para.x_rev = 0;
+        ge2d_config->dst_para.y_rev = 0;
+        ge2d_config->dst_para.color = 0;
+
+
+        ge2d_config->dst_para.top = 0;
+        ge2d_config->dst_para.left = 0;
+        ge2d_config->dst_para.width = w;
+        ge2d_config->dst_para.height = h2;
+        if(ge2d_context_config_ex(context,ge2d_config)<0) {
+            printk("++ge2d configing error.\n");
+            return;
+        }
+        fillrect(context ,l,t,w,h2,0x00808000 )    ;
+
+       ge2d_config->src_para.canvas_index=PPMGR_DOUBLE_CANVAS_INDEX + 4 + i;
+        ge2d_config->dst_para.canvas_index=PPMGR_DOUBLE_CANVAS_INDEX + 4 + i;
+        if(ge2d_context_config_ex(context,ge2d_config)<0) {
+            printk("++ge2d configing error.\n");
+            return;
+        }
+        fillrect(context ,l,t,w,h2,0x00808000 )    ;
+    }
+}
+
+static void window_clear_3D(ge2d_context_t *context, config_para_ex_t* ge2d_config,int index ,int l ,int t ,int w ,int h)
+{
+    ge2d_config->alu_const_color= 0;//0x000000ff;
+    ge2d_config->bitmask_en  = 0;
+    ge2d_config->src1_gb_alpha = 0;//0xff;
+    ge2d_config->dst_xy_swap = 0;
+
+    ge2d_config->src_key.key_enable = 0;
+    ge2d_config->src_key.key_mask = 0;
+    ge2d_config->src_key.key_mode = 0;
+    ge2d_config->src_para.canvas_index=  index;
+    ge2d_config->src_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->src_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->src_para.fill_color_en = 0;
+    ge2d_config->src_para.fill_mode = 0;
+    ge2d_config->src_para.x_rev = 0;
+    ge2d_config->src_para.y_rev = 0;
+    ge2d_config->src_para.color = 0;
+    ge2d_config->src_para.top = 0;
+    ge2d_config->src_para.left = 0;
+    ge2d_config->src_para.width = 1920;
+    ge2d_config->src_para.height = 544;
+
+    ge2d_config->src2_para.mem_type = CANVAS_TYPE_INVALID;
+    ge2d_config->dst_para.canvas_index= index;
+    ge2d_config->dst_para.mem_type = CANVAS_TYPE_INVALID;
+
+    ge2d_config->dst_para.format = GE2D_FORMAT_S24_YUV444;
+    ge2d_config->dst_para.fill_color_en = 0;
+    ge2d_config->dst_para.fill_mode = 0;
+    ge2d_config->dst_para.x_rev = 0;
+    ge2d_config->dst_para.y_rev = 0;
+    ge2d_config->dst_para.color = 0;
+
+
+    ge2d_config->dst_para.top = 0;
+    ge2d_config->dst_para.left = 0;
+    ge2d_config->dst_para.width = 1920;
+    ge2d_config->dst_para.height = 544;
+    if(ge2d_context_config_ex(context,ge2d_config)<0) {
+        printk("++ge2d configing error.\n");
+        return;
+    }
+    fillrect(context ,l,t,w,h,0x00808000 )    ;
+}
+void ppmgr_buffer_clear(ge2d_context_t *context, config_para_ex_t* ge2d_config)
+{
+    switch(cur_process_type){
+	case TYPE_NONE:
+	case TYPE_3D_TO_2D_L:
+	case TYPE_3D_TO_2D_R:
+	buffer_clear_2D(context ,ge2d_config , -1)	;
+	break;
+
+	case TYPE_2D_TO_3D:
+	case TYPE_LR:
+	case TYPE_BT:
+	case TYPE_LR_SWITCH:
+	case TYPE_FILED_DEPTH:
+	buffer_clear_3D(context ,ge2d_config, -1)	;
+	break;
+	default:
+	break;
+    }
+}
+
+void ppmgr_index_clear(ge2d_context_t *context, config_para_ex_t* ge2d_config ,int index)
+{
+    switch(cur_process_type){
+	case TYPE_NONE:
+	case TYPE_3D_TO_2D_L:
+	case TYPE_3D_TO_2D_R:
+	buffer_clear_2D(context ,ge2d_config,index)	;
+	break;
+
+	case TYPE_2D_TO_3D:
+	case TYPE_LR:
+	case TYPE_BT:
+	case TYPE_LR_SWITCH:
+	case TYPE_FILED_DEPTH:
+	buffer_clear_3D(context ,ge2d_config,index)	;
+	break;
+	default:
+	break;
+    }
+}
+
+
+
+
+void ppmgr_vf_3d_tv(vframe_t* vf, ge2d_context_t *context,config_para_ex_t* ge2d_config)
+{
+    display_frame_t input_frame ;
+    display_frame_t l_frame ,r_frame ;
+    canvas_t cd;
+    int process_type = get_tv_process_type(vf);
+    cur_process_type = process_type;
+    get_input_frame(vf,&input_frame);
+    get_input_l_frame(vf,&l_frame);
+    get_input_r_frame(vf,&r_frame);
+
+     canvas_read(vf->canvas0Addr&0xff,&cd);
+    if(vf->type&VIDTYPE_VIU_422){
+         cd.width >>=1;
+    }
+    if(((input_frame.content_left +input_frame.content_width )> cd.width )
+     ||((input_frame.content_top +input_frame.content_height ) > cd.height )
+     ||((input_frame.frame_left +input_frame.frame_width )> cd.width )
+     ||((input_frame.frame_top +input_frame.frame_height ) > cd.height )){
+    ppmgr_vf_put_dec(vf);
+		printk("case 1: vdin canvas setting is not compatible with vframe!!!\n");
+		return ;
+    }
+
+    if(((l_frame.content_left +l_frame.content_width )> cd.width )
+     ||((l_frame.content_top +l_frame.content_height ) > cd.height )
+     ||((l_frame.frame_left +l_frame.frame_width )> cd.width )
+     ||((l_frame.frame_top +l_frame.frame_height ) > cd.height )){
+    ppmgr_vf_put_dec(vf);
+		printk("case 2: vdin canvas setting is not compatible with vframe!!!\n");
+		return ;
+    }
+
+    if(((r_frame.content_left +r_frame.content_width )> cd.width )
+     ||((r_frame.content_top +r_frame.content_height ) > cd.height )
+     ||((r_frame.frame_left +r_frame.frame_width )> cd.width )
+     ||((r_frame.frame_top +r_frame.frame_height ) > cd.height )){
+    ppmgr_vf_put_dec(vf);
+		printk("case 3:vdin canvas setting is not compatible with vframe!!!\n");
+		return ;
+    }
+    switch(process_type){
+        case TYPE_NONE           :
+ //           printk("process  none type\n");
+// 		enable_vscaler();
+            process_none(vf,context,ge2d_config);
+            break;
+        case TYPE_2D_TO_3D       :
+ //           printk("process 2d to 3d type\n");
+  //          process_2d_to_3d(vf,context,ge2d_config);
+            //process_none(vf,context,ge2d_config);
+ //           disable_vscaler();
+            process_field_depth(vf,context,ge2d_config);
+            break;
+        case TYPE_LR             :
+ //           printk("process  lr type\n");
+// 		disable_vscaler();
+            process_lr(vf,context,ge2d_config);
+            break;
+        case TYPE_BT             :
+ //           printk("process  bt type\n");
+// 		disable_vscaler();
+            process_bt(vf,context,ge2d_config);
+            break;
+        case TYPE_LR_SWITCH      :
+ //           printk("process  lr switch type\n");
+// 		disable_vscaler();
+            process_lr_switch(vf,context,ge2d_config);
+            break;
+        case TYPE_FILED_DEPTH    :
+//            printk("process field depth type\n");
+ //           process_2d_to_3d(vf,context,ge2d_config);
+// 		disable_vscaler();
+            process_field_depth(vf,context,ge2d_config);
+            //process_none(vf,context,ge2d_config);
+            break;
+        case TYPE_3D_TO_2D_L     :
+//            printk("process  3d to 2d l type\n");
+//		enable_vscaler();
+            process_3d_to_2d_l(vf,context,ge2d_config);
+            break;
+        case TYPE_3D_TO_2D_R     :
+//        	enable_vscaler();
+ //           printk("process  3d to  2d r type\n");
+            process_3d_to_2d_r(vf,context,ge2d_config);
+            break;
+        default:
+        break;
+    }
 }
diff --git a/drivers/amlogic/ppmgr/ppmgr_dev.h b/drivers/amlogic/ppmgr/ppmgr_dev.h
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/ppmgr/ppmgr_drv.c b/drivers/amlogic/ppmgr/ppmgr_drv.c
index 42f56147..47b0e550 100644
--- a/drivers/amlogic/ppmgr/ppmgr_drv.c
+++ b/drivers/amlogic/ppmgr/ppmgr_drv.c
@@ -1,295 +1,295 @@
-/*******************************************************************
- *
- *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- *
- *  Description:
- *
- *  Author: Amlogic Software
- *  Created: 2010/4/1   19:46
- *
- *******************************************************************/
-#include <linux/amlogic/ppmgr/ppmgr.h>
-#include <linux/amlogic/ppmgr/ppmgr_status.h>
-#include <linux/platform_device.h>
-#include <linux/amlogic/ge2d/ge2d_main.h>
-#include <linux/amlogic/ge2d/ge2d.h>
-#include <linux/amlogic/amlog.h>
-#include <linux/ctype.h>
-#include <linux/amlogic/vout/vout_notify.h>
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/amports/vframe_provider.h>
-#include <linux/amlogic/amports/vframe_receiver.h>
-#include <linux/of_fdt.h>
-
-
-#include "ppmgr_log.h"
-#include "ppmgr_pri.h"
-#include "ppmgr_dev.h"
-#include <linux/amlogic/ppmgr/ppmgr.h>
-#include <linux/amlogic/ppmgr/ppmgr_status.h>
-#include <linux/amlogic/amports/video_prot.h>
-
-/***********************************************************************
-*
-* global status.
-*
-************************************************************************/
-static int ppmgr_enable_flag=0;
-static int ppmgr_flag_change = 0;
-static int property_change = 0;
-static int buff_change = 0;
-
-static platform_type_t platform_type = PLATFORM_MID;
-ppmgr_device_t  ppmgr_device;
-#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-extern void Reset3Dclear(void);
-extern void Set3DProcessPara(unsigned mode);
-#endif
-#ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
-static bool scaler_pos_reset = false;
-#endif
-
-#include "../amports/amports_config.h"
-
-
-platform_type_t get_platform_type(void)
-{
-	return	platform_type;
-}
-
-int get_bypass_mode(void)
-{
-    return ppmgr_device.bypass;
-}
-
-int get_property_change(void)
-{
-    return property_change;
-}
-void set_property_change(int flag)
-{
-    property_change = flag;
-}
-
-int get_buff_change(void)
-{
-    return buff_change;
-}
-void set_buff_change(int flag)
-{
-    buff_change = flag;
-}
-
-#ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
-bool get_scaler_pos_reset(void)
-{
-    return scaler_pos_reset;
-}
-void set_scaler_pos_reset(bool flag)
-{
-    scaler_pos_reset = flag;
-}
-#endif
-
-int get_ppmgr_status(void) {
-    return ppmgr_enable_flag;
-}
-
-void set_ppmgr_status(int flag) {
-	if(flag != ppmgr_enable_flag){
-		ppmgr_flag_change = 1;
-	}
-    if(flag >= 0){
-        ppmgr_enable_flag=flag;
-    }
-    else {
-        ppmgr_enable_flag=0;
-    }
-}
-
-/***********************************************************************
-*
-* 3D function.
-*
-************************************************************************/
-#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-unsigned get_ppmgr_3dmode(void)
-{
-    return ppmgr_device.ppmgr_3d_mode;
-}
-
-void set_ppmgr_3dmode(unsigned mode)
-{
-    if(ppmgr_device.ppmgr_3d_mode != mode){
-        ppmgr_device.ppmgr_3d_mode = mode;
-        Set3DProcessPara(ppmgr_device.ppmgr_3d_mode);
-        Reset3Dclear();
-        //property_change = 1;
-    }
-}
-
-unsigned get_ppmgr_viewmode(void)
-{
-    return ppmgr_device.viewmode;
-}
-
-void set_ppmgr_viewmode(unsigned mode)
-{
-    if((ppmgr_device.viewmode != mode)&&(mode<VIEWMODE_MAX)){
-        ppmgr_device.viewmode = mode;
-        Reset3Dclear();
-        //property_change = 1;
-    }
-}
-
-unsigned get_ppmgr_scaledown(void)
-{
-    return ppmgr_device.scale_down;
-}
-
-void set_ppmgr_scaledown(unsigned scale_down)
-{
-    if((ppmgr_device.scale_down != scale_down)&&(scale_down<3)){
-        ppmgr_device.scale_down = scale_down;
-        Reset3Dclear();
-    }
-}
-
-unsigned get_ppmgr_direction3d(void)
-{
-    return ppmgr_device.direction_3d;
-}
-
-void set_ppmgr_direction3d(unsigned angle)
-{
-    if((ppmgr_device.direction_3d != angle)&&(angle<4)){
-        ppmgr_device.direction_3d = angle;
-        Reset3Dclear();
-        //property_change = 1;
-    }
-}
-#endif
-
-/***********************************************************************
-*
-* Utilities.
-*
-************************************************************************/
-static ssize_t _ppmgr_angle_write(unsigned long val)
-{
-    unsigned long angle = val;
-
-    if (angle > 3) {
-        if (angle == 90)
-            angle = 1;
-        else if (angle == 180)
-            angle = 2;
-        else if (angle == 270)
-            angle = 3;
-        else {
-            printk("invalid orientation value\n");
-            printk("you should set 0 or 0 for 0 clock wise,");
-            printk("1 or 90 for 90 clockwise,2 or 180 for 180 clockwise");
-            printk("3 or 270 for 270 clockwise\n");
-            return -EINVAL;
-        }
-    }
-
-    ppmgr_device.global_angle = angle;
-    if (!ppmgr_device.use_prot) {
-        if (angle != ppmgr_device.angle) {
-            property_change = 1;
-        }
-        ppmgr_device.angle = angle;
-        ppmgr_device.videoangle = (ppmgr_device.angle + ppmgr_device.orientation) % 4;
-        printk("ppmgr angle:%x,orientation:%x,videoangle:%x \n", ppmgr_device.angle, ppmgr_device.orientation, ppmgr_device.videoangle);
-    } else {
-        set_video_angle(angle);
-        printk("prot angle:%ld\n", angle);
-    }
-    return 0;
-}
-
-/***********************************************************************
-*
-* class property info.
-*
-************************************************************************/
-
-#define    	PPMGR_CLASS_NAME   				"ppmgr"
-static int parse_para(const char *para, int para_num, int *result)
-{
-    char *endp;
-    const char *startp = para;
-    int *out = result;
-    int len = 0, count = 0;
-
-    if (!startp) {
-        return 0;
-    }
-
-    len = strlen(startp);
-
-    do {
-        //filter space out
-        while (startp && (isspace(*startp) || !isgraph(*startp)) && len) {
-            startp++;
-            len--;
-        }
-
-        if (len == 0) {
-            break;
-        }
-
-        *out++ = simple_strtol(startp, &endp, 0);
-
-        len -= endp - startp;
-        startp = endp;
-        count++;
-
-    } while ((endp) && (count < para_num) && (len > 0));
-
-    return count;
-}
-
-static ssize_t show_ppmgr_info(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    char *bstart;
-    unsigned int bsize;
-    get_ppmgr_buf_info(&bstart,&bsize);
-    return snprintf(buf,80,"buffer:\n start:%x.\tsize:%d\n",(unsigned int)bstart,bsize/(1024*1024));
-}
-
-static ssize_t angle_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    return snprintf(buf,80,"current angel is %d\n",ppmgr_device.global_angle);
-
-}
-
-static ssize_t angle_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-    ssize_t size;
-    char *endp;
-    unsigned long angle = simple_strtoul(buf, &endp, 0);
-
-    if (angle > 3 || angle < 0) {
-        size = endp - buf;
-        return count;
-    }
-
-    if (_ppmgr_angle_write(angle) < 0) {
-        return -EINVAL;
-    }
-    size = endp - buf;
-    return count;
-}
-
-int get_use_prot(void) {
-    return ppmgr_device.use_prot;
-}
-EXPORT_SYMBOL(get_use_prot);
+/*******************************************************************
+ *
+ *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *
+ *  Author: Amlogic Software
+ *  Created: 2010/4/1   19:46
+ *
+ *******************************************************************/
+#include <linux/amlogic/ppmgr/ppmgr.h>
+#include <linux/amlogic/ppmgr/ppmgr_status.h>
+#include <linux/platform_device.h>
+#include <linux/amlogic/ge2d/ge2d_main.h>
+#include <linux/amlogic/ge2d/ge2d.h>
+#include <linux/amlogic/amlog.h>
+#include <linux/ctype.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include <linux/amlogic/amports/vframe_receiver.h>
+#include <linux/of_fdt.h>
+
+
+#include "ppmgr_log.h"
+#include "ppmgr_pri.h"
+#include "ppmgr_dev.h"
+#include <linux/amlogic/ppmgr/ppmgr.h>
+#include <linux/amlogic/ppmgr/ppmgr_status.h>
+#include <linux/amlogic/amports/video_prot.h>
+
+/***********************************************************************
+*
+* global status.
+*
+************************************************************************/
+static int ppmgr_enable_flag=0;
+static int ppmgr_flag_change = 0;
+static int property_change = 0;
+static int buff_change = 0;
+
+static platform_type_t platform_type = PLATFORM_MID;
+ppmgr_device_t  ppmgr_device;
+#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
+extern void Reset3Dclear(void);
+extern void Set3DProcessPara(unsigned mode);
+#endif
+#ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
+static bool scaler_pos_reset = false;
+#endif
+
+#include "../amports/amports_config.h"
+
+
+platform_type_t get_platform_type(void)
+{
+	return	platform_type;
+}
+
+int get_bypass_mode(void)
+{
+    return ppmgr_device.bypass;
+}
+
+int get_property_change(void)
+{
+    return property_change;
+}
+void set_property_change(int flag)
+{
+    property_change = flag;
+}
+
+int get_buff_change(void)
+{
+    return buff_change;
+}
+void set_buff_change(int flag)
+{
+    buff_change = flag;
+}
+
+#ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
+bool get_scaler_pos_reset(void)
+{
+    return scaler_pos_reset;
+}
+void set_scaler_pos_reset(bool flag)
+{
+    scaler_pos_reset = flag;
+}
+#endif
+
+int get_ppmgr_status(void) {
+    return ppmgr_enable_flag;
+}
+
+void set_ppmgr_status(int flag) {
+	if(flag != ppmgr_enable_flag){
+		ppmgr_flag_change = 1;
+	}
+    if(flag >= 0){
+        ppmgr_enable_flag=flag;
+    }
+    else {
+        ppmgr_enable_flag=0;
+    }
+}
+
+/***********************************************************************
+*
+* 3D function.
+*
+************************************************************************/
+#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
+unsigned get_ppmgr_3dmode(void)
+{
+    return ppmgr_device.ppmgr_3d_mode;
+}
+
+void set_ppmgr_3dmode(unsigned mode)
+{
+    if(ppmgr_device.ppmgr_3d_mode != mode){
+        ppmgr_device.ppmgr_3d_mode = mode;
+        Set3DProcessPara(ppmgr_device.ppmgr_3d_mode);
+        Reset3Dclear();
+        //property_change = 1;
+    }
+}
+
+unsigned get_ppmgr_viewmode(void)
+{
+    return ppmgr_device.viewmode;
+}
+
+void set_ppmgr_viewmode(unsigned mode)
+{
+    if((ppmgr_device.viewmode != mode)&&(mode<VIEWMODE_MAX)){
+        ppmgr_device.viewmode = mode;
+        Reset3Dclear();
+        //property_change = 1;
+    }
+}
+
+unsigned get_ppmgr_scaledown(void)
+{
+    return ppmgr_device.scale_down;
+}
+
+void set_ppmgr_scaledown(unsigned scale_down)
+{
+    if((ppmgr_device.scale_down != scale_down)&&(scale_down<3)){
+        ppmgr_device.scale_down = scale_down;
+        Reset3Dclear();
+    }
+}
+
+unsigned get_ppmgr_direction3d(void)
+{
+    return ppmgr_device.direction_3d;
+}
+
+void set_ppmgr_direction3d(unsigned angle)
+{
+    if((ppmgr_device.direction_3d != angle)&&(angle<4)){
+        ppmgr_device.direction_3d = angle;
+        Reset3Dclear();
+        //property_change = 1;
+    }
+}
+#endif
+
+/***********************************************************************
+*
+* Utilities.
+*
+************************************************************************/
+static ssize_t _ppmgr_angle_write(unsigned long val)
+{
+    unsigned long angle = val;
+
+    if (angle > 3) {
+        if (angle == 90)
+            angle = 1;
+        else if (angle == 180)
+            angle = 2;
+        else if (angle == 270)
+            angle = 3;
+        else {
+            printk("invalid orientation value\n");
+            printk("you should set 0 or 0 for 0 clock wise,");
+            printk("1 or 90 for 90 clockwise,2 or 180 for 180 clockwise");
+            printk("3 or 270 for 270 clockwise\n");
+            return -EINVAL;
+        }
+    }
+
+    ppmgr_device.global_angle = angle;
+    ppmgr_device.angle = angle;
+    ppmgr_device.videoangle = (ppmgr_device.angle + ppmgr_device.orientation) % 4;    
+    if (!ppmgr_device.use_prot) {
+        if (angle != ppmgr_device.angle) {
+            property_change = 1;
+        }
+        printk("ppmgr angle:%x,orientation:%x,videoangle:%x \n", ppmgr_device.angle, ppmgr_device.orientation, ppmgr_device.videoangle);
+    } else {
+        set_video_angle(angle);
+        printk("prot angle:%ld\n", angle);
+    }
+    return 0;
+}
+
+/***********************************************************************
+*
+* class property info.
+*
+************************************************************************/
+
+#define    	PPMGR_CLASS_NAME   				"ppmgr"
+static int parse_para(const char *para, int para_num, int *result)
+{
+    char *endp;
+    const char *startp = para;
+    int *out = result;
+    int len = 0, count = 0;
+
+    if (!startp) {
+        return 0;
+    }
+
+    len = strlen(startp);
+
+    do {
+        //filter space out
+        while (startp && (isspace(*startp) || !isgraph(*startp)) && len) {
+            startp++;
+            len--;
+        }
+
+        if (len == 0) {
+            break;
+        }
+
+        *out++ = simple_strtol(startp, &endp, 0);
+
+        len -= endp - startp;
+        startp = endp;
+        count++;
+
+    } while ((endp) && (count < para_num) && (len > 0));
+
+    return count;
+}
+
+static ssize_t show_ppmgr_info(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    char *bstart;
+    unsigned int bsize;
+    get_ppmgr_buf_info(&bstart,&bsize);
+    return snprintf(buf,80,"buffer:\n start:%x.\tsize:%d\n",(unsigned int)bstart,bsize/(1024*1024));
+}
+
+static ssize_t angle_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    return snprintf(buf,80,"current angel is %d\n",ppmgr_device.global_angle);
+
+}
+
+static ssize_t angle_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    ssize_t size;
+    char *endp;
+    unsigned long angle = simple_strtoul(buf, &endp, 0);
+
+    if (angle > 3 || angle < 0) {
+        size = endp - buf;
+        return count;
+    }
+
+    if (_ppmgr_angle_write(angle) < 0) {
+        return -EINVAL;
+    }
+    size = endp - buf;
+    return count;
+}
+
+int get_use_prot(void) {
+    return ppmgr_device.use_prot;
+}
+EXPORT_SYMBOL(get_use_prot);
 
 static ssize_t disable_prot_show(struct class *cla, struct class_attribute *attr, char *buf) {
     return snprintf(buf, 40, "%d\n", ppmgr_device.disable_prot);
@@ -306,496 +306,496 @@ static ssize_t disable_prot_store(struct class *cla, struct class_attribute *att
     return strnlen(buf, count);
 }
 
-static ssize_t orientation_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    //ppmgr_device_t* ppmgr_dev=(ppmgr_device_t*)cla;
-    return snprintf(buf,80,"current orientation is %d\n",ppmgr_device.orientation*90);
-}
-
-/* set the initial orientation for video, it should be set before video start. */
-static ssize_t orientation_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-    ssize_t ret = -EINVAL, size;
-    char *endp;
-    unsigned angle  =  simple_strtoul(buf, &endp, 0);
-    //if(property_change) return ret;
-    if(angle>3) {
-        if(angle==90) angle=1;
-        else if(angle==180) angle=2;
-        else if(angle==270) angle=3;
-        else {
-            printk("invalid orientation value\n");
-            printk("you should set 0 or 0 for 0 clock wise,");
-            printk("1 or 90 for 90 clockwise,2 or 180 for 180 clockwise");
-            printk("3 or 270 for 270 clockwise\n");
-            return ret;
-        }
-    }
-    ppmgr_device.orientation = angle;
-    ppmgr_device.videoangle = (ppmgr_device.angle+ ppmgr_device.orientation)%4;
-    printk("angle:%d,orientation:%d,videoangle:%d \n",ppmgr_device.angle ,
-        ppmgr_device.orientation, ppmgr_device.videoangle);
-    size = endp - buf;
-    return count;
-}
-
-static ssize_t bypass_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    //ppmgr_device_t* ppmgr_dev=(ppmgr_device_t*)cla;
-    return snprintf(buf,80,"current bypass is %d\n",ppmgr_device.bypass);
-}
-
-static ssize_t bypass_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-    ssize_t size;
-    char *endp;
-
-    ppmgr_device.bypass = simple_strtoul(buf, &endp, 0);
-    size = endp - buf;
-    return count;
-}
-
-
-static ssize_t rect_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    return snprintf(buf,80,"rotate rect:\nl:%d,t:%d,w:%d,h:%d\n",
-			ppmgr_device.left,ppmgr_device.top,ppmgr_device.width,ppmgr_device.height);
-}
-
-static ssize_t rect_write(struct class *cla,struct class_attribute *attr,const char *buf, size_t count)
-{
-    char* errstr="data error,access string is \"left,top,width,height\"\n";
-    char* strp=(char*)buf;
-    char* endp;
-    int value_array[4];
-    static int buflen;
-    static char* tokenlen;
-    int i;
-    buflen=strlen(buf);
-    value_array[0]=value_array[1]=value_array[2]=value_array[3]= -1;
-
-    for(i=0;i<4;i++) {
-        if(buflen==0) {
-            printk(errstr);
-            return  -EINVAL;
-        }
-        tokenlen=strnchr(strp,buflen,',');
-        if(tokenlen!=NULL) *tokenlen='\0';
-        value_array[i]= simple_strtoul(strp,&endp,0);
-        if((endp-strp)>(tokenlen-strp)) break;
-        if(tokenlen!=NULL)  {
-            *tokenlen=',';
-            strp= tokenlen+1;
-            buflen=strlen(strp);
-        }  else
-            break;
-    }
-
-    if(value_array[0]>=0) ppmgr_device.left= value_array[0];
-    if(value_array[1]>=0) ppmgr_device.left= value_array[1];
-    if(value_array[2]>0) ppmgr_device.left= value_array[2];
-    if(value_array[3]>0) ppmgr_device.left= value_array[3];
-
-    return count;
-}
-
-static ssize_t disp_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    return snprintf(buf,80,"disp width is %d ; disp height is %d \n",ppmgr_device.disp_width, ppmgr_device.disp_height);
-}
-static void set_disp_para(const char *para)
-{
-    int parsed[2];
-
-    if (likely(parse_para(para, 2, parsed) == 2)) {
-        int w, h;
-        w = parsed[0] ;
-        h = parsed[1];
-        if((ppmgr_device.disp_width != w)||(ppmgr_device.disp_height != h))
-            buff_change = 1;
-        ppmgr_device.disp_width = w ;
-        ppmgr_device.disp_height =  h ;
-    }
-}
-
-static ssize_t disp_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-    set_disp_para(buf);
-    return count;
-}
-
-#ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
-extern int video_scaler_notify(int flag);
-extern void amvideo_set_scaler_para(int x, int y, int w, int h,int flag);
-
-static ssize_t ppscaler_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    return snprintf(buf,80,"current ppscaler mode is %s\n",(ppmgr_device.ppscaler_flag)?"enabled":"disabled");
-}
-
-static ssize_t ppscaler_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-    ssize_t size;
-    char *endp;
-    int flag = simple_strtoul(buf, &endp, 0);
-    if((flag<2)&&(flag != ppmgr_device.ppscaler_flag)){
-        if(flag)
-            video_scaler_notify(1);
-        else
-            video_scaler_notify(0);
-        ppmgr_device.ppscaler_flag = flag;
-        if(ppmgr_device.ppscaler_flag == 0)
-            set_scaler_pos_reset(true);
-    }
-    size = endp - buf;
-    return count;
-}
-
-
-static void set_ppscaler_para(const char *para)
-{
-    int parsed[5];
-
-    if (likely(parse_para(para, 5, parsed) == 5)) {
-        ppmgr_device.scale_h_start = parsed[0];
-        ppmgr_device.scale_v_start = parsed[1];
-        ppmgr_device.scale_h_end = parsed[2];
-        ppmgr_device.scale_v_end = parsed[3];
-        amvideo_set_scaler_para(ppmgr_device.scale_h_start,ppmgr_device.scale_v_start,
-                                ppmgr_device.scale_h_end-ppmgr_device.scale_h_start+1,
-                                ppmgr_device.scale_v_end-ppmgr_device.scale_v_start+1,parsed[4]);
-    }
-}
-
-static ssize_t ppscaler_rect_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    return snprintf(buf,80,"ppscaler rect:\nx:%d,y:%d,w:%d,h:%d\n",
-            ppmgr_device.scale_h_start,ppmgr_device.scale_v_start,
-            ppmgr_device.scale_h_end-ppmgr_device.scale_h_start+1,
-            ppmgr_device.scale_v_end-ppmgr_device.scale_v_start+1);
-}
-
-static ssize_t ppscaler_rect_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-    set_ppscaler_para(buf);
-    return count;
-}
-#endif
-
-static ssize_t receiver_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-	if(ppmgr_device.receiver==1)
-		return snprintf(buf,80,"video stream out to video4linux\n");
-	else
-		return snprintf(buf,80,"video stream out to vlayer\n");
-}
-
-static ssize_t receiver_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-	ssize_t size;
-	char *endp;
-    if(buf[0]!='0'&&buf[0]!='1') {
-		printk("device to whitch the video stream decoded\n");
-		printk("0: to video layer\n");
-		printk("1: to amlogic video4linux /dev/video10\n");
-		return 0;
-	}
-	ppmgr_device.receiver = simple_strtoul(buf, &endp, 0);
-	vf_ppmgr_reset(0);
-	size = endp - buf;
-	return count;
-}
-
-static ssize_t platform_type_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-	if(platform_type ==PLATFORM_TV){
-		return snprintf(buf,80,"current platform is TV\n");
-	}else if(platform_type ==PLATFORM_MID){
-		return snprintf(buf,80,"current platform is MID\n");
-	}else if(platform_type ==PLATFORM_MID_VERTICAL){
-        	return snprintf(buf,80,"current platform is vertical MID\n");
-	}else{
-		return snprintf(buf,80,"current platform is MBX\n");
-	}
-}
-
-static ssize_t platform_type_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-	ssize_t size;
-	char *endp;
-	platform_type = simple_strtoul(buf, &endp, 0);
-	size = endp - buf;
-	return count;
-}
-
-#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-static ssize_t _3dmode_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    return snprintf(buf,80,"current 3d mode is 0x%x\n",ppmgr_device.ppmgr_3d_mode);
-}
-
-static ssize_t _3dmode_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-    ssize_t size;
-    char *endp;
-    unsigned mode = simple_strtoul(buf, &endp, 0);
-    set_ppmgr_3dmode(mode);
-    size = endp - buf;
-    return count;
-}
-
-static ssize_t viewmode_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    const char *viewmode_str[] = {"normal", "full", "4:3","16:9","1:1"};
-    return snprintf(buf,80,"current view mode is %d:%s\n",ppmgr_device.viewmode,viewmode_str[ppmgr_device.viewmode]);
-}
-
-static ssize_t viewmode_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-    ssize_t size;
-    char *endp;
-    unsigned mode = simple_strtoul(buf, &endp, 0);
-    set_ppmgr_viewmode(mode);
-    size = endp - buf;
-    return count;
-}
-
-static ssize_t doublemode_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    const char *doublemode_str[] = {"normal", "horizontal double", "vertical double"};
-    unsigned mode = get_ppmgr_3dmode();
-    mode = ((mode & PPMGR_3D_PROCESS_DOUBLE_TYPE)>>PPMGR_3D_PROCESS_DOUBLE_TYPE_SHIFT);
-    return snprintf(buf,80,"current 3d double scale mode is %d:%s\n",mode,doublemode_str[mode]);
-}
-
-static ssize_t doublemode_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-    ssize_t size;
-    char *endp;
-    unsigned flag = simple_strtoul(buf, &endp, 0);
-    unsigned mode = get_ppmgr_3dmode();
-    mode = (mode & (~PPMGR_3D_PROCESS_DOUBLE_TYPE))|((flag<<PPMGR_3D_PROCESS_DOUBLE_TYPE_SHIFT)&(PPMGR_3D_PROCESS_DOUBLE_TYPE));
-    set_ppmgr_3dmode(mode);
-    size = endp - buf;
-    return count;
-}
-
-static ssize_t switchmode_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    const char *switchmode_str[] = {"disable", "enable"};
-    unsigned mode = get_ppmgr_3dmode();
-    unsigned flag = (mode & PPMGR_3D_PROCESS_SWITCH_FLAG)?1:0;
-    return snprintf(buf,80,"current 3d switch mode is %d:%s\n",flag,switchmode_str[flag]);
-}
-
-static ssize_t switchmode_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-    ssize_t size;
-    char *endp;
-    int flag = simple_strtoul(buf, &endp, 0);
-    unsigned mode = get_ppmgr_3dmode();
-    if(!flag)
-        mode = mode & (~PPMGR_3D_PROCESS_SWITCH_FLAG);
-    else
-        mode = mode | PPMGR_3D_PROCESS_SWITCH_FLAG;
-    set_ppmgr_3dmode(mode);
-    size = endp - buf;
-    return count;
-}
-
-static ssize_t direction_3d_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    const char *direction_str[] = {"0 degree", "90 degree", "180 degree","270 degree"};
-    //unsigned mode = get_ppmgr_3dmode();
-    //mode = ((mode & PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK)>>PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_VAULE_SHIFT);
-    //return snprintf(buf,80,"current 3d direction is %d:%s\n",mode,direction_str[mode]);
-    unsigned angle = get_ppmgr_direction3d();
-    return snprintf(buf,80,"current 3d direction is %d:%s\n",angle,direction_str[angle]);
-}
-
-static ssize_t direction_3d_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-    ssize_t size;
-    char *endp;
-    int flag = simple_strtoul(buf, &endp, 0);
-    //unsigned mode = get_ppmgr_3dmode();
-    //mode = (mode & (~PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK))|((flag<<PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_VAULE_SHIFT)&(PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK));
-    //set_ppmgr_3dmode(mode);
-    set_ppmgr_direction3d(flag);
-    size = endp - buf;
-    return count;
-}
-
-static ssize_t scale_down_read(struct class *cla,struct class_attribute *attr,char *buf)
-{
-    const char *value_str[] = {"noraml", "div 2", "div 3","div 4"};
-    unsigned mode = ppmgr_device.scale_down;
-    return snprintf(buf,80,"current scale down value is %d:%s\n",mode+1,value_str[mode]);
-}
-
-static ssize_t scale_down_write(struct class *cla,
-					struct class_attribute *attr,
-					const char *buf, size_t count)
-{
-    ssize_t size;
-    char *endp;
-    unsigned mode = simple_strtoul(buf, &endp, 0);
-    set_ppmgr_scaledown(mode);
-    size = endp - buf;
-    return count;
-}
-
-/******************************************************************
-					3D TV usage
-*********************************************************************/
-
-frame_info_t frame_info;
-
-static int ppmgr_view_mode = 0 ;
-static int ppmgr_vertical_sample =1 ;
-static int ppmgr_scale_width = 800 ;
-int ppmgr_cutwin_top = 0;
-int ppmgr_cutwin_left = 0;
-int get_ppmgr_change_notify(void)
-{
-	if(ppmgr_flag_change){
-		ppmgr_flag_change = 0 ;
-		return 1;
-	}else{
-		return 0;
-	}
-}
-
-int get_ppmgr_view_mode(void)
-{
-	return ppmgr_view_mode;
-}
-int get_ppmgr_vertical_sample(void)
-{
-	return ppmgr_vertical_sample;
-}
-int get_ppmgr_scale_width(void)
-{
-	return ppmgr_scale_width;
-}
-
-static int depth = 3200;  /*12.5 pixels*/
-void set_depth(int para)
-{
-	depth = para;
-}
-int get_depth(void)
-{
-	return depth;
-}
-static ssize_t read_depth(struct class *cla,struct class_attribute *attr,char *buf)
-{
-	 return snprintf(buf,80,"current depth is %d\n",depth);
-}
-static ssize_t write_depth(struct class *cla, struct class_attribute *attr, const char *buf,
-                                size_t count)
-{
-    int r;
-    char *endp;
-
-    r = simple_strtoul(buf, &endp, 0);
-	printk("r is %d\n" ,r);
-	set_depth(r) ;
-    return count;
-}
-static ssize_t read_view_mode(struct class *cla,struct class_attribute *attr,char *buf)
-{
-	 return snprintf(buf,80,"current view mode is %d\n",ppmgr_view_mode);
-}
-static ssize_t write_view_mode(struct class *cla, struct class_attribute *attr, const char *buf,
-                                size_t count)
-{
-    int r;
-    char *endp;
-
-    r = simple_strtoul(buf, &endp, 0);
-    ppmgr_view_mode = r ;
-    return count;
-}
-
-static ssize_t read_vertical_sample(struct class *cla,struct class_attribute *attr,char *buf)
-{
-	 return snprintf(buf,80,"ppmgr_vertical_sample %d\n",ppmgr_vertical_sample);
-}
-static ssize_t write_vertical_sample(struct class *cla, struct class_attribute *attr, const char *buf,
-                                size_t count)
-{
-    int r;
-    char *endp;
-
-    r = simple_strtoul(buf, &endp, 0);
-    ppmgr_vertical_sample = r ;
-    return count;
-}
-static ssize_t read_scale_width(struct class *cla,struct class_attribute *attr,char *buf)
-{
-	 return snprintf(buf,80,"ppmgr_scale_width is %d\n",ppmgr_scale_width);
-}
-static ssize_t write_scale_width(struct class *cla, struct class_attribute *attr, const char *buf,
-                                size_t count)
-{
-    int r;
-    char *endp;
-
-    r = simple_strtoul(buf, &endp, 0);
-    ppmgr_scale_width = r ;
-    return count;
-}
-static void set_cut_window(const char *para)
-{
-  int parsed[2];
-
-  if (likely(parse_para(para, 2, parsed) == 2)) {
-	      int top ,left;
-	      top = parsed[0] ;
-	      left = parsed[1];
-	      ppmgr_cutwin_top = top ;
-	      ppmgr_cutwin_left = left ;
-     }
- }
-
-static ssize_t cut_win_show(struct class *cla, struct class_attribute *attr, char *buf)
-{
-    return snprintf(buf, 80, "cut win top is %d ; cut win left is %d \n", ppmgr_cutwin_top,ppmgr_cutwin_left);
-}
-
-static ssize_t cut_win_store(struct class *cla, struct class_attribute *attr, const char *buf,
-                                size_t count)
-{
-	set_cut_window(buf);
-    return strnlen(buf, count);
-}
-
-#endif
+static ssize_t orientation_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    //ppmgr_device_t* ppmgr_dev=(ppmgr_device_t*)cla;
+    return snprintf(buf,80,"current orientation is %d\n",ppmgr_device.orientation*90);
+}
+
+/* set the initial orientation for video, it should be set before video start. */
+static ssize_t orientation_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    ssize_t ret = -EINVAL, size;
+    char *endp;
+    unsigned angle  =  simple_strtoul(buf, &endp, 0);
+    //if(property_change) return ret;
+    if(angle>3) {
+        if(angle==90) angle=1;
+        else if(angle==180) angle=2;
+        else if(angle==270) angle=3;
+        else {
+            printk("invalid orientation value\n");
+            printk("you should set 0 or 0 for 0 clock wise,");
+            printk("1 or 90 for 90 clockwise,2 or 180 for 180 clockwise");
+            printk("3 or 270 for 270 clockwise\n");
+            return ret;
+        }
+    }
+    ppmgr_device.orientation = angle;
+    ppmgr_device.videoangle = (ppmgr_device.angle+ ppmgr_device.orientation)%4;
+    printk("angle:%d,orientation:%d,videoangle:%d \n",ppmgr_device.angle ,
+        ppmgr_device.orientation, ppmgr_device.videoangle);
+    size = endp - buf;
+    return count;
+}
+
+static ssize_t bypass_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    //ppmgr_device_t* ppmgr_dev=(ppmgr_device_t*)cla;
+    return snprintf(buf,80,"current bypass is %d\n",ppmgr_device.bypass);
+}
+
+static ssize_t bypass_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    ssize_t size;
+    char *endp;
+
+    ppmgr_device.bypass = simple_strtoul(buf, &endp, 0);
+    size = endp - buf;
+    return count;
+}
+
+
+static ssize_t rect_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    return snprintf(buf,80,"rotate rect:\nl:%d,t:%d,w:%d,h:%d\n",
+			ppmgr_device.left,ppmgr_device.top,ppmgr_device.width,ppmgr_device.height);
+}
+
+static ssize_t rect_write(struct class *cla,struct class_attribute *attr,const char *buf, size_t count)
+{
+    char* errstr="data error,access string is \"left,top,width,height\"\n";
+    char* strp=(char*)buf;
+    char* endp;
+    int value_array[4];
+    static int buflen;
+    static char* tokenlen;
+    int i;
+    buflen=strlen(buf);
+    value_array[0]=value_array[1]=value_array[2]=value_array[3]= -1;
+
+    for(i=0;i<4;i++) {
+        if(buflen==0) {
+            printk(errstr);
+            return  -EINVAL;
+        }
+        tokenlen=strnchr(strp,buflen,',');
+        if(tokenlen!=NULL) *tokenlen='\0';
+        value_array[i]= simple_strtoul(strp,&endp,0);
+        if((endp-strp)>(tokenlen-strp)) break;
+        if(tokenlen!=NULL)  {
+            *tokenlen=',';
+            strp= tokenlen+1;
+            buflen=strlen(strp);
+        }  else
+            break;
+    }
+
+    if(value_array[0]>=0) ppmgr_device.left= value_array[0];
+    if(value_array[1]>=0) ppmgr_device.left= value_array[1];
+    if(value_array[2]>0) ppmgr_device.left= value_array[2];
+    if(value_array[3]>0) ppmgr_device.left= value_array[3];
+
+    return count;
+}
+
+static ssize_t disp_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    return snprintf(buf,80,"disp width is %d ; disp height is %d \n",ppmgr_device.disp_width, ppmgr_device.disp_height);
+}
+static void set_disp_para(const char *para)
+{
+    int parsed[2];
+
+    if (likely(parse_para(para, 2, parsed) == 2)) {
+        int w, h;
+        w = parsed[0] ;
+        h = parsed[1];
+        if((ppmgr_device.disp_width != w)||(ppmgr_device.disp_height != h))
+            buff_change = 1;
+        ppmgr_device.disp_width = w ;
+        ppmgr_device.disp_height =  h ;
+    }
+}
+
+static ssize_t disp_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    set_disp_para(buf);
+    return count;
+}
+
+#ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
+extern int video_scaler_notify(int flag);
+extern void amvideo_set_scaler_para(int x, int y, int w, int h,int flag);
+
+static ssize_t ppscaler_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    return snprintf(buf,80,"current ppscaler mode is %s\n",(ppmgr_device.ppscaler_flag)?"enabled":"disabled");
+}
+
+static ssize_t ppscaler_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    ssize_t size;
+    char *endp;
+    int flag = simple_strtoul(buf, &endp, 0);
+    if((flag<2)&&(flag != ppmgr_device.ppscaler_flag)){
+        if(flag)
+            video_scaler_notify(1);
+        else
+            video_scaler_notify(0);
+        ppmgr_device.ppscaler_flag = flag;
+        if(ppmgr_device.ppscaler_flag == 0)
+            set_scaler_pos_reset(true);
+    }
+    size = endp - buf;
+    return count;
+}
+
+
+static void set_ppscaler_para(const char *para)
+{
+    int parsed[5];
+
+    if (likely(parse_para(para, 5, parsed) == 5)) {
+        ppmgr_device.scale_h_start = parsed[0];
+        ppmgr_device.scale_v_start = parsed[1];
+        ppmgr_device.scale_h_end = parsed[2];
+        ppmgr_device.scale_v_end = parsed[3];
+        amvideo_set_scaler_para(ppmgr_device.scale_h_start,ppmgr_device.scale_v_start,
+                                ppmgr_device.scale_h_end-ppmgr_device.scale_h_start+1,
+                                ppmgr_device.scale_v_end-ppmgr_device.scale_v_start+1,parsed[4]);
+    }
+}
+
+static ssize_t ppscaler_rect_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    return snprintf(buf,80,"ppscaler rect:\nx:%d,y:%d,w:%d,h:%d\n",
+            ppmgr_device.scale_h_start,ppmgr_device.scale_v_start,
+            ppmgr_device.scale_h_end-ppmgr_device.scale_h_start+1,
+            ppmgr_device.scale_v_end-ppmgr_device.scale_v_start+1);
+}
+
+static ssize_t ppscaler_rect_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    set_ppscaler_para(buf);
+    return count;
+}
+#endif
+
+static ssize_t receiver_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+	if(ppmgr_device.receiver==1)
+		return snprintf(buf,80,"video stream out to video4linux\n");
+	else
+		return snprintf(buf,80,"video stream out to vlayer\n");
+}
+
+static ssize_t receiver_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+	ssize_t size;
+	char *endp;
+    if(buf[0]!='0'&&buf[0]!='1') {
+		printk("device to whitch the video stream decoded\n");
+		printk("0: to video layer\n");
+		printk("1: to amlogic video4linux /dev/video10\n");
+		return 0;
+	}
+	ppmgr_device.receiver = simple_strtoul(buf, &endp, 0);
+	vf_ppmgr_reset(0);
+	size = endp - buf;
+	return count;
+}
+
+static ssize_t platform_type_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+	if(platform_type ==PLATFORM_TV){
+		return snprintf(buf,80,"current platform is TV\n");
+	}else if(platform_type ==PLATFORM_MID){
+		return snprintf(buf,80,"current platform is MID\n");
+	}else if(platform_type ==PLATFORM_MID_VERTICAL){
+		return snprintf(buf,80,"current platform is vertical MID\n");
+	}else{
+		return snprintf(buf,80,"current platform is MBX\n");
+	}
+}
+
+static ssize_t platform_type_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+	ssize_t size;
+	char *endp;
+	platform_type = simple_strtoul(buf, &endp, 0);
+	size = endp - buf;
+	return count;
+}
+
+#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
+static ssize_t _3dmode_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    return snprintf(buf,80,"current 3d mode is 0x%x\n",ppmgr_device.ppmgr_3d_mode);
+}
+
+static ssize_t _3dmode_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    ssize_t size;
+    char *endp;
+    unsigned mode = simple_strtoul(buf, &endp, 0);
+    set_ppmgr_3dmode(mode);
+    size = endp - buf;
+    return count;
+}
+
+static ssize_t viewmode_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    const char *viewmode_str[] = {"normal", "full", "4:3","16:9","1:1"};
+    return snprintf(buf,80,"current view mode is %d:%s\n",ppmgr_device.viewmode,viewmode_str[ppmgr_device.viewmode]);
+}
+
+static ssize_t viewmode_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    ssize_t size;
+    char *endp;
+    unsigned mode = simple_strtoul(buf, &endp, 0);
+    set_ppmgr_viewmode(mode);
+    size = endp - buf;
+    return count;
+}
+
+static ssize_t doublemode_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    const char *doublemode_str[] = {"normal", "horizontal double", "vertical double"};
+    unsigned mode = get_ppmgr_3dmode();
+    mode = ((mode & PPMGR_3D_PROCESS_DOUBLE_TYPE)>>PPMGR_3D_PROCESS_DOUBLE_TYPE_SHIFT);
+    return snprintf(buf,80,"current 3d double scale mode is %d:%s\n",mode,doublemode_str[mode]);
+}
+
+static ssize_t doublemode_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    ssize_t size;
+    char *endp;
+    unsigned flag = simple_strtoul(buf, &endp, 0);
+    unsigned mode = get_ppmgr_3dmode();
+    mode = (mode & (~PPMGR_3D_PROCESS_DOUBLE_TYPE))|((flag<<PPMGR_3D_PROCESS_DOUBLE_TYPE_SHIFT)&(PPMGR_3D_PROCESS_DOUBLE_TYPE));
+    set_ppmgr_3dmode(mode);
+    size = endp - buf;
+    return count;
+}
+
+static ssize_t switchmode_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    const char *switchmode_str[] = {"disable", "enable"};
+    unsigned mode = get_ppmgr_3dmode();
+    unsigned flag = (mode & PPMGR_3D_PROCESS_SWITCH_FLAG)?1:0;
+    return snprintf(buf,80,"current 3d switch mode is %d:%s\n",flag,switchmode_str[flag]);
+}
+
+static ssize_t switchmode_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    ssize_t size;
+    char *endp;
+    int flag = simple_strtoul(buf, &endp, 0);
+    unsigned mode = get_ppmgr_3dmode();
+    if(!flag)
+        mode = mode & (~PPMGR_3D_PROCESS_SWITCH_FLAG);
+    else
+        mode = mode | PPMGR_3D_PROCESS_SWITCH_FLAG;
+    set_ppmgr_3dmode(mode);
+    size = endp - buf;
+    return count;
+}
+
+static ssize_t direction_3d_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    const char *direction_str[] = {"0 degree", "90 degree", "180 degree","270 degree"};
+    //unsigned mode = get_ppmgr_3dmode();
+    //mode = ((mode & PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK)>>PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_VAULE_SHIFT);
+    //return snprintf(buf,80,"current 3d direction is %d:%s\n",mode,direction_str[mode]);
+    unsigned angle = get_ppmgr_direction3d();
+    return snprintf(buf,80,"current 3d direction is %d:%s\n",angle,direction_str[angle]);
+}
+
+static ssize_t direction_3d_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    ssize_t size;
+    char *endp;
+    int flag = simple_strtoul(buf, &endp, 0);
+    //unsigned mode = get_ppmgr_3dmode();
+    //mode = (mode & (~PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK))|((flag<<PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_VAULE_SHIFT)&(PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK));
+    //set_ppmgr_3dmode(mode);
+    set_ppmgr_direction3d(flag);
+    size = endp - buf;
+    return count;
+}
+
+static ssize_t scale_down_read(struct class *cla,struct class_attribute *attr,char *buf)
+{
+    const char *value_str[] = {"noraml", "div 2", "div 3","div 4"};
+    unsigned mode = ppmgr_device.scale_down;
+    return snprintf(buf,80,"current scale down value is %d:%s\n",mode+1,value_str[mode]);
+}
+
+static ssize_t scale_down_write(struct class *cla,
+					struct class_attribute *attr,
+					const char *buf, size_t count)
+{
+    ssize_t size;
+    char *endp;
+    unsigned mode = simple_strtoul(buf, &endp, 0);
+    set_ppmgr_scaledown(mode);
+    size = endp - buf;
+    return count;
+}
+
+/******************************************************************
+					3D TV usage
+*********************************************************************/
+
+frame_info_t frame_info;
+
+static int ppmgr_view_mode = 0 ;
+static int ppmgr_vertical_sample =1 ;
+static int ppmgr_scale_width = 800 ;
+int ppmgr_cutwin_top = 0;
+int ppmgr_cutwin_left = 0;
+int get_ppmgr_change_notify(void)
+{
+	if(ppmgr_flag_change){
+		ppmgr_flag_change = 0 ;
+		return 1;
+	}else{
+		return 0;
+	}
+}
+
+int get_ppmgr_view_mode(void)
+{
+	return ppmgr_view_mode;
+}
+int get_ppmgr_vertical_sample(void)
+{
+	return ppmgr_vertical_sample;
+}
+int get_ppmgr_scale_width(void)
+{
+	return ppmgr_scale_width;
+}
+
+static int depth = 3200;  /*12.5 pixels*/
+void set_depth(int para)
+{
+	depth = para;
+}
+int get_depth(void)
+{
+	return depth;
+}
+static ssize_t read_depth(struct class *cla,struct class_attribute *attr,char *buf)
+{
+	 return snprintf(buf,80,"current depth is %d\n",depth);
+}
+static ssize_t write_depth(struct class *cla, struct class_attribute *attr, const char *buf,
+                                size_t count)
+{
+    int r;
+    char *endp;
+
+    r = simple_strtoul(buf, &endp, 0);
+	printk("r is %d\n" ,r);
+	set_depth(r) ;
+    return count;
+}
+static ssize_t read_view_mode(struct class *cla,struct class_attribute *attr,char *buf)
+{
+	 return snprintf(buf,80,"current view mode is %d\n",ppmgr_view_mode);
+}
+static ssize_t write_view_mode(struct class *cla, struct class_attribute *attr, const char *buf,
+                                size_t count)
+{
+    int r;
+    char *endp;
+
+    r = simple_strtoul(buf, &endp, 0);
+    ppmgr_view_mode = r ;
+    return count;
+}
+
+static ssize_t read_vertical_sample(struct class *cla,struct class_attribute *attr,char *buf)
+{
+	 return snprintf(buf,80,"ppmgr_vertical_sample %d\n",ppmgr_vertical_sample);
+}
+static ssize_t write_vertical_sample(struct class *cla, struct class_attribute *attr, const char *buf,
+                                size_t count)
+{
+    int r;
+    char *endp;
+
+    r = simple_strtoul(buf, &endp, 0);
+    ppmgr_vertical_sample = r ;
+    return count;
+}
+static ssize_t read_scale_width(struct class *cla,struct class_attribute *attr,char *buf)
+{
+	 return snprintf(buf,80,"ppmgr_scale_width is %d\n",ppmgr_scale_width);
+}
+static ssize_t write_scale_width(struct class *cla, struct class_attribute *attr, const char *buf,
+                                size_t count)
+{
+    int r;
+    char *endp;
+
+    r = simple_strtoul(buf, &endp, 0);
+    ppmgr_scale_width = r ;
+    return count;
+}
+static void set_cut_window(const char *para)
+{
+  int parsed[2];
+
+  if (likely(parse_para(para, 2, parsed) == 2)) {
+	      int top ,left;
+	      top = parsed[0] ;
+	      left = parsed[1];
+	      ppmgr_cutwin_top = top ;
+	      ppmgr_cutwin_left = left ;
+     }
+ }
+
+static ssize_t cut_win_show(struct class *cla, struct class_attribute *attr, char *buf)
+{
+    return snprintf(buf, 80, "cut win top is %d ; cut win left is %d \n", ppmgr_cutwin_top,ppmgr_cutwin_left);
+}
+
+static ssize_t cut_win_store(struct class *cla, struct class_attribute *attr, const char *buf,
+                                size_t count)
+{
+	set_cut_window(buf);
+    return strnlen(buf, count);
+}
+
+#endif
 static ssize_t mirror_read(struct class *cla,struct class_attribute *attr,char *buf)
 {
 	if(ppmgr_device.mirror_flag == 1)
@@ -818,458 +818,457 @@ static ssize_t mirror_write(struct class *cla,
 	size = endp - buf;
 	return count;
 }
-
-/**************************************************************
- 			3DTV usage
-*******************************************************************/
-extern int  vf_ppmgr_get_states(vframe_states_t *states);
-
-static ssize_t ppmgr_vframe_states_show(struct class *cla, struct class_attribute* attr, char* buf)
-{
-    int ret = 0;
-    vframe_states_t states;
-
-    if (vf_ppmgr_get_states(&states) == 0) {
-        ret += sprintf(buf + ret, "vframe_pool_size=%d\n", states.vf_pool_size);
-        ret += sprintf(buf + ret, "vframe buf_free_num=%d\n", states.buf_free_num);
-        ret += sprintf(buf + ret, "vframe buf_recycle_num=%d\n", states.buf_recycle_num);
-        ret += sprintf(buf + ret, "vframe buf_avail_num=%d\n", states.buf_avail_num);
-
-    } else {
-        ret += sprintf(buf + ret, "vframe no states\n");
-    }
-
-    return ret;
-}
-
-static struct class_attribute ppmgr_class_attrs[] = {
-    __ATTR(info,
-           S_IRUGO | S_IWUSR,
-           show_ppmgr_info,
-           NULL),
-    __ATTR(angle,
-           S_IRUGO | S_IWUSR | S_IWGRP,
-           angle_read,
-           angle_write),
-    __ATTR(rect,
-           S_IRUGO | S_IWUSR,
-           rect_read,
-           rect_write),
-    __ATTR(bypass,
-           S_IRUGO | S_IWUSR,
-           bypass_read,
-           bypass_write),
-
-    __ATTR(disp,
-           S_IRUGO | S_IWUSR | S_IWGRP,
-           disp_read,
-           disp_write),
-
-    __ATTR(orientation,
-           S_IRUGO | S_IWUSR,
-           orientation_read,
-           orientation_write),
-#ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
-    __ATTR(ppscaler,
-           S_IRUGO | S_IWUSR | S_IWGRP,
-           ppscaler_read,
-           ppscaler_write),
-    __ATTR(ppscaler_rect,
-           S_IRUGO | S_IWUSR | S_IWGRP,
-           ppscaler_rect_read,
-           ppscaler_rect_write),
+
+/**************************************************************
+			3DTV usage
+*******************************************************************/
+extern int  vf_ppmgr_get_states(vframe_states_t *states);
+
+static ssize_t ppmgr_vframe_states_show(struct class *cla, struct class_attribute* attr, char* buf)
+{
+    int ret = 0;
+    vframe_states_t states;
+
+    if (vf_ppmgr_get_states(&states) == 0) {
+        ret += sprintf(buf + ret, "vframe_pool_size=%d\n", states.vf_pool_size);
+        ret += sprintf(buf + ret, "vframe buf_free_num=%d\n", states.buf_free_num);
+        ret += sprintf(buf + ret, "vframe buf_recycle_num=%d\n", states.buf_recycle_num);
+        ret += sprintf(buf + ret, "vframe buf_avail_num=%d\n", states.buf_avail_num);
+
+    } else {
+        ret += sprintf(buf + ret, "vframe no states\n");
+    }
+
+    return ret;
+}
+
+static struct class_attribute ppmgr_class_attrs[] = {
+    __ATTR(info,
+           S_IRUGO | S_IWUSR,
+           show_ppmgr_info,
+           NULL),
+    __ATTR(angle,
+           S_IRUGO | S_IWUSR | S_IWGRP,
+           angle_read,
+           angle_write),
+    __ATTR(rect,
+           S_IRUGO | S_IWUSR,
+           rect_read,
+           rect_write),
+    __ATTR(bypass,
+           S_IRUGO | S_IWUSR,
+           bypass_read,
+           bypass_write),
+
+    __ATTR(disp,
+           S_IRUGO | S_IWUSR | S_IWGRP,
+           disp_read,
+           disp_write),
+
+    __ATTR(orientation,
+           S_IRUGO | S_IWUSR,
+           orientation_read,
+           orientation_write),
+#ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
+    __ATTR(ppscaler,
+           S_IRUGO | S_IWUSR | S_IWGRP,
+           ppscaler_read,
+           ppscaler_write),
+    __ATTR(ppscaler_rect,
+           S_IRUGO | S_IWUSR | S_IWGRP,
+           ppscaler_rect_read,
+           ppscaler_rect_write),
+#endif
+       __ATTR(vtarget,
+           S_IRUGO | S_IWUSR | S_IWGRP,
+           receiver_read,
+           receiver_write),
+#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
+    __ATTR(ppmgr_3d_mode,
+           S_IRUGO | S_IWUSR,
+           _3dmode_read,
+           _3dmode_write),
+    __ATTR(viewmode,
+           S_IRUGO | S_IWUSR,
+           viewmode_read,
+           viewmode_write),
+    __ATTR(doublemode,
+           S_IRUGO | S_IWUSR,
+           doublemode_read,
+           doublemode_write),
+    __ATTR(switchmode,
+           S_IRUGO | S_IWUSR,
+           switchmode_read,
+           switchmode_write),
+    __ATTR(direction_3d,
+           S_IRUGO | S_IWUSR,
+           direction_3d_read,
+           direction_3d_write),
+    __ATTR(scale_down,
+           S_IRUGO | S_IWUSR,
+           scale_down_read,
+           scale_down_write),
+    __ATTR(depth,
+			S_IRUGO | S_IWUSR,
+			read_depth,
+			write_depth),
+    __ATTR(view_mode,
+			S_IRUGO | S_IWUSR,
+			read_view_mode,
+			write_view_mode),
+    __ATTR(vertical_sample,
+			S_IRUGO | S_IWUSR,
+			read_vertical_sample,
+			write_vertical_sample),
+    __ATTR(scale_width,
+			S_IRUGO | S_IWUSR,
+			read_scale_width,
+			write_scale_width),
+    __ATTR(axis,
+		S_IRUGO | S_IWUSR,
+		    cut_win_show,
+		    cut_win_store),
 #endif
-       __ATTR(vtarget,
-           S_IRUGO | S_IWUSR | S_IWGRP,
-           receiver_read,
-           receiver_write),
-#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-    __ATTR(ppmgr_3d_mode,
-           0666,
-           _3dmode_read,
-           _3dmode_write),
-    __ATTR(viewmode,
-           S_IRUGO | S_IWUSR,
-           viewmode_read,
-           viewmode_write),
-    __ATTR(doublemode,
-           S_IRUGO | S_IWUSR,
-           doublemode_read,
-           doublemode_write),
-    __ATTR(switchmode,
-           S_IRUGO | S_IWUSR,
-           switchmode_read,
-           switchmode_write),
-    __ATTR(direction_3d,
-           S_IRUGO | S_IWUSR,
-           direction_3d_read,
-           direction_3d_write),
-    __ATTR(scale_down,
-           S_IRUGO | S_IWUSR,
-           scale_down_read,
-           scale_down_write),
-    __ATTR(depth,
-			S_IRUGO | S_IWUSR,
-			read_depth,
-			write_depth),
-    __ATTR(view_mode,
-			S_IRUGO | S_IWUSR,
-			read_view_mode,
-			write_view_mode),
-    __ATTR(vertical_sample,
-			S_IRUGO | S_IWUSR,
-			read_vertical_sample,
-			write_vertical_sample),
-    __ATTR(scale_width,
-			S_IRUGO | S_IWUSR,
-			read_scale_width,
-			write_scale_width),
-    __ATTR(axis,
-    		S_IRUGO | S_IWUSR,
-		    cut_win_show,
-		    cut_win_store),
-#endif
-
+
     __ATTR(platform_type,
            S_IRUGO | S_IWUSR,
            platform_type_read,
-           platform_type_write),
-
+           platform_type_write),
+
     __ATTR(mirror,
            S_IRUGO | S_IWUSR,
            mirror_read,
            mirror_write),
-    __ATTR_RO(ppmgr_vframe_states),
+    __ATTR_RO(ppmgr_vframe_states),
     __ATTR(disable_prot,
            S_IRUGO | S_IWUSR,
            disable_prot_show,
            disable_prot_store),
-    __ATTR_NULL
-};
-
-static struct class ppmgr_class = {
-    .name = PPMGR_CLASS_NAME,
-    .class_attrs = ppmgr_class_attrs,
-};
-
-struct class* init_ppmgr_cls() {
-    int  ret=0;
-    ret = class_register(&ppmgr_class);
-    if(ret<0 )
-    {
-        amlog_level(LOG_LEVEL_HIGH,"error create ppmgr class\r\n");
-        return NULL;
-    }
-    return &ppmgr_class;
-}
-
-/***********************************************************************
-*
-* file op section.
-*
-************************************************************************/
-
-void set_ppmgr_buf_info(char* start,unsigned int size) {
-    ppmgr_device.buffer_start=(char*)start;
-    ppmgr_device.buffer_size=size;
-}
-
-void get_ppmgr_buf_info(char** start,unsigned int* size) {
-    *start=ppmgr_device.buffer_start;
-    *size=ppmgr_device.buffer_size;
-}
-
-static int ppmgr_open(struct inode *inode, struct file *file)
-{
-    ppmgr_device.open_count++;
-    return 0;
-}
-
-static long ppmgr_ioctl(struct file *file,
-                        unsigned int cmd, ulong args)
-{
-    void  __user* argp =(void __user*)args;
-    int ret = 0;
-#if 0
-    ge2d_context_t *context=(ge2d_context_t *)filp->private_data;
-    config_para_t     ge2d_config;
-    ge2d_para_t  para ;
-    int flag;
-    frame_info_t frame_info;
-#endif
-#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-    unsigned mode = 0;
-    int flag = 0;
-#endif
-    switch (cmd)
-    {
-#if 0
-        case PPMGR_IOC_CONFIG_FRAME:
-            copy_from_user(&frame_info,argp,sizeof(frame_info_t));
-            break;
-#endif
-        case PPMGR_IOC_GET_ANGLE:
-            put_user(ppmgr_device.angle,(unsigned int *)argp);
-            break;
-        case PPMGR_IOC_SET_ANGLE:
-            ret = _ppmgr_angle_write(args);
-            break;
-#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-        case PPMGR_IOC_ENABLE_PP:
-            mode=(int)argp;
-            platform_type_t plarform_type;
-            plarform_type = get_platform_type();
-            if( plarform_type == PLATFORM_TV){
-            	set_ppmgr_status(mode);
-            }else{
-          	  set_ppmgr_3dmode(mode);
-         	}
-            break;
-        case PPMGR_IOC_VIEW_MODE:
-            mode=(int)argp;
-            set_ppmgr_viewmode(mode);
-            break;
-        case PPMGR_IOC_HOR_VER_DOUBLE:
-            flag = (int)argp;
-            mode = get_ppmgr_3dmode();
-            mode = (mode & (~PPMGR_3D_PROCESS_DOUBLE_TYPE))|((flag<<PPMGR_3D_PROCESS_DOUBLE_TYPE_SHIFT)&(PPMGR_3D_PROCESS_DOUBLE_TYPE));
-            set_ppmgr_3dmode(mode);
-            break;
-        case PPMGR_IOC_SWITCHMODE:
-            flag = (int)argp;
-            mode = get_ppmgr_3dmode();
-            if(flag)
-                mode = mode & PPMGR_3D_PROCESS_SWITCH_FLAG ;
-            else
-                mode = mode & (~PPMGR_3D_PROCESS_SWITCH_FLAG);
-            set_ppmgr_3dmode(mode);
-            break;
-        case PPMGR_IOC_3D_DIRECTION:
-            flag = (int)argp;
-            //mode = get_ppmgr_3dmode();
-            //mode = (mode & (~PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK))|((flag<<PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_VAULE_SHIFT)&(PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK));
-            //set_ppmgr_3dmode(mode);
-            set_ppmgr_direction3d(flag);
-            break;
-        case PPMGR_IOC_3D_SCALE_DOWN:
-            mode=(int)argp;
-            set_ppmgr_scaledown(mode);
-            break;
-#endif
-        default :
-            return -ENOIOCTLCMD;
-
-    }
-    return ret;
-}
-
-static int ppmgr_release(struct inode *inode, struct file *file)
-{
-#ifdef CONFIG_ARCH_MESON
-    ge2d_context_t *context=(ge2d_context_t *)file->private_data;
-
-    if(context && (0==destroy_ge2d_work_queue(context)))
-    {
-        ppmgr_device.open_count--;
-        return 0;
-    }
-    amlog_level(LOG_LEVEL_LOW,"release one ppmgr device\n");
-    return -1;
-#else
-    return 0;
-#endif
-}
-
-/***********************************************************************
-*
-* file op initintg section.
-*
-************************************************************************/
-
-static const struct file_operations ppmgr_fops = {
-    .owner   = THIS_MODULE,
-    .open    = ppmgr_open,
-    .unlocked_ioctl  = ppmgr_ioctl,
-    .release = ppmgr_release,
-};
-
-int  init_ppmgr_device(void)
-{
-    int  ret=0;
-
-    strcpy(ppmgr_device.name,"ppmgr");
-    ret=register_chrdev(0,ppmgr_device.name,&ppmgr_fops);
-    if(ret <=0)
-    {
-        amlog_level(LOG_LEVEL_HIGH,"register ppmgr device error\r\n");
-        return  ret ;
-    }
-    ppmgr_device.major=ret;
-    ppmgr_device.dbg_enable=0;
-
-    ppmgr_device.angle=0;
-    ppmgr_device.bypass =0 ;
-    ppmgr_device.videoangle=0;
-    ppmgr_device.orientation=0;
-#ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
-    ppmgr_device.ppscaler_flag = 0;
-    ppmgr_device.scale_h_start = 0;
-    ppmgr_device.scale_h_end = 0;
-    ppmgr_device.scale_v_start = 0;
-    ppmgr_device.scale_v_end = 0;
-    scaler_pos_reset = false;
+    __ATTR_NULL
+};
+
+static struct class ppmgr_class = {
+    .name = PPMGR_CLASS_NAME,
+    .class_attrs = ppmgr_class_attrs,
+};
+
+struct class* init_ppmgr_cls() {
+    int  ret=0;
+    ret = class_register(&ppmgr_class);
+    if(ret<0 )
+    {
+        amlog_level(LOG_LEVEL_HIGH,"error create ppmgr class\n");
+        return NULL;
+    }
+    return &ppmgr_class;
+}
+
+/***********************************************************************
+*
+* file op section.
+*
+************************************************************************/
+
+void set_ppmgr_buf_info(char* start,unsigned int size) {
+    ppmgr_device.buffer_start=(char*)start;
+    ppmgr_device.buffer_size=size;
+}
+
+void get_ppmgr_buf_info(char** start,unsigned int* size) {
+    *start=ppmgr_device.buffer_start;
+    *size=ppmgr_device.buffer_size;
+}
+EXPORT_SYMBOL(get_ppmgr_buf_info);
+
+static int ppmgr_open(struct inode *inode, struct file *file)
+{
+    ppmgr_device.open_count++;
+    return 0;
+}
+
+static long ppmgr_ioctl(struct file *file,
+                        unsigned int cmd, ulong args)
+{
+    void  __user* argp =(void __user*)args;
+    int ret = 0;
+#if 0
+    ge2d_context_t *context=(ge2d_context_t *)filp->private_data;
+    config_para_t     ge2d_config;
+    ge2d_para_t  para ;
+    int flag;
+    frame_info_t frame_info;
 #endif
-	ppmgr_device.receiver=0;
-	ppmgr_device.receiver_format = (GE2D_FORMAT_M24_NV21|GE2D_LITTLE_ENDIAN);
+#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
+    unsigned mode = 0;
+    int flag = 0;
+#endif
+    switch (cmd)
+    {
+#if 0
+        case PPMGR_IOC_CONFIG_FRAME:
+            copy_from_user(&frame_info,argp,sizeof(frame_info_t));
+            break;
+#endif
+        case PPMGR_IOC_GET_ANGLE:
+            put_user(ppmgr_device.angle,(unsigned int *)argp);
+            break;
+        case PPMGR_IOC_SET_ANGLE:
+            ret = _ppmgr_angle_write(args);
+            break;
+#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
+        case PPMGR_IOC_ENABLE_PP:
+            mode=(int)argp;
+            platform_type_t plarform_type;
+            plarform_type = get_platform_type();
+            if( plarform_type == PLATFORM_TV){
+		set_ppmgr_status(mode);
+            }else{
+		  set_ppmgr_3dmode(mode);
+		}
+            break;
+        case PPMGR_IOC_VIEW_MODE:
+            mode=(int)argp;
+            set_ppmgr_viewmode(mode);
+            break;
+        case PPMGR_IOC_HOR_VER_DOUBLE:
+            flag = (int)argp;
+            mode = get_ppmgr_3dmode();
+            mode = (mode & (~PPMGR_3D_PROCESS_DOUBLE_TYPE))|((flag<<PPMGR_3D_PROCESS_DOUBLE_TYPE_SHIFT)&(PPMGR_3D_PROCESS_DOUBLE_TYPE));
+            set_ppmgr_3dmode(mode);
+            break;
+        case PPMGR_IOC_SWITCHMODE:
+            flag = (int)argp;
+            mode = get_ppmgr_3dmode();
+            if(flag)
+                mode = mode & PPMGR_3D_PROCESS_SWITCH_FLAG ;
+            else
+                mode = mode & (~PPMGR_3D_PROCESS_SWITCH_FLAG);
+            set_ppmgr_3dmode(mode);
+            break;
+        case PPMGR_IOC_3D_DIRECTION:
+            flag = (int)argp;
+            //mode = get_ppmgr_3dmode();
+            //mode = (mode & (~PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK))|((flag<<PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_VAULE_SHIFT)&(PPMGR_3D_PROCESS_3D_ROTATE_DIRECTION_MASK));
+            //set_ppmgr_3dmode(mode);
+            set_ppmgr_direction3d(flag);
+            break;
+        case PPMGR_IOC_3D_SCALE_DOWN:
+            mode=(int)argp;
+            set_ppmgr_scaledown(mode);
+            break;
+#endif
+        default :
+            return -ENOIOCTLCMD;
+
+    }
+    return ret;
+}
+
+static int ppmgr_release(struct inode *inode, struct file *file)
+{
+#ifdef CONFIG_ARCH_MESON
+    ge2d_context_t *context=(ge2d_context_t *)file->private_data;
+
+    if(context && (0==destroy_ge2d_work_queue(context)))
+    {
+        ppmgr_device.open_count--;
+        return 0;
+    }
+    amlog_level(LOG_LEVEL_LOW,"release one ppmgr device\n");
+    return -1;
+#else
+    return 0;
+#endif
+}
+
+/***********************************************************************
+*
+* file op initintg section.
+*
+************************************************************************/
+
+static const struct file_operations ppmgr_fops = {
+    .owner   = THIS_MODULE,
+    .open    = ppmgr_open,
+    .unlocked_ioctl  = ppmgr_ioctl,
+    .release = ppmgr_release,
+};
+
+int  init_ppmgr_device(void)
+{
+    int  ret=0;
+
+    strcpy(ppmgr_device.name,"ppmgr");
+    ret=register_chrdev(0,ppmgr_device.name,&ppmgr_fops);
+    if(ret <=0)
+    {
+        amlog_level(LOG_LEVEL_HIGH,"register ppmgr device error\n");
+        return  ret ;
+    }
+    ppmgr_device.major=ret;
+    ppmgr_device.dbg_enable=0;
+
+    ppmgr_device.angle=0;
+    ppmgr_device.bypass =0 ;
+    ppmgr_device.videoangle=0;
+    ppmgr_device.orientation=0;
+#ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
+    ppmgr_device.ppscaler_flag = 0;
+    ppmgr_device.scale_h_start = 0;
+    ppmgr_device.scale_h_end = 0;
+    ppmgr_device.scale_v_start = 0;
+    ppmgr_device.scale_v_end = 0;
+    scaler_pos_reset = false;
+#endif
+	ppmgr_device.receiver=0;
+	ppmgr_device.receiver_format = (GE2D_FORMAT_M24_NV21|GE2D_LITTLE_ENDIAN);
     ppmgr_device.display_mode = 0;
-#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-    ppmgr_device.ppmgr_3d_mode = EXTERNAL_MODE_3D_DISABLE ;
-    ppmgr_device.direction_3d = 0;
-    ppmgr_device.viewmode = VIEWMODE_NORMAL;
-    ppmgr_device.scale_down = 0;
-#endif
-    ppmgr_device.mirror_flag  = 0;
-    ppmgr_device.canvas_width = ppmgr_device.canvas_height = 0;
-    amlog_level(LOG_LEVEL_LOW,"ppmgr_dev major:%d\r\n",ret);
-
-    if((ppmgr_device.cla = init_ppmgr_cls())==NULL) return -1;
-    ppmgr_device.dev=device_create(ppmgr_device.cla,NULL,MKDEV(ppmgr_device.major,0),NULL,ppmgr_device.name);
-    if (IS_ERR(ppmgr_device.dev)) {
-        amlog_level(LOG_LEVEL_HIGH,"create ppmgr device error\n");
-        goto unregister_dev;
-    }
-    buff_change = 0;
-    ppmgr_register();
+#ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
+    ppmgr_device.ppmgr_3d_mode = EXTERNAL_MODE_3D_DISABLE ;
+    ppmgr_device.direction_3d = 0;
+    ppmgr_device.viewmode = VIEWMODE_NORMAL;
+    ppmgr_device.scale_down = 0;
+#endif
+    ppmgr_device.mirror_flag  = 0;
+    ppmgr_device.canvas_width = ppmgr_device.canvas_height = 0;
+    amlog_level(LOG_LEVEL_LOW,"ppmgr_dev major:%d\n",ret);
+
+    if((ppmgr_device.cla = init_ppmgr_cls())==NULL) return -1;
+    ppmgr_device.dev=device_create(ppmgr_device.cla,NULL,MKDEV(ppmgr_device.major,0),NULL,ppmgr_device.name);
+    if (IS_ERR(ppmgr_device.dev)) {
+        amlog_level(LOG_LEVEL_HIGH,"create ppmgr device error\n");
+        goto unregister_dev;
+    }
+    buff_change = 0;
+    ppmgr_register();
     if(ppmgr_buffer_init(0) < 0) goto unregister_dev;
-    //if(start_vpp_task()<0) return -1;
-    ppmgr_device.use_prot = 1;
-#if HAS_VPU_PROT
-    ppmgr_device.disable_prot = 0;
-#else
-    ppmgr_device.disable_prot = 1;
-#endif
-    ppmgr_device.global_angle = 0;
+    //if(start_vpp_task()<0) return -1;
+    ppmgr_device.use_prot = 1;
+#if HAS_VPU_PROT
+    ppmgr_device.disable_prot = 0;
+#else
+    ppmgr_device.disable_prot = 1;
+#endif
+    ppmgr_device.global_angle = 0;
     ppmgr_device.started = 0;
-    return 0;
-
-unregister_dev:
-    class_unregister(ppmgr_device.cla);
-    return -1;
-}
-
-int uninit_ppmgr_device(void)
-{
-    stop_ppmgr_task();
-
-    if(ppmgr_device.cla)
-    {
-        if(ppmgr_device.dev)
-            device_destroy(ppmgr_device.cla, MKDEV(ppmgr_device.major, 0));
-        class_unregister(ppmgr_device.cla);
-    }
-
-    unregister_chrdev(ppmgr_device.major, ppmgr_device.name);
-    return  0;
-}
-
-/*******************************************************************
- *
- * interface for Linux driver
- *
- * ******************************************************************/
-
-MODULE_AMLOG(AMLOG_DEFAULT_LEVEL, 0xff, LOG_LEVEL_DESC, LOG_MASK_DESC);
-
-static struct platform_device *ppmgr_dev0 = NULL;
-static struct resource memobj;
-/* for driver. */
-static int ppmgr_driver_probe(struct platform_device *pdev)
-{
-    char* buf_start;
-    unsigned int buf_size;
-    struct resource *mem;
-    int idx;
-
-#if 0
-    if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, 0)))
-    {
-        amlog_level(LOG_LEVEL_HIGH, "ppmgr memory resource undefined.\n");
-        return -EFAULT;
-    }
-#else
-    mem = &memobj;
-    idx = find_reserve_block(pdev->dev.of_node->name,0);
-    if(idx < 0){
-	 amlog_level(LOG_LEVEL_HIGH, "ppmgr memory resource undefined.\n");
-        return -EFAULT;
-    }
-    mem->start = (phys_addr_t)get_reserve_block_addr(idx);
-    mem->end = mem->start+ (phys_addr_t)get_reserve_block_size(idx)-1;
-#endif
-    buf_start = (char *)mem->start;
-    buf_size = mem->end - mem->start + 1;
-    set_ppmgr_buf_info((char *)mem->start,buf_size);
-    init_ppmgr_device();
-    return 0;
-}
-
-static int ppmgr_drv_remove(struct platform_device *plat_dev)
-{
-    //struct rtc_device *rtc = platform_get_drvdata(plat_dev);
-    //rtc_device_unregister(rtc);
-    //device_remove_file(&plat_dev->dev, &dev_attr_irq);
-    uninit_ppmgr_device();
-    return 0;
-}
-
-#ifdef CONFIG_USE_OF
-static const struct of_device_id amlogic_ppmgr_dt_match[]={
-	{	.compatible = "amlogic,ppmgr",
-	},
-	{},
-};
-#else
-#define amlogic_ppmgr_dt_match NULL
-#endif
-
-/* general interface for a linux driver .*/
-struct platform_driver ppmgr_drv = {
-    .probe  = ppmgr_driver_probe,
-    .remove = ppmgr_drv_remove,
-    .driver = {
-        .name = "ppmgr",
-        .owner = THIS_MODULE,
-        .of_match_table = amlogic_ppmgr_dt_match,
-    }
-};
-
-static int __init
-ppmgr_init_module(void)
-{
-    int err;
-
-    amlog_level(LOG_LEVEL_HIGH,"ppmgr_init\n");
-    if ((err = platform_driver_register(&ppmgr_drv))) {
-        return err;
-    }
-
-    return err;
-
-}
-
-static void __exit
-ppmgr_remove_module(void)
-{
-    platform_device_put(ppmgr_dev0);
-    platform_driver_unregister(&ppmgr_drv);
-    amlog_level(LOG_LEVEL_HIGH,"ppmgr module removed.\n");
-}
-
-module_init(ppmgr_init_module);
-module_exit(ppmgr_remove_module);
-
-MODULE_DESCRIPTION("AMLOGIC  ppmgr driver");
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("aml-sh <kasin.li@amlogic.com>");
-
-
+    return 0;
+
+unregister_dev:
+    class_unregister(ppmgr_device.cla);
+    return -1;
+}
+
+int uninit_ppmgr_device(void)
+{
+    stop_ppmgr_task();
+
+    if(ppmgr_device.cla)
+    {
+        if(ppmgr_device.dev)
+            device_destroy(ppmgr_device.cla, MKDEV(ppmgr_device.major, 0));
+        class_unregister(ppmgr_device.cla);
+    }
+
+    unregister_chrdev(ppmgr_device.major, ppmgr_device.name);
+    return  0;
+}
+
+/*******************************************************************
+ *
+ * interface for Linux driver
+ *
+ * ******************************************************************/
+
+MODULE_AMLOG(AMLOG_DEFAULT_LEVEL, 0xff, LOG_LEVEL_DESC, LOG_MASK_DESC);
+
+static struct platform_device *ppmgr_dev0 = NULL;
+static struct resource memobj;
+/* for driver. */
+static int ppmgr_driver_probe(struct platform_device *pdev)
+{
+    char* buf_start;
+    unsigned int buf_size;
+    struct resource *mem;
+    int idx;
+
+#if 0
+    if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, 0)))
+    {
+        amlog_level(LOG_LEVEL_HIGH, "ppmgr memory resource undefined.\n");
+        return -EFAULT;
+    }
+#else
+    mem = &memobj;
+    idx = find_reserve_block(pdev->dev.of_node->name,0);
+    if(idx < 0){
+	 amlog_level(LOG_LEVEL_HIGH, "ppmgr memory resource undefined.\n");
+        return -EFAULT;
+    }
+    mem->start = (phys_addr_t)get_reserve_block_addr(idx);
+    mem->end = mem->start+ (phys_addr_t)get_reserve_block_size(idx)-1;
+#endif
+    buf_start = (char *)mem->start;
+    buf_size = mem->end - mem->start + 1;
+    set_ppmgr_buf_info((char *)mem->start,buf_size);
+    init_ppmgr_device();
+    return 0;
+}
+
+static int ppmgr_drv_remove(struct platform_device *plat_dev)
+{
+    //struct rtc_device *rtc = platform_get_drvdata(plat_dev);
+    //rtc_device_unregister(rtc);
+    //device_remove_file(&plat_dev->dev, &dev_attr_irq);
+    uninit_ppmgr_device();
+    return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id amlogic_ppmgr_dt_match[]={
+	{	.compatible = "amlogic,ppmgr",
+	},
+	{},
+};
+#else
+#define amlogic_ppmgr_dt_match NULL
+#endif
+
+/* general interface for a linux driver .*/
+struct platform_driver ppmgr_drv = {
+    .probe  = ppmgr_driver_probe,
+    .remove = ppmgr_drv_remove,
+    .driver = {
+        .name = "ppmgr",
+        .owner = THIS_MODULE,
+        .of_match_table = amlogic_ppmgr_dt_match,
+    }
+};
+
+static int __init
+ppmgr_init_module(void)
+{
+    int err;
+
+    amlog_level(LOG_LEVEL_HIGH,"ppmgr_init\n");
+    if ((err = platform_driver_register(&ppmgr_drv))) {
+        return err;
+    }
+
+    return err;
+
+}
+
+static void __exit
+ppmgr_remove_module(void)
+{
+    platform_device_put(ppmgr_dev0);
+    platform_driver_unregister(&ppmgr_drv);
+    amlog_level(LOG_LEVEL_HIGH,"ppmgr module removed.\n");
+}
+
+module_init(ppmgr_init_module);
+module_exit(ppmgr_remove_module);
+
+MODULE_DESCRIPTION("AMLOGIC  ppmgr driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("aml-sh <kasin.li@amlogic.com>");
diff --git a/drivers/amlogic/ppmgr/ppmgr_log.h b/drivers/amlogic/ppmgr/ppmgr_log.h
old mode 100644
new mode 100755
index 47cc93c3..ff6fbd34
--- a/drivers/amlogic/ppmgr/ppmgr_log.h
+++ b/drivers/amlogic/ppmgr/ppmgr_log.h
@@ -1,28 +1,27 @@
-#ifndef  OSD_LOG_H
-#define OSD_LOG_H
-
-#define DEBUG
-#ifdef  DEBUG
-#define  AMLOG   1
-#define LOG_LEVEL_VAR amlog_level_ppmgr
-#define LOG_MASK_VAR amlog_mask_ppmgr
-#endif
-
-
-#define  	LOG_LEVEL_HIGH    		0x00f
-#define	LOG_LEVEL_1				0x001
-#define 	LOG_LEVEL_LOW			0x000
-
-#define LOG_LEVEL_DESC \
-"[0x00]LOW[0X01]LEVEL1[0xf]HIGH"	
-
-#define  	LOG_MASK_INIT			0x001
-#define	LOG_MASK_IOCTL			0x002
-#define	LOG_MASK_HARDWARE		0x004
-#define	LOG_MASK_CONFIG		0x008
-#define	LOG_MASK_WORK			0x010
-#define 	LOG_MASK_DESC \
-"[0x01]:INIT,[0x02]:IOCTL,[0x04]:HARDWARE,[0x08]LOG_MASK_CONFIG[0x10]LOG_MASK_WORK"
-
-#endif
-
+#ifndef  OSD_LOG_H
+#define OSD_LOG_H
+
+#define DEBUG
+#ifdef  DEBUG
+#define  AMLOG   1
+#define LOG_LEVEL_VAR amlog_level_ppmgr
+#define LOG_MASK_VAR amlog_mask_ppmgr
+#endif
+
+
+#define  	LOG_LEVEL_HIGH    		0x00f
+#define	LOG_LEVEL_1				0x001
+#define 	LOG_LEVEL_LOW			0x000
+
+#define LOG_LEVEL_DESC \
+"[0x00]LOW[0X01]LEVEL1[0xf]HIGH"
+
+#define  	LOG_MASK_INIT			0x001
+#define	LOG_MASK_IOCTL			0x002
+#define	LOG_MASK_HARDWARE		0x004
+#define	LOG_MASK_CONFIG		0x008
+#define	LOG_MASK_WORK			0x010
+#define 	LOG_MASK_DESC \
+"[0x01]:INIT,[0x02]:IOCTL,[0x04]:HARDWARE,[0x08]LOG_MASK_CONFIG[0x10]LOG_MASK_WORK"
+
+#endif
diff --git a/drivers/amlogic/ppmgr/ppmgr_pri.h b/drivers/amlogic/ppmgr/ppmgr_pri.h
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/ppmgr/ppmgr_vpp.c b/drivers/amlogic/ppmgr/ppmgr_vpp.c
old mode 100644
new mode 100755
index 47d9ce4a..f507eb98
--- a/drivers/amlogic/ppmgr/ppmgr_vpp.c
+++ b/drivers/amlogic/ppmgr/ppmgr_vpp.c
@@ -204,7 +204,7 @@ static void ppmgr_vf_put(vframe_t *vf, void *op_arg)
 
 
     i=vfq_level(&q_free);
-    
+
     while(i>0)
     {
         index=(q_free.rp+i-1)%(q_free.size);
@@ -318,7 +318,7 @@ static int ppmgr_event_cb(int type, void *data, void *private_data)
 #endif
     if(type & VFRAME_EVENT_RECEIVER_FRAME_WAIT){
         if(task_running && !ppmgr_device.use_prot){
-			
+
 			if(timestamp_pcrscr_enable_state()){
 				return 0;
 			}
@@ -459,8 +459,8 @@ void vf_local_init(void)
     }
 
     for(i =0 ; i < VF_POOL_SIZE ;i++ ){
-    	buf_status[i].index = ppmgr_canvas_tab[i];
-    	buf_status[i].dirty = 1;
+	buf_status[i].index = ppmgr_canvas_tab[i];
+	buf_status[i].dirty = 1;
     }
     sema_init(&thread_sem,1);
 }
@@ -637,11 +637,11 @@ static void display_mode_adjust(ge2d_context_t *context, vframe_t *new_vf, int p
     int vf_height = new_vf->height;
     static int current_display_mode = 0;
     if (ppmgr_device.display_mode != current_display_mode) {
-    	current_display_mode = ppmgr_device.display_mode;
-    	display_mode_change = VF_POOL_SIZE;
+	current_display_mode = ppmgr_device.display_mode;
+	display_mode_change = VF_POOL_SIZE;
     }
     if (display_mode_change > 0) {
-    	display_mode_change--;
+	display_mode_change--;
         fillrect(context, 0, 0, canvas_width, canvas_height, 0x008080ff);
     }
     if (ppmgr_device.display_mode == 0) {//stretch full
@@ -679,6 +679,9 @@ static int process_vf_deinterlace_nv21(vframe_t *vf, ge2d_context_t *context, co
     if (!vf)
         return -1;
 
+    if(vf->type & VIDTYPE_MVC){
+		return 0;
+	}
     if ((vf->canvas0Addr == vf->canvas1Addr)||(ppmgr_device.angle == 0)){
         //printk("++ppmgr interlace skip.\n");
         return 0;
@@ -834,6 +837,9 @@ static int process_vf_deinterlace(vframe_t *vf, ge2d_context_t *context, config_
     if (!vf)
         return -1;
 
+    if(vf->type & VIDTYPE_MVC){
+		return 0;
+	}
     if ((vf->canvas0Addr == vf->canvas1Addr)||(ppmgr_device.bypass)||(ppmgr_device.angle == 0)){
         //printk("++ppmgr interlace skip.\n");
         return 0;
@@ -1297,6 +1303,9 @@ static void process_vf_rotate(vframe_t *vf, ge2d_context_t *context, config_para
         pp_vf->dec_frame = NULL;
 #endif
 
+   if(vf->type & VIDTYPE_MVC){
+		pp_vf->dec_frame = vf;
+	}
     if (pp_vf->dec_frame) {
         /* bypass mode */
         *new_vf = *vf;
@@ -1333,23 +1342,23 @@ static void process_vf_rotate(vframe_t *vf, ge2d_context_t *context, config_para
 
     if(vf->type&VIDTYPE_VIU_422){
         if(interlace_mode == VIDTYPE_INTERLACE_TOP)
-    			  vf->height >>=1;
-    		else if(interlace_mode == VIDTYPE_INTERLACE_BOTTOM){
-    		    vf->height >>=1;
-    		}else{
+			  vf->height >>=1;
+		else if(interlace_mode == VIDTYPE_INTERLACE_BOTTOM){
+		    vf->height >>=1;
+		}else{
             pic_struct = (GE2D_FORMAT_S16_YUV422T &(3<<3));
         }
     }else if(vf->type&VIDTYPE_VIU_NV21){
-    		if(interlace_mode == VIDTYPE_INTERLACE_TOP)
-    			pic_struct = (GE2D_FORMAT_M24_NV21T & (3<<3));
-    		else if(interlace_mode == VIDTYPE_INTERLACE_BOTTOM)
-    			pic_struct = (GE2D_FORMAT_M24_NV21B & (3<<3));
-    	}else{
-        		if(interlace_mode == VIDTYPE_INTERLACE_TOP)
-        			pic_struct = (GE2D_FORMAT_M24_YUV420T & (3<<3));
-        		else if(interlace_mode == VIDTYPE_INTERLACE_BOTTOM)
-        			pic_struct = (GE2D_FORMAT_M24_YUV420B & (3<<3));
-    	}
+		if(interlace_mode == VIDTYPE_INTERLACE_TOP)
+			pic_struct = (GE2D_FORMAT_M24_NV21T & (3<<3));
+		else if(interlace_mode == VIDTYPE_INTERLACE_BOTTOM)
+			pic_struct = (GE2D_FORMAT_M24_NV21B & (3<<3));
+	}else{
+			if(interlace_mode == VIDTYPE_INTERLACE_TOP)
+				pic_struct = (GE2D_FORMAT_M24_YUV420T & (3<<3));
+			else if(interlace_mode == VIDTYPE_INTERLACE_BOTTOM)
+				pic_struct = (GE2D_FORMAT_M24_YUV420B & (3<<3));
+	}
 
 #ifndef CONFIG_POST_PROCESS_MANAGER_PPSCALER
     vf_rotate_adjust(vf, new_vf, cur_angle);
@@ -1371,8 +1380,8 @@ static void process_vf_rotate(vframe_t *vf, ge2d_context_t *context, config_para
             scaler_w = rect_w;
             scaler_h = rect_h;
             for(i =0 ; i < VF_POOL_SIZE ;i++ ){
-            	buf_status[i].index = ppmgr_canvas_tab[i];
-            	buf_status[i].dirty = 1;
+		buf_status[i].index = ppmgr_canvas_tab[i];
+		buf_status[i].dirty = 1;
             }
             //printk("--ppmgr new rect x:%d, y:%d, w:%d, h:%d.\n", rect_x, rect_y, rect_w, rect_h);
         }
@@ -1394,14 +1403,14 @@ static void process_vf_rotate(vframe_t *vf, ge2d_context_t *context, config_para
     memset(ge2d_config,0,sizeof(config_para_ex_t));
 
     for(i =0 ; i < VF_POOL_SIZE ;i++ ){
-    	if(buf_status[i].index == new_vf->canvas0Addr){
-    		break;
-    	}
+	if(buf_status[i].index == new_vf->canvas0Addr){
+		break;
+	}
     }
 
     if(buf_status[i].dirty == 1){
-    	buf_status[i].dirty = 0;
-    	//printk("--scale_clear_count is %d ------new_vf->canvas0Addr is %d ----------x:%d, y:%d, w:%d, h:%d.\n",scale_clear_count,new_vf->canvas0Addr, rect_x, rect_y, rect_w, rect_h);
+	buf_status[i].dirty = 0;
+	//printk("--scale_clear_count is %d ------new_vf->canvas0Addr is %d ----------x:%d, y:%d, w:%d, h:%d.\n",scale_clear_count,new_vf->canvas0Addr, rect_x, rect_y, rect_w, rect_h);
     /* data operating. */
         ge2d_config->alu_const_color= 0;//0x000000ff;
         ge2d_config->bitmask_en  = 0;
@@ -1662,10 +1671,10 @@ static void process_vf_rotate(vframe_t *vf, ge2d_context_t *context, config_para
 			ge2d_config->dst_para.y_rev = 1;
 	} else if (ppmgr_device.mirror_flag == 2) {
 		if(cur_angle == 1 || cur_angle == 2)
-    			ge2d_config->dst_para.x_rev = 0;
-    		else
-    			ge2d_config->dst_para.x_rev = 1;
-    	}
+			ge2d_config->dst_para.x_rev = 0;
+		else
+			ge2d_config->dst_para.x_rev = 1;
+	}
     }
     ge2d_config->dst_para.color = 0;
     ge2d_config->dst_para.top = 0;
@@ -1791,22 +1800,22 @@ static void process_vf_change(vframe_t *vf, ge2d_context_t *context, config_para
 
     if(vf->type&VIDTYPE_VIU_422){
         if(interlace_mode == VIDTYPE_INTERLACE_TOP)
-    			  vf->height >>=1;
-    		else if(interlace_mode == VIDTYPE_INTERLACE_BOTTOM){
-    		    vf->height >>=1;
-    		}else{
+			  vf->height >>=1;
+		else if(interlace_mode == VIDTYPE_INTERLACE_BOTTOM){
+		    vf->height >>=1;
+		}else{
             pic_struct = (GE2D_FORMAT_S16_YUV422T &(3<<3));
         }
     }else if(vf->type&VIDTYPE_VIU_NV21){
-    		if(interlace_mode == VIDTYPE_INTERLACE_TOP)
-    			pic_struct = (GE2D_FORMAT_M24_NV21T & (3<<3));
-    		else if(interlace_mode == VIDTYPE_INTERLACE_BOTTOM)
-    			pic_struct = (GE2D_FORMAT_M24_NV21B & (3<<3));
+		if(interlace_mode == VIDTYPE_INTERLACE_TOP)
+			pic_struct = (GE2D_FORMAT_M24_NV21T & (3<<3));
+		else if(interlace_mode == VIDTYPE_INTERLACE_BOTTOM)
+			pic_struct = (GE2D_FORMAT_M24_NV21B & (3<<3));
 	}else{
-    		if(interlace_mode == VIDTYPE_INTERLACE_TOP)
-    			pic_struct = (GE2D_FORMAT_M24_YUV420T & (3<<3));
-    		else if(interlace_mode == VIDTYPE_INTERLACE_BOTTOM)
-    			pic_struct = (GE2D_FORMAT_M24_YUV420B & (3<<3));
+		if(interlace_mode == VIDTYPE_INTERLACE_TOP)
+			pic_struct = (GE2D_FORMAT_M24_YUV420T & (3<<3));
+		else if(interlace_mode == VIDTYPE_INTERLACE_BOTTOM)
+			pic_struct = (GE2D_FORMAT_M24_YUV420B & (3<<3));
 	}
 
     memset(ge2d_config,0,sizeof(config_para_ex_t));
@@ -2017,8 +2026,8 @@ static int process_vf_adjust(vframe_t *vf, ge2d_context_t *context, config_para_
 
     scale_clear_count = VF_POOL_SIZE;
     for(i =0 ; i < VF_POOL_SIZE ;i++ ){
-    	buf_status[i].index = ppmgr_canvas_tab[i];
-    	buf_status[i].dirty = 1;
+	buf_status[i].index = ppmgr_canvas_tab[i];
+	buf_status[i].dirty = 1;
     }
     scaler_x = rect_x;
     scaler_y = rect_y;
@@ -2281,7 +2290,7 @@ static int ppmgr_task(void *data)
     struct sched_param param = {.sched_priority = MAX_RT_PRIO - 1 };
     int i;
 	 vframe_t *vf_local = NULL;
-	 ppframe_t *pp_local=NULL;    
+	 ppframe_t *pp_local=NULL;
     ge2d_context_t *context=create_ge2d_work_queue();
     config_para_ex_t ge2d_config;
     memset(&ge2d_config,0,sizeof(config_para_ex_t));
@@ -2362,6 +2371,7 @@ static int ppmgr_task(void *data)
                 break;
             if (vf && ppmgr_device.started) {
                 if (!(vf->type & (VIDTYPE_VIU_422 | VIDTYPE_VIU_444 | VIDTYPE_VIU_NV21)) || (vf->type & VIDTYPE_INTERLACE) || ppmgr_device.disable_prot
+                || (vf->type & VIDTYPE_MVC)
 #ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
                 || amvideo_get_scaler_mode()
 #endif
@@ -2369,44 +2379,47 @@ static int ppmgr_task(void *data)
                 || ppmgr_device.receiver
 #endif
                 ) {
-                    ppmgr_device.use_prot = 0;
-                    set_video_angle(0);
-                    ppmgr_device.angle = ppmgr_device.global_angle;
-                    ppmgr_device.videoangle = (ppmgr_device.angle + ppmgr_device.orientation) % 4;
-                    set_property_change(1);
+                    if (ppmgr_device.use_prot != 0) {
+                        ppmgr_device.use_prot = 0;
+                        set_video_angle(0);
+                        //ppmgr_device.angle = ppmgr_device.global_angle;
+                        ppmgr_device.videoangle = (ppmgr_device.angle + ppmgr_device.orientation) % 4;
+                        set_property_change(1);
+                    }
                 } else {
                     ppmgr_device.use_prot = 1;
-                    ppmgr_device.angle = 0;
+                    //ppmgr_device.angle = 0;
                     ppmgr_device.videoangle = (ppmgr_device.angle + ppmgr_device.orientation) % 4;
                     set_property_change(1);
                     //set_video_angle(ppmgr_device.global_angle);
                 }
                 ppmgr_device.started = 0;
             }
+            vf->video_angle = (ppmgr_device.angle + ppmgr_device.orientation + vf->orientation)%4;
             plarform_type = get_platform_type();
             if( plarform_type == PLATFORM_TV){
-            	process_type = get_tv_process_type(vf);
+		process_type = get_tv_process_type(vf);
             }else{
-            	process_type = get_mid_process_type(vf);
-        	}
+		process_type = get_mid_process_type(vf);
+		}
             if(process_type== TYPE_NONE){
                 int ret = 0;
                 if( plarform_type != PLATFORM_TV){
-                	ret = process_vf_deinterlace(vf, context, &ge2d_config);
-            	}
+			ret = process_vf_deinterlace(vf, context, &ge2d_config);
+		}
                 process_vf_rotate(vf, context, &ge2d_config,(ret>0)?ret:0);
             }else{
-            	if( plarform_type == PLATFORM_TV){
-            		ppmgr_vf_3d_tv(vf, context, &ge2d_config);
-            	}else{
-                	ppmgr_vf_3d(vf, context, &ge2d_config);
-            	}
+		if( plarform_type == PLATFORM_TV){
+			ppmgr_vf_3d_tv(vf, context, &ge2d_config);
+		}else{
+			ppmgr_vf_3d(vf, context, &ge2d_config);
+		}
             }
 #else
             int ret = 0;
             vf = ppmgr_vf_get_dec();
             if(!vf)
-                break;            
+                break;
             if (vf && ppmgr_device.started) {
                 if (!(vf->type & (VIDTYPE_VIU_422 | VIDTYPE_VIU_444 | VIDTYPE_VIU_NV21)) || (vf->type & VIDTYPE_INTERLACE) || ppmgr_device.disable_prot
 #ifdef CONFIG_POST_PROCESS_MANAGER_PPSCALER
@@ -2416,20 +2429,23 @@ static int ppmgr_task(void *data)
                 || ppmgr_device.receiver
 #endif
                 ) {
-                    ppmgr_device.use_prot = 0;
-                    set_video_angle(0);
-                    ppmgr_device.angle = ppmgr_device.global_angle;
-                    ppmgr_device.videoangle = (ppmgr_device.angle + ppmgr_device.orientation) % 4;
-                    set_property_change(1);
+                    if (ppmgr_device.use_prot != 0) {
+                        ppmgr_device.use_prot = 0;
+                        set_video_angle(0);
+                        //ppmgr_device.angle = ppmgr_device.global_angle;
+                        ppmgr_device.videoangle = (ppmgr_device.angle + ppmgr_device.orientation) % 4;
+                        set_property_change(1);
+                    }
                 } else {
                     ppmgr_device.use_prot = 1;
                     set_video_angle(ppmgr_device.global_angle);
-                    ppmgr_device.angle = 0;
+                    //ppmgr_device.angle = 0;
                     ppmgr_device.videoangle = (ppmgr_device.angle + ppmgr_device.orientation) % 4;
                     set_property_change(1);
                 }
                 ppmgr_device.started = 0;
             }
+            vf->video_angle = (ppmgr_device.angle + ppmgr_device.orientation + vf->orientation)%4;
             ret = process_vf_deinterlace(vf, context, &ge2d_config);
             process_vf_rotate(vf, context, &ge2d_config,(ret>0)?ret:0);
 #endif
@@ -2437,10 +2453,10 @@ static int ppmgr_task(void *data)
 
         if (ppmgr_blocking) {
             #if 0
-        	if(ppmgr_reset_type){
+		if(ppmgr_reset_type){
 				vf_notify_provider(PROVIDER_NAME,VFRAME_EVENT_RECEIVER_RESET,NULL);
-            	ppmgr_reset_type = 0 ;
-        	}
+		ppmgr_reset_type = 0 ;
+		}
             #endif
             /***recycle buffer to decoder***/
 
@@ -2702,11 +2718,11 @@ int start_ppmgr_task(void)
         vf_local_init();
         //if(get_buff_change())
         #ifdef CONFIG_POST_PROCESS_MANAGER_3D_PROCESS
-        	if( plarform_type == PLATFORM_TV){
-        		ppmgr_buffer_init(1);
-        	}else{
-        		ppmgr_buffer_init(0);
-        	}
+		if( plarform_type == PLATFORM_TV){
+			ppmgr_buffer_init(1);
+		}else{
+			ppmgr_buffer_init(0);
+		}
         #else
             ppmgr_buffer_init(0);
         #endif
