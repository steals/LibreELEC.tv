diff --git a/drivers/amlogic/display/Kconfig b/drivers/amlogic/display/Kconfig
index 31637842..5d834b2f 100755
--- a/drivers/amlogic/display/Kconfig
+++ b/drivers/amlogic/display/Kconfig
@@ -17,5 +17,5 @@ source "drivers/amlogic/display/osd_ext/Kconfig"
 source "drivers/amlogic/display/backlight/Kconfig"
 source "drivers/amlogic/display/ge2d/Kconfig"
 source "drivers/amlogic/display/aml_logo/Kconfig"
+source "drivers/amlogic/display/sys_led/Kconfig"
 endif
-
diff --git a/drivers/amlogic/display/Makefile b/drivers/amlogic/display/Makefile
index d005b35d..e401b397 100755
--- a/drivers/amlogic/display/Makefile
+++ b/drivers/amlogic/display/Makefile
@@ -5,11 +5,10 @@ obj-$(CONFIG_AM_TCON_OUTPUT)	+= vout/
 obj-$(CONFIG_AM_GE2D)		+= ge2d/
 obj-$(CONFIG_FB_AM)		+= osd/
 obj-$(CONFIG_AM_FB_EXT)		+= osd_ext/
-obj-$(CONFIG_AML_TV_LCD)	+= lcd/
+obj-y						+= lcd/
 obj-$(CONFIG_AM_LOGO)		+= aml_logo/
 
 obj-y				+= backlight/
 
 obj-$(CONFIG_AM_TV_OUTPUT2)	+= vout2/
-
-
+obj-$(CONFIG_AMLOGIC_SYS_LED)	+= sys_led/
diff --git a/drivers/amlogic/display/aml_logo/Kconfig b/drivers/amlogic/display/aml_logo/Kconfig
index 86d059e1..e4a9decf 100755
--- a/drivers/amlogic/display/aml_logo/Kconfig
+++ b/drivers/amlogic/display/aml_logo/Kconfig
@@ -1,12 +1,12 @@
-config  AM_LOGO
+config  AM_LOGO
 	bool  "setup logo"
 	default n
 	depends on FB_AM && AM_GE2D
-	help 
-		setup logo support osd parameter offered by Uboot 
-
-config AM_HDMI_ONLY
-	bool  "hdmi only"
-	default n
-	help
-		if enable hdmi only then only one display work
+	help
+		setup logo support osd parameter offered by Uboot
+
+config AM_HDMI_ONLY
+	bool  "hdmi only"
+	default n
+	help
+		if enable hdmi only then only one display work
diff --git a/drivers/amlogic/display/aml_logo/Makefile b/drivers/amlogic/display/aml_logo/Makefile
index d5cbddd1..b3c4e8d9 100755
--- a/drivers/amlogic/display/aml_logo/Makefile
+++ b/drivers/amlogic/display/aml_logo/Makefile
@@ -16,7 +16,7 @@ amlogo-objs := ./loader/logo_setup_uboot.o  \
 			./logo_display/output_dev_vid.o \
 			./logo_parse/jpeg_parser.o
 
-EXTRA_CFLAGS += -Iinclude/linux/amlogic/logo/			  
+EXTRA_CFLAGS += -Iinclude/linux/amlogic/logo/
 EXTRA_CFLAGS += -Idrivers/amlogic/display/ge2d
 EXTRA_CFLAGS += -Idrivers/amlogic/amports/
 else
diff --git a/drivers/amlogic/display/aml_logo/loader/logo_empty_setup.c b/drivers/amlogic/display/aml_logo/loader/logo_empty_setup.c
old mode 100644
new mode 100755
index 645ade11..848f7ff9
--- a/drivers/amlogic/display/aml_logo/loader/logo_empty_setup.c
+++ b/drivers/amlogic/display/aml_logo/loader/logo_empty_setup.c
@@ -1,17 +1,17 @@
-/*******************************************************************
- *
- *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- *
- *  Description:
- *		this file will parse all parameters offered by loader.
- *
- *  Author: Amlogic Software
- *  Created: 2010/8/23   19:46
- *
- *******************************************************************/
- #include  "loader.h"
- 
- logo_object_t* get_current_logo_obj(void)
-{
-	return NULL;
+/*******************************************************************
+ *
+ *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *		this file will parse all parameters offered by loader.
+ *
+ *  Author: Amlogic Software
+ *  Created: 2010/8/23   19:46
+ *
+ *******************************************************************/
+ #include  "loader.h"
+
+ logo_object_t* get_current_logo_obj(void)
+{
+	return NULL;
 }
\ No newline at end of file
diff --git a/drivers/amlogic/display/aml_logo/loader/logo_setup_myloader.c b/drivers/amlogic/display/aml_logo/loader/logo_setup_myloader.c
old mode 100644
new mode 100755
index ae560b70..d0b7db1f
--- a/drivers/amlogic/display/aml_logo/loader/logo_setup_myloader.c
+++ b/drivers/amlogic/display/aml_logo/loader/logo_setup_myloader.c
@@ -1,21 +1,21 @@
-/******************************************************************
- *
- *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- *
- *  Description:
- *		this file is an examble for how to setup parameter by other loader 
- *
- *  Author: Amlogic Software
- *  Created: 2010/4/1   19:46
- *
- *******************************************************************/
-
- /******************logo entry point ***************/
-static int logo_para_setup(void)
-{
-	//todo 
-	//	1  load parameter from nand or flash 
-	//    2  setup logo object 
-	return 0;
-}
+/******************************************************************
+ *
+ *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *		this file is an examble for how to setup parameter by other loader
+ *
+ *  Author: Amlogic Software
+ *  Created: 2010/4/1   19:46
+ *
+ *******************************************************************/
+
+ /******************logo entry point ***************/
+static int logo_para_setup(void)
+{
+	//todo
+	//	1  load parameter from nand or flash
+	//    2  setup logo object
+	return 0;
+}
 subsys_initcall_sync(logo_para_setup) ;
\ No newline at end of file
diff --git a/drivers/amlogic/display/aml_logo/loader/logo_setup_uboot.c b/drivers/amlogic/display/aml_logo/loader/logo_setup_uboot.c
old mode 100644
new mode 100755
index 8bb308f6..daf09240
--- a/drivers/amlogic/display/aml_logo/loader/logo_setup_uboot.c
+++ b/drivers/amlogic/display/aml_logo/loader/logo_setup_uboot.c
@@ -1,208 +1,212 @@
-/*******************************************************************
- *
- *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- *
- *  Description:
- *		this file will parse all parameters offered by loader.
- *
- *  Author: Amlogic Software
- *  Created: 2010/8/23   19:46
- *
- *******************************************************************/
- #include	"loader.h"
- #include	"amlogo_log.h"
- #include <linux/amlogic/amlog.h>
-
-/******************************************************************
-**																   **
-**	sample para for bootargs=> logo=osd1,0x84100000,full,720p,dbg,progress  **
-**																   **
-*******************************************************************/
-/******************logo entry point ***************/
-
-MODULE_AMLOG(LOG_LEVEL_MAX-1, LOG_MASK_ALL, LOG_LEVEL_DESC, LOG_MASK_DESC);
-logo_object_t  aml_logo={
-	.name="default",
-	.dev=NULL,
-	.parser=NULL,
-} ;
-
-static inline  int str2lower(char *str)
-{
-	while(*str != '\0')
-	{
-		*str= TOLOWER(*str);
-		str++;
-	}
-	return 0;
-}
-
-static inline int install_logo_info(logo_object_t *plogo,char *para)
-{
-	static  para_info_pair_t para_info_pair[PARA_END+2]={
-//head
-	{"head",INVALID_INFO,		PARA_END+1,		1,	0,	PARA_END+1},
-
-//dev		
-	{"osd0",LOGO_DEV_OSD0,	PARA_FIRST_GROUP_START-1,	PARA_FIRST_GROUP_START+1,	PARA_FIRST_GROUP_START,	PARA_SECOND_GROUP_START-1},
-	{"osd1",LOGO_DEV_OSD1,	PARA_FIRST_GROUP_START,		PARA_FIRST_GROUP_START+2,	PARA_FIRST_GROUP_START,	PARA_SECOND_GROUP_START-1},
-	{"vid",LOGO_DEV_VID,		PARA_FIRST_GROUP_START+1,	PARA_FIRST_GROUP_START+3,	PARA_FIRST_GROUP_START,	PARA_SECOND_GROUP_START-1},  // 3
-	{"mem",LOGO_DEV_MEM,	PARA_FIRST_GROUP_START+2,	PARA_FIRST_GROUP_START+4,	PARA_FIRST_GROUP_START,	PARA_SECOND_GROUP_START-1},
-//vmode
-	{"480i",VMODE_480I,		PARA_SECOND_GROUP_START-1,	PARA_SECOND_GROUP_START+1,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"480cvbs",VMODE_480CVBS,PARA_SECOND_GROUP_START,	PARA_SECOND_GROUP_START+2,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"480p",VMODE_480P,		PARA_SECOND_GROUP_START+1,	PARA_SECOND_GROUP_START+3,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"576i",VMODE_576I,		PARA_SECOND_GROUP_START+2,	PARA_SECOND_GROUP_START+4,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"576cvbs",VMODE_576CVBS,PARA_SECOND_GROUP_START+3,	PARA_SECOND_GROUP_START+5,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"576p",VMODE_576P,		PARA_SECOND_GROUP_START+4,	PARA_SECOND_GROUP_START+6,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"720p",VMODE_720P,		PARA_SECOND_GROUP_START+5,	PARA_SECOND_GROUP_START+7,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"1080i",VMODE_1080I,		PARA_SECOND_GROUP_START+6,	PARA_SECOND_GROUP_START+8,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"1080p",VMODE_1080P,	PARA_SECOND_GROUP_START+7,	PARA_SECOND_GROUP_START+9,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"panel",VMODE_LCD,			PARA_SECOND_GROUP_START+8,	PARA_SECOND_GROUP_START+10,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"720p50hz",VMODE_720P_50HZ,			PARA_SECOND_GROUP_START+9,	PARA_SECOND_GROUP_START+11,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"1080i50hz",VMODE_1080I_50HZ,			PARA_SECOND_GROUP_START+10,	PARA_SECOND_GROUP_START+12,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"1080p50hz",VMODE_1080P_50HZ,			PARA_SECOND_GROUP_START+11,	PARA_SECOND_GROUP_START+13,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"1080p24hz", VMODE_1080P_24HZ,			PARA_SECOND_GROUP_START+12,	PARA_SECOND_GROUP_START+14, PARA_SECOND_GROUP_START,    PARA_THIRD_GROUP_START-1},
-	{"4k2k24hz",VMODE_4K2K_24HZ,			PARA_SECOND_GROUP_START+13,	PARA_SECOND_GROUP_START+15,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"4k2k25hz",VMODE_4K2K_25HZ,			PARA_SECOND_GROUP_START+14,	PARA_SECOND_GROUP_START+16,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"4k2k30hz",VMODE_4K2K_30HZ,			PARA_SECOND_GROUP_START+15,	PARA_SECOND_GROUP_START+17,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"4k2ksmpte",VMODE_4K2K_SMPTE,			PARA_SECOND_GROUP_START+16,	PARA_SECOND_GROUP_START+18,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"lvds1080p",VMODE_LVDS_1080P,			PARA_SECOND_GROUP_START+17,	PARA_SECOND_GROUP_START+19,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-	{"lvds1080p50hz",VMODE_LVDS_1080P_50HZ,			PARA_SECOND_GROUP_START+18,	PARA_SECOND_GROUP_START+20,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
-//display mode
-	{"origin",DISP_MODE_ORIGIN,	PARA_THIRD_GROUP_START-1,	PARA_THIRD_GROUP_START+1,	PARA_THIRD_GROUP_START,PARA_FOURTH_GROUP_START-1},  //15
-	{"center",DISP_MODE_CENTER,	PARA_THIRD_GROUP_START,		PARA_THIRD_GROUP_START+2,	PARA_THIRD_GROUP_START,PARA_FOURTH_GROUP_START-1},
-	{"full",DISP_MODE_FULL_SCREEN,	PARA_THIRD_GROUP_START+1,	PARA_THIRD_GROUP_START+3,	PARA_THIRD_GROUP_START,PARA_FOURTH_GROUP_START-1},
-//dbg
-	{"dbg",LOGO_DBG_ENABLE,	PARA_FOURTH_GROUP_START-1,	PARA_FOURTH_GROUP_START+1,	PARA_FOURTH_GROUP_START,PARA_FIFTH_GROUP_START-1},  //18
-//progress	
-	{"progress",LOGO_PROGRESS_ENABLE,PARA_FIFTH_GROUP_START-1,PARA_FIFTH_GROUP_START+1,PARA_FIFTH_GROUP_START,PARA_SIXTH_GROUP_START-1},
-//loaded
-	{"loaded",LOGO_LOADED,PARA_SIXTH_GROUP_START-1,PARA_SIXTH_GROUP_START+1,PARA_SIXTH_GROUP_START,PARA_END},
-
-//tail	
-	{"tail",INVALID_INFO,PARA_END,0,0,PARA_END+1},
-	};
-
-	static u32 tail=PARA_END+1;
-	u32 first=para_info_pair[0].next_idx ; 
-	u32 i,addr;
-	
-	for(i=first;i<tail;i=para_info_pair[i].next_idx)
-	{
-		if(strcmp(para_info_pair[i].name,para)==0)
-		{
-			u32 group_start=para_info_pair[i].cur_group_start ;
-			u32 group_end=para_info_pair[i].cur_group_end;
-			u32	prev=para_info_pair[group_start].prev_idx;
-			u32  next=para_info_pair[group_end].next_idx;
-			amlog_level(LOG_LEVEL_MAX,"%s:%d\n",para_info_pair[i].name,para_info_pair[i].info);
-			switch(para_info_pair[i].cur_group_start)
-			{
-				case PARA_FIRST_GROUP_START:
-				plogo->para.output_dev_type=(platform_dev_t)para_info_pair[i].info;
-				break;
-				case PARA_SECOND_GROUP_START:
-				plogo->para.vout_mode=(vmode_t)para_info_pair[i].info;
-				break;
-				case PARA_THIRD_GROUP_START:
-				plogo->para.dis_mode=(logo_display_mode_t)para_info_pair[i].info;
-				break;
-				case PARA_FOURTH_GROUP_START:
-				amlog_level(LOG_LEVEL_MAX,"select debug mode\n");	
-				amlog_level_logo=AMLOG_DEFAULT_LEVEL;
-				amlog_mask_logo=AMLOG_DEFAULT_MASK;
-				break;
-				case PARA_FIFTH_GROUP_START:
-				plogo->para.progress=1;
-				break;	
-				case PARA_SIXTH_GROUP_START:
-				plogo->para.loaded=1;
-				amlog_level(LOG_LEVEL_MAX,"logo has been loaded\n");
-				break;	
-			}
-			para_info_pair[prev].next_idx=next;
-			para_info_pair[next].prev_idx=prev;
-			return 0;
-		}//addr we will deal with it specially. 
-	}
-	addr=simple_strtoul(para, NULL,16);
-	//addr we will deal with it specially. 
-	if(addr >=PHYS_OFFSET)
-	{
-		plogo->para.mem_addr=(char*)phys_to_virt(addr);
-		amlog_mask_level(LOG_MASK_LOADER,LOG_LEVEL_LOW,"mem_addr:0x%p\n",plogo->para.mem_addr);
-	}
-	return 0;
-}
-logo_object_t*	 get_current_logo_obj(void)
-{
-	if((aml_logo.dev ==NULL || aml_logo.parser ==NULL)&&!aml_logo.para.loaded)
-	{
-		return NULL;
-	}
+/*******************************************************************
+ *
+ *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *		this file will parse all parameters offered by loader.
+ *
+ *  Author: Amlogic Software
+ *  Created: 2010/8/23   19:46
+ *
+ *******************************************************************/
+ #include	"loader.h"
+ #include	"amlogo_log.h"
+ #include <linux/amlogic/amlog.h>
+
+/******************************************************************
+**																   **
+**	sample para for bootargs=> logo=osd1,0x84100000,full,720p,dbg,progress  **
+**																   **
+*******************************************************************/
+/******************logo entry point ***************/
+
+MODULE_AMLOG(LOG_LEVEL_MAX-1, LOG_MASK_ALL, LOG_LEVEL_DESC, LOG_MASK_DESC);
+logo_object_t  aml_logo={
+	.name="default",
+	.dev=NULL,
+	.parser=NULL,
+} ;
+
+static inline  int str2lower(char *str)
+{
+	while(*str != '\0')
+	{
+		*str= TOLOWER(*str);
+		str++;
+	}
+	return 0;
+}
+
+static inline int install_logo_info(logo_object_t *plogo,char *para)
+{
+	static  para_info_pair_t para_info_pair[PARA_END+2]={
+//head
+	{"head",INVALID_INFO,		PARA_END+1,		1,	0,	PARA_END+1},
+
+//dev
+	{"osd0",LOGO_DEV_OSD0,	PARA_FIRST_GROUP_START-1,	PARA_FIRST_GROUP_START+1,	PARA_FIRST_GROUP_START,	PARA_SECOND_GROUP_START-1},
+	{"osd1",LOGO_DEV_OSD1,	PARA_FIRST_GROUP_START,		PARA_FIRST_GROUP_START+2,	PARA_FIRST_GROUP_START,	PARA_SECOND_GROUP_START-1},
+	{"vid",LOGO_DEV_VID,		PARA_FIRST_GROUP_START+1,	PARA_FIRST_GROUP_START+3,	PARA_FIRST_GROUP_START,	PARA_SECOND_GROUP_START-1},  // 3
+	{"mem",LOGO_DEV_MEM,	PARA_FIRST_GROUP_START+2,	PARA_FIRST_GROUP_START+4,	PARA_FIRST_GROUP_START,	PARA_SECOND_GROUP_START-1},
+//vmode
+	{"480i",VMODE_480I,		PARA_SECOND_GROUP_START-1,	PARA_SECOND_GROUP_START+1,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"480cvbs",VMODE_480CVBS,PARA_SECOND_GROUP_START,	PARA_SECOND_GROUP_START+2,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"480p",VMODE_480P,		PARA_SECOND_GROUP_START+1,	PARA_SECOND_GROUP_START+3,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"576i",VMODE_576I,		PARA_SECOND_GROUP_START+2,	PARA_SECOND_GROUP_START+4,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"576cvbs",VMODE_576CVBS,PARA_SECOND_GROUP_START+3,	PARA_SECOND_GROUP_START+5,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"576p",VMODE_576P,		PARA_SECOND_GROUP_START+4,	PARA_SECOND_GROUP_START+6,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"720p",VMODE_720P,		PARA_SECOND_GROUP_START+5,	PARA_SECOND_GROUP_START+7,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"1080i",VMODE_1080I,		PARA_SECOND_GROUP_START+6,	PARA_SECOND_GROUP_START+8,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"1080p",VMODE_1080P,	PARA_SECOND_GROUP_START+7,	PARA_SECOND_GROUP_START+9,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"panel",VMODE_LCD,			PARA_SECOND_GROUP_START+8,	PARA_SECOND_GROUP_START+10,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"720p50hz",VMODE_720P_50HZ,			PARA_SECOND_GROUP_START+9,	PARA_SECOND_GROUP_START+11,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"1080i50hz",VMODE_1080I_50HZ,			PARA_SECOND_GROUP_START+10,	PARA_SECOND_GROUP_START+12,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"1080p50hz",VMODE_1080P_50HZ,			PARA_SECOND_GROUP_START+11,	PARA_SECOND_GROUP_START+13,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"1080p24hz", VMODE_1080P_24HZ,			PARA_SECOND_GROUP_START+12,	PARA_SECOND_GROUP_START+14, PARA_SECOND_GROUP_START,    PARA_THIRD_GROUP_START-1},
+	{"4k2k24hz",VMODE_4K2K_24HZ,			PARA_SECOND_GROUP_START+13,	PARA_SECOND_GROUP_START+15,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"4k2k25hz",VMODE_4K2K_25HZ,			PARA_SECOND_GROUP_START+14,	PARA_SECOND_GROUP_START+16,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"4k2k30hz",VMODE_4K2K_30HZ,			PARA_SECOND_GROUP_START+15,	PARA_SECOND_GROUP_START+17,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"4k2k60hz",VMODE_4K2K_60HZ,	        PARA_SECOND_GROUP_START+16,	PARA_SECOND_GROUP_START+18,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"4k2k60hz420",VMODE_4K2K_60HZ_Y420,	PARA_SECOND_GROUP_START+17,	PARA_SECOND_GROUP_START+19,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"4k2k5g",VMODE_4K2K_5G,	            PARA_SECOND_GROUP_START+18,	PARA_SECOND_GROUP_START+20,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"4k2k50hz420",VMODE_4K2K_50HZ_Y420,	            PARA_SECOND_GROUP_START+19,	PARA_SECOND_GROUP_START+21,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"4k2ksmpte",VMODE_4K2K_SMPTE,			PARA_SECOND_GROUP_START+20,	PARA_SECOND_GROUP_START+22,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"lvds1080p",VMODE_LVDS_1080P,			PARA_SECOND_GROUP_START+21,	PARA_SECOND_GROUP_START+23,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+	{"lvds1080p50hz",VMODE_LVDS_1080P_50HZ, PARA_SECOND_GROUP_START+22,	PARA_SECOND_GROUP_START+24,	PARA_SECOND_GROUP_START,	PARA_THIRD_GROUP_START-1},
+//display mode
+	{"origin",DISP_MODE_ORIGIN,	PARA_THIRD_GROUP_START-1,	PARA_THIRD_GROUP_START+1,	PARA_THIRD_GROUP_START,PARA_FOURTH_GROUP_START-1},  //15
+	{"center",DISP_MODE_CENTER,	PARA_THIRD_GROUP_START,		PARA_THIRD_GROUP_START+2,	PARA_THIRD_GROUP_START,PARA_FOURTH_GROUP_START-1},
+	{"full",DISP_MODE_FULL_SCREEN,	PARA_THIRD_GROUP_START+1,	PARA_THIRD_GROUP_START+3,	PARA_THIRD_GROUP_START,PARA_FOURTH_GROUP_START-1},
+//dbg
+	{"dbg",LOGO_DBG_ENABLE,	PARA_FOURTH_GROUP_START-1,	PARA_FOURTH_GROUP_START+1,	PARA_FOURTH_GROUP_START,PARA_FIFTH_GROUP_START-1},  //18
+//progress
+	{"progress",LOGO_PROGRESS_ENABLE,PARA_FIFTH_GROUP_START-1,PARA_FIFTH_GROUP_START+1,PARA_FIFTH_GROUP_START,PARA_SIXTH_GROUP_START-1},
+//loaded
+	{"loaded",LOGO_LOADED,PARA_SIXTH_GROUP_START-1,PARA_SIXTH_GROUP_START+1,PARA_SIXTH_GROUP_START,PARA_END},
+
+//tail
+	{"tail",INVALID_INFO,PARA_END,0,0,PARA_END+1},
+	};
+
+	static u32 tail=PARA_END+1;
+	u32 first=para_info_pair[0].next_idx ;
+	u32 i,addr;
+
+	for(i=first;i<tail;i=para_info_pair[i].next_idx)
+	{
+		if(strcmp(para_info_pair[i].name,para)==0)
+		{
+			u32 group_start=para_info_pair[i].cur_group_start ;
+			u32 group_end=para_info_pair[i].cur_group_end;
+			u32	prev=para_info_pair[group_start].prev_idx;
+			u32  next=para_info_pair[group_end].next_idx;
+			amlog_level(LOG_LEVEL_MAX,"%s:%d\n",para_info_pair[i].name,para_info_pair[i].info);
+			switch(para_info_pair[i].cur_group_start)
+			{
+				case PARA_FIRST_GROUP_START:
+				plogo->para.output_dev_type=(platform_dev_t)para_info_pair[i].info;
+				break;
+				case PARA_SECOND_GROUP_START:
+				plogo->para.vout_mode=(vmode_t)para_info_pair[i].info;
+				break;
+				case PARA_THIRD_GROUP_START:
+				plogo->para.dis_mode=(logo_display_mode_t)para_info_pair[i].info;
+				break;
+				case PARA_FOURTH_GROUP_START:
+				amlog_level(LOG_LEVEL_MAX,"select debug mode\n");
+				amlog_level_logo=AMLOG_DEFAULT_LEVEL;
+				amlog_mask_logo=AMLOG_DEFAULT_MASK;
+				break;
+				case PARA_FIFTH_GROUP_START:
+				plogo->para.progress=1;
+				break;
+				case PARA_SIXTH_GROUP_START:
+				plogo->para.loaded=1;
+				amlog_level(LOG_LEVEL_MAX,"logo has been loaded\n");
+				break;
+			}
+			para_info_pair[prev].next_idx=next;
+			para_info_pair[next].prev_idx=prev;
+			return 0;
+		}//addr we will deal with it specially.
+	}
+	addr=simple_strtoul(para, NULL,16);
+	//addr we will deal with it specially.
+	if(addr >=PHYS_OFFSET)
+	{
+		plogo->para.mem_addr=(char*)phys_to_virt(addr);
+		amlog_mask_level(LOG_MASK_LOADER,LOG_LEVEL_LOW,"mem_addr:0x%p\n",plogo->para.mem_addr);
+	}
+	return 0;
+}
+logo_object_t*	 get_current_logo_obj(void)
+{
+	if((aml_logo.dev ==NULL || aml_logo.parser ==NULL)&&!aml_logo.para.loaded)
+	{
+		return NULL;
+	}
 	if ( aml_logo.dev != NULL &&  aml_logo.dev->output_dev.osd.color_depth == 0)
         aml_logo.dev->output_dev.osd.color_depth=32;
-	return &aml_logo;
-}
-
-vmode_t get_resolution_vmode(void)
-{
-	logo_object_t *plogo=&aml_logo;
-
-	if (plogo != NULL)
-		return plogo->para.vout_mode;
-	else
-		return VMODE_1080P;
-}
-
-vmode_set_t get_current_mode_state(void)
-{
-	if(aml_logo.dev == NULL)
-	{
-		return VMODE_NOT_SETTED;
-	}else{
-		return VMODE_SETTED;
-	}
-}
-
-int  __init  logo_setup(char *str)
+	return &aml_logo;
+}
+
+vmode_t get_resolution_vmode(void)
 {
-
-	char	     *ptr=str;
-	char 	       sep[2];
-	char      *option;
-	int     	count=6;
-	char	   	find=0;
-	logo_object_t	*plogo;
-
-
-	if(NULL==str)
-	{
-		return -EINVAL;
-	}
-	plogo=&aml_logo;
-	memset(plogo,0,sizeof(logo_object_t));
-	sprintf(plogo->name,LOGO_NAME);
-	
-	do
+    logo_object_t *plogo=&aml_logo;
+
+	if (plogo != NULL)
+		return plogo->para.vout_mode;
+	else
+		return VMODE_1080P;
+}
+
+vmode_set_t get_current_mode_state(void)
+{
+	if(aml_logo.dev == NULL)
+	{
+		return VMODE_NOT_SETTED;
+	}else{
+		return VMODE_SETTED;
+	}
+}
+
+int  __init  logo_setup(char *str)
+{
+
+	char	     *ptr=str;
+	char 	       sep[2];
+	char      *option;
+	int     	count=6;
+	char	   	find=0;
+	logo_object_t	*plogo;
+
+
+	if(NULL==str)
+	{
+		return -EINVAL;
+	}
+	plogo=&aml_logo;
+	memset(plogo,0,sizeof(logo_object_t));
+	sprintf(plogo->name,LOGO_NAME);
+
+	do
 	{
 		if(!isalpha(*ptr)&&!isdigit(*ptr))
 		{
 			find=1;
 			break;
 		}
-	}while(*++ptr != '\0');
-	if(!find) return -EINVAL;
+	}while(*++ptr != '\0');
+	if(!find) return -EINVAL;
 	sep[0]=*ptr;
-	sep[1]='\0' ;
-	while((count--) && (option=strsep(&str,sep)))
-	{
-		str2lower(option);
-		install_logo_info(plogo,option); //all has been parsed.
-	}
-	return 0;
+	sep[1]='\0' ;
+	while((count--) && (option=strsep(&str,sep)))
+	{
+		str2lower(option);
+		install_logo_info(plogo,option); //all has been parsed.
+	}
+	return 0;
 }
-
-
-__setup("logo=",logo_setup) ;
+
+
+__setup("logo=",logo_setup) ;
diff --git a/drivers/amlogic/display/aml_logo/logo_display/dev_ge2d.c b/drivers/amlogic/display/aml_logo/logo_display/dev_ge2d.c
old mode 100644
new mode 100755
index ef68ee2b..60091cf8
--- a/drivers/amlogic/display/aml_logo/logo_display/dev_ge2d.c
+++ b/drivers/amlogic/display/aml_logo/logo_display/dev_ge2d.c
@@ -1,112 +1,111 @@
-/*******************************************************************
- **
- ** Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- **
- **  Description:
- **		this file decode logo data according to it's type.
- **
- **  Author: Amlogic Software
- **  Created: 10/08/23
- **
- *******************************************************************
- **
- ** function :we will not use interrupt mode ,and ge2d device only process one cmd here.
- **
- *******************************************************************/
- #include "logo.h"
- #include "dev_ge2d.h"
- #include	"amlogo_log.h"
- #include <linux/amlogic/amlog.h>
-ge2d_context_t*	dev_ge2d_setup(void* para)
-{
-	config_para_t  *config=(config_para_t*)para;
-	static ge2d_context_t  context;	
-
-	if(NULL==config) return NULL;
-
-	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"current ge2d type:%d\n",config->src_dst_type);	
-	if(0==ge2d_context_config(&context,config))
-	{
-		return &context;
-	}else{
-		return NULL;
-	}
-	
-}
-int	dev_ge2d_cmd(ge2d_context_t *context ,int  cmd,src_dst_info_t  *info)
-{
-	ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(context);
-	ge2d_config_t	*cfg=&context->config;
-	rectangle_t *src=&info->src_rect,*dst=&info->dst_rect;
-	unsigned int color=info->color;
-
-	ge2d_cmd_cfg->sc_hsc_en = 0;
-	ge2d_cmd_cfg->sc_vsc_en = 0;
-	ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
-	ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
-	ge2d_cmd_cfg->hsc_div_en = 0; 
-	switch (cmd)
-	{	
-		case	CMD_FILLRECT:
-		cfg->src1_data.def_color=color;
-		ge2d_cmd_cfg->dst_x_start  = dst->x;
-    		ge2d_cmd_cfg->dst_x_end    = dst->x+dst->w-1;
-    		ge2d_cmd_cfg->dst_y_start  = dst->y;
-    		ge2d_cmd_cfg->dst_y_end    = dst->y+dst->h-1;
-
-		ge2d_cmd_cfg->src1_x_start  = ge2d_cmd_cfg->dst_x_start;
-    		ge2d_cmd_cfg->src1_x_end    = ge2d_cmd_cfg->dst_x_end ;
-    		ge2d_cmd_cfg->src1_y_start= ge2d_cmd_cfg->dst_y_start ;
-    		ge2d_cmd_cfg->src1_y_end= ge2d_cmd_cfg->dst_y_end;
-
-    		ge2d_cmd_cfg->src1_fill_color_en = 1;
-		break;
-		case	CMD_BITBLT:
-		ge2d_cmd_cfg->src1_x_start = src->x;
-    		ge2d_cmd_cfg->src1_x_end   = src->x+src->w-1;
-    		ge2d_cmd_cfg->src1_y_start = src->y;
-    		ge2d_cmd_cfg->src1_y_end   = src->y+src->h-1;
-
-    		ge2d_cmd_cfg->dst_x_start = dst->x;
-    		ge2d_cmd_cfg->dst_x_end   = dst->x+src->w-1;
-    		ge2d_cmd_cfg->dst_y_start = dst->y;
-    		ge2d_cmd_cfg->dst_y_end   = dst->y+src->h-1;
-		
-		break;
-		case	CMD_STRETCH_BLIT:
-              ge2d_cmd_cfg->src1_x_start = src->x;
-              ge2d_cmd_cfg->src1_x_end   = src->x+src->w-1;
-              ge2d_cmd_cfg->src1_y_start = src->y;
-              ge2d_cmd_cfg->src1_y_end   = src->y+src->h-1;
-          
-              ge2d_cmd_cfg->dst_x_start  = dst->x;
-              ge2d_cmd_cfg->dst_x_end    = dst->x+dst->w-1;
-              ge2d_cmd_cfg->dst_y_start  = dst->y;
-              ge2d_cmd_cfg->dst_y_end    = dst->y+dst->h-1;
-          
-              ge2d_cmd_cfg->sc_hsc_en = 1;
-              ge2d_cmd_cfg->sc_vsc_en = 1;
-              ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
-              ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
-              ge2d_cmd_cfg->hsc_div_en = 1; 
-                     
-
-    		break;	
-	}
-	ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
-    	ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;  
-    	ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
-    	ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_COPY; 
-	ge2d_set_src1_data(&cfg->src1_data);
-	ge2d_set_src1_gen(&cfg->src1_gen);
-	ge2d_set_src2_dst_data(&cfg->src2_dst_data);	
-	ge2d_set_src2_dst_gen(&cfg->src2_dst_gen);
-	ge2d_set_dp_gen(&cfg->dp_gen);
-	ge2d_set_src1_scale_coef(FILTER_TYPE_TRIANGLE, FILTER_TYPE_TRIANGLE);
-		
-	ge2d_set_cmd(ge2d_cmd_cfg);
-	ge2d_wait_done();
-	memset(ge2d_cmd_cfg,0,sizeof(ge2d_cmd_t));
-	return 0;
-}
-	
\ No newline at end of file
+/*******************************************************************
+ **
+ ** Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
+ **
+ **  Description:
+ **		this file decode logo data according to it's type.
+ **
+ **  Author: Amlogic Software
+ **  Created: 10/08/23
+ **
+ *******************************************************************
+ **
+ ** function :we will not use interrupt mode ,and ge2d device only process one cmd here.
+ **
+ *******************************************************************/
+ #include "logo.h"
+ #include "dev_ge2d.h"
+ #include	"amlogo_log.h"
+ #include <linux/amlogic/amlog.h>
+ge2d_context_t*	dev_ge2d_setup(void* para)
+{
+	config_para_t  *config=(config_para_t*)para;
+	static ge2d_context_t  context;
+
+	if(NULL==config) return NULL;
+
+	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"current ge2d type:%d\n",config->src_dst_type);
+	if(0==ge2d_context_config(&context,config))
+	{
+		return &context;
+	}else{
+		return NULL;
+	}
+
+}
+int	dev_ge2d_cmd(ge2d_context_t *context ,int  cmd,src_dst_info_t  *info)
+{
+	ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(context);
+	ge2d_config_t	*cfg=&context->config;
+	rectangle_t *src=&info->src_rect,*dst=&info->dst_rect;
+	unsigned int color=info->color;
+
+	ge2d_cmd_cfg->sc_hsc_en = 0;
+	ge2d_cmd_cfg->sc_vsc_en = 0;
+	ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+	ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+	ge2d_cmd_cfg->hsc_div_en = 0;
+	switch (cmd)
+	{
+		case	CMD_FILLRECT:
+		cfg->src1_data.def_color=color;
+		ge2d_cmd_cfg->dst_x_start  = dst->x;
+		ge2d_cmd_cfg->dst_x_end    = dst->x+dst->w-1;
+		ge2d_cmd_cfg->dst_y_start  = dst->y;
+		ge2d_cmd_cfg->dst_y_end    = dst->y+dst->h-1;
+
+		ge2d_cmd_cfg->src1_x_start  = ge2d_cmd_cfg->dst_x_start;
+		ge2d_cmd_cfg->src1_x_end    = ge2d_cmd_cfg->dst_x_end ;
+		ge2d_cmd_cfg->src1_y_start= ge2d_cmd_cfg->dst_y_start ;
+		ge2d_cmd_cfg->src1_y_end= ge2d_cmd_cfg->dst_y_end;
+
+		ge2d_cmd_cfg->src1_fill_color_en = 1;
+		break;
+		case	CMD_BITBLT:
+		ge2d_cmd_cfg->src1_x_start = src->x;
+		ge2d_cmd_cfg->src1_x_end   = src->x+src->w-1;
+		ge2d_cmd_cfg->src1_y_start = src->y;
+		ge2d_cmd_cfg->src1_y_end   = src->y+src->h-1;
+
+		ge2d_cmd_cfg->dst_x_start = dst->x;
+		ge2d_cmd_cfg->dst_x_end   = dst->x+src->w-1;
+		ge2d_cmd_cfg->dst_y_start = dst->y;
+		ge2d_cmd_cfg->dst_y_end   = dst->y+src->h-1;
+
+		break;
+		case	CMD_STRETCH_BLIT:
+              ge2d_cmd_cfg->src1_x_start = src->x;
+              ge2d_cmd_cfg->src1_x_end   = src->x+src->w-1;
+              ge2d_cmd_cfg->src1_y_start = src->y;
+              ge2d_cmd_cfg->src1_y_end   = src->y+src->h-1;
+
+              ge2d_cmd_cfg->dst_x_start  = dst->x;
+              ge2d_cmd_cfg->dst_x_end    = dst->x+dst->w-1;
+              ge2d_cmd_cfg->dst_y_start  = dst->y;
+              ge2d_cmd_cfg->dst_y_end    = dst->y+dst->h-1;
+
+              ge2d_cmd_cfg->sc_hsc_en = 1;
+              ge2d_cmd_cfg->sc_vsc_en = 1;
+              ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+              ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+              ge2d_cmd_cfg->hsc_div_en = 1;
+
+
+		break;
+	}
+	ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;
+	ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+	ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_COPY;
+	ge2d_set_src1_data(&cfg->src1_data);
+	ge2d_set_src1_gen(&cfg->src1_gen);
+	ge2d_set_src2_dst_data(&cfg->src2_dst_data);
+	ge2d_set_src2_dst_gen(&cfg->src2_dst_gen);
+	ge2d_set_dp_gen(&cfg->dp_gen);
+	ge2d_set_src1_scale_coef(FILTER_TYPE_TRIANGLE, FILTER_TYPE_TRIANGLE);
+
+	ge2d_set_cmd(ge2d_cmd_cfg);
+	ge2d_wait_done();
+	memset(ge2d_cmd_cfg,0,sizeof(ge2d_cmd_t));
+	return 0;
+}
diff --git a/drivers/amlogic/display/aml_logo/logo_display/logo_output.c b/drivers/amlogic/display/aml_logo/logo_display/logo_output.c
old mode 100644
new mode 100755
index bf16219a..60374fe4
--- a/drivers/amlogic/display/aml_logo/logo_display/logo_output.c
+++ b/drivers/amlogic/display/aml_logo/logo_display/logo_output.c
@@ -1,126 +1,126 @@
-/*******************************************************************
- *
- *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- *
- *  Description:
- *		this file decode logo data according to it's type.
- *
- *  Author: Amlogic Software
- *  Created: 
- *
- *******************************************************************/
-#include  "logo.h"
-#include	"amlogo_log.h"
-#include <linux/amlogic/amlog.h>
+/*******************************************************************
+ *
+ *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *		this file decode logo data according to it's type.
+ *
+ *  Author: Amlogic Software
+ *  Created:
+ *
+ *******************************************************************/
+#include  "logo.h"
+#include	"amlogo_log.h"
+#include <linux/amlogic/amlog.h>
 #include <linux/of.h>
-#include <linux/of_fdt.h>
-static  LIST_HEAD(output_dev_line);
-static  output_dev_list_t aml_output_dev[LOGO_DEV_MAX];
-
- int match_device_name(struct device *dev, void *data)
-{
-#define DEVICE_NAME_LEN		7
+#include <linux/of_fdt.h>
+static  LIST_HEAD(output_dev_line);
+static  output_dev_list_t aml_output_dev[LOGO_DEV_MAX];
+
+ int match_device_name(struct device *dev, void *data)
+{
+#define DEVICE_NAME_LEN		7
 	const char *name = data;
 
-	if (strncmp(name, dev_name(dev),DEVICE_NAME_LEN) == 0)
+	if (strncmp(name, dev_name(dev),DEVICE_NAME_LEN) == 0)
 		return 1;
 	return 0;
-}
- static struct resource memobj;
- int   setup_logo_platform_resource(logo_object_t *logo)
-{
-	int  i;
-	const char  *device_name[3]={"mesonfb0","mesonfb1","amstream"};
-	struct  device  *dev=NULL;
-	struct platform_device  * platform_dev;
-	struct resource * res; 
-	int idx;
-
-	for(i=0;i<LOGO_DEV_MEM;i++)
-	{
-		 u32  num=i%2;
-		 strcpy(logo->platform_res[i].name,device_name[i]);
-		 amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"device name:%s\n",logo->platform_res[i].name);
-		 if(1 != i) //osd1 special one
-		 dev=bus_find_device(&platform_bus_type, NULL, logo->platform_res[i].name, match_device_name) ;
-		 if(dev)
-		{
-			
-			platform_dev =dev_to_platformdev(dev) ;
-			amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"got platform resource\n");
-#if 0			
-			res=platform_get_resource(platform_dev,IORESOURCE_MEM,num);//something special.
-#else
-			res = &memobj;
-			idx = find_reserve_block(platform_dev->dev.of_node->name,num);
-			if(idx < 0){
-				amlog_mask_level(LOG_MASK_DEVICE, LOG_LEVEL_HIGH,"can not find %s %d reserve block\n",platform_dev->dev.of_node->name, num);
-				continue;
-			}
-			res->start = (phys_addr_t)get_reserve_block_addr(idx);
-			res->end = res->start+ (phys_addr_t)get_reserve_block_size(idx)-1;
-#endif
-			if(res)
-			{
-				amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"resource: start=0x%x,end=0x%x\r\n",res->start,res->end);
-				logo->platform_res[i].mem_start=res->start;
-				logo->platform_res[i].mem_end=res->end;
-			}else{
-				amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_HIGH,"can't get device resource\n");
-			}
-			
-		}
-	}
-	return SUCCESS;
-}
-int  register_logo_output_dev(logo_output_dev_t* new_dev)
-{
-	output_dev_list_t  *pitem;
-	static int count=0;
-	
-	pitem=&aml_output_dev[count++];
-	pitem->dev=new_dev;
-	list_add_tail(&pitem->list,&output_dev_line);
-	return SUCCESS;
-}
-static int  load_all_output_dev(void)
-{
-	dev_osd_setup();
-	dev_vid_setup();
-	return SUCCESS;
-}
-//entry point for this file .
-int  setup_output_device(logo_object_t *plogo)
-{
-	output_dev_list_t  *pitem;
-	int  found=0;
-	if(setup_logo_platform_resource(plogo))
-	{
-		return -ENOSPC;
-	}
-	load_all_output_dev();
-	list_for_each_entry(pitem,&output_dev_line,list){
-		if(pitem->dev->op.init(plogo)==OUTPUT_DEV_FOUND)	
-		{
-			found=1;
-			amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"output device setup OK,logo dev index:0x%d\n",plogo->dev->idx);
-			return  SUCCESS; 
-		}
-	}
-	return -OUTPUT_DEV_SETUP_FAIL;
-}
- 
-int  unregister_logo_output_dev(void)
-{
-	output_dev_list_t  *pitem,*tmp;
-
-	list_for_each_entry_safe(pitem,tmp,&output_dev_line,list){
-		if(pitem)  
-		{
-			pitem->dev->op.deinit();
-			list_del(&pitem->list );
-			kfree(pitem);
-		}
-	}
-	return SUCCESS;
-}
+}
+ static struct resource memobj;
+ int   setup_logo_platform_resource(logo_object_t *logo)
+{
+	int  i;
+	const char  *device_name[3]={"mesonfb0","mesonfb1","amstream"};
+	struct  device  *dev=NULL;
+	struct platform_device  * platform_dev;
+	struct resource * res;
+	int idx;
+
+	for(i=0;i<LOGO_DEV_MEM;i++)
+	{
+		 u32  num=i%2;
+		 strcpy(logo->platform_res[i].name,device_name[i]);
+		 amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"device name:%s\n",logo->platform_res[i].name);
+		 if(1 != i) //osd1 special one
+		 dev=bus_find_device(&platform_bus_type, NULL, logo->platform_res[i].name, match_device_name) ;
+		 if(dev)
+		{
+
+			platform_dev =dev_to_platformdev(dev) ;
+			amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"got platform resource\n");
+#if 0
+			res=platform_get_resource(platform_dev,IORESOURCE_MEM,num);//something special.
+#else
+			res = &memobj;
+			idx = find_reserve_block(platform_dev->dev.of_node->name,num);
+			if(idx < 0){
+				amlog_mask_level(LOG_MASK_DEVICE, LOG_LEVEL_HIGH,"can not find %s %d reserve block\n",platform_dev->dev.of_node->name, num);
+				continue;
+			}
+			res->start = (phys_addr_t)get_reserve_block_addr(idx);
+			res->end = res->start+ (phys_addr_t)get_reserve_block_size(idx)-1;
+#endif
+			if(res)
+			{
+				amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"resource: start=0x%x,end=0x%x\n",res->start,res->end);
+				logo->platform_res[i].mem_start=res->start;
+				logo->platform_res[i].mem_end=res->end;
+			}else{
+				amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_HIGH,"can't get device resource\n");
+			}
+
+		}
+	}
+	return SUCCESS;
+}
+int  register_logo_output_dev(logo_output_dev_t* new_dev)
+{
+	output_dev_list_t  *pitem;
+	static int count=0;
+
+	pitem=&aml_output_dev[count++];
+	pitem->dev=new_dev;
+	list_add_tail(&pitem->list,&output_dev_line);
+	return SUCCESS;
+}
+static int  load_all_output_dev(void)
+{
+	dev_osd_setup();
+	dev_vid_setup();
+	return SUCCESS;
+}
+//entry point for this file .
+int  setup_output_device(logo_object_t *plogo)
+{
+	output_dev_list_t  *pitem;
+	int  found=0;
+	if(setup_logo_platform_resource(plogo))
+	{
+		return -ENOSPC;
+	}
+	load_all_output_dev();
+	list_for_each_entry(pitem,&output_dev_line,list){
+		if(pitem->dev->op.init(plogo)==OUTPUT_DEV_FOUND)
+		{
+			found=1;
+			amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"output device setup OK,logo dev index:0x%d\n",plogo->dev->idx);
+			return  SUCCESS;
+		}
+	}
+	return -OUTPUT_DEV_SETUP_FAIL;
+}
+
+int  unregister_logo_output_dev(void)
+{
+	output_dev_list_t  *pitem,*tmp;
+
+	list_for_each_entry_safe(pitem,tmp,&output_dev_line,list){
+		if(pitem)
+		{
+			pitem->dev->op.deinit();
+			list_del(&pitem->list );
+			kfree(pitem);
+		}
+	}
+	return SUCCESS;
+}
diff --git a/drivers/amlogic/display/aml_logo/logo_display/output_dev_osd.c b/drivers/amlogic/display/aml_logo/logo_display/output_dev_osd.c
old mode 100644
new mode 100755
index c339468b..39883fed
--- a/drivers/amlogic/display/aml_logo/logo_display/output_dev_osd.c
+++ b/drivers/amlogic/display/aml_logo/logo_display/output_dev_osd.c
@@ -1,578 +1,617 @@
-//we will need ge2d device to transfer logo data ,
-//so will also startup ge2d hardware.
-#include "logo.h"
-#include "logo_dev_osd.h"
-#include "dev_ge2d.h"
-#include <linux/wait.h>
-#include	"amlogo_log.h" 
-#include <linux/amlogic/amlog.h>
-#include <linux/amlogic/vout/vinfo.h>
-#include <linux/amlogic/vout/vout_notify.h>
-
-static int osd0_init(logo_object_t *plogo);
-static int osd1_init(logo_object_t *plogo);
-static int osd_enable_set(int  enable);
-static int osd_deinit(void);
-static int osd_transfer(logo_object_t *plogo);
-
-static  logo_output_dev_t   output_osd0={
-	.idx=LOGO_DEV_OSD0,
-	.hw_initialized=0,	
-	.op={
-		.init=osd0_init,
-		.transfer=osd_transfer,
-		.enable=osd_enable_set,
-		.deinit=osd_deinit,
-		},
-};
-static  logo_output_dev_t   output_osd1={
-	.idx=LOGO_DEV_OSD1,
-	.hw_initialized=0,		
-	.op={
-		.init=osd1_init,
-		.transfer=osd_transfer,
-		.enable=osd_enable_set,
-		.deinit=osd_deinit,
-		},
-};
-
-#ifdef CONFIG_AM_HDMI_ONLY
-static  hdmi_only_info_t hdmi_only_info[PARA_HDMI_ONLY]={
-	{"480x320p60hz", VMODE_480X320P_60HZ},
-	{"480x272p60hz", VMODE_480X272P_60HZ},
-	{"480i",VMODE_480I},
-	{"480p",VMODE_480P},
-	{"576i",VMODE_576I},
-	{"576p",VMODE_576P},
-	{"720p",VMODE_720P},
-	{"800p",VMODE_800P},
-	{"vga",VMODE_VGA},
-	{"sxga", VMODE_SXGA},
-	{"xga",VMODE_XGA},
-	{"800x480p60hz", VMODE_800X480P_60HZ},
-	{"480x800p60hz", VMODE_480X800P_60HZ},
-	{"1366x768p60hz", VMODE_1366X768P_60HZ},
-	{"1600x900p60hz", VMODE_1600X900P_60HZ},
-	{"800x600p60hz", VMODE_800X600P_60HZ},
-	{"1024x600p60hz", VMODE_1024X600P_60HZ},
-	{"1024x768p60hz", VMODE_1024X768P_60HZ},
-	{"1360x768p60hz", VMODE_1360X768P_60HZ},
-	{"1440x900p60hz", VMODE_1440X900P_60HZ},
-	{"1680x1050p60hz", VMODE_1680X1050P_60HZ},
-	{"1920x1200", VMODE_1920x1200},
-	{"1080i",VMODE_1080I},
-	{"1080p",VMODE_1080P},
-	{"720p50hz",VMODE_720P_50HZ},
-	{"1080i50hz",VMODE_1080I_50HZ},
-	{"1080p50hz",VMODE_1080P_50HZ},
-	{"1080p24hz", VMODE_1080P_24HZ},
-	{"4k2k24hz",VMODE_4K2K_24HZ},
-	{"4k2k25hz",VMODE_4K2K_25HZ},
-	{"4k2k30hz",VMODE_4K2K_30HZ},
-	{"4k2ksmpte",VMODE_4K2K_SMPTE},
-};
-
-static vmode_t hdmimode_hdmionly = VMODE_1080P;
-#endif
-
-static vmode_t cvbsmode_hdmionly = VMODE_480CVBS;
-
-static  inline void  setup_color_mode(const color_bit_define_t *color,u32  reg)
-{
-	u32  data32;
-
-	data32 = aml_read_reg32(reg)&(~(0xf<<8));
-	data32 |=  color->hw_blkmode<< 8; /* osd_blk_mode */
-	aml_write_reg32(reg, data32);
-}
-static inline u32 get_curr_color_depth(u32 reg)
-{
-	u32  data32=0;
-
-	data32 =(aml_read_reg32(reg)>>8)&0xf;
-	switch(data32)
-	{
-		case 4:
-		data32=16;
-		break;
-		case 7:
-		data32=24;
-		break;
-		case 5:
-		data32=32;
-		break;
-	}
-	return data32;
-}
-static int osd_hw_setup(logo_object_t *plogo)
-{
-	struct osd_ctl_s  osd_ctl;
-	const color_bit_define_t  *color;
-
-	osd_ctl.addr=plogo->dev->output_dev.osd.mem_start;
-	osd_ctl.index=plogo->dev->idx;
-	plogo->dev->output_dev.osd.color_depth=plogo->parser->logo_pic_info.color_info;
-	color=&default_color_format_array[plogo->dev->output_dev.osd.color_depth];
-	
-	osd_ctl.xres=plogo->dev->vinfo->width ;					//logo pic.	
-	osd_ctl.yres=plogo->dev->vinfo->height;
-	osd_ctl.xres_virtual=plogo->dev->vinfo->width ;
-	osd_ctl.yres_virtual=plogo->dev->vinfo->height<<1;
-	osd_ctl.disp_start_x=0;
-	osd_ctl.disp_end_x=osd_ctl.xres -1;
-	osd_ctl.disp_start_y=0;
-	osd_ctl.disp_end_y=osd_ctl.yres-1;
-	osd_init_hw(0);
-	setup_color_mode(color,osd_ctl.index==0?P_VIU_OSD1_BLK0_CFG_W0:P_VIU_OSD2_BLK0_CFG_W0);
-	if(!plogo->para.loaded)
-	{
-	    if(plogo->dev->idx == LOGO_DEV_OSD0){
-	        aml_set_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
-	    }else if(plogo->dev->idx == LOGO_DEV_OSD1){
-	        aml_set_reg32_mask(P_VPP_MISC,VPP_OSD2_POSTBLEND);
-	    }
-	}
-	osd_setup(&osd_ctl, \
+//we will need ge2d device to transfer logo data ,
+//so will also startup ge2d hardware.
+#include "logo.h"
+#include "logo_dev_osd.h"
+#include "dev_ge2d.h"
+#include <linux/wait.h>
+#include	"amlogo_log.h"
+#include <linux/amlogic/amlog.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
+
+static int osd0_init(logo_object_t *plogo);
+static int osd1_init(logo_object_t *plogo);
+static int osd_enable_set(int  enable);
+static int osd_deinit(void);
+static int osd_transfer(logo_object_t *plogo);
+
+static  logo_output_dev_t   output_osd0={
+	.idx=LOGO_DEV_OSD0,
+	.hw_initialized=0,
+	.op={
+		.init=osd0_init,
+		.transfer=osd_transfer,
+		.enable=osd_enable_set,
+		.deinit=osd_deinit,
+		},
+};
+static  logo_output_dev_t   output_osd1={
+	.idx=LOGO_DEV_OSD1,
+	.hw_initialized=0,
+	.op={
+		.init=osd1_init,
+		.transfer=osd_transfer,
+		.enable=osd_enable_set,
+		.deinit=osd_deinit,
+		},
+};
+
+#ifdef CONFIG_AM_HDMI_ONLY
+static  hdmi_only_info_t hdmi_only_info[PARA_HDMI_ONLY]={
+	{"480i",VMODE_480I},
+	{"480p",VMODE_480P},
+	{"576i",VMODE_576I},
+	{"576p",VMODE_576P},
+	{"720p",VMODE_720P},
+	{"1080i",VMODE_1080I},
+	{"1080p",VMODE_1080P},
+	{"720p50hz",VMODE_720P_50HZ},
+	{"1080i50hz",VMODE_1080I_50HZ},
+	{"1080p50hz",VMODE_1080P_50HZ},
+	{"1080p24hz", VMODE_1080P_24HZ},
+	{"4k2k24hz",VMODE_4K2K_24HZ},
+	{"4k2k25hz",VMODE_4K2K_25HZ},
+	{"4k2k30hz",VMODE_4K2K_30HZ},
+	{"4k2ksmpte",VMODE_4K2K_SMPTE},
+};
+
+static vmode_t hdmimode_hdmionly = VMODE_1080P;
+#endif
+
+static vmode_t cvbsmode_hdmionly = VMODE_480CVBS;
+
+static  inline void  setup_color_mode(const color_bit_define_t *color,u32  reg)
+{
+	u32  data32;
+
+	data32 = aml_read_reg32(reg)&(~(0xf<<8));
+	data32 |=  color->hw_blkmode<< 8; /* osd_blk_mode */
+	aml_write_reg32(reg, data32);
+}
+static inline u32 get_curr_color_depth(u32 reg)
+{
+	u32  data32=0;
+
+	data32 =(aml_read_reg32(reg)>>8)&0xf;
+	switch(data32)
+	{
+		case 4:
+		data32=16;
+		break;
+		case 7:
+		data32=24;
+		break;
+		case 5:
+		data32=32;
+		break;
+	}
+	return data32;
+}
+static int osd_hw_setup(logo_object_t *plogo)
+{
+	struct osd_ctl_s  osd_ctl;
+	const color_bit_define_t  *color;
+
+	osd_ctl.addr=plogo->dev->output_dev.osd.mem_start;
+	osd_ctl.index=plogo->dev->idx;
+	plogo->dev->output_dev.osd.color_depth=plogo->parser->logo_pic_info.color_info;
+	color=&default_color_format_array[plogo->dev->output_dev.osd.color_depth];
+
+	osd_ctl.xres=plogo->dev->vinfo->width ;					//logo pic.
+	osd_ctl.yres=plogo->dev->vinfo->height;
+	osd_ctl.xres_virtual=plogo->dev->vinfo->width ;
+	osd_ctl.yres_virtual=plogo->dev->vinfo->height<<1;
+	osd_ctl.disp_start_x=0;
+	osd_ctl.disp_end_x=osd_ctl.xres -1;
+	osd_ctl.disp_start_y=0;
+	osd_ctl.disp_end_y=osd_ctl.yres-1;
+	osd_init_hw(0);
+	setup_color_mode(color,osd_ctl.index==0?P_VIU_OSD1_BLK0_CFG_W0:P_VIU_OSD2_BLK0_CFG_W0);
+	if(!plogo->para.loaded)
+	{
+	    if(plogo->dev->idx == LOGO_DEV_OSD0){
+	        aml_set_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
+	    }else if(plogo->dev->idx == LOGO_DEV_OSD1){
+	        aml_set_reg32_mask(P_VPP_MISC,VPP_OSD2_POSTBLEND);
+	    }
+	}
+	osd_setup(&osd_ctl, \
 					0, \
 					0, \
-					osd_ctl.xres, \
-					osd_ctl.yres, \
-					osd_ctl.xres_virtual, \
-					osd_ctl.yres_virtual, \
-					osd_ctl.disp_start_x, \
-					osd_ctl.disp_start_y, \
-					osd_ctl.disp_end_x, \
-					osd_ctl.disp_end_y, \
-					osd_ctl.addr, \
-					color, \
-					osd_ctl.index) ;
-
-	return SUCCESS;
-	
-}
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-void set_osd_freescaler(int index, logo_object_t *plogo, vmode_t new_mode) {
-    vmode_t old_mode = plogo->para.vout_mode & VMODE_MODE_BIT_MASK;
-    printk("aml_logo: outputmode changed(%d->%d), reset osd%d scaler.\n", old_mode, new_mode, index);
-    osd_free_scale_mode_hw(index, 1);
-    osd_free_scale_enable_hw(index, 0);
-    osd_set_color_mode(index, &default_color_format_array[plogo->dev->output_dev.osd.color_depth]);
-    switch(old_mode) {
-        case VMODE_480I:
-        case VMODE_480CVBS:
-        case VMODE_480P:
-        case VMODE_576I:
-        case VMODE_576CVBS:
-        case VMODE_576P:
-        case VMODE_720P:
-        case VMODE_720P_50HZ:
-            osd_set_free_scale_axis_hw(index, 0, 0, 1279, 719);
-            osddev_update_disp_axis_hw(0, 1279, 0, 719, 0, 0, 0, index);
-            break;
-        case VMODE_1080I:
-        case VMODE_1080I_50HZ:
-        case VMODE_1080P:
-        case VMODE_1080P_50HZ:
-        case VMODE_1080P_24HZ:
-        case VMODE_4K2K_24HZ:
-        case VMODE_4K2K_25HZ:
-        case VMODE_4K2K_30HZ:
-        case VMODE_4K2K_SMPTE:
-            osd_set_free_scale_axis_hw(index, 0, 0, 1919, 1079);
-            osddev_update_disp_axis_hw(0, 1919, 0, 1079, 0, 0, 0, index);
-            break;
+					osd_ctl.xres, \
+					osd_ctl.yres, \
+					osd_ctl.xres_virtual, \
+					osd_ctl.yres_virtual, \
+					osd_ctl.disp_start_x, \
+					osd_ctl.disp_start_y, \
+					osd_ctl.disp_end_x, \
+					osd_ctl.disp_end_y, \
+					osd_ctl.addr, \
+					color, \
+					osd_ctl.index) ;
+
+	return SUCCESS;
+
+}
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+void set_osd_freescaler(int index, logo_object_t *plogo, vmode_t new_mode) {
+    vmode_t old_mode = plogo->para.vout_mode & VMODE_MODE_BIT_MASK;
+    printk("aml_logo: outputmode changed(%d->%d), reset osd%d scaler.\n", old_mode, new_mode, index);
+    osd_free_scale_mode_hw(index, 1);
+    osd_free_scale_enable_hw(index, 0);
+    osd_set_color_mode(index, &default_color_format_array[plogo->dev->output_dev.osd.color_depth]);
+    switch(old_mode) {
+        case VMODE_480I:
+        case VMODE_480CVBS:
+        case VMODE_480P:
+        case VMODE_576I:
+        case VMODE_576CVBS:
+        case VMODE_576P:
+        case VMODE_720P:
+        case VMODE_720P_50HZ:
+            osd_set_free_scale_axis_hw(index, 0, 0, 1279, 719);
+            osddev_update_disp_axis_hw(0, 1279, 0, 719, 0, 0, 0, index);
+            break;
+        case VMODE_1080I:
+        case VMODE_1080I_50HZ:
+        case VMODE_1080P:
+        case VMODE_1080P_50HZ:
+        case VMODE_1080P_24HZ:
+        case VMODE_4K2K_24HZ:
+        case VMODE_4K2K_25HZ:
+        case VMODE_4K2K_30HZ:
+        case VMODE_4K2K_SMPTE:
+            osd_set_free_scale_axis_hw(index, 0, 0, 1919, 1079);
+            osddev_update_disp_axis_hw(0, 1919, 0, 1079, 0, 0, 0, index);
+            break;
 		default:
 			break;
-   }
-   switch(new_mode) {
-        case VMODE_480I:
-        case VMODE_480CVBS:
-        case VMODE_480P:
-            osd_set_window_axis_hw(index, 0, 0, 719, 479);
-            break;
-        case VMODE_576I:
-        case VMODE_576CVBS:
-        case VMODE_576P:
-            osd_set_window_axis_hw(index, 0, 0, 719, 575);
-            break;
-        case VMODE_720P:
-        case VMODE_720P_50HZ:
-            osd_set_window_axis_hw(index, 0, 0, 1279, 719);
-             break;
-        case VMODE_1080I:
-        case VMODE_1080I_50HZ:
-        case VMODE_1080P:
-        case VMODE_1080P_50HZ:
-        case VMODE_1080P_24HZ:
-            osd_set_window_axis_hw(index, 0, 0, 1919, 1079);
-            break;
-        case VMODE_4K2K_24HZ:
-        case VMODE_4K2K_25HZ:
-        case VMODE_4K2K_30HZ:
-            osd_set_window_axis_hw(index, 0, 0, 3839, 2159);
-            break;
-        case VMODE_4K2K_SMPTE:
-            osd_set_window_axis_hw(index, 0, 0, 4095, 2159);
-            break;
+   }
+   switch(new_mode) {
+        case VMODE_480I:
+        case VMODE_480CVBS:
+        case VMODE_480P:
+            osd_set_window_axis_hw(index, 0, 0, 719, 479);
+            break;
+        case VMODE_576I:
+        case VMODE_576CVBS:
+        case VMODE_576P:
+            osd_set_window_axis_hw(index, 0, 0, 719, 575);
+            break;
+        case VMODE_720P:
+        case VMODE_720P_50HZ:
+            osd_set_window_axis_hw(index, 0, 0, 1279, 719);
+             break;
+        case VMODE_1080I:
+        case VMODE_1080I_50HZ:
+        case VMODE_1080P:
+        case VMODE_1080P_50HZ:
+        case VMODE_1080P_24HZ:
+            osd_set_window_axis_hw(index, 0, 0, 1919, 1079);
+            break;
+        case VMODE_4K2K_24HZ:
+        case VMODE_4K2K_25HZ:
+        case VMODE_4K2K_30HZ:
+            osd_set_window_axis_hw(index, 0, 0, 3839, 2159);
+            break;
+        case VMODE_4K2K_SMPTE:
+            osd_set_window_axis_hw(index, 0, 0, 4095, 2159);
+            break;
 		default:
 			break;
-   }
-   osd_free_scale_enable_hw(index, 0x10001);
-   osd_enable_hw(1, index);
-}
-#endif
-
-static int osd0_init(logo_object_t *plogo)
-{
-#if defined(CONFIG_AM_HDMI_ONLY)
-	int hpd_state = 0;
-#endif
-#if defined(CONFIG_AM_HDMI_ONLY) || (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
-	vmode_t cur_mode = plogo->para.vout_mode;
-#endif
-
-	if(plogo->para.output_dev_type==output_osd0.idx)
-	{
-		DisableVideoLayer();
-		if((plogo->platform_res[output_osd0.idx].mem_end - plogo->platform_res[output_osd0.idx].mem_start) ==0 ) 
-		{
-			return OUTPUT_DEV_UNFOUND;
-		}
-		if(plogo->para.loaded)
-		{
-			osd_init_hw(plogo->para.loaded);
-			if(plogo->para.vout_mode > VMODE_4K2K_SMPTE){
-				plogo->para.vout_mode|=VMODE_LOGO_BIT_MASK;
-			}
-		}
-#ifdef CONFIG_AM_HDMI_ONLY
-		if(plogo->para.vout_mode > VMODE_4K2K_SMPTE) {
-			set_current_vmode(plogo->para.vout_mode);
-		}else{
-			extern int read_hpd_gpio(void);
-			hpd_state = read_hpd_gpio();
-    		
-			if (hpd_state == 0){
-			    cur_mode = cvbsmode_hdmionly;
-			}
-			else{
-			    cur_mode = hdmimode_hdmionly;
-			}
-			set_current_vmode(cur_mode);
-		}
-#else
-		set_current_vmode(plogo->para.vout_mode);
-#endif
-
-#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
-		osd_init_scan_mode();
-#endif
-		output_osd0.vinfo=get_current_vinfo();
-		plogo->dev=&output_osd0;
-		plogo->dev->window.x=0;
-		plogo->dev->window.y=0;
-		plogo->dev->window.w=plogo->dev->vinfo->width;
-		plogo->dev->window.h=plogo->dev->vinfo->height;
-		plogo->dev->output_dev.osd.mem_start=plogo->platform_res[LOGO_DEV_OSD0].mem_start;
-		plogo->dev->output_dev.osd.mem_end=plogo->platform_res[LOGO_DEV_OSD0].mem_end;
-		plogo->dev->output_dev.osd.color_depth=get_curr_color_depth(P_VIU_OSD1_BLK0_CFG_W0);//setup by uboot
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-		if((cur_mode != (plogo->para.vout_mode & VMODE_MODE_BIT_MASK)) && (cur_mode <= VMODE_4K2K_SMPTE)) {
-		    set_osd_freescaler(LOGO_DEV_OSD0, plogo, cur_mode);
-		}
-#endif
-		return OUTPUT_DEV_FOUND;
-	}
-	return OUTPUT_DEV_UNFOUND;
-}
-static int osd1_init(logo_object_t *plogo)
-{
-#if defined(CONFIG_AM_HDMI_ONLY)
-	int hpd_state = 0;
-#endif
-#if defined(CONFIG_AM_HDMI_ONLY) || (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
-	vmode_t cur_mode = plogo->para.vout_mode;
-#endif
-
-	if(plogo->para.output_dev_type==output_osd1.idx)
-	{
-		DisableVideoLayer();
-		if((plogo->platform_res[output_osd1.idx].mem_end - plogo->platform_res[output_osd1.idx].mem_start) ==0)
-		{
-			return OUTPUT_DEV_UNFOUND;
-		}
-		if(plogo->para.loaded)
-		{
-			osd_init_hw(plogo->para.loaded);
-			if(plogo->para.vout_mode > VMODE_4K2K_SMPTE){
-				plogo->para.vout_mode|=VMODE_LOGO_BIT_MASK;
-			}
-		}
-#ifdef CONFIG_AM_HDMI_ONLY
-		if(plogo->para.vout_mode > VMODE_4K2K_SMPTE) {
-			set_current_vmode(plogo->para.vout_mode);
-		}else{
-			extern int read_hpd_gpio(void);
-			hpd_state = read_hpd_gpio();
-    		
-			if (hpd_state == 0){
-			    cur_mode = cvbsmode_hdmionly;
-			}
-			else{
-			    cur_mode = hdmimode_hdmionly;
-			}
-			set_current_vmode(cur_mode);
-		}
-#else
-		set_current_vmode(plogo->para.vout_mode);
-#endif
-
-#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
-		osd_init_scan_mode();
-#endif
-		output_osd1.vinfo=get_current_vinfo();
-		plogo->dev=&output_osd1;
-		plogo->dev->window.x=0;
-		plogo->dev->window.y=0;
-		plogo->dev->window.w=plogo->dev->vinfo->width;
-		plogo->dev->window.h=plogo->dev->vinfo->height;
-		plogo->dev->output_dev.osd.mem_start=plogo->platform_res[LOGO_DEV_OSD1].mem_start;
-		plogo->dev->output_dev.osd.mem_end=plogo->platform_res[LOGO_DEV_OSD1].mem_end;
-		plogo->dev->output_dev.osd.color_depth=get_curr_color_depth(P_VIU_OSD2_BLK0_CFG_W0);//setup by uboot
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-		if((cur_mode != (plogo->para.vout_mode & VMODE_MODE_BIT_MASK)) && (cur_mode <= VMODE_4K2K_SMPTE)) {
-		    set_osd_freescaler(LOGO_DEV_OSD1, plogo, cur_mode);
-		}
-#endif
-		return OUTPUT_DEV_FOUND;
-	}
-	return OUTPUT_DEV_UNFOUND;
-}
-
-static  int  osd_enable_set(int  enable)
-{
-	return SUCCESS;
-}
-static int osd_deinit(void)
-{
-	return SUCCESS;
-}
-//just an examble;
-static  int  thread_progress(void *para)
-{
-#define	OFFSET_PROGRESS_X 15
-#define  START_PROGRESS_X	70
-#define  START_PROGRESS_Y	70
-#define  PROGRESS_HEIGHT	25 
-#define  PORGRESS_BORDER	3
-	unsigned int progress= 0 ;
-	unsigned int step =1;
-	src_dst_info_t  op_info;
-	logo_object_t *plogo=(logo_object_t*)para;
-	ge2d_context_t  *context=plogo->dev->ge2d_context;
-	wait_queue_head_t  wait_head;
-
-	init_waitqueue_head(&wait_head);
-	op_info.color=0x555555ff;
-	op_info.dst_rect.x=START_PROGRESS_X+OFFSET_PROGRESS_X;
-	op_info.dst_rect.y=plogo->dev->vinfo->height-START_PROGRESS_Y;
-	op_info.dst_rect.w=(plogo->dev->vinfo->width -START_PROGRESS_X*2);
-	op_info.dst_rect.h=PROGRESS_HEIGHT;
-	dev_ge2d_cmd(context,CMD_FILLRECT,&op_info);
-
-	op_info.dst_rect.x+=PORGRESS_BORDER;
-	op_info.dst_rect.y+=PORGRESS_BORDER;
-	op_info.dst_rect.w=(plogo->dev->vinfo->width -START_PROGRESS_X*2-PORGRESS_BORDER*2)*step/100;
-	op_info.dst_rect.h=PROGRESS_HEIGHT -PORGRESS_BORDER*2;
-	op_info.color=0x00ffff;
-	while(progress < 100)
-	{
-		dev_ge2d_cmd(context,CMD_FILLRECT,&op_info);
-		wait_event_interruptible_timeout(wait_head,0,7);
-		progress+=step;
-		op_info.dst_rect.x+=op_info.dst_rect.w;
-		op_info.color-=(0xff*step/100)<<8; //color change smoothly.
-	}
-	op_info.dst_rect.w=(plogo->dev->vinfo->width -START_PROGRESS_X-PORGRESS_BORDER+ OFFSET_PROGRESS_X) - op_info.dst_rect.x ;
-	dev_ge2d_cmd(context,CMD_FILLRECT,&op_info);
-	return 0;
-}
-static  int  osd_transfer(logo_object_t *plogo)
-{
-	src_dst_info_t  op_info;
-	ge2d_context_t  *context;
-	config_para_t	ge2d_config;
-	int  screen_mem_start;
-	int  screen_size ;
-	u32  	canvas_index;
-	canvas_t	canvas;		
-	
-	if(!plogo->dev->hw_initialized) // hardware need initialized first .
-	{
-		if(osd_hw_setup(plogo))
-		return  -OUTPUT_DEV_SETUP_FAIL;
-		amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"osd hardware initiate success\n");
-	}
-	if (plogo->need_transfer==FALSE) return -EDEV_NO_TRANSFER_NEED;
-
-	ge2d_config.src_dst_type=plogo->dev->idx?OSD1_OSD1:OSD0_OSD0;
-	ge2d_config.alu_const_color=0x000000ff;
-	context=dev_ge2d_setup(&ge2d_config);
-	//we use ge2d to strechblit pic.
-	if(NULL==context) return -OUTPUT_DEV_SETUP_FAIL;
-	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"logo setup ge2d device OK\n");
-	plogo->dev->ge2d_context=context;
-	//clear dst rect
-	op_info.color=0x000000ff;
-	op_info.dst_rect.x=0;
-	op_info.dst_rect.y=0;
-	op_info.dst_rect.w=plogo->dev->vinfo->width;
-	op_info.dst_rect.h=plogo->dev->vinfo->height;
-	dev_ge2d_cmd(context,CMD_FILLRECT,&op_info);
-	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"fill==dst:%d-%d-%d-%d\n",op_info.dst_rect.x,op_info.dst_rect.y,op_info.dst_rect.w,op_info.dst_rect.h);	
-
-	op_info.src_rect.x=0;  //setup origin src rect 
-	op_info.src_rect.y=0;
-	op_info.src_rect.w=plogo->parser->logo_pic_info.width;
-	op_info.src_rect.h=plogo->parser->logo_pic_info.height;
-
-	switch (plogo->para.dis_mode)
-	{
-		case DISP_MODE_ORIGIN:
-		op_info.dst_rect.x=op_info.src_rect.x;
-		op_info.dst_rect.y=op_info.src_rect.y;
-		op_info.dst_rect.w=op_info.src_rect.w;
-		op_info.dst_rect.h=op_info.src_rect.h;
-		break;
-		case DISP_MODE_CENTER: //maybe offset is useful
-		op_info.dst_rect.x=	(plogo->dev->vinfo->width - plogo->parser->logo_pic_info.width)>>1;
-		op_info.dst_rect.y=(plogo->dev->vinfo->height - plogo->parser->logo_pic_info.height)>>1;
-		op_info.dst_rect.w=op_info.src_rect.w;
-		op_info.dst_rect.h=op_info.src_rect.h;
-		break;
-		case DISP_MODE_FULL_SCREEN:
-		op_info.dst_rect.x=0;
-		op_info.dst_rect.y=0;
-		op_info.dst_rect.w=plogo->dev->vinfo->width;
-		op_info.dst_rect.h=plogo->dev->vinfo->height;
-	
-		break;	
-	}
-	if(strcmp(plogo->parser->name,"bmp")==0)
-	{
-		screen_mem_start = plogo->platform_res[plogo->para.output_dev_type].mem_start;
-		screen_size=plogo->dev->vinfo->width*plogo->dev->vinfo->height*(plogo->parser->decoder.bmp.color_depth>>3);
-		ge2d_config.src_dst_type=plogo->dev->idx?ALLOC_OSD1:ALLOC_OSD0;
-		ge2d_config.alu_const_color=0x000000ff;
-		ge2d_config.src_format=GE2D_FORMAT_S24_RGB;
-		ge2d_config.src_planes[0].addr = screen_mem_start+screen_size;
-		ge2d_config.src_planes[0].w = plogo->parser->logo_pic_info.width;
-		ge2d_config.src_planes[0].h = plogo->parser->logo_pic_info.height;
-		context=dev_ge2d_setup(&ge2d_config);
-		if(NULL==context) return -OUTPUT_DEV_SETUP_FAIL;
-		amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"logo setup ge2d device OK\n");
-		plogo->dev->ge2d_context=context;
-	}
-	else if(strcmp(plogo->parser->name,"jpg")==0)
-	{// transfer from video layer to osd layer.
-		amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"transfer from video layer to osd layer\n");
-		ge2d_config.src_dst_type=plogo->dev->idx?ALLOC_OSD1:ALLOC_OSD0;
-		ge2d_config.alu_const_color=0x000000ff;
-		canvas_index=plogo->parser->decoder.jpg.out_canvas_index;
-		if(plogo->parser->logo_pic_info.color_info==24)//we only support this format
-		{
-			ge2d_config.src_format=GE2D_FORMAT_M24_YUV420;
-			ge2d_config.dst_format=GE2D_FORMAT_S24_RGB;
-			canvas_read(canvas_index&0xff,&canvas);
-			if(canvas.addr==0) return FAIL;
-			ge2d_config.src_planes[0].addr = canvas.addr;
-			ge2d_config.src_planes[0].w = canvas.width;
-			ge2d_config.src_planes[0].h = canvas.height;
-			amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"Y:[0x%x][%d*%d]\n",(u32)canvas.addr,canvas.width,canvas.height);
-			canvas_read(canvas_index>>8&0xff,&canvas);
-			if(canvas.addr==0) return FAIL;
-			ge2d_config.src_planes[1].addr = canvas.addr;
-			ge2d_config.src_planes[1].w = canvas.width;
-			ge2d_config.src_planes[1].h = canvas.height;
-			amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"U:[0x%x][%d*%d]\n",(u32)canvas.addr,canvas.width,canvas.height);	
-			canvas_read(canvas_index>>16&0xff,&canvas);
-			if(canvas.addr==0) return FAIL;
-			ge2d_config.src_planes[2].addr =  canvas.addr;
-			ge2d_config.src_planes[2].w = canvas.width;
-			ge2d_config.src_planes[2].h = canvas.height;
-			amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"V:[0x%x][%d*%d]\n",(u32)canvas.addr,canvas.width,canvas.height);
-			context=dev_ge2d_setup(&ge2d_config);		
-		}else{
-			amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"can't transfer unsupported jpg format\n");	
-			return FAIL;
-		}
-	}else
-	{
-		amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"unsupported logo picture format format\n");	
-		return FAIL ;
-	}
-	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"blit==src:%d-%d-%d-%d\t",op_info.src_rect.x,op_info.src_rect.y,op_info.src_rect.w,op_info.src_rect.h);
-	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"dst:%d-%d-%d-%d\n",op_info.dst_rect.x,op_info.dst_rect.y,op_info.dst_rect.w,op_info.dst_rect.h);	
-	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"move logo pic completed\n");
-	
-	dev_ge2d_cmd(context,CMD_STRETCH_BLIT,&op_info);
-
-	if(plogo->para.progress) //need progress.
-	{
-		kernel_thread(thread_progress, plogo, 0);
-	}
-	return SUCCESS;	
-}
-int dev_osd_setup(void)
-{
-	register_logo_output_dev(&output_osd0);
-	register_logo_output_dev(&output_osd1);
-	return SUCCESS;
-}
-
-vmode_t get_current_cvbs_vmode(void)
-{
-	return cvbsmode_hdmionly;
-}
-
-#ifdef CONFIG_AM_HDMI_ONLY
-vmode_t get_current_hdmi_vmode(void)
-{
-	return hdmimode_hdmionly;
-}
-#endif
-
-static int __init get_cvbs_mode(char *str)
-{
-    if(strncmp("480", str, 3) == 0){
-        cvbsmode_hdmionly = VMODE_480CVBS;
-    }else if(strncmp("576", str, 3) == 0){
-        cvbsmode_hdmionly = VMODE_576CVBS;
-    }else{
-	cvbsmode_hdmionly = VMODE_480CVBS;
-    }
-    printk("kernel get cvbsmode form uboot is %s\n", str);
-    return 1;
-}
-__setup("cvbsmode=", get_cvbs_mode);
-
-#ifdef CONFIG_AM_HDMI_ONLY
-static int __init get_hdmi_mode(char *str)
-{
-    u32 i;
-    for(i = 0; i<PARA_HDMI_ONLY; i++){
-	if (strcmp(hdmi_only_info[i].name, str) == 0){
-		hdmimode_hdmionly = hdmi_only_info[i].info;
-		break;
-	}
-   }
-
-   if(i == PARA_HDMI_ONLY){
-	hdmimode_hdmionly = VMODE_1080P;
-   }
-   printk("kernel get hdmimode form uboot is %s\n", str);
-   return 1;
-}
-__setup("hdmimode=", get_hdmi_mode);
-#endif
+   }
+   osd_free_scale_enable_hw(index, 0x10001);
+   osd_enable_hw(1, index);
+}
+
+#ifdef CONFIG_AM_HDMI_ONLY
+vmode_t tvmode;
+
+// change tv mode and show logo immediatly when hdmi pluged
+int set_mode_and_show_logo(int hpd_state) {
+    int value;
+    logo_object_t* plogo = get_current_logo_obj();
+
+    if((plogo->para.vout_mode & VMODE_MODE_BIT_MASK) > VMODE_4K2K_SMPTE) {
+        return 0;    //  MID
+    }
+
+    printk("hdmi detect: %s.\n", (hpd_state==1)?"plug":"unplug");
+    // osd2 freescale enable,   the logo is shown on osd2, reset freescale.
+    value = aml_read_reg32(P_VPP_OSD_SC_CTRL0) & 0xb;
+    if(value == 0x9) {
+        vmode_t cur_mode;
+        if (hpd_state == 0){
+            cur_mode = cvbsmode_hdmionly;
+        }
+        else{
+            cur_mode = hdmimode_hdmionly;
+        }
+        if(tvmode != cur_mode) {
+            tvmode = cur_mode;
+            osd_enable_hw(0, plogo->para.output_dev_type);
+            set_current_vmode(cur_mode);
+            vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE,&cur_mode) ;
+            set_osd_freescaler(plogo->para.output_dev_type, plogo, cur_mode); 
+        }
+    }
+    return 1;
+}
+EXPORT_SYMBOL(set_mode_and_show_logo);
+
+#endif
+#endif
+
+static int osd0_init(logo_object_t *plogo)
+{
+#if defined(CONFIG_AM_HDMI_ONLY)
+	int hpd_state = 0;
+#endif
+#if defined(CONFIG_AM_HDMI_ONLY) || (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6)
+	vmode_t cur_mode = plogo->para.vout_mode;
+#endif
+
+	if(plogo->para.output_dev_type==output_osd0.idx)
+	{
+		DisableVideoLayer();
+		if((plogo->platform_res[output_osd0.idx].mem_end - plogo->platform_res[output_osd0.idx].mem_start) ==0 )
+		{
+			return OUTPUT_DEV_UNFOUND;
+		}
+		if(plogo->para.loaded)
+		{
+			osd_init_hw(plogo->para.loaded);
+			if(plogo->para.vout_mode > VMODE_4K2K_SMPTE){
+				plogo->para.vout_mode|=VMODE_LOGO_BIT_MASK;
+			}
+		}
+#ifdef CONFIG_AM_HDMI_ONLY
+		if(plogo->para.vout_mode > VMODE_4K2K_SMPTE) {
+			set_current_vmode(plogo->para.vout_mode);
+		}else{
+			extern int read_hpd_gpio(void);
+			hpd_state = read_hpd_gpio();
+
+			if (hpd_state == 0){
+			    cur_mode = cvbsmode_hdmionly;
+			}
+			else{
+			    cur_mode = hdmimode_hdmionly;
+			}
+			set_current_vmode(cur_mode);
+		}
+#else
+		set_current_vmode(plogo->para.vout_mode);
+#endif
+
+#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
+		osd_init_scan_mode();
+#endif
+		output_osd0.vinfo=get_current_vinfo();
+		plogo->dev=&output_osd0;
+		plogo->dev->window.x=0;
+		plogo->dev->window.y=0;
+		plogo->dev->window.w=plogo->dev->vinfo->width;
+		plogo->dev->window.h=plogo->dev->vinfo->height;
+		plogo->dev->output_dev.osd.mem_start=plogo->platform_res[LOGO_DEV_OSD0].mem_start;
+		plogo->dev->output_dev.osd.mem_end=plogo->platform_res[LOGO_DEV_OSD0].mem_end;
+		plogo->dev->output_dev.osd.color_depth=get_curr_color_depth(P_VIU_OSD1_BLK0_CFG_W0);//setup by uboot
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+		if((cur_mode != (plogo->para.vout_mode & VMODE_MODE_BIT_MASK)) && (cur_mode <= VMODE_4K2K_SMPTE)) {
+		    set_osd_freescaler(LOGO_DEV_OSD0, plogo, cur_mode);
+		}
+#else // MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+		if((cur_mode != (plogo->para.vout_mode&VMODE_MODE_BIT_MASK)) && (cur_mode < VMODE_VGA)) {
+
+							plogo->para.loaded = 0;
+
+		}
+#endif
+		return OUTPUT_DEV_FOUND;
+	}
+	return OUTPUT_DEV_UNFOUND;
+}
+static int osd1_init(logo_object_t *plogo)
+{
+#if defined(CONFIG_AM_HDMI_ONLY)
+	int hpd_state = 0;
+#endif
+#if defined(CONFIG_AM_HDMI_ONLY) || (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6)
+	vmode_t cur_mode = plogo->para.vout_mode;
+#endif
+
+	if(plogo->para.output_dev_type==output_osd1.idx)
+	{
+		DisableVideoLayer();
+		if((plogo->platform_res[output_osd1.idx].mem_end - plogo->platform_res[output_osd1.idx].mem_start) ==0)
+		{
+			return OUTPUT_DEV_UNFOUND;
+		}
+		if(plogo->para.loaded)
+		{
+			osd_init_hw(plogo->para.loaded);
+			if(plogo->para.vout_mode > VMODE_4K2K_SMPTE){
+				plogo->para.vout_mode|=VMODE_LOGO_BIT_MASK;
+			}
+		}
+#ifdef CONFIG_AM_HDMI_ONLY
+		if(plogo->para.vout_mode > VMODE_4K2K_SMPTE) {
+			set_current_vmode(plogo->para.vout_mode);
+		}else{
+			extern int read_hpd_gpio(void);
+			hpd_state = read_hpd_gpio();
+
+			if (hpd_state == 0){
+			    cur_mode = cvbsmode_hdmionly;
+			}
+			else{
+			    cur_mode = hdmimode_hdmionly;
+			}
+			set_current_vmode(cur_mode);
+		}
+#else
+		set_current_vmode(plogo->para.vout_mode);
+#endif
+
+#if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
+		osd_init_scan_mode();
+#endif
+		output_osd1.vinfo=get_current_vinfo();
+		plogo->dev=&output_osd1;
+		plogo->dev->window.x=0;
+		plogo->dev->window.y=0;
+		plogo->dev->window.w=plogo->dev->vinfo->width;
+		plogo->dev->window.h=plogo->dev->vinfo->height;
+		plogo->dev->output_dev.osd.mem_start=plogo->platform_res[LOGO_DEV_OSD1].mem_start;
+		plogo->dev->output_dev.osd.mem_end=plogo->platform_res[LOGO_DEV_OSD1].mem_end;
+		plogo->dev->output_dev.osd.color_depth=get_curr_color_depth(P_VIU_OSD2_BLK0_CFG_W0);//setup by uboot
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+		if((cur_mode != (plogo->para.vout_mode & VMODE_MODE_BIT_MASK)) && (cur_mode <= VMODE_4K2K_SMPTE)) {
+		    set_osd_freescaler(LOGO_DEV_OSD1, plogo, cur_mode);
+		}
+#ifdef CONFIG_AM_HDMI_ONLY
+        tvmode = cur_mode;
+#endif
+        
+#else // MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+		if((cur_mode != (plogo->para.vout_mode&VMODE_MODE_BIT_MASK)) && (cur_mode < VMODE_VGA)) {
+
+							plogo->para.loaded = 0;
+
+		}
+
+#endif
+		return OUTPUT_DEV_FOUND;
+	}
+	return OUTPUT_DEV_UNFOUND;
+}
+
+static  int  osd_enable_set(int  enable)
+{
+	return SUCCESS;
+}
+static int osd_deinit(void)
+{
+	return SUCCESS;
+}
+//just an examble;
+static  int  thread_progress(void *para)
+{
+#define	OFFSET_PROGRESS_X 15
+#define  START_PROGRESS_X	70
+#define  START_PROGRESS_Y	70
+#define  PROGRESS_HEIGHT	25
+#define  PORGRESS_BORDER	3
+	unsigned int progress= 0 ;
+	unsigned int step =1;
+	src_dst_info_t  op_info;
+	logo_object_t *plogo=(logo_object_t*)para;
+	ge2d_context_t  *context=plogo->dev->ge2d_context;
+	wait_queue_head_t  wait_head;
+
+	init_waitqueue_head(&wait_head);
+	op_info.color=0x555555ff;
+	op_info.dst_rect.x=START_PROGRESS_X+OFFSET_PROGRESS_X;
+	op_info.dst_rect.y=plogo->dev->vinfo->height-START_PROGRESS_Y;
+	op_info.dst_rect.w=(plogo->dev->vinfo->width -START_PROGRESS_X*2);
+	op_info.dst_rect.h=PROGRESS_HEIGHT;
+	dev_ge2d_cmd(context,CMD_FILLRECT,&op_info);
+
+	op_info.dst_rect.x+=PORGRESS_BORDER;
+	op_info.dst_rect.y+=PORGRESS_BORDER;
+	op_info.dst_rect.w=(plogo->dev->vinfo->width -START_PROGRESS_X*2-PORGRESS_BORDER*2)*step/100;
+	op_info.dst_rect.h=PROGRESS_HEIGHT -PORGRESS_BORDER*2;
+	op_info.color=0x00ffff;
+	while(progress < 100)
+	{
+		dev_ge2d_cmd(context,CMD_FILLRECT,&op_info);
+		wait_event_interruptible_timeout(wait_head,0,7);
+		progress+=step;
+		op_info.dst_rect.x+=op_info.dst_rect.w;
+		op_info.color-=(0xff*step/100)<<8; //color change smoothly.
+	}
+	op_info.dst_rect.w=(plogo->dev->vinfo->width -START_PROGRESS_X-PORGRESS_BORDER+ OFFSET_PROGRESS_X) - op_info.dst_rect.x ;
+	dev_ge2d_cmd(context,CMD_FILLRECT,&op_info);
+	return 0;
+}
+static  int  osd_transfer(logo_object_t *plogo)
+{
+	src_dst_info_t  op_info;
+	ge2d_context_t  *context;
+	config_para_t	ge2d_config;
+	int  screen_mem_start;
+	int  screen_size ;
+	u32  	canvas_index;
+	canvas_t	canvas;
+
+	if(!plogo->dev->hw_initialized) // hardware need initialized first .
+	{
+		if(osd_hw_setup(plogo))
+		return  -OUTPUT_DEV_SETUP_FAIL;
+		amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"osd hardware initiate success\n");
+	}
+	if (plogo->need_transfer==FALSE) return -EDEV_NO_TRANSFER_NEED;
+
+	ge2d_config.src_dst_type=plogo->dev->idx?OSD1_OSD1:OSD0_OSD0;
+	ge2d_config.alu_const_color=0x000000ff;
+	context=dev_ge2d_setup(&ge2d_config);
+	//we use ge2d to strechblit pic.
+	if(NULL==context) return -OUTPUT_DEV_SETUP_FAIL;
+	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"logo setup ge2d device OK\n");
+	plogo->dev->ge2d_context=context;
+	//clear dst rect
+	op_info.color=0x000000ff;
+	op_info.dst_rect.x=0;
+	op_info.dst_rect.y=0;
+	op_info.dst_rect.w=plogo->dev->vinfo->width;
+	op_info.dst_rect.h=plogo->dev->vinfo->height;
+	dev_ge2d_cmd(context,CMD_FILLRECT,&op_info);
+	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"fill==dst:%d-%d-%d-%d\n",op_info.dst_rect.x,op_info.dst_rect.y,op_info.dst_rect.w,op_info.dst_rect.h);
+
+	op_info.src_rect.x=0;  //setup origin src rect
+	op_info.src_rect.y=0;
+	op_info.src_rect.w=plogo->parser->logo_pic_info.width;
+	op_info.src_rect.h=plogo->parser->logo_pic_info.height;
+
+	switch (plogo->para.dis_mode)
+	{
+		case DISP_MODE_ORIGIN:
+		op_info.dst_rect.x=op_info.src_rect.x;
+		op_info.dst_rect.y=op_info.src_rect.y;
+		op_info.dst_rect.w=op_info.src_rect.w;
+		op_info.dst_rect.h=op_info.src_rect.h;
+		break;
+		case DISP_MODE_CENTER: //maybe offset is useful
+		op_info.dst_rect.x=	(plogo->dev->vinfo->width - plogo->parser->logo_pic_info.width)>>1;
+		op_info.dst_rect.y=(plogo->dev->vinfo->height - plogo->parser->logo_pic_info.height)>>1;
+		op_info.dst_rect.w=op_info.src_rect.w;
+		op_info.dst_rect.h=op_info.src_rect.h;
+		break;
+		case DISP_MODE_FULL_SCREEN:
+		op_info.dst_rect.x=0;
+		op_info.dst_rect.y=0;
+		op_info.dst_rect.w=plogo->dev->vinfo->width;
+		op_info.dst_rect.h=plogo->dev->vinfo->height;
+
+		break;
+	}
+	if(strcmp(plogo->parser->name,"bmp")==0)
+	{
+		screen_mem_start = plogo->platform_res[plogo->para.output_dev_type].mem_start;
+		screen_size=plogo->dev->vinfo->width*plogo->dev->vinfo->height*(plogo->parser->decoder.bmp.color_depth>>3);
+		ge2d_config.src_dst_type=plogo->dev->idx?ALLOC_OSD1:ALLOC_OSD0;
+		ge2d_config.alu_const_color=0x000000ff;
+		ge2d_config.src_format=GE2D_FORMAT_S24_RGB;
+		ge2d_config.src_planes[0].addr = screen_mem_start+screen_size;
+		ge2d_config.src_planes[0].w = plogo->parser->logo_pic_info.width;
+		ge2d_config.src_planes[0].h = plogo->parser->logo_pic_info.height;
+		context=dev_ge2d_setup(&ge2d_config);
+		if(NULL==context) return -OUTPUT_DEV_SETUP_FAIL;
+		amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"logo setup ge2d device OK\n");
+		plogo->dev->ge2d_context=context;
+	}
+	else if(strcmp(plogo->parser->name,"jpg")==0)
+	{// transfer from video layer to osd layer.
+		amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"transfer from video layer to osd layer\n");
+		ge2d_config.src_dst_type=plogo->dev->idx?ALLOC_OSD1:ALLOC_OSD0;
+		ge2d_config.alu_const_color=0x000000ff;
+		canvas_index=plogo->parser->decoder.jpg.out_canvas_index;
+		if(plogo->parser->logo_pic_info.color_info==24)//we only support this format
+		{
+			ge2d_config.src_format=GE2D_FORMAT_M24_YUV420;
+			ge2d_config.dst_format=GE2D_FORMAT_S24_RGB;
+			canvas_read(canvas_index&0xff,&canvas);
+			if(canvas.addr==0) return FAIL;
+			ge2d_config.src_planes[0].addr = canvas.addr;
+			ge2d_config.src_planes[0].w = canvas.width;
+			ge2d_config.src_planes[0].h = canvas.height;
+			amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"Y:[0x%x][%d*%d]\n",(u32)canvas.addr,canvas.width,canvas.height);
+			canvas_read(canvas_index>>8&0xff,&canvas);
+			if(canvas.addr==0) return FAIL;
+			ge2d_config.src_planes[1].addr = canvas.addr;
+			ge2d_config.src_planes[1].w = canvas.width;
+			ge2d_config.src_planes[1].h = canvas.height;
+			amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"U:[0x%x][%d*%d]\n",(u32)canvas.addr,canvas.width,canvas.height);
+			canvas_read(canvas_index>>16&0xff,&canvas);
+			if(canvas.addr==0) return FAIL;
+			ge2d_config.src_planes[2].addr =  canvas.addr;
+			ge2d_config.src_planes[2].w = canvas.width;
+			ge2d_config.src_planes[2].h = canvas.height;
+			amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"V:[0x%x][%d*%d]\n",(u32)canvas.addr,canvas.width,canvas.height);
+			context=dev_ge2d_setup(&ge2d_config);
+		}else{
+			amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"can't transfer unsupported jpg format\n");
+			return FAIL;
+		}
+	}else
+	{
+		amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"unsupported logo picture format format\n");
+		return FAIL ;
+	}
+	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"blit==src:%d-%d-%d-%d\t",op_info.src_rect.x,op_info.src_rect.y,op_info.src_rect.w,op_info.src_rect.h);
+	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"dst:%d-%d-%d-%d\n",op_info.dst_rect.x,op_info.dst_rect.y,op_info.dst_rect.w,op_info.dst_rect.h);
+	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"move logo pic completed\n");
+
+	dev_ge2d_cmd(context,CMD_STRETCH_BLIT,&op_info);
+
+	if(plogo->para.progress) //need progress.
+	{
+		kernel_thread(thread_progress, plogo, 0);
+	}
+	return SUCCESS;
+}
+int dev_osd_setup(void)
+{
+	register_logo_output_dev(&output_osd0);
+	register_logo_output_dev(&output_osd1);
+	return SUCCESS;
+}
+
+vmode_t get_current_cvbs_vmode(void)
+{
+	return cvbsmode_hdmionly;
+}
+
+#ifdef CONFIG_AM_HDMI_ONLY
+vmode_t get_current_hdmi_vmode(void)
+{
+	return hdmimode_hdmionly;
+}
+#endif
+
+#ifdef CONFIG_AM_HDMI_ONLY
+static int __init get_hdmi_mode(char *str)
+{
+    u32 i;
+    for(i = 0; i<PARA_HDMI_ONLY; i++){
+	if (strcmp(hdmi_only_info[i].name, str) == 0){
+		hdmimode_hdmionly = hdmi_only_info[i].info;
+		break;
+	}
+   }
+
+   if(i == PARA_HDMI_ONLY){
+	hdmimode_hdmionly = VMODE_1080P;
+   }
+   printk("kernel get hdmimode form uboot is %s\n", str);
+   return 1;
+}
+__setup("hdmimode=", get_hdmi_mode);
+
+static int __init get_cvbs_mode(char *str)
+{
+    if(strncmp("480", str, 3) == 0){
+        cvbsmode_hdmionly = VMODE_480CVBS;
+    }else if(strncmp("576", str, 3) == 0){
+        cvbsmode_hdmionly = VMODE_576CVBS;
+    }else if (strncmp("nocvbs", str, 6) == 0){
+        cvbsmode_hdmionly = hdmimode_hdmionly;
+    }else{
+        cvbsmode_hdmionly = VMODE_480CVBS;
+    }
+    printk("kernel get cvbsmode form uboot is %s\n", str);
+    return 1;
+}
+__setup("cvbsmode=", get_cvbs_mode);
+#endif
diff --git a/drivers/amlogic/display/aml_logo/logo_display/output_dev_vid.c b/drivers/amlogic/display/aml_logo/logo_display/output_dev_vid.c
old mode 100644
new mode 100755
index cd7ba95b..b8758d3c
--- a/drivers/amlogic/display/aml_logo/logo_display/output_dev_vid.c
+++ b/drivers/amlogic/display/aml_logo/logo_display/output_dev_vid.c
@@ -1,54 +1,54 @@
-#include "logo.h"
-#include <linux/wait.h>
-#include "logo_dev_vid.h"
- #include	"amlogo_log.h"
-#include <linux/amlogic/amlog.h>
-static  logo_output_dev_t   output_vid={
-	.idx=LOGO_DEV_VID,
-	.hw_initialized=0,	
-	.op={
-		.init=vid_init,
-		.transfer=vid_transfer,
-		.enable=vid_enable,
-		.deinit=vid_deinit,
-		},
-};
-
-static int vid_init(logo_object_t *plogo)
-{
-	if(plogo->para.output_dev_type==output_vid.idx)
-	{
-		set_current_vmode(plogo->para.vout_mode);
-		output_vid.vinfo=get_current_vinfo();
-		plogo->dev=&output_vid;
-		plogo->dev->window.x=0;
-		plogo->dev->window.y=0;
-		plogo->dev->window.w=plogo->dev->vinfo->width;
-		plogo->dev->window.h=plogo->dev->vinfo->height;
-		plogo->dev->output_dev.vid.mem_start=plogo->platform_res[LOGO_DEV_VID].mem_start;
-		plogo->dev->output_dev.vid.mem_end=plogo->platform_res[LOGO_DEV_VID].mem_end;
-		amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"display on video layer\n");
-		return OUTPUT_DEV_FOUND;
-	}
-	return OUTPUT_DEV_UNFOUND;
-}
-static  int  vid_enable(int  enable)
-{
-	return SUCCESS;
-}
-static int vid_deinit(void)
-{
-	return SUCCESS;
-}
-static  int  vid_transfer(logo_object_t *plogo)
-{
-	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"start video transfer\n");;
-	SET_MPEG_REG_MASK(VPP_MISC, VPP_VD1_PREBLEND | VPP_PREBLEND_EN | VPP_VD1_POSTBLEND|VPP_POSTBLEND_EN); 
-	CLEAR_MPEG_REG_MASK(VPP_MISC, VPP_OSD1_POSTBLEND | VPP_OSD2_POSTBLEND);
-	return SUCCESS;
-}
-int dev_vid_setup(void)
-{
-	register_logo_output_dev(&output_vid);
-	return SUCCESS;
+#include "logo.h"
+#include <linux/wait.h>
+#include "logo_dev_vid.h"
+ #include	"amlogo_log.h"
+#include <linux/amlogic/amlog.h>
+static  logo_output_dev_t   output_vid={
+	.idx=LOGO_DEV_VID,
+	.hw_initialized=0,
+	.op={
+		.init=vid_init,
+		.transfer=vid_transfer,
+		.enable=vid_enable,
+		.deinit=vid_deinit,
+		},
+};
+
+static int vid_init(logo_object_t *plogo)
+{
+	if(plogo->para.output_dev_type==output_vid.idx)
+	{
+		set_current_vmode(plogo->para.vout_mode);
+		output_vid.vinfo=get_current_vinfo();
+		plogo->dev=&output_vid;
+		plogo->dev->window.x=0;
+		plogo->dev->window.y=0;
+		plogo->dev->window.w=plogo->dev->vinfo->width;
+		plogo->dev->window.h=plogo->dev->vinfo->height;
+		plogo->dev->output_dev.vid.mem_start=plogo->platform_res[LOGO_DEV_VID].mem_start;
+		plogo->dev->output_dev.vid.mem_end=plogo->platform_res[LOGO_DEV_VID].mem_end;
+		amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"display on video layer\n");
+		return OUTPUT_DEV_FOUND;
+	}
+	return OUTPUT_DEV_UNFOUND;
+}
+static  int  vid_enable(int  enable)
+{
+	return SUCCESS;
+}
+static int vid_deinit(void)
+{
+	return SUCCESS;
+}
+static  int  vid_transfer(logo_object_t *plogo)
+{
+	amlog_mask_level(LOG_MASK_DEVICE,LOG_LEVEL_LOW,"start video transfer\n");;
+	SET_MPEG_REG_MASK(VPP_MISC, VPP_VD1_PREBLEND | VPP_PREBLEND_EN | VPP_VD1_POSTBLEND|VPP_POSTBLEND_EN);
+	CLEAR_MPEG_REG_MASK(VPP_MISC, VPP_OSD1_POSTBLEND | VPP_OSD2_POSTBLEND);
+	return SUCCESS;
+}
+int dev_vid_setup(void)
+{
+	register_logo_output_dev(&output_vid);
+	return SUCCESS;
 }
\ No newline at end of file
diff --git a/drivers/amlogic/display/aml_logo/logo_parse/bmp_parser.c b/drivers/amlogic/display/aml_logo/logo_parse/bmp_parser.c
old mode 100644
new mode 100755
index 2b2b2202..906d540e
--- a/drivers/amlogic/display/aml_logo/logo_parse/bmp_parser.c
+++ b/drivers/amlogic/display/aml_logo/logo_parse/bmp_parser.c
@@ -1,137 +1,137 @@
-/*******************************************************************
- *
- *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- *
- *  Description:
- *		parse bmp data 
- *
- *  Author: Amlogic Software
- *  Created: 2010/4/1   19:46
- *
- *******************************************************************/
-#include "logo.h"
-#include "bmp_parser.h"
-#include <asm/cacheflush.h>
- #include	"amlogo_log.h"
-#include <linux/amlogic/amlog.h>
-
-static  logo_parser_t    logo_bmp_parser={
- 	.name="bmp",
-	.op={
-	 .init = bmp_init,
-	 .decode=bmp_decode,
-	 .deinit=bmp_deinit,
-	}
- };
-
-/**************************************************************************
-**	before we setup parser output addr ,output device info and ************************
-**	pic info has been setup already.						   **********************
-** 	different  pic type will select different output place      	 **************************                                                                 
-**************************************************************************/
-static  int  setup_parser_output_addr(logo_object_t *plogo)
-{
-	int  screen_mem_start;
-	int  screen_size ;
-
-	if(plogo->para.output_dev_type > LOGO_DEV_OSD1) //bmp pic decoded into video layer 
-	{											//not supported .
-		return -1;
-	}
-	screen_mem_start=plogo->platform_res[plogo->para.output_dev_type].mem_start;
-	screen_size=plogo->dev->vinfo->width*plogo->dev->vinfo->height*(plogo->parser->decoder.bmp.color_depth>>3);
-	//double buffer ,bottom part .
-	plogo->parser->output_addr=(char *)phys_to_virt(screen_mem_start + screen_size);
-	plogo->need_transfer=TRUE;
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"bmp decode output addr:0x%p,%s\n",plogo->parser->output_addr,plogo->need_transfer?"transfer":"no transfer");
-	return 0;
-}
-/****************************************************************************/
-/*****************************************************************************/
-static  int  bmp_decode(logo_object_t *plogo)
-{
-	char	*in=plogo->para.mem_addr ;
-	char *out=plogo->parser->output_addr;
-	char *bmp_data;
-	int 	i;
-	bmp_header_t  *bmp_header=(bmp_header_t  *)plogo->parser->priv;
-	int bpp=plogo->parser->logo_pic_info.color_info/8 ;
-	int width=plogo->parser->logo_pic_info.width;
-	int height=plogo->parser->logo_pic_info.height;
-	int line_length=width*bpp;
-	int bmp_size=line_length*height;
-
-	if(NULL==in || NULL==out)  return FAIL;
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"in addr:0x%p  out addr:0x%p,bmp size :%d,osd width:%d,h=%d, bmp_width:%d, height=%d.\n",in,out,bmp_size,plogo->dev->vinfo->width,plogo->dev->vinfo->height, width, height);
-	//decode data to out buffer
-	bmp_data=(char*)(in+bmp_header->bmp_file_header->bfOffBits+line_length*(height-1));
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"data offset:%d\n",bmp_header->bmp_file_header->bfOffBits);
-	for (i=0;i<height ;i++)
-	{
-		memcpy(out,bmp_data,line_length);
-		out+=width*bpp;
-		bmp_data-=line_length;
-	}
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"get bmp data completed\n");
-	return SUCCESS;
-}
-static int bmp_init(logo_object_t *logo)
-{
-	BITMAPFILEHEADER *header;
-	BITMAPINFOHEADER *bmp_info_header;
-	bmp_header_t		*bmp_header;
-	void  __iomem*	logo_vaddr=logo->para.mem_addr;
-
-	header=(BITMAPFILEHEADER*)logo_vaddr;
-	bmp_info_header=(BITMAPINFOHEADER*)(logo_vaddr+sizeof(BITMAPFILEHEADER));
-	
-	
-	if (NULL==header) goto error; 
-	if(header->bfType == 0x4d42) //"BM"
-	{
-		logo->parser=&logo_bmp_parser;
-		logo->parser->decoder.bmp.color_depth=bmp_info_header->biBitCount;
-		logo->parser->logo_pic_info.color_info=logo->parser->decoder.bmp.color_depth;
-		logo->parser->logo_pic_info.width=bmp_info_header->biWidth;
-		logo->parser->logo_pic_info.height=bmp_info_header->biHeight;
-		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"bmp color depth:%d\n",logo->parser->decoder.bmp.color_depth);
-		if(bmp_info_header->biBitCount<16)
-		{
-			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_HIGH,"color depth less than 16 not supported\n");
-			goto error;
-		}
-		if(!setup_parser_output_addr(logo))
-		{
-			bmp_header=kmalloc(sizeof(bmp_header_t),GFP_KERNEL);
-			bmp_header->bmp_file_header=header;
-			bmp_header->bmp_info_header=bmp_info_header;
-			logo->parser->priv=bmp_header ;
-			logo->para.mem_addr=(char *)logo_vaddr;
-			return PARSER_FOUND;
-		}
-		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_HIGH,"bmp can only display on osd0 or osd1 ,other layer not supported\n");
-	}
-error:
-	return PARSER_UNFOUND;
-	
-}
-static int  bmp_deinit(logo_object_t *plogo)
-{
-	bmp_header_t	*bmp_header=(bmp_header_t*)plogo->parser->priv;
-	
-	if(bmp_header)
-	{
-		kfree(bmp_header);
-	}
-	return SUCCESS;
-}
-
-
-int bmp_setup(void)
-{
-	register_logo_parser(&logo_bmp_parser);
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"bmp setup\n");
-	return SUCCESS;
-}
-	
-//arch_initcall(bmp_setup) ;
+/*******************************************************************
+ *
+ *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *		parse bmp data
+ *
+ *  Author: Amlogic Software
+ *  Created: 2010/4/1   19:46
+ *
+ *******************************************************************/
+#include "logo.h"
+#include "bmp_parser.h"
+#include <asm/cacheflush.h>
+ #include	"amlogo_log.h"
+#include <linux/amlogic/amlog.h>
+
+static  logo_parser_t    logo_bmp_parser={
+	.name="bmp",
+	.op={
+	 .init = bmp_init,
+	 .decode=bmp_decode,
+	 .deinit=bmp_deinit,
+	}
+ };
+
+/**************************************************************************
+**	before we setup parser output addr ,output device info and ************************
+**	pic info has been setup already.						   **********************
+** 	different  pic type will select different output place      	 **************************
+**************************************************************************/
+static  int  setup_parser_output_addr(logo_object_t *plogo)
+{
+	int  screen_mem_start;
+	int  screen_size ;
+
+	if(plogo->para.output_dev_type > LOGO_DEV_OSD1) //bmp pic decoded into video layer
+	{											//not supported .
+		return -1;
+	}
+	screen_mem_start=plogo->platform_res[plogo->para.output_dev_type].mem_start;
+	screen_size=plogo->dev->vinfo->width*plogo->dev->vinfo->height*(plogo->parser->decoder.bmp.color_depth>>3);
+	//double buffer ,bottom part .
+	plogo->parser->output_addr=(char *)phys_to_virt(screen_mem_start + screen_size);
+	plogo->need_transfer=TRUE;
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"bmp decode output addr:0x%p,%s\n",plogo->parser->output_addr,plogo->need_transfer?"transfer":"no transfer");
+	return 0;
+}
+/****************************************************************************/
+/*****************************************************************************/
+static  int  bmp_decode(logo_object_t *plogo)
+{
+	char	*in=plogo->para.mem_addr ;
+	char *out=plogo->parser->output_addr;
+	char *bmp_data;
+	int 	i;
+	bmp_header_t  *bmp_header=(bmp_header_t  *)plogo->parser->priv;
+	int bpp=plogo->parser->logo_pic_info.color_info/8 ;
+	int width=plogo->parser->logo_pic_info.width;
+	int height=plogo->parser->logo_pic_info.height;
+	int line_length=width*bpp;
+	int bmp_size=line_length*height;
+
+	if(NULL==in || NULL==out)  return FAIL;
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"in addr:0x%p  out addr:0x%p,bmp size :%d,osd width:%d,h=%d, bmp_width:%d, height=%d.\n",in,out,bmp_size,plogo->dev->vinfo->width,plogo->dev->vinfo->height, width, height);
+	//decode data to out buffer
+	bmp_data=(char*)(in+bmp_header->bmp_file_header->bfOffBits+line_length*(height-1));
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"data offset:%d\n",bmp_header->bmp_file_header->bfOffBits);
+	for (i=0;i<height ;i++)
+	{
+		memcpy(out,bmp_data,line_length);
+		out+=width*bpp;
+		bmp_data-=line_length;
+	}
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"get bmp data completed\n");
+	return SUCCESS;
+}
+static int bmp_init(logo_object_t *logo)
+{
+	BITMAPFILEHEADER *header;
+	BITMAPINFOHEADER *bmp_info_header;
+	bmp_header_t		*bmp_header;
+	void  __iomem*	logo_vaddr=logo->para.mem_addr;
+
+	header=(BITMAPFILEHEADER*)logo_vaddr;
+	bmp_info_header=(BITMAPINFOHEADER*)(logo_vaddr+sizeof(BITMAPFILEHEADER));
+
+
+	if (NULL==header) goto error;
+	if(header->bfType == 0x4d42) //"BM"
+	{
+		logo->parser=&logo_bmp_parser;
+		logo->parser->decoder.bmp.color_depth=bmp_info_header->biBitCount;
+		logo->parser->logo_pic_info.color_info=logo->parser->decoder.bmp.color_depth;
+		logo->parser->logo_pic_info.width=bmp_info_header->biWidth;
+		logo->parser->logo_pic_info.height=bmp_info_header->biHeight;
+		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"bmp color depth:%d\n",logo->parser->decoder.bmp.color_depth);
+		if(bmp_info_header->biBitCount<16)
+		{
+			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_HIGH,"color depth less than 16 not supported\n");
+			goto error;
+		}
+		if(!setup_parser_output_addr(logo))
+		{
+			bmp_header=kmalloc(sizeof(bmp_header_t),GFP_KERNEL);
+			bmp_header->bmp_file_header=header;
+			bmp_header->bmp_info_header=bmp_info_header;
+			logo->parser->priv=bmp_header ;
+			logo->para.mem_addr=(char *)logo_vaddr;
+			return PARSER_FOUND;
+		}
+		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_HIGH,"bmp can only display on osd0 or osd1 ,other layer not supported\n");
+	}
+error:
+	return PARSER_UNFOUND;
+
+}
+static int  bmp_deinit(logo_object_t *plogo)
+{
+	bmp_header_t	*bmp_header=(bmp_header_t*)plogo->parser->priv;
+
+	if(bmp_header)
+	{
+		kfree(bmp_header);
+	}
+	return SUCCESS;
+}
+
+
+int bmp_setup(void)
+{
+	register_logo_parser(&logo_bmp_parser);
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"bmp setup\n");
+	return SUCCESS;
+}
+
+//arch_initcall(bmp_setup) ;
diff --git a/drivers/amlogic/display/aml_logo/logo_parse/jpeg_parser.c b/drivers/amlogic/display/aml_logo/logo_parse/jpeg_parser.c
old mode 100644
new mode 100755
index 04ec7838..0c3493c3
--- a/drivers/amlogic/display/aml_logo/logo_parse/jpeg_parser.c
+++ b/drivers/amlogic/display/aml_logo/logo_parse/jpeg_parser.c
@@ -1,511 +1,511 @@
-/*******************************************************************
- *
- *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- *
- *  Description:
- *		parse bmp data 
- *
- *  Author: Amlogic Software
- *  Created: 2010/4/1   19:46
- *
- *******************************************************************/
-#include "logo.h"
-#include <mach/am_regs.h>
-#include <asm/cacheflush.h>
-#include	"amlogo_log.h"
-#include <linux/amlogic/amlog.h>
-#include <linux/amlogic/amports/canvas.h>
-#include "amvdec.h"
-#include "vmjpeg_mc.h"
-#include <linux/amlogic/amports/vframe.h>
-#include <linux/amlogic/amports/vframe_provider.h>
-#include "jpeg_parser.h"
-#include <linux/delay.h>
-#include <linux/syscalls.h>
-
-
-static  logo_parser_t    logo_jpeg_parser={
- 	.name="jpg",
-	.op={
-	 .init = jpeg_init,
-	 .decode=jpeg_decode,
-	 .deinit=jpeg_deinit,
-	}
- };
-jpeg_private_t *g_jpeg_parser;
-
-
-static vframe_t *jpeglogo_vf_peek(void *para)
-{
-	return (g_jpeg_parser->state== PIC_DECODED) ? &g_jpeg_parser->vf : NULL;
-}
-
-static vframe_t *jpeglogo_vf_get(void *para)
-{
-	if (g_jpeg_parser->state == PIC_DECODED) {
-		g_jpeg_parser->state = PIC_FETCHED;
-		return &g_jpeg_parser->vf;
-	}
-	
-	return NULL;
-}
-static const struct vframe_operations_s jpeglogo_vf_provider_op =
-{
-    	.peek = jpeglogo_vf_peek,
-    	.get  = jpeglogo_vf_get,
-    	.put  = NULL,
-};
-#ifdef CONFIG_AM_VIDEO 
-static struct vframe_provider_s jpeglogo_vf_prov;
-#endif
-static inline u32 index2canvas(u32 index)
-{
-    const u32 canvas_tab[4] = {
-        0x020100, 0x050403, 0x080706, 0x0b0a09
-    };
-
-    return canvas_tab[index];
-}
-
-#if 0
-static irqreturn_t jpeglogo_isr(int irq, void *dev_id)
-{
-	u32 reg, index;
-     	vframe_t  *pvf=&g_jpeg_parser->vf;	
-
-    	WRITE_MPEG_REG(VDEC_ASSIST_MBOX1_CLR_REG, 1);
-
-    	reg = READ_MPEG_REG(MREG_FROM_AMRISC);
-
-    	if (reg & PICINFO_BUF_IDX_MASK) {
-       		index = ((reg & PICINFO_BUF_IDX_MASK) - 1) & 3;
-
-        	pvf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
-        	pvf->canvas0Addr = pvf->canvas1Addr = index2canvas(index);
-		g_jpeg_parser->state= PIC_DECODED;
-		g_jpeg_parser->canvas_index=pvf->canvas0Addr;
-		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"[jpeglogo]: One frame decoded\n");
-		
-    }
-
-    return IRQ_HANDLED;
-}
-#endif
-
-static s32 parse_jpeg_info(u8 *dp,logo_object_t *plogo)
-{
-	int len = 0;
-	int end=0;
-	u8 *p = dp + 2;
-	u8 tag;
-	int	ret=-EINVAL;
-
-
-	if((u32)dp&7) goto exit ;  //logo not align at 8byte boundary.
-	if ((dp[0] != JPEG_TAG) ||
-		(dp[1] != JPEG_TAG_SOI))
-		goto exit;
-
-	if (*p++ != JPEG_TAG)
-		goto exit;
-		
-	tag = *p++;
-	len = ((u32)(p[0]) << 8) | p[1];
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"picture format jpeg\n");
-	plogo->parser=&logo_jpeg_parser;
-	while (!end) {
-		switch(tag)
-		{
-			case  JPEG_TAG_SOF0: //get picture info
-			plogo->parser->logo_pic_info.height= ((u32)p[3] << 8) | p[4];
-			plogo->parser->logo_pic_info.width = ((u32)p[5] << 8) | p[6];
-			plogo->parser->logo_pic_info.color_info=p[7]*8;
-			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"[picture info]%dx%d \n",plogo->parser->logo_pic_info.width ,plogo->parser->logo_pic_info.height);
-			break;
-			case JPEG_TAG_SOS: //goto file end
-			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"[0x%p]start scan line\n",p);
-			while(p[0]!=JPEG_TAG || p[1]!=JPEG_TAG_EOI )
-			{
-				p++;						//to speed up we need setup file_size outof parser.
-				if(p-dp>JPEG_INVALID_FILE_SIZE)//exception check
-				{
-					end=1;
-					continue;
-				}
-			}
-			ret=p-dp+2;
-			end=1;
-			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"jpeg parser end,file size:%d\n",ret);
-			continue;
-			default:
-			break;
-		}
-		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"tag:0x%x,len:0x%x\n",tag,len);
-		p += len;
-		if (*p++ != JPEG_TAG)
-		break;
-
-		tag = *p++;
-		len = ((u32)p[0] << 8) | p[1];
-		
-	}
-exit:	
-	return ret;
-}
-/* addr must be aligned at 8 bytes boundary */
-static void swap_tailzero_data(u8 *addr, u32 s)
-{
-	register u8 d;
-	u8 *p = addr;
-	u32 len = (s + 7) >> 3;
-	
-	memset(addr + s, 0, PADDINGSIZE);
-
-	while (len > 0) {
-		d = p[0]; p[0] = p[7]; p[7] = d;
-		d = p[1]; p[1] = p[6]; p[6] = d;
-		d = p[2]; p[2] = p[5]; p[5] = d;
-		d = p[3]; p[3] = p[4]; p[4] = d;
-		p += 8;
-		len --;
-	}
-}
-
-static void jpeglogo_canvas_init(logo_object_t *plogo)
-{
-       int i;
-       u32 canvas_width, canvas_height;
-       u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
-	jpeg_private_t *priv=(jpeg_private_t *)plogo->parser->priv;
-	u32 disp=plogo->platform_res[LOGO_DEV_VID].mem_start;//decode to video layer.
-    
-        if ((priv->vf.width< 768) && (priv->vf.height< 576)) {
-            /* SD only */
-            canvas_width   = 768;
-            canvas_height  = 576;
-            decbuf_y_size  = 0x80000;
-            decbuf_uv_size = 0x20000;
-            decbuf_size    = 0x100000;
-        }
-        else {
-            /* HD & SD */
-            canvas_width   = 1920;
-            canvas_height  = 1088;
-            decbuf_y_size  = 0x200000;
-            decbuf_uv_size = 0x80000;
-            decbuf_size    = 0x300000;
-        }
-    
-        for (i = 0; i < 4; i++) {
-            canvas_config(3 * i + 0,
-                          disp + i * decbuf_size,
-                          canvas_width, canvas_height,
-                          CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-            canvas_config(3 * i + 1,
-                          disp + i * decbuf_size + decbuf_y_size,
-                          canvas_width / 2, canvas_height / 2,
-                          CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-            canvas_config(3 * i + 2,
-                          disp + i * decbuf_size + decbuf_y_size + decbuf_uv_size,
-                          canvas_width/2, canvas_height/2,
-                          CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-	    		
-        }
-}
-static void init_scaler(void)
-{
-    /* 4 point triangle */
-    const unsigned filt_coef[] = {
-        0x20402000, 0x20402000, 0x1f3f2101, 0x1f3f2101,
-        0x1e3e2202, 0x1e3e2202, 0x1d3d2303, 0x1d3d2303,
-        0x1c3c2404, 0x1c3c2404, 0x1b3b2505, 0x1b3b2505,
-        0x1a3a2606, 0x1a3a2606, 0x19392707, 0x19392707,
-        0x18382808, 0x18382808, 0x17372909, 0x17372909,
-        0x16362a0a, 0x16362a0a, 0x15352b0b, 0x15352b0b,
-        0x14342c0c, 0x14342c0c, 0x13332d0d, 0x13332d0d,
-        0x12322e0e, 0x12322e0e, 0x11312f0f, 0x11312f0f,
-        0x10303010
-    };
-    int i;
-
-    /* pscale enable, PSCALE cbus bmem enable */
-    WRITE_MPEG_REG(PSCALE_CTRL, 0xc000);
-
-    /* write filter coefs */
-    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 0);
-    for (i = 0; i < 33; i++) {
-        WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0);
-        WRITE_MPEG_REG(PSCALE_BMEM_DAT, filt_coef[i]);
-    }
-
-    /* Y horizontal initial info */
-    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 37*2);
-    /* [35]: buf repeat pix0,
-     * [34:29] => buf receive num,
-     * [28:16] => buf blk x,
-     * [15:0] => buf phase
-     */
-    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x0008);
-    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x60000000);
-
-    /* C horizontal initial info */
-    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 41*2);
-    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x0008);
-    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x60000000);
-
-    /* Y vertical initial info */
-    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 39*2);
-    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x0008);
-    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x60000000);
-
-    /* C vertical initial info */
-    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 43*2);
-    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x0008);
-    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x60000000);
-
-    /* Y horizontal phase step */
-    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 36*2 + 1);
-    /* [19:0] => Y horizontal phase step */
-    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x10000);
-    /* C horizontal phase step */
-    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 40*2 + 1);
-    /* [19:0] => C horizontal phase step */
-    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x10000);
-
-    /* Y vertical phase step */
-    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 38*2+1);
-    /* [19:0] => Y vertical phase step */
-    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x10000);
-    /* C vertical phase step */
-    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 42*2+1);
-    /* [19:0] => C horizontal phase step */
-    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x10000);
-
-    /* reset pscaler */
-    WRITE_MPEG_REG(RESET2_REGISTER, RESET_PSCALE);
-	READ_MPEG_REG(RESET2_REGISTER);
-	READ_MPEG_REG(RESET2_REGISTER);
-	READ_MPEG_REG(RESET2_REGISTER);
-
-    WRITE_MPEG_REG(PSCALE_RST, 0x7);
-    WRITE_MPEG_REG(PSCALE_RST, 0x0);
-}
-
-static void jpeglogo_prot_init(logo_object_t *plogo)
-{
-	WRITE_MPEG_REG(RESET0_REGISTER, RESET_IQIDCT | RESET_MC);
-   
-       jpeglogo_canvas_init(plogo);
-   
-       WRITE_MPEG_REG(AV_SCRATCH_0, 12);
-       WRITE_MPEG_REG(AV_SCRATCH_1, 0x031a);
-       WRITE_MPEG_REG(AV_SCRATCH_4, 0x020100);
-       WRITE_MPEG_REG(AV_SCRATCH_5, 0x050403);
-       WRITE_MPEG_REG(AV_SCRATCH_6, 0x080706);
-       WRITE_MPEG_REG(AV_SCRATCH_7, 0x0b0a09);
-   
-       init_scaler();
-   
-       /* clear buffer IN/OUT registers */
-       WRITE_MPEG_REG(MREG_TO_AMRISC, 0);
-       WRITE_MPEG_REG(MREG_FROM_AMRISC, 0);
-   
-       WRITE_MPEG_REG(MCPU_INTR_MSK, 0xffff);
-       WRITE_MPEG_REG(MREG_DECODE_PARAM, 0);
-   
-       /* clear mailbox interrupt */
-       WRITE_MPEG_REG(VDEC_ASSIST_MBOX1_CLR_REG, 1);
-       /* enable mailbox interrupt */
-       WRITE_MPEG_REG(VDEC_ASSIST_MBOX1_MASK, 1);
-}
-static void setup_vb(u32 addr, int s)
-{
-    WRITE_MPEG_REG(VLD_MEM_VIFIFO_START_PTR, addr);
-    WRITE_MPEG_REG(VLD_MEM_VIFIFO_CURR_PTR, addr);
-    WRITE_MPEG_REG(VLD_MEM_VIFIFO_END_PTR, (addr + s + PADDINGSIZE + 7) & ~7);
-
-    SET_MPEG_REG_MASK(VLD_MEM_VIFIFO_CONTROL, MEM_BUFCTRL_INIT);
-    CLEAR_MPEG_REG_MASK(VLD_MEM_VIFIFO_CONTROL, MEM_BUFCTRL_INIT);
-
-    WRITE_MPEG_REG(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_MANUAL);
-    WRITE_MPEG_REG(VLD_MEM_VIFIFO_WP, addr);
-
-    SET_MPEG_REG_MASK(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-    CLEAR_MPEG_REG_MASK(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
-
-    SET_MPEG_REG_MASK(VLD_MEM_VIFIFO_CONTROL, MEM_FILL_ON_LEVEL | MEM_CTRL_FILL_EN | MEM_CTRL_EMPTY_EN);
-}
-static inline void feed_vb(s32 s)
-{
-	u32 addr = READ_MPEG_REG(VLD_MEM_VIFIFO_START_PTR);
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"feed start addr:0x%x\n",addr);
-    	WRITE_MPEG_REG(VLD_MEM_VIFIFO_WP, (addr + s + PADDINGSIZE + 7) & ~7);
-}
-
-static int hardware_init(logo_object_t *plogo,int logo_size)
-{
-#ifdef CONFIG_AM_STREAMING
-	u32	*mc_addr_aligned = (u32 *)vmjpeg_mc;
-#endif
-	int ret = 0;
-	if(plogo->para.output_dev_type  <=LOGO_DEV_VID ) //now only support display on video layer.
-	{
-		if(plogo->para.output_dev_type < LOGO_DEV_VID)
-		plogo->need_transfer=TRUE;
-		else
-		plogo->need_transfer=FALSE;	
-	}
-	else
-	{
-		return -EINVAL;
-	}
-	WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU | RESET_CCPU);
-#ifdef CONFIG_AM_STREAMING	
-	if (amvdec_loadmc(mc_addr_aligned) < 0) {
-		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"[jpeglogo]: Can not loading HW decoding ucode.\n");
-        	return -EBUSY;
-    	}
-#endif	
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"load micro code completed\n");
-	jpeglogo_prot_init(plogo);
-	
-	/*ret= request_irq(INT_MAILBOX_1A, jpeglogo_isr,
-                    IRQF_SHARED, "jpeglogo-irq", (void *)hardware_init);*/
-	
-    	if (ret) {
-        amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"jpeglogo_init irq register error.\n");
-        return -ENOENT;
-    	}
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"jpeg irq request ok\n");	
-	setup_vb((u32)virt_to_phys(plogo->para.mem_addr),logo_size);
-	WRITE_MPEG_REG(M4_CONTROL_REG, 0x0300);
-	WRITE_MPEG_REG(POWER_CTL_VLD, 0);
-	//set initial screen mode :
-	
-	
-	return SUCCESS;
-
-
-}
-
-static int jpeg_init(logo_object_t *plogo)
-{
-	int  logo_size;
-	void  __iomem* vaddr;
-	jpeg_private_t  *priv;
-
-	vaddr=(void  __iomem*)plogo->para.mem_addr;
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"logo vaddr:0x%p\n ",vaddr);
-	if((logo_size=parse_jpeg_info(vaddr,plogo)) <=0 )
-	return PARSER_UNFOUND;
-	vaddr = ioremap_wc((unsigned int)virt_to_phys(plogo->para.mem_addr), logo_size + PADDINGSIZE);
-	if(NULL==vaddr)
-	{
-		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"remapping logo data failed\n");
-		return  -ENOMEM;
-	}
-	priv=(jpeg_private_t  *)kmalloc(sizeof(jpeg_private_t),GFP_KERNEL);
-	if(IS_ERR(priv))
-	{
-		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"can't alloc memory for jpeg private data\n");
-		return  -ENOMEM;
-	}
-	memset(priv, 0, sizeof(jpeg_private_t));
-	priv->vf.width=plogo->parser->logo_pic_info.width;
-	priv->vf.height=plogo->parser->logo_pic_info.height;
-	plogo->parser->priv=priv;
-	g_jpeg_parser=priv;
-	priv->vaddr=vaddr;
-	swap_tailzero_data((u8 *)vaddr, logo_size);
-	if(hardware_init(plogo,logo_size) !=SUCCESS)
-	{
-		return PARSER_UNFOUND;
-	}
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"jpeg parser hardware init ok\n");
-	plogo->parser->logo_pic_info.size=logo_size;
-	return PARSER_FOUND;
-}
-static  int  thread_progress(void *para)
-{
-	logo_object_t *plogo=(logo_object_t*)para;
-	jpeg_private_t *priv=(jpeg_private_t*)plogo->parser->priv;
-	ulong timeout;
-		
-	timeout = jiffies + HZ*8;
-    	while (time_before(jiffies, timeout)) {
-		if (priv->state== PIC_FETCHED)
-		{
-#ifdef CONFIG_AM_VIDEO 	
-			vf_unreg_provider(&jpeglogo_vf_prov);
-#endif
-			kfree(priv);
-			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"logo fetched\n");
-			return SUCCESS;
-		}	
-	}
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"logo unfetched\n");
-	return FAIL;
-}
-static  int  jpeg_decode(logo_object_t *plogo)
-{
-	ulong timeout;
-	jpeg_private_t *priv=(jpeg_private_t*)plogo->parser->priv;
-#ifdef CONFIG_AM_STREAMING	
-	amvdec_start();
-#endif
-       	feed_vb(plogo->parser->logo_pic_info.size);
-	timeout = jiffies + HZ * 2;//wait 2s
-    
-    	while (time_before(jiffies, timeout)) {
-		if (priv->state == PIC_DECODED) {
-			/* disable OSD layer to expose logo on video layer  */
-			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"[jpeglogo]: logo decoded.\n");
-			break;
-		}
-    	}
-#ifdef CONFIG_AM_STREAMING		
-    	amvdec_stop();
-#endif
-	/*free_irq(INT_MAILBOX_1A, (void *)hardware_init);*/
-	if (priv->state > PIC_NA) 
-	{
-		if(plogo->para.output_dev_type == LOGO_DEV_VID)
-		{
-#ifdef CONFIG_AM_VIDEO 
-                     vf_provider_init(&jpeglogo_vf_prov, "jpeglogo_provider", &jpeglogo_vf_provider_op, NULL);
-			vf_reg_provider(&jpeglogo_vf_prov);
-#endif
-			kernel_thread(thread_progress, plogo, 0);
-		}else
-		{
-			plogo->parser->decoder.jpg.out_canvas_index=priv->canvas_index;
-			kfree(priv);
-		}
-    		
-	}
-	else
-	{
-		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"deocod jpeg uncompleted\n");
-		return FAIL;
-	}
-	return SUCCESS;
-}
-static int  jpeg_deinit(logo_object_t *plogo)
-{
-	jpeg_private_t	*priv=(jpeg_private_t*)plogo->parser->priv;
-
-	if(priv)
-	{
-		if(priv->vaddr)
-		{
-			iounmap(priv->vaddr);
-		}
-	}
-	return SUCCESS;
-}
-int jpeg_setup(void)
-{
-	register_logo_parser(&logo_jpeg_parser);
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"jpeg parser setup\n");
-	return SUCCESS;
-}
+/*******************************************************************
+ *
+ *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *		parse bmp data
+ *
+ *  Author: Amlogic Software
+ *  Created: 2010/4/1   19:46
+ *
+ *******************************************************************/
+#include "logo.h"
+#include <mach/am_regs.h>
+#include <asm/cacheflush.h>
+#include	"amlogo_log.h"
+#include <linux/amlogic/amlog.h>
+#include <linux/amlogic/amports/canvas.h>
+#include "amvdec.h"
+#include "vmjpeg_mc.h"
+#include <linux/amlogic/amports/vframe.h>
+#include <linux/amlogic/amports/vframe_provider.h>
+#include "jpeg_parser.h"
+#include <linux/delay.h>
+#include <linux/syscalls.h>
+
+
+static  logo_parser_t    logo_jpeg_parser={
+	.name="jpg",
+	.op={
+	 .init = jpeg_init,
+	 .decode=jpeg_decode,
+	 .deinit=jpeg_deinit,
+	}
+ };
+jpeg_private_t *g_jpeg_parser;
+
+
+static vframe_t *jpeglogo_vf_peek(void *para)
+{
+	return (g_jpeg_parser->state== PIC_DECODED) ? &g_jpeg_parser->vf : NULL;
+}
+
+static vframe_t *jpeglogo_vf_get(void *para)
+{
+	if (g_jpeg_parser->state == PIC_DECODED) {
+		g_jpeg_parser->state = PIC_FETCHED;
+		return &g_jpeg_parser->vf;
+	}
+
+	return NULL;
+}
+static const struct vframe_operations_s jpeglogo_vf_provider_op =
+{
+	.peek = jpeglogo_vf_peek,
+	.get  = jpeglogo_vf_get,
+	.put  = NULL,
+};
+#ifdef CONFIG_AM_VIDEO
+static struct vframe_provider_s jpeglogo_vf_prov;
+#endif
+static inline u32 index2canvas(u32 index)
+{
+    const u32 canvas_tab[4] = {
+        0x020100, 0x050403, 0x080706, 0x0b0a09
+    };
+
+    return canvas_tab[index];
+}
+
+#if 0
+static irqreturn_t jpeglogo_isr(int irq, void *dev_id)
+{
+	u32 reg, index;
+	vframe_t  *pvf=&g_jpeg_parser->vf;
+
+	WRITE_MPEG_REG(VDEC_ASSIST_MBOX1_CLR_REG, 1);
+
+	reg = READ_MPEG_REG(MREG_FROM_AMRISC);
+
+	if (reg & PICINFO_BUF_IDX_MASK) {
+		index = ((reg & PICINFO_BUF_IDX_MASK) - 1) & 3;
+
+		pvf->type = VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD;
+		pvf->canvas0Addr = pvf->canvas1Addr = index2canvas(index);
+		g_jpeg_parser->state= PIC_DECODED;
+		g_jpeg_parser->canvas_index=pvf->canvas0Addr;
+		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"[jpeglogo]: One frame decoded\n");
+
+    }
+
+    return IRQ_HANDLED;
+}
+#endif
+
+static s32 parse_jpeg_info(u8 *dp,logo_object_t *plogo)
+{
+	int len = 0;
+	int end=0;
+	u8 *p = dp + 2;
+	u8 tag;
+	int	ret=-EINVAL;
+
+
+	if((u32)dp&7) goto exit ;  //logo not align at 8byte boundary.
+	if ((dp[0] != JPEG_TAG) ||
+		(dp[1] != JPEG_TAG_SOI))
+		goto exit;
+
+	if (*p++ != JPEG_TAG)
+		goto exit;
+
+	tag = *p++;
+	len = ((u32)(p[0]) << 8) | p[1];
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"picture format jpeg\n");
+	plogo->parser=&logo_jpeg_parser;
+	while (!end) {
+		switch(tag)
+		{
+			case  JPEG_TAG_SOF0: //get picture info
+			plogo->parser->logo_pic_info.height= ((u32)p[3] << 8) | p[4];
+			plogo->parser->logo_pic_info.width = ((u32)p[5] << 8) | p[6];
+			plogo->parser->logo_pic_info.color_info=p[7]*8;
+			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"[picture info]%dx%d \n",plogo->parser->logo_pic_info.width ,plogo->parser->logo_pic_info.height);
+			break;
+			case JPEG_TAG_SOS: //goto file end
+			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"[0x%p]start scan line\n",p);
+			while(p[0]!=JPEG_TAG || p[1]!=JPEG_TAG_EOI )
+			{
+				p++;						//to speed up we need setup file_size outof parser.
+				if(p-dp>JPEG_INVALID_FILE_SIZE)//exception check
+				{
+					end=1;
+					continue;
+				}
+			}
+			ret=p-dp+2;
+			end=1;
+			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"jpeg parser end,file size:%d\n",ret);
+			continue;
+			default:
+			break;
+		}
+		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"tag:0x%x,len:0x%x\n",tag,len);
+		p += len;
+		if (*p++ != JPEG_TAG)
+		break;
+
+		tag = *p++;
+		len = ((u32)p[0] << 8) | p[1];
+
+	}
+exit:
+	return ret;
+}
+/* addr must be aligned at 8 bytes boundary */
+static void swap_tailzero_data(u8 *addr, u32 s)
+{
+	register u8 d;
+	u8 *p = addr;
+	u32 len = (s + 7) >> 3;
+
+	memset(addr + s, 0, PADDINGSIZE);
+
+	while (len > 0) {
+		d = p[0]; p[0] = p[7]; p[7] = d;
+		d = p[1]; p[1] = p[6]; p[6] = d;
+		d = p[2]; p[2] = p[5]; p[5] = d;
+		d = p[3]; p[3] = p[4]; p[4] = d;
+		p += 8;
+		len --;
+	}
+}
+
+static void jpeglogo_canvas_init(logo_object_t *plogo)
+{
+       int i;
+       u32 canvas_width, canvas_height;
+       u32 decbuf_size, decbuf_y_size, decbuf_uv_size;
+	jpeg_private_t *priv=(jpeg_private_t *)plogo->parser->priv;
+	u32 disp=plogo->platform_res[LOGO_DEV_VID].mem_start;//decode to video layer.
+
+        if ((priv->vf.width< 768) && (priv->vf.height< 576)) {
+            /* SD only */
+            canvas_width   = 768;
+            canvas_height  = 576;
+            decbuf_y_size  = 0x80000;
+            decbuf_uv_size = 0x20000;
+            decbuf_size    = 0x100000;
+        }
+        else {
+            /* HD & SD */
+            canvas_width   = 1920;
+            canvas_height  = 1088;
+            decbuf_y_size  = 0x200000;
+            decbuf_uv_size = 0x80000;
+            decbuf_size    = 0x300000;
+        }
+
+        for (i = 0; i < 4; i++) {
+            canvas_config(3 * i + 0,
+                          disp + i * decbuf_size,
+                          canvas_width, canvas_height,
+                          CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+            canvas_config(3 * i + 1,
+                          disp + i * decbuf_size + decbuf_y_size,
+                          canvas_width / 2, canvas_height / 2,
+                          CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+            canvas_config(3 * i + 2,
+                          disp + i * decbuf_size + decbuf_y_size + decbuf_uv_size,
+                          canvas_width/2, canvas_height/2,
+                          CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+
+        }
+}
+static void init_scaler(void)
+{
+    /* 4 point triangle */
+    const unsigned filt_coef[] = {
+        0x20402000, 0x20402000, 0x1f3f2101, 0x1f3f2101,
+        0x1e3e2202, 0x1e3e2202, 0x1d3d2303, 0x1d3d2303,
+        0x1c3c2404, 0x1c3c2404, 0x1b3b2505, 0x1b3b2505,
+        0x1a3a2606, 0x1a3a2606, 0x19392707, 0x19392707,
+        0x18382808, 0x18382808, 0x17372909, 0x17372909,
+        0x16362a0a, 0x16362a0a, 0x15352b0b, 0x15352b0b,
+        0x14342c0c, 0x14342c0c, 0x13332d0d, 0x13332d0d,
+        0x12322e0e, 0x12322e0e, 0x11312f0f, 0x11312f0f,
+        0x10303010
+    };
+    int i;
+
+    /* pscale enable, PSCALE cbus bmem enable */
+    WRITE_MPEG_REG(PSCALE_CTRL, 0xc000);
+
+    /* write filter coefs */
+    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 0);
+    for (i = 0; i < 33; i++) {
+        WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0);
+        WRITE_MPEG_REG(PSCALE_BMEM_DAT, filt_coef[i]);
+    }
+
+    /* Y horizontal initial info */
+    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 37*2);
+    /* [35]: buf repeat pix0,
+     * [34:29] => buf receive num,
+     * [28:16] => buf blk x,
+     * [15:0] => buf phase
+     */
+    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x0008);
+    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x60000000);
+
+    /* C horizontal initial info */
+    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 41*2);
+    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x0008);
+    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x60000000);
+
+    /* Y vertical initial info */
+    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 39*2);
+    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x0008);
+    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x60000000);
+
+    /* C vertical initial info */
+    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 43*2);
+    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x0008);
+    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x60000000);
+
+    /* Y horizontal phase step */
+    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 36*2 + 1);
+    /* [19:0] => Y horizontal phase step */
+    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x10000);
+    /* C horizontal phase step */
+    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 40*2 + 1);
+    /* [19:0] => C horizontal phase step */
+    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x10000);
+
+    /* Y vertical phase step */
+    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 38*2+1);
+    /* [19:0] => Y vertical phase step */
+    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x10000);
+    /* C vertical phase step */
+    WRITE_MPEG_REG(PSCALE_BMEM_ADDR, 42*2+1);
+    /* [19:0] => C horizontal phase step */
+    WRITE_MPEG_REG(PSCALE_BMEM_DAT, 0x10000);
+
+    /* reset pscaler */
+    WRITE_MPEG_REG(RESET2_REGISTER, RESET_PSCALE);
+	READ_MPEG_REG(RESET2_REGISTER);
+	READ_MPEG_REG(RESET2_REGISTER);
+	READ_MPEG_REG(RESET2_REGISTER);
+
+    WRITE_MPEG_REG(PSCALE_RST, 0x7);
+    WRITE_MPEG_REG(PSCALE_RST, 0x0);
+}
+
+static void jpeglogo_prot_init(logo_object_t *plogo)
+{
+	WRITE_MPEG_REG(RESET0_REGISTER, RESET_IQIDCT | RESET_MC);
+
+       jpeglogo_canvas_init(plogo);
+
+       WRITE_MPEG_REG(AV_SCRATCH_0, 12);
+       WRITE_MPEG_REG(AV_SCRATCH_1, 0x031a);
+       WRITE_MPEG_REG(AV_SCRATCH_4, 0x020100);
+       WRITE_MPEG_REG(AV_SCRATCH_5, 0x050403);
+       WRITE_MPEG_REG(AV_SCRATCH_6, 0x080706);
+       WRITE_MPEG_REG(AV_SCRATCH_7, 0x0b0a09);
+
+       init_scaler();
+
+       /* clear buffer IN/OUT registers */
+       WRITE_MPEG_REG(MREG_TO_AMRISC, 0);
+       WRITE_MPEG_REG(MREG_FROM_AMRISC, 0);
+
+       WRITE_MPEG_REG(MCPU_INTR_MSK, 0xffff);
+       WRITE_MPEG_REG(MREG_DECODE_PARAM, 0);
+
+       /* clear mailbox interrupt */
+       WRITE_MPEG_REG(VDEC_ASSIST_MBOX1_CLR_REG, 1);
+       /* enable mailbox interrupt */
+       WRITE_MPEG_REG(VDEC_ASSIST_MBOX1_MASK, 1);
+}
+static void setup_vb(u32 addr, int s)
+{
+    WRITE_MPEG_REG(VLD_MEM_VIFIFO_START_PTR, addr);
+    WRITE_MPEG_REG(VLD_MEM_VIFIFO_CURR_PTR, addr);
+    WRITE_MPEG_REG(VLD_MEM_VIFIFO_END_PTR, (addr + s + PADDINGSIZE + 7) & ~7);
+
+    SET_MPEG_REG_MASK(VLD_MEM_VIFIFO_CONTROL, MEM_BUFCTRL_INIT);
+    CLEAR_MPEG_REG_MASK(VLD_MEM_VIFIFO_CONTROL, MEM_BUFCTRL_INIT);
+
+    WRITE_MPEG_REG(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_MANUAL);
+    WRITE_MPEG_REG(VLD_MEM_VIFIFO_WP, addr);
+
+    SET_MPEG_REG_MASK(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+    CLEAR_MPEG_REG_MASK(VLD_MEM_VIFIFO_BUF_CNTL, MEM_BUFCTRL_INIT);
+
+    SET_MPEG_REG_MASK(VLD_MEM_VIFIFO_CONTROL, MEM_FILL_ON_LEVEL | MEM_CTRL_FILL_EN | MEM_CTRL_EMPTY_EN);
+}
+static inline void feed_vb(s32 s)
+{
+	u32 addr = READ_MPEG_REG(VLD_MEM_VIFIFO_START_PTR);
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"feed start addr:0x%x\n",addr);
+	WRITE_MPEG_REG(VLD_MEM_VIFIFO_WP, (addr + s + PADDINGSIZE + 7) & ~7);
+}
+
+static int hardware_init(logo_object_t *plogo,int logo_size)
+{
+#ifdef CONFIG_AM_STREAMING
+	u32	*mc_addr_aligned = (u32 *)vmjpeg_mc;
+#endif
+	int ret = 0;
+	if(plogo->para.output_dev_type  <=LOGO_DEV_VID ) //now only support display on video layer.
+	{
+		if(plogo->para.output_dev_type < LOGO_DEV_VID)
+		plogo->need_transfer=TRUE;
+		else
+		plogo->need_transfer=FALSE;
+	}
+	else
+	{
+		return -EINVAL;
+	}
+	WRITE_MPEG_REG(RESET0_REGISTER, RESET_VCPU | RESET_CCPU);
+#ifdef CONFIG_AM_STREAMING
+	if (amvdec_loadmc(mc_addr_aligned) < 0) {
+		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"[jpeglogo]: Can not loading HW decoding ucode.\n");
+		return -EBUSY;
+	}
+#endif
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"load micro code completed\n");
+	jpeglogo_prot_init(plogo);
+
+	/*ret= request_irq(INT_MAILBOX_1A, jpeglogo_isr,
+                    IRQF_SHARED, "jpeglogo-irq", (void *)hardware_init);*/
+
+	if (ret) {
+        amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"jpeglogo_init irq register error.\n");
+        return -ENOENT;
+	}
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"jpeg irq request ok\n");
+	setup_vb((u32)virt_to_phys(plogo->para.mem_addr),logo_size);
+	WRITE_MPEG_REG(M4_CONTROL_REG, 0x0300);
+	WRITE_MPEG_REG(POWER_CTL_VLD, 0);
+	//set initial screen mode :
+
+
+	return SUCCESS;
+
+
+}
+
+static int jpeg_init(logo_object_t *plogo)
+{
+	int  logo_size;
+	void  __iomem* vaddr;
+	jpeg_private_t  *priv;
+
+	vaddr=(void  __iomem*)plogo->para.mem_addr;
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"logo vaddr:0x%p\n ",vaddr);
+	if((logo_size=parse_jpeg_info(vaddr,plogo)) <=0 )
+	return PARSER_UNFOUND;
+	vaddr = ioremap_wc((unsigned int)virt_to_phys(plogo->para.mem_addr), logo_size + PADDINGSIZE);
+	if(NULL==vaddr)
+	{
+		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"remapping logo data failed\n");
+		return  -ENOMEM;
+	}
+	priv=(jpeg_private_t  *)kmalloc(sizeof(jpeg_private_t),GFP_KERNEL);
+	if(IS_ERR(priv))
+	{
+		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"can't alloc memory for jpeg private data\n");
+		return  -ENOMEM;
+	}
+	memset(priv, 0, sizeof(jpeg_private_t));
+	priv->vf.width=plogo->parser->logo_pic_info.width;
+	priv->vf.height=plogo->parser->logo_pic_info.height;
+	plogo->parser->priv=priv;
+	g_jpeg_parser=priv;
+	priv->vaddr=vaddr;
+	swap_tailzero_data((u8 *)vaddr, logo_size);
+	if(hardware_init(plogo,logo_size) !=SUCCESS)
+	{
+		return PARSER_UNFOUND;
+	}
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"jpeg parser hardware init ok\n");
+	plogo->parser->logo_pic_info.size=logo_size;
+	return PARSER_FOUND;
+}
+static  int  thread_progress(void *para)
+{
+	logo_object_t *plogo=(logo_object_t*)para;
+	jpeg_private_t *priv=(jpeg_private_t*)plogo->parser->priv;
+	ulong timeout;
+
+	timeout = jiffies + HZ*8;
+	while (time_before(jiffies, timeout)) {
+		if (priv->state== PIC_FETCHED)
+		{
+#ifdef CONFIG_AM_VIDEO
+			vf_unreg_provider(&jpeglogo_vf_prov);
+#endif
+			kfree(priv);
+			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"logo fetched\n");
+			return SUCCESS;
+		}
+	}
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"logo unfetched\n");
+	return FAIL;
+}
+static  int  jpeg_decode(logo_object_t *plogo)
+{
+	ulong timeout;
+	jpeg_private_t *priv=(jpeg_private_t*)plogo->parser->priv;
+#ifdef CONFIG_AM_STREAMING
+	amvdec_start();
+#endif
+	feed_vb(plogo->parser->logo_pic_info.size);
+	timeout = jiffies + HZ * 2;//wait 2s
+
+	while (time_before(jiffies, timeout)) {
+		if (priv->state == PIC_DECODED) {
+			/* disable OSD layer to expose logo on video layer  */
+			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"[jpeglogo]: logo decoded.\n");
+			break;
+		}
+	}
+#ifdef CONFIG_AM_STREAMING
+	amvdec_stop();
+#endif
+	/*free_irq(INT_MAILBOX_1A, (void *)hardware_init);*/
+	if (priv->state > PIC_NA)
+	{
+		if(plogo->para.output_dev_type == LOGO_DEV_VID)
+		{
+#ifdef CONFIG_AM_VIDEO
+                     vf_provider_init(&jpeglogo_vf_prov, "jpeglogo_provider", &jpeglogo_vf_provider_op, NULL);
+			vf_reg_provider(&jpeglogo_vf_prov);
+#endif
+			kernel_thread(thread_progress, plogo, 0);
+		}else
+		{
+			plogo->parser->decoder.jpg.out_canvas_index=priv->canvas_index;
+			kfree(priv);
+		}
+
+	}
+	else
+	{
+		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"deocod jpeg uncompleted\n");
+		return FAIL;
+	}
+	return SUCCESS;
+}
+static int  jpeg_deinit(logo_object_t *plogo)
+{
+	jpeg_private_t	*priv=(jpeg_private_t*)plogo->parser->priv;
+
+	if(priv)
+	{
+		if(priv->vaddr)
+		{
+			iounmap(priv->vaddr);
+		}
+	}
+	return SUCCESS;
+}
+int jpeg_setup(void)
+{
+	register_logo_parser(&logo_jpeg_parser);
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"jpeg parser setup\n");
+	return SUCCESS;
+}
diff --git a/drivers/amlogic/display/aml_logo/logo_parse/logo_parse.c b/drivers/amlogic/display/aml_logo/logo_parse/logo_parse.c
old mode 100644
new mode 100755
index b49cca8c..77116b08
--- a/drivers/amlogic/display/aml_logo/logo_parse/logo_parse.c
+++ b/drivers/amlogic/display/aml_logo/logo_parse/logo_parse.c
@@ -1,124 +1,124 @@
-/*******************************************************************
- *
- *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- *
- *  Description:
- *		this file decode logo data according to it's type.
- *
- *  Author: Amlogic Software
- *  Created: 2010/4/1   19:46
- *
- *******************************************************************/
-#include  "logo.h"
- #include	"amlogo_log.h"
-#include  <linux/amlogic/amlog.h>
-//#define SETUP_SELF_RAISE
-
-static  LIST_HEAD(parser_line);
-
-#ifdef   SETUP_SELF_RAISE 
-static  parser_list_t aml_parser[MAX_PIC_TYPE];
-#endif
-
-void (*Power_on_bl)(void);
-EXPORT_SYMBOL(Power_on_bl);
-
-int  register_logo_parser(logo_parser_t* new_parser)
-{
-
-	parser_list_t  *pitem;
-
-#ifdef   SETUP_SELF_RAISE   
-	static int count=0;
-	pitem=&aml_parser[count++];
-#else
-	pitem=kmalloc(sizeof(parser_list_t),GFP_KERNEL);
-#endif
-
-	pitem->parser=new_parser;
-	list_add_tail(&pitem->list,&parser_line);
-	return SUCCESS;
-}
-static int  all_parser_setup(void)
-{
-	bmp_setup();
-	jpeg_setup();
-	return SUCCESS;
-}
- int start_logo(void)
- {
-	parser_list_t  *pitem;
-	logo_object_t *plogo=&aml_logo;
-	int  found=0;
-	int  ret=0 ;
-	if(0!=strcmp(plogo->name,LOGO_NAME)){   
-	    ret = -LOGO_PARA_UNPARSED;
-        goto start_logo_fail;
-	} 
-	if ((ret=setup_output_device(plogo))!=SUCCESS)//we will use this device to get display info
-	{						//for examble: width height 
-        goto start_logo_fail;
-	}
-	if(plogo->para.loaded) //if logo be loaded by uboot or other loader.then return
-	return SUCCESS;
-
-	all_parser_setup();	
-	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"start decode logo\n");	
-	list_for_each_entry(pitem,&parser_line,list){
-		if(pitem->parser->op.init(plogo)==PARSER_FOUND)	
-		{
-			found=1;
-			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_HIGH,"parser found,logo type:%s\n",pitem->parser->name);
-			break;
-		}
-	}
-	if(0==found){   
-	    ret = -ENOPARSER;
-        goto start_logo_fail;
-	}
-	
-	if(plogo->parser->op.decode(plogo))
-	{
-		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_HIGH,"decode logo picture fail\n")	;
-	    ret = -PARSER_DECODE_FAIL;
-        goto start_logo_fail;		
-	}
-	plogo->dev->op.transfer(plogo);
-	plogo->dev->op.deinit();
-	plogo->parser->op.deinit(plogo);
-
-	if (Power_on_bl)
-		Power_on_bl();
-		
-	return SUCCESS;	
-	
-start_logo_fail:
-	if (Power_on_bl)
-		Power_on_bl();
-		
-	return ret;	
-
- }
- int exit_logo(logo_object_t *logo)
- {
- 	return 0;
- }
-int  unregister_logo_parser(void)
-{
-	parser_list_t  *pitem,*tmp;
-	logo_object_t *plogo=&aml_logo;
-
-	list_for_each_entry_safe(pitem,tmp,&parser_line,list){
-		if(pitem)  
-		{
-			pitem->parser->op.deinit(plogo);
-			list_del(&pitem->list );
-#ifndef   SETUP_SELF_RAISE 
-			kfree(pitem);
-#endif			
-			
-		}
-	}
-	return SUCCESS;
-}
-subsys_initcall(start_logo);
+/*******************************************************************
+ *
+ *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *		this file decode logo data according to it's type.
+ *
+ *  Author: Amlogic Software
+ *  Created: 2010/4/1   19:46
+ *
+ *******************************************************************/
+#include  "logo.h"
+ #include	"amlogo_log.h"
+#include  <linux/amlogic/amlog.h>
+//#define SETUP_SELF_RAISE
+
+static  LIST_HEAD(parser_line);
+
+#ifdef   SETUP_SELF_RAISE
+static  parser_list_t aml_parser[MAX_PIC_TYPE];
+#endif
+
+void (*Power_on_bl)(void);
+EXPORT_SYMBOL(Power_on_bl);
+
+int  register_logo_parser(logo_parser_t* new_parser)
+{
+
+	parser_list_t  *pitem;
+
+#ifdef   SETUP_SELF_RAISE
+	static int count=0;
+	pitem=&aml_parser[count++];
+#else
+	pitem=kmalloc(sizeof(parser_list_t),GFP_KERNEL);
+#endif
+
+	pitem->parser=new_parser;
+	list_add_tail(&pitem->list,&parser_line);
+	return SUCCESS;
+}
+static int  all_parser_setup(void)
+{
+	bmp_setup();
+	jpeg_setup();
+	return SUCCESS;
+}
+ int start_logo(void)
+ {
+	parser_list_t  *pitem;
+	logo_object_t *plogo=&aml_logo;
+	int  found=0;
+	int  ret=0 ;
+	if(0!=strcmp(plogo->name,LOGO_NAME)){
+	    ret = -LOGO_PARA_UNPARSED;
+        goto start_logo_fail;
+	}
+	if ((ret=setup_output_device(plogo))!=SUCCESS)//we will use this device to get display info
+	{						//for examble: width height
+        goto start_logo_fail;
+	}
+	if(plogo->para.loaded) //if logo be loaded by uboot or other loader.then return
+	return SUCCESS;
+
+	all_parser_setup();
+	amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_LOW,"start decode logo\n");
+	list_for_each_entry(pitem,&parser_line,list){
+		if(pitem->parser->op.init(plogo)==PARSER_FOUND)
+		{
+			found=1;
+			amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_HIGH,"parser found,logo type:%s\n",pitem->parser->name);
+			break;
+		}
+	}
+	if(0==found){
+	    ret = -ENOPARSER;
+        goto start_logo_fail;
+	}
+
+	if(plogo->parser->op.decode(plogo))
+	{
+		amlog_mask_level(LOG_MASK_PARSER,LOG_LEVEL_HIGH,"decode logo picture fail\n")	;
+	    ret = -PARSER_DECODE_FAIL;
+        goto start_logo_fail;
+	}
+	plogo->dev->op.transfer(plogo);
+	plogo->dev->op.deinit();
+	plogo->parser->op.deinit(plogo);
+
+	if (Power_on_bl)
+		Power_on_bl();
+
+	return SUCCESS;
+
+start_logo_fail:
+	if (Power_on_bl)
+		Power_on_bl();
+
+	return ret;
+
+ }
+ int exit_logo(logo_object_t *logo)
+ {
+	return 0;
+ }
+int  unregister_logo_parser(void)
+{
+	parser_list_t  *pitem,*tmp;
+	logo_object_t *plogo=&aml_logo;
+
+	list_for_each_entry_safe(pitem,tmp,&parser_line,list){
+		if(pitem)
+		{
+			pitem->parser->op.deinit(plogo);
+			list_del(&pitem->list );
+#ifndef   SETUP_SELF_RAISE
+			kfree(pitem);
+#endif
+
+		}
+	}
+	return SUCCESS;
+}
+subsys_initcall(start_logo);
diff --git a/drivers/amlogic/display/backlight/aml.dtd b/drivers/amlogic/display/backlight/aml.dtd
index c0e5097a..633a6b98 100755
--- a/drivers/amlogic/display/backlight/aml.dtd
+++ b/drivers/amlogic/display/backlight/aml.dtd
@@ -9,7 +9,7 @@
 //$$ L2 PROP_U32 2= "bl_level_max_min"
 //$$ L2 PROP_U32 = "bl_power_on_delay"
 //$$ L2 PROP_U32 = "bl_ctrl_method"
-//$$ L2 PROP_STR = "bl_gpio_port"
+//$$ L2 PROP_STR = "bl_gpio_port_on_off"
 //$$ L2 PROP_U32 2 = "bl_gpio_dim_max_min"
 //$$ L2 PROP_STR 2 = "bl_pwm_port_gpio_used"
 //$$ L2 PROP_U32 = "bl_pwm_freq"
@@ -26,21 +26,21 @@
 		pinctrl-names = "default","pwm_combo";
 		pinctrl-0 = <&lcd_backlight_pins>;	/** pwm_default pinmux */
 		pinctrl-1 = <&lcd_backlight_combo_pins>;	/** pwm_combo pinmux */
-		
+
 		bl_level_default_uboot_kernel=<10 102>;	/** default brightness level for uboot & kernel */
 		bl_level_middle_mapping=<128 102>;	/** brightness middle level mapping to a new level*/
 		bl_level_max_min=<255 10>;	/** brightness level max & min, must match the rootfs setting*/
-		
+
 		/* backlight power ctrl */
 		bl_power_on_delay=<200>; /** delay time before backlight power on(unit: ms) */
 		bl_ctrl_method=<1>;	/** backlight control method(0=gpio, 1=pwm_negative, 2=pwm_positive. 3=pwm_combo. 4=extern. decided by hardware design) */
-		
-		bl_gpio_port="GPIODV_28";	/** backlight control gpio port */
+
+		bl_gpio_port_on_off="GPIODV_28","1","0";	/** backlight control gpio port, (on/off:1=output high, 0=output low, 2=input) */
 		bl_gpio_dim_max_min=<0x0 0xf>;	/** brightness diming level_max, level_min : (0x0~0xf, negative logic, only for gpio control method) */
 		bl_pwm_port_gpio_used="PWM_C","1";	/** pwm_port_name(for pwm control method), pwm_gpio_used(0=use pwm_port only, 1=use bl_gpio_port to control on/off) */
 		bl_pwm_freq=<1000>;	/** backlight control pwm frequency(unit: Hz, only for pwm control method) */
 		bl_pwm_duty_max_min=<100 25>;	/** brightness diminig duty_max, duty_min : (unit: %, positive logic, only for pwm control method) */
-		
+
 		/** backlight pwm_combo control: low_duty_max is always active for level_high, and high_duty_min is always active for level_low */
 		bl_pwm_combo_high_low_level_switch=<102>;	/** backlight pwm_combo control switch level */
 		bl_pwm_combo_high_port_method="PWM_C","1";	/** backlight pwm_combo high port name, pwm control method(1=pwm_negative, 2=pwm_positive) */
diff --git a/drivers/amlogic/display/backlight/aml_bl.c b/drivers/amlogic/display/backlight/aml_bl.c
old mode 100644
new mode 100755
index 71190a14..3738b25f
--- a/drivers/amlogic/display/backlight/aml_bl.c
+++ b/drivers/amlogic/display/backlight/aml_bl.c
@@ -16,7 +16,7 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
  *
  * Author:  Wang Han <han.wang@amlogic.com>
- *  
+ *
  * Modify:  Evoke Zhang <evoke.zhang@amlogic.com>
  * compatible dts
  */
@@ -43,6 +43,7 @@
 #include <linux/amlogic/aml_lcd_bl.h>
 #include <linux/amlogic/aml_bl_extern.h>
 #endif
+#include <linux/amlogic/vout/lcdoutc.h>
 
 //#define MESON_BACKLIGHT_DEBUG
 #ifdef MESON_BACKLIGHT_DEBUG
@@ -87,6 +88,10 @@ typedef enum {
     BL_PWM_B,
     BL_PWM_C,
     BL_PWM_D,
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+    BL_PWM_E,
+    BL_PWM_F,
+#endif
     BL_PWM_MAX,
 } BL_PWM_t;
 
@@ -100,6 +105,8 @@ typedef struct {
     unsigned char method;
 
     int gpio;
+    unsigned char gpio_on;
+    unsigned char gpio_off;
     unsigned dim_max;
     unsigned dim_min;
     unsigned char pwm_port;
@@ -175,7 +182,7 @@ static void power_on_bl(int bl_flag)
             aml_set_reg32_bits(P_LED_PWM_REG0, 1, 12, 2);
 #endif
             mdelay(20);
-            bl_gpio_direction_output(bl_config.gpio, 1);
+            bl_gpio_direction_output(bl_config.gpio, bl_config.gpio_on);
             break;
         case BL_CTL_PWM_NEGATIVE:
         case BL_CTL_PWM_POSITIVE:
@@ -204,6 +211,20 @@ static void power_on_bl(int bl_flag)
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 23, 1);  //pwm_d_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 1, 1);  //enable pwm_d
                     break;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                case BL_PWM_E:
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bl_config.pwm_pre_div, 8, 7);  //pwm_c_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 4, 2);  //pwm_c_clk_sel
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 15, 1);  //pwm_c_clk_en
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 0, 1);  //enable pwm_c
+                    break;
+                case BL_PWM_F:
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bl_config.pwm_pre_div, 16, 7);  //pwm_d_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 6, 2);  //pwm_d_clk_sel
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 23, 1);  //pwm_d_clk_en
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 1, 1);  //enable pwm_d
+                    break;
+#endif
                 default:
                     break;
             }
@@ -228,7 +249,7 @@ static void power_on_bl(int bl_flag)
             mdelay(20);
             if (bl_config.pwm_gpio_used) {
                 if (bl_config.gpio)
-                    bl_gpio_direction_output(bl_config.gpio, 1);
+                    bl_gpio_direction_output(bl_config.gpio, bl_config.gpio_on);
             }
             break;
         case BL_CTL_PWM_COMBO:
@@ -257,6 +278,20 @@ static void power_on_bl(int bl_flag)
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 23, 1);  //pwm_d_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 1, 1);  //enable pwm_d
                     break;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                case BL_PWM_E:
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bl_config.combo_high_pre_div, 8, 7);  //pwm_c_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 4, 2);  //pwm_c_clk_sel
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 15, 1);  //pwm_c_clk_en
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 0, 1);  //enable pwm_c
+                    break;
+                case BL_PWM_F:
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bl_config.combo_high_pre_div, 16, 7);  //pwm_d_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 6, 2);  //pwm_d_clk_sel
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 23, 1);  //pwm_d_clk_en
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 1, 1);  //enable pwm_d
+                    break;
+#endif
                 default:
                     break;
             }
@@ -285,6 +320,20 @@ static void power_on_bl(int bl_flag)
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 23, 1);  //pwm_d_clk_en
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 1, 1, 1);  //enable pwm_d
                     break;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                case BL_PWM_E:
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bl_config.combo_low_pre_div, 8, 7);  //pwm_c_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 4, 2);  //pwm_c_clk_sel
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 15, 1);  //pwm_c_clk_en
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 0, 1);  //enable pwm_c
+                    break;
+                case BL_PWM_F:
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, bl_config.combo_low_pre_div, 16, 7);  //pwm_d_clk_div
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 6, 2);  //pwm_d_clk_sel
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 23, 1);  //pwm_d_clk_en
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 1, 1, 1);  //enable pwm_d
+                    break;
+#endif
                 default:
                     break;
             }
@@ -388,13 +437,13 @@ void bl_power_off(int bl_flag)
 
     switch (bl_config.method) {
         case BL_CTL_GPIO:
-            bl_gpio_direction_output(bl_config.gpio, 0);
+            bl_gpio_direction_output(bl_config.gpio, bl_config.gpio_off);
             break;
         case BL_CTL_PWM_NEGATIVE:
         case BL_CTL_PWM_POSITIVE:
             if (bl_config.pwm_gpio_used) {
                 if (bl_config.gpio)
-                    bl_gpio_direction_output(bl_config.gpio, 0);
+                    bl_gpio_direction_output(bl_config.gpio, bl_config.gpio_off);
             }
             switch (bl_config.pwm_port) {
                 case BL_PWM_A:
@@ -409,6 +458,14 @@ void bl_power_off(int bl_flag)
                 case BL_PWM_D:
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 1, 1);  //disable pwm_d
                     break;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                case BL_PWM_E:
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 0, 1);  //disable pwm_c
+                    break;
+                case BL_PWM_F:
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 1, 1);  //disable pwm_d
+                    break;
+#endif
                 default:
                     break;
             }
@@ -427,6 +484,14 @@ void bl_power_off(int bl_flag)
                 case BL_PWM_D:
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 1, 1);  //disable pwm_d
                     break;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                case BL_PWM_E:
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 0, 1);  //disable pwm_c
+                    break;
+                case BL_PWM_F:
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 1, 1);  //disable pwm_d
+                    break;
+#endif
                 default:
                     break;
             }
@@ -443,6 +508,14 @@ void bl_power_off(int bl_flag)
                 case BL_PWM_D:
                     aml_set_reg32_bits(P_PWM_MISC_REG_CD, 0, 1, 1);  //disable pwm_d
                     break;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                case BL_PWM_E:
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 0, 1);  //disable pwm_c
+                    break;
+                case BL_PWM_F:
+                    aml_set_reg32_bits(P_PWM_MISC_REG_EF, 0, 1, 1);  //disable pwm_d
+                    break;
+#endif
                 default:
                     break;
             }
@@ -527,6 +600,14 @@ static void set_backlight_level(unsigned level)
                     case BL_PWM_D:
                         aml_write_reg32(P_PWM_PWM_D, (pwm_hi << 16) | (pwm_lo));
                         break;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                    case BL_PWM_E:
+                        aml_write_reg32(P_PWM_PWM_E, (pwm_hi << 16) | (pwm_lo));
+                        break;
+                    case BL_PWM_F:
+                        aml_write_reg32(P_PWM_PWM_F, (pwm_hi << 16) | (pwm_lo));
+                        break;
+#endif
                     default:
                         break;
                 }
@@ -555,6 +636,14 @@ static void set_backlight_level(unsigned level)
                         case BL_PWM_D:
                             aml_write_reg32(P_PWM_PWM_D, (pwm_hi << 16) | (pwm_lo));
                             break;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                        case BL_PWM_E:
+                            aml_write_reg32(P_PWM_PWM_E, (pwm_hi << 16) | (pwm_lo));
+                            break;
+                        case BL_PWM_F:
+                            aml_write_reg32(P_PWM_PWM_F, (pwm_hi << 16) | (pwm_lo));
+                            break;
+#endif
                         default:
                             break;
                     }
@@ -582,6 +671,14 @@ static void set_backlight_level(unsigned level)
                         case BL_PWM_D:
                             aml_write_reg32(P_PWM_PWM_D, (pwm_hi << 16) | (pwm_lo));
                             break;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                        case BL_PWM_E:
+                            aml_write_reg32(P_PWM_PWM_E, (pwm_hi << 16) | (pwm_lo));
+                            break;
+                        case BL_PWM_F:
+                            aml_write_reg32(P_PWM_PWM_F, (pwm_hi << 16) | (pwm_lo));
+                            break;
+#endif
                         default:
                             break;
                     }
@@ -609,6 +706,14 @@ static void set_backlight_level(unsigned level)
                         case BL_PWM_D:
                             aml_write_reg32(P_PWM_PWM_D, (pwm_hi << 16) | (pwm_lo));
                             break;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                        case BL_PWM_E:
+                            aml_write_reg32(P_PWM_PWM_E, (pwm_hi << 16) | (pwm_lo));
+                            break;
+                        case BL_PWM_F:
+                            aml_write_reg32(P_PWM_PWM_F, (pwm_hi << 16) | (pwm_lo));
+                            break;
+#endif
                         default:
                             break;
                     }
@@ -636,6 +741,14 @@ static void set_backlight_level(unsigned level)
                         case BL_PWM_D:
                             aml_write_reg32(P_PWM_PWM_D, (pwm_hi << 16) | (pwm_lo));
                             break;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                        case BL_PWM_E:
+                            aml_write_reg32(P_PWM_PWM_E, (pwm_hi << 16) | (pwm_lo));
+                            break;
+                        case BL_PWM_F:
+                            aml_write_reg32(P_PWM_PWM_F, (pwm_hi << 16) | (pwm_lo));
+                            break;
+#endif
                         default:
                             break;
                     }
@@ -1031,9 +1144,9 @@ static inline int _get_backlight_config(struct platform_device *pdev)
         DPRINT("bl control_method: %s(%u)\n", bl_ctrl_method_table[bl_config.method], bl_config.method);
 
         if (bl_config.method == BL_CTL_GPIO) {
-            ret = of_property_read_string(pdev->dev.of_node, "bl_gpio_port", &str);
+            ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 0, &str);
             if (ret) {
-                printk("faild to get bl_gpio_port!\n");
+                printk("faild to get bl_gpio_port_on_off!\n");
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
                 str = "GPIOD_1";
 #elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
@@ -1046,12 +1159,39 @@ static inline int _get_backlight_config(struct platform_device *pdev)
                 if (ret) {
                     printk("faild to alloc bl gpio (%s)!\n", str);
                 }
-                bl_config.gpio = val;
+                bl_config.gpio = val;                
                 DPRINT("bl gpio = %s(%d)\n", str, bl_config.gpio);
             }
             else {
                 bl_config.gpio = -1;
             }
+            ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 1, &str);
+            if (ret) {
+                printk("faild to get bl_gpio_port_on!\n");
+                bl_config.gpio_on = LCD_POWER_GPIO_OUTPUT_HIGH;
+            }
+            else {
+                if (strcmp(str, "2") == 0)
+                    bl_config.gpio_on = LCD_POWER_GPIO_INPUT;
+                else if(strcmp(str, "0") == 0)
+                    bl_config.gpio_on = LCD_POWER_GPIO_OUTPUT_LOW;
+                else
+                    bl_config.gpio_on = LCD_POWER_GPIO_OUTPUT_HIGH;
+            }
+            ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 2, &str);
+            if (ret) {
+                printk("faild to get bl_gpio_port_off!\n");
+                bl_config.gpio_off = LCD_POWER_GPIO_OUTPUT_LOW;
+            }
+            else {
+                if (strcmp(str, "2") == 0)
+                    bl_config.gpio_off = LCD_POWER_GPIO_INPUT;
+                else if(strcmp(str, "1") == 0)
+                    bl_config.gpio_off = LCD_POWER_GPIO_OUTPUT_HIGH;
+                else
+                    bl_config.gpio_off = LCD_POWER_GPIO_OUTPUT_LOW;
+            }
+            DPRINT("bl gpio_on=%u, bl gpio_off=%u\n", bl_config.gpio_on, bl_config.gpio_off);
             ret = of_property_read_u32_array(pdev->dev.of_node,"bl_gpio_dim_max_min",&bl_para[0],2);
             if (ret) {
                 printk("faild to get bl_gpio_dim_max_min\n");
@@ -1078,9 +1218,9 @@ static inline int _get_backlight_config(struct platform_device *pdev)
                 DPRINT("bl_pwm gpio_used: %u\n", bl_config.pwm_gpio_used);
             }
             if (bl_config.pwm_gpio_used == 1) {
-                ret = of_property_read_string(pdev->dev.of_node, "bl_gpio_port", &str);
+                ret = of_property_read_string(pdev->dev.of_node, "bl_gpio_port_on_off", &str);
                 if (ret) {
-                    printk("faild to get bl_gpio_port!\n");
+                    printk("faild to get bl_gpio_port_on_off!\n");
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6)
                     str = "GPIOD_1";
 #elif ((MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B))
@@ -1099,7 +1239,34 @@ static inline int _get_backlight_config(struct platform_device *pdev)
                 else {
                     bl_config.gpio = -1;
                 }
+                          ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 1, &str);
+            if (ret) {
+                printk("faild to get bl_gpio_port_on!\n");
+                bl_config.gpio_on = LCD_POWER_GPIO_OUTPUT_HIGH;
+            }
+            else {
+                if (strcmp(str, "2") == 0)
+                    bl_config.gpio_on = LCD_POWER_GPIO_INPUT;
+                else if(strcmp(str, "0") == 0)
+                    bl_config.gpio_on = LCD_POWER_GPIO_OUTPUT_LOW;
+                else
+                    bl_config.gpio_on = LCD_POWER_GPIO_OUTPUT_HIGH;
+            }
+            ret = of_property_read_string_index(pdev->dev.of_node, "bl_gpio_port_on_off", 2, &str);
+            if (ret) {
+                printk("faild to get bl_gpio_port_off!\n");
+                bl_config.gpio_off = LCD_POWER_GPIO_OUTPUT_LOW;
+            }
+            else {
+                if (strcmp(str, "2") == 0)
+                    bl_config.gpio_off = LCD_POWER_GPIO_INPUT;
+                else if(strcmp(str, "1") == 0)
+                    bl_config.gpio_off = LCD_POWER_GPIO_OUTPUT_HIGH;
+                else
+                    bl_config.gpio_off = LCD_POWER_GPIO_OUTPUT_LOW;
             }
+            DPRINT("gpio_on=%u, gpio_off=%u\n", bl_config.gpio_on, bl_config.gpio_off);
+          }
             ret = of_property_read_string_index(pdev->dev.of_node, "bl_pwm_port_gpio_used", 0, &str);
             if (ret) {
                 printk("faild to get bl_pwm_port_gpio_used!\n");
@@ -1120,6 +1287,12 @@ static inline int _get_backlight_config(struct platform_device *pdev)
                     bl_config.pwm_port = BL_PWM_C;
                 else if (strcmp(str, "PWM_D") == 0)
                     bl_config.pwm_port = BL_PWM_D;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                else if (strcmp(str, "PWM_E") == 0)
+                    bl_config.pwm_port = BL_PWM_E;
+                else if (strcmp(str, "PWM_F") == 0)
+                    bl_config.pwm_port = BL_PWM_F;
+#endif
                 else
                     bl_config.pwm_port = BL_PWM_MAX;
                 DPRINT("bl pwm_port: %s(%u)\n", str, bl_config.pwm_port);
@@ -1153,7 +1326,7 @@ static inline int _get_backlight_config(struct platform_device *pdev)
             }
             bl_config.pwm_max = (bl_config.pwm_cnt * bl_para[0] / 100);
             bl_config.pwm_min = (bl_config.pwm_cnt * bl_para[1] / 100);
-            DPRINT("bl pwm_duty max=%u\%, min=%u\%\n", bl_para[0], bl_para[1]);
+            DPRINT("bl pwm_duty max=%u%%, min=%u%%\n", bl_para[0], bl_para[1]);
         }
         else if (bl_config.method == BL_CTL_PWM_COMBO) {
             ret = of_property_read_u32(pdev->dev.of_node,"bl_pwm_combo_high_low_level_switch",&val);
@@ -1182,6 +1355,12 @@ static inline int _get_backlight_config(struct platform_device *pdev)
                     bl_config.combo_high_port = BL_PWM_C;
                 else if (strcmp(str, "PWM_D") == 0)
                     bl_config.combo_high_port = BL_PWM_D;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                else if (strcmp(str, "PWM_E") == 0)
+                    bl_config.pwm_port = BL_PWM_E;
+                else if (strcmp(str, "PWM_F") == 0)
+                    bl_config.pwm_port = BL_PWM_F;
+#endif
                 else
                     bl_config.combo_high_port = BL_PWM_MAX;
             }
@@ -1214,6 +1393,12 @@ static inline int _get_backlight_config(struct platform_device *pdev)
                     bl_config.combo_low_port = BL_PWM_C;
                 else if (strcmp(str, "PWM_D") == 0)
                     bl_config.combo_low_port = BL_PWM_D;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+                else if (strcmp(str, "PWM_E") == 0)
+                    bl_config.pwm_port = BL_PWM_E;
+                else if (strcmp(str, "PWM_F") == 0)
+                    bl_config.pwm_port = BL_PWM_F;
+#endif
                 else
                     bl_config.combo_low_port = BL_PWM_MAX;
             }
@@ -1249,7 +1434,7 @@ static inline int _get_backlight_config(struct platform_device *pdev)
             bl_config.combo_high_pre_div = pwm_pre_div;
             bl_config.combo_high_duty_max = (bl_config.combo_high_cnt * bl_para[1] / 100);
             bl_config.combo_high_duty_min = (bl_config.combo_high_cnt * bl_para[2] / 100);
-            DPRINT("bl pwm_combo high freq=%uHz, duty_max=%u\%, duty_min=%u\%\n", pwm_freq, bl_para[1], bl_para[2]);
+            DPRINT("bl pwm_combo high freq=%uHz, duty_max=%u%%, duty_min=%u%%\n", pwm_freq, bl_para[1], bl_para[2]);
             ret = of_property_read_u32_array(pdev->dev.of_node,"bl_pwm_combo_low_freq_duty_max_min",&bl_para[0],3);
             if (ret) {
                 printk("faild to get bl_pwm_combo_low_freq_duty_max_min\n");
@@ -1268,7 +1453,7 @@ static inline int _get_backlight_config(struct platform_device *pdev)
             bl_config.combo_low_pre_div = pwm_pre_div;
             bl_config.combo_low_duty_max = (bl_config.combo_low_cnt * bl_para[1] / 100);
             bl_config.combo_low_duty_min = (bl_config.combo_low_cnt * bl_para[2] / 100);
-            DPRINT("bl pwm_combo low freq=%uHz, duty_max=%u\%, duty_min=%u\%\n", pwm_freq, bl_para[1], bl_para[2]);
+            DPRINT("bl pwm_combo low freq=%uHz, duty_max=%u%%, duty_min=%u%%\n", pwm_freq, bl_para[1], bl_para[2]);
         }
 
         //pinmux
@@ -1285,7 +1470,7 @@ static inline int _get_backlight_config(struct platform_device *pdev)
 static struct class *bl_debug_class = NULL;
 static ssize_t bl_status_read(struct class *class, struct class_attribute *attr, char *buf)
 {
-	return sprintf(buf, "read backlight status: bl_real_status=%s(%d), bl_status=%s(%d), bl_level=%d\n", (bl_real_status ? "ON" : "OFF"), bl_real_status, 
+	return sprintf(buf, "read backlight status: bl_real_status=%s(%d), bl_status=%s(%d), bl_level=%d\n", (bl_real_status ? "ON" : "OFF"), bl_real_status,
 						((bl_status == 0) ? "OFF" : ((bl_status == 1) ? "lcd_on_bl_off" : "lcd_on_bl_on")), bl_status, bl_level);
 }
 
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/Makefile b/drivers/amlogic/display/backlight/aml_bl_extern/Makefile
index 9d057e56..e164adfd 100644
--- a/drivers/amlogic/display/backlight/aml_bl_extern/Makefile
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/Makefile
@@ -3,4 +3,3 @@ obj-y	+= aml_bl_extern.o
 obj-y	+= i2c_lp8556.o
 obj-y	+= pmu_aml1218.o
 obj-y	+= mipi_LT070ME05.o
-
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/aml.dtd b/drivers/amlogic/display/backlight/aml_bl_extern/aml.dtd
index b1e0ce99..6d4ed122 100755
--- a/drivers/amlogic/display/backlight/aml_bl_extern/aml.dtd
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/aml.dtd
@@ -6,7 +6,7 @@
 //******************************************************************************
 //$$ DEVICE = "bl_extern_pmu_aml1218"
 //$$ L2 PROP_STR = "status"
-//$$ L2 PROP_STR 2 = "gpio_enable"
+//$$ L2 PROP_STR 2 = "gpio_enable_on_off"
 //$$ L2 PROP_U32 = "type"
 //$$ L2 PROP_U32 2 = "dim_max_min"
 	bl_extern_pmu_aml1218{
@@ -14,14 +14,14 @@
 		dev_name ="bl_pmu_aml1218";
 		status = "disabled"; /** "disabled" or "okay" */
 
-		gpio_enable = "GPIODV_28"; /** "n" for none */
+		gpio_enable_on_off = "GPIODV_28","1","0"; /** gpio("n"for none), on/off(1=output high, 0=output low, 2=input)*/
 		type = <2>;	/** bl_extern_driver type: 0=i2c, 1=spi, 2=other */
 		dim_max_min = <0x1 0x1b>;
 	};
 
 //$$ DEVICE = "bl_extern_i2c_lp8556"
 //$$ L2 PROP_STR = "status"
-//$$ L2 PROP_STR 2 = "gpio_enable"
+//$$ L2 PROP_STR 2 = "gpio_enable_on_off"
 //$$ L2 PROP_U32 = "type"
 //$$ L2 PROP_STR = "i2c_bus"
 //$$ L2 PROP_U32 2 = "dim_max_min"
@@ -30,7 +30,7 @@
 		dev_name ="bl_i2c_lp8556";
 		status = "disabled"; /** "disabled" or "okay" */
 
-		gpio_enable = "GPIODV_28"; /** "n" for none */
+		gpio_enable_on_off = "GPIODV_28","1","0"; /** gpio("n"for none), on/off(1=output high, 0=output low, 2=input)*/
 		type = <0>;	/** bl_extern_driver type: 0=i2c, 1=spi, 2=other */
 		i2c_address = <0x2c>; /** 7bit i2c address */
 		i2c_bus = "i2c_bus_b";
@@ -39,7 +39,7 @@
 
 //$$ DEVICE = "bl_extern_mipi_LT070ME05"
 //$$ L2 PROP_STR = "status"
-//$$ L2 PROP_STR 2 = "gpio_enable"
+//$$ L2 PROP_STR 2 = "gpio_enable_on_off"
 //$$ L2 PROP_U32 = "type"
 //$$ L2 PROP_U32 2 = "dim_max_min"
 	bl_extern_mipi_LT070ME05{
@@ -47,7 +47,7 @@
 		dev_name ="bl_mipi_LT070ME056";
 		status = "disabled"; /** "disabled" or "okay" */
 
-		gpio_enable = "GPIODV_28"; /** "n" for none */
+		gpio_enable_on_off = "GPIODV_28","1","0"; /** gpio("n"for none), on/off(1=output high, 0=output low, 2=input)*/
 		type = <2>;	/** bl_extern_driver type: 0=i2c, 1=spi, 2=other */
 		dim_max_min = <255 10>;
 	};
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/aml_bl_extern.c b/drivers/amlogic/display/backlight/aml_bl_extern/aml_bl_extern.c
index 93b4b6bf..f7167fb4 100644
--- a/drivers/amlogic/display/backlight/aml_bl_extern/aml_bl_extern.c
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/aml_bl_extern.c
@@ -1,198 +1,224 @@
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-#include <linux/i2c-aml.h>
-#include <linux/clk.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/of.h>
-#include <mach/am_regs.h>
-#include <mach/gpio.h>
-#include <linux/amlogic/aml_bl_extern.h>
-
-//#define BL_EXT_DEBUG_INFO
-#ifdef BL_EXT_DEBUG_INFO
-#define DBG_PRINT(...)		printk(__VA_ARGS__)
-#else
-#define DBG_PRINT(...)
-#endif
-
-static struct aml_bl_extern_driver_t bl_ext_driver = {
-    .type = BL_EXTERN_MAX,
-    .name = NULL,
-    .power_on = NULL,
-    .power_off = NULL,
-    .set_level = NULL,
-
-};
-
-struct aml_bl_extern_driver_t* aml_bl_extern_get_driver(void)
-{
-    return &bl_ext_driver;
-}
-
-int bl_extern_driver_check(void)
-{
-    struct aml_bl_extern_driver_t* bl_ext;
-
-    bl_ext = aml_bl_extern_get_driver();
-    if (bl_ext) {
-        if (bl_ext->type < BL_EXTERN_MAX) {
-            printk("[warning]: bl_extern has already exist (%s)\n", bl_ext->name);
-            return -1;
-        }
-    }
-    else {
-        printk("get bl_extern_driver failed\n");
-    }
-    
-    return 0;
-}
-
-int get_bl_extern_dt_data(struct device_node* of_node, struct bl_extern_config_t *pdata)
-{
-    int ret;
-    int val;
-    unsigned int bl_para[2];
-    const char *str;
-
-    ret = of_property_read_string(of_node, "dev_name", (const char **)&pdata->name);
-    if (ret) {
-        pdata->name = "aml_bl_extern";
-        printk("warning: get dev_name failed\n");
-    }
-
-    ret = of_property_read_u32(of_node, "type", &pdata->type);
-    if (ret) {
-        pdata->type = BL_EXTERN_MAX;
-        printk("%s warning: get type failed, exit\n", pdata->name);
-        return -1;
-    }
-    pdata->gpio_used = 0;
-    pdata->gpio = GPIO_MAX;
-    ret = of_property_read_string(of_node, "gpio_enable", &str);
-    if (ret) {
-        printk("%s warning: get gpio_enable failed\n", pdata->name);
-    }
-    else {
-        if (strncmp(str, "G", 1) == 0) {//"GPIO_xx"
-                pdata->gpio_used = 1;
-                val = amlogic_gpio_name_map_num(str);
-                ret = bl_extern_gpio_request(val);
-                if (ret) {
-                    printk("%s warning: faild to alloc gpio (%s)\n", pdata->name, str);
-                }
-                pdata->gpio = val;
-        }
-        DBG_PRINT("%s: gpio_enable %s\n", pdata->name, ((pdata->gpio_used) ? str:"none"));
-    }
-    switch (pdata->type) {
-        case BL_EXTERN_I2C:
-            ret = of_property_read_u32(of_node,"i2c_address",&pdata->i2c_addr);
-            if (ret) {
-                printk("%s warning: get i2c_address failed\n", pdata->name);
-                pdata->i2c_addr = 0;
-            }
-            DBG_PRINT("%s: i2c_address=0x%02x\n", pdata->name, pdata->i2c_addr);
-          
-            ret = of_property_read_string(of_node, "i2c_bus", &str);
-            if (ret) {
-                printk("%s warning: get i2c_bus failed, use default i2c bus\n", pdata->name);
-                pdata->i2c_bus = AML_I2C_MASTER_A;
-            }
-            else {
-                if (strncmp(str, "i2c_bus_a", 9) == 0)
-                    pdata->i2c_bus = AML_I2C_MASTER_A;
-                else if (strncmp(str, "i2c_bus_b", 9) == 0)
-                    pdata->i2c_bus = AML_I2C_MASTER_B;
-                else if (strncmp(str, "i2c_bus_c", 9) == 0)
-                    pdata->i2c_bus = AML_I2C_MASTER_C;
-                else if (strncmp(str, "i2c_bus_d", 9) == 0)
-                    pdata->i2c_bus = AML_I2C_MASTER_D;
-                else if (strncmp(str, "i2c_bus_ao", 10) == 0)
-                    pdata->i2c_bus = AML_I2C_MASTER_AO;
-                else
-                    pdata->i2c_bus = AML_I2C_MASTER_A; 
-            }
-            DBG_PRINT("%s: i2c_bus=%s[%d]\n", pdata->name, str, pdata->i2c_bus);
-            break;
-        case BL_EXTERN_SPI:
-            ret = of_property_read_string(of_node,"gpio_spi_cs", &str);
-            if (ret) {
-                printk("%s warning: get spi gpio_spi_cs failed\n", pdata->name);
-                pdata->spi_cs = -1;
-            }
-            else {
-                val = amlogic_gpio_name_map_num(str);
-                if (val > 0) {
-                    ret = bl_extern_gpio_request(val);
-                    if (ret) {
-                        printk("faild to alloc spi_cs gpio (%s)!\n", str);
-                    }
-                    pdata->spi_cs = val;
-                    DBG_PRINT("spi_cs gpio = %s(%d)\n", str, pdata->spi_cs);
-                }
-                else {
-                    pdata->spi_cs = -1;
-                }
-            }
-            ret = of_property_read_string(of_node,"gpio_spi_clk", &str);
-            if (ret) {
-                printk("%s warning: get spi gpio_spi_clk failed\n", pdata->name);
-                pdata->spi_clk = -1;
-            }
-            else {
-                val = amlogic_gpio_name_map_num(str);
-                if (val > 0) {
-                    ret = bl_extern_gpio_request(val);
-                    if (ret) {
-                        printk("%s: faild to alloc spi_clk gpio (%s)!\n", pdata->name, str);
-                    }
-                    pdata->spi_clk = val;
-                    DBG_PRINT("%s: spi_clk gpio = %s(%d)\n", pdata->name, str, pdata->spi_clk);
-                }
-                else {
-                    pdata->spi_clk = -1;
-                }
-            }
-            ret = of_property_read_string(of_node,"gpio_spi_data", &str);
-            if (ret) {
-                printk("%s warning: get spi gpio_spi_data failed\n", pdata->name);
-                pdata->spi_data = -1;
-            }
-            else {
-                val = amlogic_gpio_name_map_num(str);
-                if (val > 0) {
-                    ret = bl_extern_gpio_request(val);
-                    if (ret) {
-                        printk("%s: faild to alloc spi_data gpio (%s)!\n", pdata->name, str);
-                    }
-                    pdata->spi_data = val;
-                    DBG_PRINT("%s: spi_data gpio = %s(%d)\n", pdata->name, str, pdata->spi_data);
-                }
-                else {
-                    pdata->spi_data = -1;
-                }
-            }
-            break;
-        case BL_EXTERN_OTHER:
-            break;
-        default:
-            break;
-    }
-    ret = of_property_read_u32_array(of_node,"dim_max_min", &bl_para[0], 2);
-    if(ret){
-            printk("%s warning: get dim_max_min failed\n", pdata->name);
-            pdata->dim_max = 0;
-            pdata->dim_min = 0;
-        }
-        else {
-            pdata->dim_max = bl_para[0];
-            pdata->dim_min = bl_para[1];
-        }
-        DBG_PRINT("%s dim_min = %d, dim_max = %d\n", pdata->name, pdata->dim_min, pdata->dim_max);
-
-    return 0;
-}
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <mach/am_regs.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/aml_bl_extern.h>
+#include <linux/amlogic/vout/lcdoutc.h>
+
+//#define BL_EXT_DEBUG_INFO
+#ifdef BL_EXT_DEBUG_INFO
+#define DBG_PRINT(...)		printk(__VA_ARGS__)
+#else
+#define DBG_PRINT(...)
+#endif
+
+static struct aml_bl_extern_driver_t bl_ext_driver = {
+    .type = BL_EXTERN_MAX,
+    .name = NULL,
+    .power_on = NULL,
+    .power_off = NULL,
+    .set_level = NULL,
+
+};
+
+struct aml_bl_extern_driver_t* aml_bl_extern_get_driver(void)
+{
+    return &bl_ext_driver;
+}
+
+int bl_extern_driver_check(void)
+{
+    struct aml_bl_extern_driver_t* bl_ext;
+
+    bl_ext = aml_bl_extern_get_driver();
+    if (bl_ext) {
+        if (bl_ext->type < BL_EXTERN_MAX) {
+            printk("[warning]: bl_extern has already exist (%s)\n", bl_ext->name);
+            return -1;
+        }
+    }
+    else {
+        printk("get bl_extern_driver failed\n");
+    }
+
+    return 0;
+}
+
+int get_bl_extern_dt_data(struct device_node* of_node, struct bl_extern_config_t *pdata)
+{
+    int ret;
+    int val;
+    unsigned int bl_para[2];
+    const char *str;
+
+    ret = of_property_read_string(of_node, "dev_name", (const char **)&pdata->name);
+    if (ret) {
+        pdata->name = "aml_bl_extern";
+        printk("warning: get dev_name failed\n");
+    }
+
+    ret = of_property_read_u32(of_node, "type", &pdata->type);
+    if (ret) {
+        pdata->type = BL_EXTERN_MAX;
+        printk("%s warning: get type failed, exit\n", pdata->name);
+        return -1;
+    }
+    pdata->gpio_used = 0;
+    pdata->gpio = GPIO_MAX;
+    ret = of_property_read_string_index(of_node, "gpio_enable_on_off", 0, &str);
+    if (ret) {
+        printk("%s warning: get gpio_enable failed\n", pdata->name);
+    }
+    else {
+        if (strncmp(str, "G", 1) == 0) {//"GPIO_xx"
+            pdata->gpio_used = 1;
+            val = amlogic_gpio_name_map_num(str);
+            ret = bl_extern_gpio_request(val);
+            if (ret) {
+                printk("%s warning: faild to alloc gpio (%s)\n", pdata->name, str);
+            }
+            pdata->gpio = val;
+        }
+        DBG_PRINT("%s: gpio_enable %s\n", pdata->name, ((pdata->gpio_used) ? str:"none"));
+    }
+    ret = of_property_read_string_index(of_node, "gpio_enable_on_off", 1, &str);
+    if (ret) {
+        printk("%s warning: get gpio_enable_on failed\n", pdata->name);
+    }
+    else {
+        if (strncmp(str, "2", 1) == 0)
+            pdata->gpio_on = LCD_POWER_GPIO_INPUT;
+        else if (strncmp(str, "0", 1) == 0)
+            pdata->gpio_on = LCD_POWER_GPIO_OUTPUT_LOW;
+        else
+            pdata->gpio_on = LCD_POWER_GPIO_OUTPUT_HIGH;
+    }
+    ret = of_property_read_string_index(of_node, "gpio_enable_on_off", 2, &str);
+    if (ret) {
+        printk("%s warning: get gpio_enable_off failed\n", pdata->name);
+    }
+    else {
+        if (strncmp(str, "2", 1) == 0)
+            pdata->gpio_off = LCD_POWER_GPIO_INPUT;
+        else if (strncmp(str, "1", 1) == 0)
+            pdata->gpio_off = LCD_POWER_GPIO_OUTPUT_HIGH;
+        else
+            pdata->gpio_off = LCD_POWER_GPIO_OUTPUT_LOW;
+    }
+    DBG_PRINT("%s: gpio_on = %d, gpio_off = %d \n", pdata->name, pdata->gpio_on, pdata->gpio_off);
+    switch (pdata->type) {
+        case BL_EXTERN_I2C:
+            ret = of_property_read_u32(of_node,"i2c_address",&pdata->i2c_addr);
+            if (ret) {
+                printk("%s warning: get i2c_address failed\n", pdata->name);
+                pdata->i2c_addr = 0;
+            }
+            DBG_PRINT("%s: i2c_address=0x%02x\n", pdata->name, pdata->i2c_addr);
+
+            ret = of_property_read_string(of_node, "i2c_bus", &str);
+            if (ret) {
+                printk("%s warning: get i2c_bus failed, use default i2c bus\n", pdata->name);
+                pdata->i2c_bus = AML_I2C_MASTER_A;
+            }
+            else {
+                if (strncmp(str, "i2c_bus_a", 9) == 0)
+                    pdata->i2c_bus = AML_I2C_MASTER_A;
+                else if (strncmp(str, "i2c_bus_b", 9) == 0)
+                    pdata->i2c_bus = AML_I2C_MASTER_B;
+                else if (strncmp(str, "i2c_bus_c", 9) == 0)
+                    pdata->i2c_bus = AML_I2C_MASTER_C;
+                else if (strncmp(str, "i2c_bus_d", 9) == 0)
+                    pdata->i2c_bus = AML_I2C_MASTER_D;
+                else if (strncmp(str, "i2c_bus_ao", 10) == 0)
+                    pdata->i2c_bus = AML_I2C_MASTER_AO;
+                else
+                    pdata->i2c_bus = AML_I2C_MASTER_A;
+            }
+            DBG_PRINT("%s: i2c_bus=%s[%d]\n", pdata->name, str, pdata->i2c_bus);
+            break;
+        case BL_EXTERN_SPI:
+            ret = of_property_read_string(of_node,"gpio_spi_cs", &str);
+            if (ret) {
+                printk("%s warning: get spi gpio_spi_cs failed\n", pdata->name);
+                pdata->spi_cs = -1;
+            }
+            else {
+                val = amlogic_gpio_name_map_num(str);
+                if (val > 0) {
+                    ret = bl_extern_gpio_request(val);
+                    if (ret) {
+                        printk("faild to alloc spi_cs gpio (%s)!\n", str);
+                    }
+                    pdata->spi_cs = val;
+                    DBG_PRINT("spi_cs gpio = %s(%d)\n", str, pdata->spi_cs);
+                }
+                else {
+                    pdata->spi_cs = -1;
+                }
+            }
+            ret = of_property_read_string(of_node,"gpio_spi_clk", &str);
+            if (ret) {
+                printk("%s warning: get spi gpio_spi_clk failed\n", pdata->name);
+                pdata->spi_clk = -1;
+            }
+            else {
+                val = amlogic_gpio_name_map_num(str);
+                if (val > 0) {
+                    ret = bl_extern_gpio_request(val);
+                    if (ret) {
+                        printk("%s: faild to alloc spi_clk gpio (%s)!\n", pdata->name, str);
+                    }
+                    pdata->spi_clk = val;
+                    DBG_PRINT("%s: spi_clk gpio = %s(%d)\n", pdata->name, str, pdata->spi_clk);
+                }
+                else {
+                    pdata->spi_clk = -1;
+                }
+            }
+            ret = of_property_read_string(of_node,"gpio_spi_data", &str);
+            if (ret) {
+                printk("%s warning: get spi gpio_spi_data failed\n", pdata->name);
+                pdata->spi_data = -1;
+            }
+            else {
+                val = amlogic_gpio_name_map_num(str);
+                if (val > 0) {
+                    ret = bl_extern_gpio_request(val);
+                    if (ret) {
+                        printk("%s: faild to alloc spi_data gpio (%s)!\n", pdata->name, str);
+                    }
+                    pdata->spi_data = val;
+                    DBG_PRINT("%s: spi_data gpio = %s(%d)\n", pdata->name, str, pdata->spi_data);
+                }
+                else {
+                    pdata->spi_data = -1;
+                }
+            }
+            break;
+        case BL_EXTERN_OTHER:
+            break;
+        default:
+            break;
+    }
+    ret = of_property_read_u32_array(of_node,"dim_max_min", &bl_para[0], 2);
+    if(ret){
+            printk("%s warning: get dim_max_min failed\n", pdata->name);
+            pdata->dim_max = 0;
+            pdata->dim_min = 0;
+        }
+        else {
+            pdata->dim_max = bl_para[0];
+            pdata->dim_min = bl_para[1];
+        }
+        DBG_PRINT("%s dim_min = %d, dim_max = %d\n", pdata->name, pdata->dim_min, pdata->dim_max);
+
+    return 0;
+}
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/i2c_lp8556.c b/drivers/amlogic/display/backlight/aml_bl_extern/i2c_lp8556.c
old mode 100644
new mode 100755
index d8b048ff..fd0b130f
--- a/drivers/amlogic/display/backlight/aml_bl_extern/i2c_lp8556.c
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/i2c_lp8556.c
@@ -2,7 +2,7 @@
  * AMLOGIC backlight external driver.
  *
  * Communication protocol:
- * I2C 
+ * I2C
  *
  */
 
@@ -11,7 +11,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
-#include <linux/jiffies.h> 
+#include <linux/jiffies.h>
 #include <linux/i2c.h>
 #include <linux/i2c-aml.h>
 #include <linux/miscdevice.h>
@@ -63,12 +63,12 @@ static int aml_i2c_write(struct i2c_client *i2client,unsigned char *buff, unsign
         .buf = buff,
         }
     };
-    
+
     res = i2c_transfer(i2client->adapter, msg, 1);
     if (res < 0) {
         printk("%s: i2c transfer failed [addr 0x%02x]\n", __FUNCTION__, i2client->addr);
     }
-    
+
     return res;
 }
 #if 0
@@ -128,7 +128,10 @@ static int bl_extern_power_on(void)
     int ret=0;
 
     if (bl_ext_config->gpio_used > 0) {
-        bl_extern_gpio_direction_output(bl_ext_config->gpio, 1);
+        if (bl_ext_config->gpio_on==2)
+            bl_extern_gpio_direction_input(bl_ext_config->gpio);
+        else
+            bl_extern_gpio_direction_output(bl_ext_config->gpio, bl_ext_config->gpio_on);
     }
 
     while (ending_flag == 0) {
@@ -158,30 +161,47 @@ static int bl_extern_power_off(void)
 {
     bl_status = 0;
     if (bl_ext_config->gpio_used > 0) {
-        bl_extern_gpio_direction_output(bl_ext_config->gpio, 0);
+        if (bl_ext_config->gpio_off==2)
+            bl_extern_gpio_direction_input(bl_ext_config->gpio);
+        else
+        bl_extern_gpio_direction_output(bl_ext_config->gpio, bl_ext_config->gpio_off);
     }
 
     printk("%s\n", __FUNCTION__);
     return 0;
 }
 
-static int bl_extern_driver_update(void)
+static int get_bl_extern_config(struct device_node* of_node, struct bl_extern_config_t *bl_ext_cfg)
 {
+    int ret = 0;
     struct aml_bl_extern_driver_t* bl_ext;
 
+    ret = get_bl_extern_dt_data(of_node, bl_ext_cfg);
+    if (ret) {
+        printk("[error] %s: failed to get dt data\n", BL_EXTERN_NAME);
+        return ret;
+    }
+
+    if (bl_ext_cfg->dim_min > 0xff)
+        bl_ext_cfg->dim_min = 0xff;
+    if (bl_ext_cfg->dim_max > 0xff)
+        bl_ext_cfg->dim_max = 0xff;
+
+    //bl extern driver update
     bl_ext = aml_bl_extern_get_driver();
     if (bl_ext) {
-        bl_ext->type      = bl_ext_config->type;
-        bl_ext->name      = bl_ext_config->name;
+        bl_ext->type      = bl_ext_cfg->type;
+        bl_ext->name      = bl_ext_cfg->name;
         bl_ext->power_on  = bl_extern_power_on;
         bl_ext->power_off = bl_extern_power_off;
         bl_ext->set_level = bl_extern_set_level;
     }
     else {
-        printk("[error] %s get bl_extern_driver failed\n", bl_ext_config->name);
+        printk("[error] %s get bl_extern_driver failed\n", bl_ext_cfg->name);
+        ret = -1;
     }
 
-    return 0;
+    return ret;
 }
 
 static int aml_lp8556_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
@@ -193,7 +213,6 @@ static int aml_lp8556_i2c_probe(struct i2c_client *client, const struct i2c_devi
     }
     else {
         aml_lp8556_i2c_client = client;
-        bl_extern_driver_update();
     }
 
     printk("%s OK\n", __FUNCTION__);
@@ -240,8 +259,8 @@ static int aml_lp8556_probe(struct platform_device *pdev)
 
     pdev->dev.platform_data = bl_ext_config;
 
-    if (get_bl_extern_dt_data(pdev->dev.of_node, bl_ext_config) != 0) {
-        printk("[error] %s probe: failed to get dt data\n", BL_EXTERN_NAME);
+    ret = get_bl_extern_config(pdev->dev.of_node, bl_ext_config);
+    if (ret) {
         goto bl_extern_probe_failed;
     }
 
@@ -280,8 +299,10 @@ static int aml_lp8556_probe(struct platform_device *pdev)
     return ret;
 
 bl_extern_probe_failed:
-    if (bl_ext_config)
+    if (bl_ext_config) {
         kfree(bl_ext_config);
+        bl_ext_config = NULL;
+    }
     return -1;
 }
 
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c b/drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c
old mode 100644
new mode 100755
index c1ddfbdd..0037c221
--- a/drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/mipi_LT070ME05.c
@@ -8,7 +8,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
-#include <linux/jiffies.h> 
+#include <linux/jiffies.h>
 #include <linux/miscdevice.h>
 #include <linux/mutex.h>
 #include <linux/mm.h>
@@ -36,9 +36,13 @@ static struct bl_extern_config_t *bl_ext_config = NULL;
 static unsigned int bl_status = 1;
 static unsigned int bl_level = 0;
 
+//******************** mipi command ********************//
+//format:  data_type, num, data....
+//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
+//******************************************************//
 static int bl_extern_set_level(unsigned int level)
 {
-    unsigned char payload[]={0x15,0x51,1,0xe6,0xff,0xff};
+    unsigned char payload[]={0x15,2,0x51,0xe6,0xff,0xff};
 
     bl_level = level;
 
@@ -61,7 +65,10 @@ static int bl_extern_set_level(unsigned int level)
 static int bl_extern_power_on(void)
 {
     if (bl_ext_config->gpio_used > 0) {
-        bl_extern_gpio_direction_output(bl_ext_config->gpio, 1);
+      if(bl_ext_config->gpio_on == 2)
+            bl_extern_gpio_direction_input(bl_ext_config->gpio);
+        else
+            bl_extern_gpio_direction_output(bl_ext_config->gpio, bl_ext_config->gpio_on);
     }
 
     bl_status = 1;
@@ -74,34 +81,53 @@ static int bl_extern_power_on(void)
 static int bl_extern_power_off(void)
 {
     if (bl_ext_config->gpio_used > 0) {
-        bl_extern_gpio_direction_output(bl_ext_config->gpio, 0);
+      if(bl_ext_config->gpio_off == 2)
+            bl_extern_gpio_direction_input(bl_ext_config->gpio);
+        else
+            bl_extern_gpio_direction_output(bl_ext_config->gpio, bl_ext_config->gpio_off);
     }
 
     printk("%s\n", __FUNCTION__);
     return 0;
 }
 
-static int bl_extern_driver_update(void)
+static int get_bl_extern_config(struct device_node* of_node, struct bl_extern_config_t *bl_ext_cfg)
 {
+    int ret = 0;
     struct aml_bl_extern_driver_t* bl_ext;
 
+    ret = get_bl_extern_dt_data(of_node, bl_ext_cfg);
+    if (ret) {
+        printk("[error] %s: failed to get dt data\n", BL_EXTERN_NAME);
+        return ret;
+    }
+
+    if (bl_ext_cfg->dim_min > 0xff)
+        bl_ext_cfg->dim_min = 0xff;
+    if (bl_ext_cfg->dim_max > 0xff)
+        bl_ext_cfg->dim_max = 0xff;
+
+    //bl extern driver update
     bl_ext = aml_bl_extern_get_driver();
     if (bl_ext) {
-        bl_ext->type      = bl_ext_config->type;
-        bl_ext->name      = bl_ext_config->name;
+        bl_ext->type      = bl_ext_cfg->type;
+        bl_ext->name      = bl_ext_cfg->name;
         bl_ext->power_on  = bl_extern_power_on;
         bl_ext->power_off = bl_extern_power_off;
         bl_ext->set_level = bl_extern_set_level;
     }
     else {
-        printk("[error] %s get bl_extern_driver failed\n", bl_ext_config->name);
+        printk("[error] %s get bl_extern_driver failed\n", bl_ext_cfg->name);
+        ret = -1;
     }
 
-    return 0;
+    return ret;
 }
 
 static int aml_LT070ME05_probe(struct platform_device *pdev)
 {
+    int ret = 0;
+
     if (bl_extern_driver_check()) {
         return -1;
     }
@@ -114,19 +140,19 @@ static int aml_LT070ME05_probe(struct platform_device *pdev)
 
     pdev->dev.platform_data = bl_ext_config;
 
-    if (get_bl_extern_dt_data(pdev->dev.of_node, bl_ext_config) != 0) {
-        printk("[error] %s probe: failed to get dt data\n", BL_EXTERN_NAME);
+    ret = get_bl_extern_config(pdev->dev.of_node, bl_ext_config);
+    if (ret) {
         goto bl_extern_probe_failed;
     }
 
-    bl_extern_driver_update();
-
     printk("%s ok\n", __FUNCTION__);
-    return 0;
+    return ret;
 
 bl_extern_probe_failed:
-    if (bl_ext_config)
+    if (bl_ext_config) {
         kfree(bl_ext_config);
+        bl_ext_config = NULL;
+    }
     return -1;
 }
 
diff --git a/drivers/amlogic/display/backlight/aml_bl_extern/pmu_aml1218.c b/drivers/amlogic/display/backlight/aml_bl_extern/pmu_aml1218.c
old mode 100644
new mode 100755
index ebb6af74..db6fc740
--- a/drivers/amlogic/display/backlight/aml_bl_extern/pmu_aml1218.c
+++ b/drivers/amlogic/display/backlight/aml_bl_extern/pmu_aml1218.c
@@ -8,7 +8,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
-#include <linux/jiffies.h> 
+#include <linux/jiffies.h>
 #include <linux/i2c.h>
 #include <linux/i2c-aml.h>
 #include <linux/miscdevice.h>
@@ -102,7 +102,10 @@ static int bl_extern_power_on(void)
     }
 #endif
     if (bl_ext_config->gpio_used > 0) {
-        bl_extern_gpio_direction_output(bl_ext_config->gpio, 1);
+        if (bl_ext_config->gpio_on==2)
+            bl_extern_gpio_direction_input(bl_ext_config->gpio);
+        else
+            bl_extern_gpio_direction_output(bl_ext_config->gpio, bl_ext_config->gpio_on);
     }
 
     printk("%s\n", __FUNCTION__);
@@ -118,7 +121,10 @@ static int bl_extern_power_off(void)
     int ret = 0;
 
     if (bl_ext_config->gpio_used > 0) {
-        bl_extern_gpio_direction_output(bl_ext_config->gpio, 0);
+        if (bl_ext_config->gpio_off==2)
+            bl_extern_gpio_direction_input(bl_ext_config->gpio);
+        else
+            bl_extern_gpio_direction_output(bl_ext_config->gpio, bl_ext_config->gpio_off);
     }
 #ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
     pmu_driver = aml_pmu_get_driver();
@@ -143,25 +149,6 @@ static int bl_extern_power_off(void)
     return ret;
 }
 
-static int bl_extern_driver_update(void)
-{
-    struct aml_bl_extern_driver_t* bl_ext;
-
-    bl_ext = aml_bl_extern_get_driver();
-    if (bl_ext) {
-        bl_ext->type      = bl_ext_config->type;
-        bl_ext->name      = bl_ext_config->name;
-        bl_ext->power_on  = bl_extern_power_on;
-        bl_ext->power_off = bl_extern_power_off;
-        bl_ext->set_level = bl_extern_set_level;
-    }
-    else {
-        printk("[error] %s get bl_extern_driver failed\n", bl_ext_config->name);
-    }
-
-    return 0;
-}
-
 //***********************************************//
 static ssize_t bl_extern_debug(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
 {
@@ -218,6 +205,39 @@ static struct class bl_extern_debug_class = {
 };
 //*********************************************************//
 
+static int get_bl_extern_config(struct device_node* of_node, struct bl_extern_config_t *bl_ext_cfg)
+{
+    int ret = 0;
+    struct aml_bl_extern_driver_t* bl_ext;
+
+    ret = get_bl_extern_dt_data(of_node, bl_ext_cfg);
+    if (ret) {
+        printk("[error] %s: failed to get dt data\n", BL_EXTERN_NAME);
+        return ret;
+    }
+
+    if (bl_ext_cfg->dim_min > 0x1f)
+        bl_ext_cfg->dim_min = 0x1f;
+    if (bl_ext_cfg->dim_max > 0x1f)
+        bl_ext_cfg->dim_max = 0x1f;
+
+    //bl extern driver update
+    bl_ext = aml_bl_extern_get_driver();
+    if (bl_ext) {
+        bl_ext->type      = bl_ext_cfg->type;
+        bl_ext->name      = bl_ext_cfg->name;
+        bl_ext->power_on  = bl_extern_power_on;
+        bl_ext->power_off = bl_extern_power_off;
+        bl_ext->set_level = bl_extern_set_level;
+    }
+    else {
+        printk("[error] %s get bl_extern_driver failed\n", bl_ext_cfg->name);
+        ret = -1;
+    }
+
+    return ret;
+}
+
 static int aml_aml1218_probe(struct platform_device *pdev)
 {
     int ret = 0;
@@ -234,13 +254,11 @@ static int aml_aml1218_probe(struct platform_device *pdev)
 
     pdev->dev.platform_data = bl_ext_config;
 
-    if (get_bl_extern_dt_data(pdev->dev.of_node, bl_ext_config) != 0) {
-        printk("[error] %s probe: failed to get dt data\n", BL_EXTERN_NAME);
+    ret = get_bl_extern_config(pdev->dev.of_node, bl_ext_config);
+    if (ret) {
         goto bl_extern_probe_failed;
     }
 
-    bl_extern_driver_update();
-
     ret = class_register(&bl_extern_debug_class);
     if(ret){
         printk("class register bl_extern_debug_class fail!\n");
@@ -250,8 +268,10 @@ static int aml_aml1218_probe(struct platform_device *pdev)
     return ret;
 
 bl_extern_probe_failed:
-    if (bl_ext_config)
+    if (bl_ext_config) {
         kfree(bl_ext_config);
+        bl_ext_config = NULL;
+    }
     return -1;
 }
 
diff --git a/drivers/amlogic/display/backlight/aml_ldim_drv.c b/drivers/amlogic/display/backlight/aml_ldim_drv.c
old mode 100644
new mode 100755
index bd241962..3f7333bc
--- a/drivers/amlogic/display/backlight/aml_ldim_drv.c
+++ b/drivers/amlogic/display/backlight/aml_ldim_drv.c
@@ -1,7 +1,7 @@
 /*
  * Amlogic Ldim Driver for Meson Chip
  *
- * Author: 
+ * Author:
  *
  * Copyright (C) 2012 Amlogic Inc.
  *
@@ -70,7 +70,7 @@ int Round(int iX, int iB)
     else {
         Rst = (iX-iB/2)/iB;
     }
-    
+
     return Rst;
 }
 
@@ -79,9 +79,9 @@ static sLDIM_RGB_MODE_Param  ldim_param_rgbMode = { 0, //RGBmapping_demo;
                                                     0, //b_ldlut_ip_mode;   //0: linear, 1: nearest
                                                     0, //g_ldlut_ip_mode;   //0: linear, 1: nearest
                                                     0, //r_ldlut_ip_mode;   //0: linear, 1: nearest
-                                                    7, //BkLit_LPFmod; u3:0 no LPF, 1:[1 14 1]/16, ...  
-                                                    1, //BackLit_Xtlk; u1 
-                                                    1, //BkLit_Intmod; u1 
+                                                    7, //BkLit_LPFmod; u3:0 no LPF, 1:[1 14 1]/16, ...
+                                                    1, //BackLit_Xtlk; u1
+                                                    1, //BkLit_Intmod; u1
                                                     1, //BkLUT_Intmod; u1
                                                     0, //BkLit_curmod; u1
                                                     0  //BackLit_mode;  u2: 0 LEFT/RIGHT edge, ...
@@ -114,7 +114,7 @@ static int ldim_lut_vdg_lext = 257;
 static int ldim_lut_vhk_lext = 220;
 
 static int ldim_pic_rowmax = 1080;
-static int ldim_pic_colmax = 1920; 
+static int ldim_pic_colmax = 1920;
 
 static int ldim_param_frm_rst_pos = 0;;
 static int ldim_param_frm_bl_start_pos = 0;
@@ -132,24 +132,24 @@ static int gVDG_LUT[32] = {256, 255, 254, 251, 248, 244, 238, 232, 225, 218, 210
 static int gVHK_LUT[32] = {201, 174, 155, 141, 122, 110, 101,  94,  88,  84,  80,  76,  74,  71,  69,  67,
                             65,  63,  62,  60,  59,  58,  57,  56,  55,  54,  53,  52,  51,  51,  50,  49}; //u10
 static int gMatrix_LUT[64] = {0}; //s12
-static int gLD_REFLECT_DGR_LUT[20+20+4] = {0}; //u6: 20 LD_REFLECT_HDGR +  20 LD_REFLECT_VDGR + 4 LD_REFLECT_XDGR 
+static int gLD_REFLECT_DGR_LUT[20+20+4] = {0}; //u6: 20 LD_REFLECT_HDGR +  20 LD_REFLECT_VDGR + 4 LD_REFLECT_XDGR
 static int gLD_RGB_IDX_LUT[16] = {0}; //12bits
 //static int gLD_G_IDX_LUT[32] = {0}; //12bits
 //static int gLD_B_IDX_LUT[32] = {0}; //12bits
 static int gLD_NRMW_LUT[16]  = {0};   //4bits
-static int gLD_RGB_LUT[3*16*32] = {0};  //12bits 
+static int gLD_RGB_LUT[3*16*32] = {0};  //12bits
 
 void LDIM_WR_32Bits(int addr, int data)
 {
    Wr(LDIM_BL_ADDR_PORT,addr);
    Wr(LDIM_BL_DATA_PORT,data);
-} 
+}
 
 int LDIM_RD_32Bits(int addr)
 {
    Wr(LDIM_BL_ADDR_PORT,addr);
    return(Rd(LDIM_BL_DATA_PORT));
-} 
+}
 
 void LDIM_wr_reg_bits(int addr, int val, int start, int len)
 {
@@ -157,7 +157,7 @@ void LDIM_wr_reg_bits(int addr, int val, int start, int len)
    data = LDIM_RD_32Bits (addr);
    data = (data & (~((1 << len) - 1)<<start))  |  ((val & ((1 << len) -1)) << start);
    LDIM_WR_32Bits(addr, data);
-} 
+}
 
 void LDIM_WR_BASE_LUT(int base,int* pData, int size_t, int len)
 {
@@ -165,13 +165,13 @@ void LDIM_WR_BASE_LUT(int base,int* pData, int size_t, int len)
   int addr,data;
   int mask,subCnt;
   int cnt;
-  
+
   addr   = base;//(base<<4);
   mask   = (1<<size_t)-1;
   subCnt = 32/size_t;
   cnt  = 0;
   data = 0;
-  
+
   Wr(LDIM_BL_ADDR_PORT,addr);
 
   for(i=0;i<len;i++)
@@ -189,7 +189,7 @@ void LDIM_WR_BASE_LUT(int base,int* pData, int size_t, int len)
   }
   if(cnt!=0)
      Wr(LDIM_BL_DATA_PORT,data);
-} 
+}
 
 
 //========================================
@@ -224,7 +224,7 @@ void ld_fw_cfg_once()
     //	}
 
     if (ldim_param_rgbMode.BackLit_mode ==0) // Left/right EdgeLit
-    { 
+    {
     ldim_param_blk_hvnum.Reflect_Vnum = 3;
     ldim_param_blk_hvnum.Reflect_Hnum = 0;
 	// config reg_LD_BLK_Hidx
@@ -232,15 +232,15 @@ void ld_fw_cfg_once()
 	    dlt = ldim_pic_colmax/ldim_param_blk_hvnum.BLK_Hnum*2;
 	    gBLK_Hidx_LUT[k] = -(dlt/2) + (k-hofst)*dlt;
             gBLK_Hidx_LUT[k] =  (gBLK_Hidx_LUT[k]>8191) ? 8191 : (gBLK_Hidx_LUT[k]<-8192) ? (-8192) : gBLK_Hidx_LUT[k]; // Clip to S14
- 
+
 	}
 	// config reg_LD_BLK_Vidx
 	for (k=0;k<LD_BLK_LEN;k++){
 	    dlt = ldim_pic_rowmax/ldim_param_blk_hvnum.BLK_Vnum;
-            gBLK_Vidx_LUT[k] = 0 + (k-vofst)*dlt;         
+            gBLK_Vidx_LUT[k] = 0 + (k-vofst)*dlt;
             gBLK_Vidx_LUT[k] = (gBLK_Vidx_LUT[k]>8191) ? 8191: (gBLK_Vidx_LUT[k]<-8192) ? (-8192) : gBLK_Vidx_LUT[k]; // Clip to S14
-         }	
-		
+         }
+
         // configure  Hgain/Vgain
         ldim_param_hgain = (128*1920/ldim_pic_colmax); //u12
         ldim_param_vgain = (256*1080/ldim_pic_rowmax); //u12
@@ -257,12 +257,12 @@ void ld_fw_cfg_once()
 	    dlt = ldim_pic_colmax/ldim_param_blk_hvnum.BLK_Hnum;
 	    gBLK_Hidx_LUT[k] =  0 + (k-hofst)*dlt;
             gBLK_Hidx_LUT[k] =  (gBLK_Hidx_LUT[k]>8191) ? 8191: (gBLK_Hidx_LUT[k]<-8192) ? (-8192) : gBLK_Hidx_LUT[k]; // Clip to S14
- 
+
 	}
 	// config reg_LD_BLK_Vidx
 	for (k=0;k<LD_BLK_LEN;k++){
 	    dlt = ldim_pic_rowmax/ldim_param_blk_hvnum.BLK_Vnum*2;
-            gBLK_Vidx_LUT[k] = -(dlt/2) + (k-vofst)*dlt;         
+            gBLK_Vidx_LUT[k] = -(dlt/2) + (k-vofst)*dlt;
             gBLK_Vidx_LUT[k] = (gBLK_Vidx_LUT[k]>8191) ? 8191: (gBLK_Vidx_LUT[k]<-8192) ? (-8192) : gBLK_Vidx_LUT[k]; // Clip to S14
          }
          // configure  Hgain/Vgain
@@ -283,12 +283,12 @@ void ld_fw_cfg_once()
 	    dlt = ldim_pic_colmax/ldim_param_blk_hvnum.BLK_Hnum;
 	    gBLK_Hidx_LUT[k] =  0 + (k-hofst)*dlt;
             gBLK_Hidx_LUT[k] =  (gBLK_Hidx_LUT[k]>8191) ? 8191: (gBLK_Hidx_LUT[k]<-8192) ? -8192 : gBLK_Hidx_LUT[k]; // Clip to S14
- 
+
 	}
 	// config reg_LD_BLK_Vidx
 	for (k=0;k<LD_BLK_LEN;k++){
 	    dlt = ldim_pic_rowmax/ldim_param_blk_hvnum.BLK_Vnum;
-            gBLK_Vidx_LUT[k] =  0 + (k-vofst)*dlt;         
+            gBLK_Vidx_LUT[k] =  0 + (k-vofst)*dlt;
             gBLK_Vidx_LUT[k] = (gBLK_Vidx_LUT[k]>8191) ? 8191: (gBLK_Vidx_LUT[k]<-8192) ? -8192 : gBLK_Vidx_LUT[k]; // Clip to S14
          }
          // configure  Hgain/Vgain
@@ -296,14 +296,14 @@ void ld_fw_cfg_once()
         ldim_param_vgain = (424*1080/ldim_pic_rowmax); //u12
         ldim_param_hgain = (ldim_param_hgain > 4095) ? 4095 : ldim_param_hgain;
         ldim_param_vgain = (ldim_param_vgain > 4095) ? 4095 : ldim_param_vgain;
- 
+
 	// configure
         for(k=0;k<LD_LUT_LEN;k++)
         {
 	   gHDG_LUT[k] = drt_LD_LUT_dg[k];
            gVDG_LUT[k] = drt_LD_LUT_dg[k];
            gVHK_LUT[k] = 64;
-	 }  
+	 }
        }
 }
 
@@ -338,10 +338,10 @@ static void ldming_stts(void)
 	 }
 */
     for(i=0;i<1024;i++)
-    	{
+	{
 	hist_matrix[i] = READ_CBUS_REG(LDIM_STTS_HIST_READ_REGION);
 	//a[i] = hist_matrix[i];
-    	}
+	}
 	if(cnt)
 		{
 		WRITE_CBUS_REG(ASSIST_SPARE8_REG1, 0);
@@ -374,26 +374,26 @@ void LDIM_Initial(int pic_h, int pic_v, int BLK_Vnum, int BLK_Hnum, int BackLit_
                                    2092,3524,
                                    2436,3444};
 
-   static int matrix_dbg_lr_1080[16] = {1780, 1780, 4095, 1964, 4012, 2096, 4095, 4095 , 
+   static int matrix_dbg_lr_1080[16] = {1780, 1780, 4095, 1964, 4012, 2096, 4095, 4095 ,
                                         3512, 4095, 4095, 4095, 2772, 2752, 1780, 1784 };
 
    static int matrix_dbg_tb[16] = {4095, 2764, 4095, 2004, 4095, 2256, 2540, 2368,
                                    4095, 2424, 4095, 2092, 4095, 4095, 4095, 4095};
 
-   static int matrix_dbg_drt[64] = {4095, 4095, 4095, 3004, 4095, 4095, 4095, 4095, 
-                                    4095, 4095, 4095, 2964, 4095, 4095, 4095, 4095, 
-                                    4095, 4095, 4095, 2804, 4095, 4095, 4095, 4095, 
-                                    4095, 4095, 4095, 2184, 2844, 4095, 4095, 4095, 
-                                    
-                                    2196, 2384, 2168, 2224, 1636, 2212, 4095, 4095, 
-                                    4095, 1844, 2480, 2468, 4095, 1784, 4095, 4095, 
-                                    2004, 1316, 2308, 3324, 4095, 2224, 4095, 2864, 
+   static int matrix_dbg_drt[64] = {4095, 4095, 4095, 3004, 4095, 4095, 4095, 4095,
+                                    4095, 4095, 4095, 2964, 4095, 4095, 4095, 4095,
+                                    4095, 4095, 4095, 2804, 4095, 4095, 4095, 4095,
+                                    4095, 4095, 4095, 2184, 2844, 4095, 4095, 4095,
+
+                                    2196, 2384, 2168, 2224, 1636, 2212, 4095, 4095,
+                                    4095, 1844, 2480, 2468, 4095, 1784, 4095, 4095,
+                                    2004, 1316, 2308, 3324, 4095, 2224, 4095, 2864,
                                     4095, 2472, 2072, 2044, 2008, 2140, 4095, 4095};
 
    int k,l,blkRow,blkCol,R_idx;
 
    ldim_pic_rowmax = pic_v;
-   ldim_pic_colmax = pic_h; 
+   ldim_pic_colmax = pic_h;
    ldim_param_rgbMode.BackLit_mode = BackLit_mode;
    ldim_param_blk_hvnum.BLK_Vnum = BLK_Vnum; //8;
    ldim_param_blk_hvnum.BLK_Hnum = BLK_Hnum; //2;
@@ -429,7 +429,7 @@ void LDIM_Initial(int pic_h, int pic_v, int BLK_Vnum, int BLK_Hnum, int BackLit_
    WRITE_CBUS_REG_BITS(LDIM_STTS_HIST_REGION_IDX,1,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
    WRITE_CBUS_REG(LDIM_STTS_HIST_SET_REGION,nPRM.reg_LD_STAhist_Hidx[2]<<12|nPRM.reg_LD_STAhist_Hidx[1]);
    WRITE_CBUS_REG_BITS(LDIM_STTS_HIST_REGION_IDX,2,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
-   WRITE_CBUS_REG(LDIM_STTS_HIST_SET_REGION,nPRM.reg_LD_STAhist_Vidx[2]<<12|nPRM.reg_LD_STAhist_Vidx[1]);   
+   WRITE_CBUS_REG(LDIM_STTS_HIST_SET_REGION,nPRM.reg_LD_STAhist_Vidx[2]<<12|nPRM.reg_LD_STAhist_Vidx[1]);
    WRITE_CBUS_REG_BITS(LDIM_STTS_HIST_REGION_IDX,3,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
    WRITE_CBUS_REG(LDIM_STTS_HIST_SET_REGION,nPRM.reg_LD_STAhist_Hidx[4]<<12|nPRM.reg_LD_STAhist_Hidx[3]);
    WRITE_CBUS_REG_BITS(LDIM_STTS_HIST_REGION_IDX,4,BLK_HV_POS_IDXS_BIT,BLK_HV_POS_IDXS_WID);
@@ -460,7 +460,7 @@ void LDIM_Initial(int pic_h, int pic_v, int BLK_Vnum, int BLK_Hnum, int BackLit_
    for(i=0;i<16;i++)
    {  gLD_RGB_IDX_LUT[i] =  4095-256*i;
       gLD_NRMW_LUT[i]   = 8;
-      for(j=0;j<32;j++) 
+      for(j=0;j<32;j++)
       {
         //gLD_RGB_LUT[i*32+j] = (32*(j+1)*16)/(16-i);//(64*(j+1)*32)/(16-i); //
         //gLD_RGB_LUT[i*32+j] = (64*(j+1)*32)/(16-i); //
@@ -469,16 +469,16 @@ void LDIM_Initial(int pic_h, int pic_v, int BLK_Vnum, int BLK_Hnum, int BackLit_
           gLD_RGB_LUT[i*32+j] = 4095;
       }
    }
-   
+
    for(i=0;i<16;i++)
-   {  
-      for(j=0;j<32;j++) 
+   {
+      for(j=0;j<32;j++)
         gLD_RGB_LUT[16*32+i*32+j] = gLD_RGB_LUT[i*32+j];
    }
-   
+
    for(i=0;i<16;i++)
-   {  
-      for(j=0;j<32;j++) 
+   {
+      for(j=0;j<32;j++)
         gLD_RGB_LUT[2*16*32+i*32+j] = gLD_RGB_LUT[i*32+j];
    }
 
@@ -492,28 +492,28 @@ void LDIM_Initial(int pic_h, int pic_v, int BLK_Vnum, int BLK_Hnum, int BackLit_
    //ldim_param_bl_matrix_avg = get_blMtxAvg(matrixNum,1);
    //ldim_param_bl_matrix_compen = ldim_param_bl_matrix_avg;
    //
-  
+
    //enable the CBUS configure the RAM
    //LD_MISC_CTRL0  {ram_clk_gate_en,2'h0,ldlut_ram_sel,ram_clk_sel,reg_hvcnt_bypass,reg_ldim_bl_en,soft_bl_start,reg_soft_rst)
    data = LDIM_RD_32Bits(LD_MISC_CTRL0);
    data = data & (~(3<<4));
    LDIM_WR_32Bits(LD_MISC_CTRL0,data);
-    
+
    //change here: gBLK_Hidx_LUT: s14*19
    LDIM_WR_BASE_LUT(LD_BLK_HIDX_BASE,gBLK_Hidx_LUT,16,19);
-   
+
    //change here: gBLK_Vidx_LUT: s14*19
    LDIM_WR_BASE_LUT(LD_BLK_VIDX_BASE,gBLK_Vidx_LUT,16,19);
- 
+
    //change here: gHDG_LUT: u10*32
    LDIM_WR_BASE_LUT(LD_LUT_HDG_BASE,gHDG_LUT,16,32);
- 
+
    //change here: gVHK_LUT: u10*32
    LDIM_WR_BASE_LUT(LD_LUT_VHK_BASE,gVHK_LUT,16,32);
-   
+
    //change here: gVDG_LUT: u10*32
    LDIM_WR_BASE_LUT(LD_LUT_VDG_BASE,gVDG_LUT,16,32);
-   
+
    //gMatrix_LUT: s12*100
    LDIM_WR_BASE_LUT(LD_MATRIX_R0_BASE,&gMatrix_LUT[0] ,16,32);
    LDIM_WR_BASE_LUT(LD_MATRIX_R1_BASE,&gMatrix_LUT[32],16,32);
@@ -526,7 +526,7 @@ void LDIM_Initial(int pic_h, int pic_v, int BLK_Vnum, int BLK_Hnum, int BackLit_
 
    //gLD_RGB_IDX_LUT: 12 * 16
    LDIM_WR_BASE_LUT(LD_RGB_IDX_BASE,gLD_RGB_IDX_LUT,16,16);
-   
+
    //gLD_BRM_LUT: 4 * 16
    LDIM_WR_BASE_LUT(LD_RGB_NRMW_BASE,gLD_NRMW_LUT,4,16);
 
@@ -548,21 +548,21 @@ void LDIM_Initial(int pic_h, int pic_v, int BLK_Vnum, int BLK_Hnum, int BackLit_
           ((ldim_param_rgbMode.BkLUT_Intmod &0x1)    <<5)  |
           ((ldim_param_rgbMode.BkLit_curmod &0x1)    <<4)  |
           ((ldim_param_rgbMode.BackLit_mode &0x3)      )  ;
-    LDIM_WR_32Bits(LD_RGB_MOD,data); 
-  
+    LDIM_WR_32Bits(LD_RGB_MOD,data);
+
    //LD_BLK_HVNUM
     data = ((ldim_param_blk_hvnum.frm_hblank_num &0xfff) << 16) |
            ((ldim_param_blk_hvnum.Reflect_Vnum & 0x7)    << 12) |
            ((ldim_param_blk_hvnum.Reflect_Hnum & 0x7)    << 8 ) |
            ((ldim_param_blk_hvnum.BLK_Vnum & 0xf )       << 4 ) |
-           ((ldim_param_blk_hvnum.BLK_Hnum & 0xf )            ) ;   
+           ((ldim_param_blk_hvnum.BLK_Hnum & 0xf )            ) ;
     LDIM_WR_32Bits(LD_BLK_HVNUM,data);
 
     //LD_HVGAIN
     data = ((ldim_param_vgain&0xfff)<<16) | (ldim_param_hgain&0xfff);
     LDIM_WR_32Bits(LD_HVGAIN,data);
 
-    //LD_BKLIT_VLD 
+    //LD_BKLIT_VLD
     LDIM_WR_32Bits(LD_BKLIT_VLD,ldim_param_bklit_valid);
 
     //LD_BKLIT_PARAM
@@ -577,7 +577,7 @@ void LDIM_Initial(int pic_h, int pic_v, int BLK_Vnum, int BLK_Hnum, int BackLit_
     //LD_LIT_GAIN_COMP
     data = ((ldim_param_litgain&0xfff)<<16) | (ldim_param_bl_matrix_compen & 0xfff);
     LDIM_WR_32Bits(LD_LIT_GAIN_COMP,data);
-   
+
     //LD_FRM_RST_POS
     ldim_param_frm_rst_pos = (16<<16) | (3); //h=16,v=3
     data = ldim_param_frm_rst_pos;
@@ -643,9 +643,9 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 }
 
 static struct class_attribute aml_ldim_class_attrs[] = {
-	//__ATTR(gamma_proc, S_IRUGO | S_IWUSR, 
+	//__ATTR(gamma_proc, S_IRUGO | S_IWUSR,
 	//	gamma_proc_show, gamma_proc_store),
-	//__ATTR(env_backlight, S_IRUGO | S_IWUSR, 
+	//__ATTR(env_backlight, S_IRUGO | S_IWUSR,
 	//	env_backlight_show, env_backlight_store),
 	__ATTR_NULL,
 };
@@ -659,14 +659,14 @@ static int aml_ldim_probe(struct platform_device *pdev)
 	  ret = - ENODEV;
 	  goto err;
 	}
-	
+
 	aml_ldim_clsp = class_create(THIS_MODULE, "aml_ldim");
 	if(IS_ERR(aml_ldim_clsp)){
 		ret = PTR_ERR(aml_ldim_clsp);
 		return ret;
 	}
 	for(i = 0; aml_ldim_class_attrs[i].attr.name; i++){
-		if(class_create_file(aml_ldim_clsp, 
+		if(class_create_file(aml_ldim_clsp,
 				&aml_ldim_class_attrs[i]) < 0)
 			goto err1;
 	}
@@ -704,16 +704,16 @@ err3:
 	 kfree(aml_ldim_cdevp);
 err2:
 	for(i=0; aml_ldim_class_attrs[i].attr.name; i++){
-		class_remove_file(aml_ldim_clsp, 
+		class_remove_file(aml_ldim_clsp,
 				&aml_ldim_class_attrs[i]);
 	}
-	class_destroy(aml_ldim_clsp); 
+	class_destroy(aml_ldim_clsp);
 err1:
     unregister_chrdev_region(aml_ldim_devno, 1);
 err:
   return ret;
 
-	return -1;  
+	return -1;
 }
 
 static int aml_ldim_remove(struct platform_device *pdev)
@@ -726,10 +726,10 @@ static int aml_ldim_remove(struct platform_device *pdev)
 	cdev_del(aml_ldim_cdevp);
 	kfree(aml_ldim_cdevp);
 	for(i=0; aml_ldim_class_attrs[i].attr.name; i++){
-		class_remove_file(aml_ldim_clsp, 
+		class_remove_file(aml_ldim_clsp,
 				&aml_ldim_class_attrs[i]);
 	}
-	class_destroy(aml_ldim_clsp); 
+	class_destroy(aml_ldim_clsp);
     unregister_chrdev_region(aml_ldim_devno, 1);
 
     pr_info("%s, driver remove ok\n", __func__);
@@ -764,4 +764,3 @@ module_exit(aml_ldim_exit);
 MODULE_AUTHOR("");
 MODULE_DESCRIPTION("Driver for ldim");
 MODULE_LICENSE("GPL");
-
diff --git a/drivers/amlogic/display/backlight/aml_ldim_drv.h b/drivers/amlogic/display/backlight/aml_ldim_drv.h
old mode 100644
new mode 100755
index 42d3f18d..96f241fc
--- a/drivers/amlogic/display/backlight/aml_ldim_drv.h
+++ b/drivers/amlogic/display/backlight/aml_ldim_drv.h
@@ -1,219 +1,218 @@
-/*
- * AMLOGIC Ldim
- *
- * Author:
- *
- * Copyright (C) 2010 Amlogic Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-#include <linux/cdev.h>
-
-#define AML_LDIM_MODULE_NAME "aml_ldim"
-#define AML_LDIM_DRIVER_NAME "aml_ldim"
-#define AML_LDIM_DEVICE_NAME "aml_ldim"
-#define AML_LDIM_CLASS_NAME  "aml_ldim"
-
-#define STA_LEN 9
-#define BLK_LEN 17
-#define LUT_LEN 32
-
-#define BLKHMAX 8
-#define BLKVMAX 8
-
-struct LDReg
-{
-	//---------------------------------------------------------------------------------------------------------------------------------------------------
-	// general parameters
-	int reg_LD_pic_RowMax;
-    int reg_LD_pic_ColMax;
-	int reg_LD_pic_YUVsum[3];         // only output u16*3, (internal ACC will be u32x3)
-    int reg_LD_pic_RGBsum[3];
-	
-	// -------------------------------------------------------------------------------------------------------------------------------------------------
-    // Statistic options
-	
-	int reg_LD_BLK_Vnum;          //u4: Maximum to 10
-    int reg_LD_BLK_Hnum;          //u4: Maximum to 10
-
-    int reg_LD_STA1max_LPF;		   //u1: STA1max statistics on [1 2 1]/4 filtered results
-	int reg_LD_STA2max_LPF;        //u1: STA2max statistics on [1 2 1]/4 filtered results
-	int reg_LD_STAhist_LPF;        //u1: STAhist statistics on [1 2 1]/4 filtered results
-    int reg_LD_STA1max_Hdlt;      // u2: (2^x) extra pixels into Max calculation
-    int reg_LD_STA1max_Vdlt;      // u4: extra pixels into Max calculation vertically
-    int reg_LD_STA2max_Hdlt;      // u2: (2^x) extra pixels into Max calculation
-    int reg_LD_STA2max_Vdlt;      // u4: extra pixels into Max calculation vertically
-    int reg_LD_STA1max_Hidx[STA_LEN];  // U12* 9
-    int reg_LD_STA1max_Vidx[STA_LEN];  // u12x 9
-    int reg_LD_STA2max_Hidx[STA_LEN];  // U12* 9
-    int reg_LD_STA2max_Vidx[STA_LEN];  // u12x 9
-
-    int reg_LD_STAhist_mode;      //u3: histogram statistics on XX separately 20bits*16bins:  0: R-only,  1:G-only 2:B-only 3:Y-only; 4: MAX(R,G,B), 5/6/7: R&G&B
-
-    int reg_LD_STAhist_Hidx[STA_LEN];  // U12* 9
-    int reg_LD_STAhist_Vidx[STA_LEN];  // u12x 9	
-
-	// -----------------------------------------------------------------------------------------------------------------------------------------------------------
-    // Backlit Modeling registers	
-	int BL_matrix[BLKVMAX*BLKHMAX];  // Define the RAM Matrix    
-    int reg_LD_BackLit_Xtlk;         //u1: 0 no block to block Xtalk model needed;   1: Xtalk model needed
-    int reg_LD_BackLit_mode;         //u2: 0- LEFT/RIGHT Edge Lit; 1- Top/Bot Edge Lit; 2 - DirectLit modeled H/V independant; 3- DirectLit modeled HV Circle distribution
-    int reg_LD_Reflect_Hnum;         //u3: numbers of band reflection considered in Horizontal direction; 0~4
-    int reg_LD_Reflect_Vnum;         //u3: numbers of band reflection considered in Horizontal direction; 0~4
-    int reg_LD_BkLit_curmod;         //u1: 0: H/V separately, 1 Circle distribution
-    int reg_LD_BkLUT_Intmod;         //u1: 0: linear interpolation, 1 cubical interpolation
-    int reg_LD_BkLit_Intmod;         //u1: 0: linear interpolation, 1 cubical interpolation
-    int reg_LD_BkLit_LPFmod;         //u3: 0: no LPF, 1:[1 14 1]/16;2:[1 6 1]/8; 3: [1 2 1]/4; 4:[9 14 9]/32  5/6/7: [5 6 5]/16;
-    int reg_LD_BkLit_Celnum;         //u8: 0: 1920~ 61
-    int reg_BL_matrix_AVG;           //u12: DC of whole picture BL to be substract from BL_matrix during modeling (Set by FW daynamically)
-    int reg_BL_matrix_Compensate;    //u12: DC of whole picture BL to be compensated back to Litfull after the model (Set by FW dynamically);
-    int reg_LD_Reflect_Hdgr[20];    //20*u6:  cells 1~20 for H Gains of different dist of Left/Right;
-    int reg_LD_Reflect_Vdgr[20];    //20*u6:  cells 1~20 for V Gains of different dist of Top/Bot;
-    int reg_LD_Reflect_Xdgr[4];     // 4*u6:
-    int reg_LD_Vgain;               //u12
-    int reg_LD_Hgain;               //u12
-    int reg_LD_Litgain;             //u12
-    int reg_LD_Litshft;             //u3   right shif of bits for the all Lit's sum
-    int reg_LD_BkLit_valid[32];     //u1x32: valid bits for the 32 cell Bklit to contribut to current position (refer to the backlit padding pattern)
-	// region division index  1      2     3    4    5(0)  6(1) 7(2) 8(3) 9(4)  10(5)11(6)12(7)13(8) 14(9)15(10) 16   17   18   19
-    int reg_LD_BLK_Hidx[BLK_LEN]; // S14* 17
-    int reg_LD_BLK_Vidx[BLK_LEN]; // S14* 17
-	// Define the RAM Matrix
-    int reg_LD_LUT_Hdg[LUT_LEN];
-    int reg_LD_LUT_Vdg[LUT_LEN];
-    int reg_LD_LUT_VHk[LUT_LEN];
-
-	// adding three cells for left boundary extend during Cubic interpolation
-	int reg_LD_LUT_Hdg_LEXT;
-    int reg_LD_LUT_Vdg_LEXT;
-    int reg_LD_LUT_VHk_LEXT;
-
-	//-----------------------------------------------------------------------------------------------------------------------------------
-    // Register used in RGB remapping
-    int reg_LD_RGBmapping_demo;              //u2: 0 no demo mode 1: display BL_fulpel on RGB
-    int reg_LD_X_LUT_interp_mode[3];         //U1 0: using linear interpolation between to neighbour LUT; 1: use the nearest LUT results
-    int X_idx[1][16];                        // Changed to 16 Lits define 32 Bin LUT to save cost
-    int X_nrm[1][16];                        // Changed to 16 Lits define 32 Bin LUT to save cost
-    int X_lut[3][16][32];                    // Changed to 16 Lits define 32 Bin LUT to save cost
-
-	//------------------------------------------------------------------------------------------------------------------------------------
-	// only do the Lit modleing on the AC part
-    int fw_LD_BLEst_ACmode; //u2: 0: est on BLmatrix; 1: est on (BL-DC); 2: est on (BL-MIN); 3: est on (BL-MAX)
-};
-
-struct FW_DAT
-{
-    // for temporary Firmware algorithm
-    int *TF_BL_alpha;
-    int *last_YUVsum;
-    int *last_RGBsum;
-    int *last_STA1_MaxRGB;
-    int *SF_BL_matrix;
-    int *TF_BL_matrix;
-};
-/*
-typedef struct Ldim_dev_s{
-    int reg_LD_pic_RowMax;
-	int reg_LD_pic_ColMax;
-	int reg_LD_BLK_Vnum;
-	int reg_LD_BLK_Hnum;
-	int reg_LD_BackLit_mode;
-	int reg_LD_BkLit_Celnum;
-	int reg_LD_STAhist_Hidx[];
-	int reg_LD_STAhist_Vidx[];
-	int reg_LD_Reflect_Hnum;
-	int reg_LD_Reflect_Vnum;
-	int reg_LD_BLK_Hidx[];
-	int reg_LD_BLK_Vidx[];
-	int reg_LD_Hgain;
-	int reg_LD_Vgain;
-	int reg_LD_STAhist_LPF;
-	int reg_LD_X_LUT_interp_mode[0];
-	int reg_LD_X_LUT_interp_mode[1];
-	int reg_LD_X_LUT_interp_mode[2];
-	
-}Ldim_dev_t;*/
-
-
-//#define LDIM_STTS_HIST_REGION_IDX                  0x1aa0
-#define LOCAL_DIM_STATISTIC_EN_BIT          31
-#define LOCAL_DIM_STATISTIC_EN_WID           1
-#define EOL_EN_BIT                          28
-#define EOL_EN_WID                           1
-
-	//0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
-#define HOVLP_NUM_SEL_BIT                   21
-#define HOVLP_NUM_SEL_WID                    2 
-#define LPF_BEFORE_STATISTIC_EN_BIT         20
-#define LPF_BEFORE_STATISTIC_EN_WID          1
-
-#define BLK_HV_POS_IDXS_BIT                 16
-#define BLK_HV_POS_IDXS_WID                  4
-#define RD_INDEX_INC_MODE_BIT               14
-#define RD_INDEX_INC_MODE_WID                2
-#define REGION_RD_SUB_INDEX_BIT              8
-#define REGION_RD_SUB_INDEX_WID              4
-#define REGION_RD_INDEX_BIT                  0
-#define REGION_RD_INDEX_WID                  7
-
-//each base has 16 address space
-#define LD_CFG_BASE          0x00
-#define LD_RGB_IDX_BASE      0x10
-#define LD_RGB_NRMW_BASE     0x40
-#define LD_BLK_HIDX_BASE     0x50
-#define LD_BLK_VIDX_BASE     0x60
-#define LD_LUT_HDG_BASE      0x70
-#define LD_LUT_VHK_BASE      0x80
-#define LD_LUT_VDG_BASE      0x90
-#define LD_MATRIX_R0_BASE    0xa0
-#define LD_MATRIX_R1_BASE    0xb0
-#define LD_REFLECT_DGR_BASE  0xf0
-
-#define LD_RGB_LUT_BASE      0x2000
- 
-
-#define LD_FRM_SIZE         0x0  
-#define LD_RGB_MOD          0x1
-#define LD_BLK_HVNUM        0x2
-#define LD_HVGAIN           0x3
-#define LD_BKLIT_VLD        0x4
-#define LD_BKLIT_PARAM      0x5
-#define LD_LUT_XDG_LEXT     0x6
-#define LD_LIT_GAIN_COMP    0x7
-#define LD_FRM_RST_POS      0x8
-#define LD_FRM_BL_START_POS 0x9
-#define LD_MISC_CTRL0       0xa 
-
-#define LD_BLK_LEN   17
-#define LD_LUT_LEN   32
-
-typedef struct _ldim_rgb_mode{
-    int RGBmapping_demo;  //u2: 0 no demo mode 1: display BL_fulpel on RGB
-    int b_ldlut_ip_mode;  //U1 0: using linear interpolation between to neighbour LUT; 1: use the nearest LUT results
-    int g_ldlut_ip_mode;
-    int r_ldlut_ip_mode;
-    int BkLit_LPFmod;  //u3: 0: no LPF, 1:[1 14 1]/16;2:[1 6 1]/8; 3: [1 2 1]/4; 4:[9 14 9]/32  5/6/7: [5 6 5]/16;
-    int BackLit_Xtlk;  //u1: 0 no block to block Xtalk model needed; 1: Xtalk model needed
-    int BkLit_Intmod;  //u1: 0: linear interpolation, 1 cubical interpolation
-    int BkLUT_Intmod;  //u1: 0: linear interpolation, 1 cubical interpolation
-    int BkLit_curmod;  //u1: 0: H/V separately, 1 Circle distribution
-    int BackLit_mode;  //u2: 0- LEFT/RIGHT Edge Lit; 1- Top/Bot Edge Lit; 2 - DirectLit modeled H/V independant;
-                       //    3- DirectLit modeled HV Circle distribution
-} sLDIM_RGB_MODE_Param;
-
-typedef struct _ldim_blk_hvnum{
-    int frm_hblank_num; //12bits
-    int Reflect_Vnum;   //3bits   //u3: numbers of band reflection considered in Horizontal direction; 0~4
-    int Reflect_Hnum;   //3bits   //u3: numbers of band reflection considered in Horizontal direction; 0~4
-    int BLK_Vnum;       //4bits
-    int BLK_Hnum;       //4bits  
-} sLDIM_BLK_HVNUM_Param;
-
-void LDIM_Initial(int pic_h, int pic_v, int BLK_Vnum, int BLK_Hnum, int BackLit_mode, int ldim_bl_en, int ldim_hvcnt_bypass);
-void LDIM_Updata_LUT(int blk_idx_update, int hdg_vhk_vdg_update, int bl_matrix_update, int bl_matrix_AVG_update, int reflect_dgr_update, int ld_rgb_update); 
-int  get_blMtxAvg(int size, int mode);
-void ld_fw_cfg_once(void);
-//int  ldim_round(int ix, int ib);
-
+/*
+ * AMLOGIC Ldim
+ *
+ * Author:
+ *
+ * Copyright (C) 2010 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/cdev.h>
+
+#define AML_LDIM_MODULE_NAME "aml_ldim"
+#define AML_LDIM_DRIVER_NAME "aml_ldim"
+#define AML_LDIM_DEVICE_NAME "aml_ldim"
+#define AML_LDIM_CLASS_NAME  "aml_ldim"
+
+#define STA_LEN 9
+#define BLK_LEN 17
+#define LUT_LEN 32
+
+#define BLKHMAX 8
+#define BLKVMAX 8
+
+struct LDReg
+{
+	//---------------------------------------------------------------------------------------------------------------------------------------------------
+	// general parameters
+	int reg_LD_pic_RowMax;
+    int reg_LD_pic_ColMax;
+	int reg_LD_pic_YUVsum[3];         // only output u16*3, (internal ACC will be u32x3)
+    int reg_LD_pic_RGBsum[3];
+
+	// -------------------------------------------------------------------------------------------------------------------------------------------------
+    // Statistic options
+
+	int reg_LD_BLK_Vnum;          //u4: Maximum to 10
+    int reg_LD_BLK_Hnum;          //u4: Maximum to 10
+
+    int reg_LD_STA1max_LPF;		   //u1: STA1max statistics on [1 2 1]/4 filtered results
+	int reg_LD_STA2max_LPF;        //u1: STA2max statistics on [1 2 1]/4 filtered results
+	int reg_LD_STAhist_LPF;        //u1: STAhist statistics on [1 2 1]/4 filtered results
+    int reg_LD_STA1max_Hdlt;      // u2: (2^x) extra pixels into Max calculation
+    int reg_LD_STA1max_Vdlt;      // u4: extra pixels into Max calculation vertically
+    int reg_LD_STA2max_Hdlt;      // u2: (2^x) extra pixels into Max calculation
+    int reg_LD_STA2max_Vdlt;      // u4: extra pixels into Max calculation vertically
+    int reg_LD_STA1max_Hidx[STA_LEN];  // U12* 9
+    int reg_LD_STA1max_Vidx[STA_LEN];  // u12x 9
+    int reg_LD_STA2max_Hidx[STA_LEN];  // U12* 9
+    int reg_LD_STA2max_Vidx[STA_LEN];  // u12x 9
+
+    int reg_LD_STAhist_mode;      //u3: histogram statistics on XX separately 20bits*16bins:  0: R-only,  1:G-only 2:B-only 3:Y-only; 4: MAX(R,G,B), 5/6/7: R&G&B
+
+    int reg_LD_STAhist_Hidx[STA_LEN];  // U12* 9
+    int reg_LD_STAhist_Vidx[STA_LEN];  // u12x 9
+
+	// -----------------------------------------------------------------------------------------------------------------------------------------------------------
+    // Backlit Modeling registers
+	int BL_matrix[BLKVMAX*BLKHMAX];  // Define the RAM Matrix
+    int reg_LD_BackLit_Xtlk;         //u1: 0 no block to block Xtalk model needed;   1: Xtalk model needed
+    int reg_LD_BackLit_mode;         //u2: 0- LEFT/RIGHT Edge Lit; 1- Top/Bot Edge Lit; 2 - DirectLit modeled H/V independant; 3- DirectLit modeled HV Circle distribution
+    int reg_LD_Reflect_Hnum;         //u3: numbers of band reflection considered in Horizontal direction; 0~4
+    int reg_LD_Reflect_Vnum;         //u3: numbers of band reflection considered in Horizontal direction; 0~4
+    int reg_LD_BkLit_curmod;         //u1: 0: H/V separately, 1 Circle distribution
+    int reg_LD_BkLUT_Intmod;         //u1: 0: linear interpolation, 1 cubical interpolation
+    int reg_LD_BkLit_Intmod;         //u1: 0: linear interpolation, 1 cubical interpolation
+    int reg_LD_BkLit_LPFmod;         //u3: 0: no LPF, 1:[1 14 1]/16;2:[1 6 1]/8; 3: [1 2 1]/4; 4:[9 14 9]/32  5/6/7: [5 6 5]/16;
+    int reg_LD_BkLit_Celnum;         //u8: 0: 1920~ 61
+    int reg_BL_matrix_AVG;           //u12: DC of whole picture BL to be substract from BL_matrix during modeling (Set by FW daynamically)
+    int reg_BL_matrix_Compensate;    //u12: DC of whole picture BL to be compensated back to Litfull after the model (Set by FW dynamically);
+    int reg_LD_Reflect_Hdgr[20];    //20*u6:  cells 1~20 for H Gains of different dist of Left/Right;
+    int reg_LD_Reflect_Vdgr[20];    //20*u6:  cells 1~20 for V Gains of different dist of Top/Bot;
+    int reg_LD_Reflect_Xdgr[4];     // 4*u6:
+    int reg_LD_Vgain;               //u12
+    int reg_LD_Hgain;               //u12
+    int reg_LD_Litgain;             //u12
+    int reg_LD_Litshft;             //u3   right shif of bits for the all Lit's sum
+    int reg_LD_BkLit_valid[32];     //u1x32: valid bits for the 32 cell Bklit to contribut to current position (refer to the backlit padding pattern)
+	// region division index  1      2     3    4    5(0)  6(1) 7(2) 8(3) 9(4)  10(5)11(6)12(7)13(8) 14(9)15(10) 16   17   18   19
+    int reg_LD_BLK_Hidx[BLK_LEN]; // S14* 17
+    int reg_LD_BLK_Vidx[BLK_LEN]; // S14* 17
+	// Define the RAM Matrix
+    int reg_LD_LUT_Hdg[LUT_LEN];
+    int reg_LD_LUT_Vdg[LUT_LEN];
+    int reg_LD_LUT_VHk[LUT_LEN];
+
+	// adding three cells for left boundary extend during Cubic interpolation
+	int reg_LD_LUT_Hdg_LEXT;
+    int reg_LD_LUT_Vdg_LEXT;
+    int reg_LD_LUT_VHk_LEXT;
+
+	//-----------------------------------------------------------------------------------------------------------------------------------
+    // Register used in RGB remapping
+    int reg_LD_RGBmapping_demo;              //u2: 0 no demo mode 1: display BL_fulpel on RGB
+    int reg_LD_X_LUT_interp_mode[3];         //U1 0: using linear interpolation between to neighbour LUT; 1: use the nearest LUT results
+    int X_idx[1][16];                        // Changed to 16 Lits define 32 Bin LUT to save cost
+    int X_nrm[1][16];                        // Changed to 16 Lits define 32 Bin LUT to save cost
+    int X_lut[3][16][32];                    // Changed to 16 Lits define 32 Bin LUT to save cost
+
+	//------------------------------------------------------------------------------------------------------------------------------------
+	// only do the Lit modleing on the AC part
+    int fw_LD_BLEst_ACmode; //u2: 0: est on BLmatrix; 1: est on (BL-DC); 2: est on (BL-MIN); 3: est on (BL-MAX)
+};
+
+struct FW_DAT
+{
+    // for temporary Firmware algorithm
+    int *TF_BL_alpha;
+    int *last_YUVsum;
+    int *last_RGBsum;
+    int *last_STA1_MaxRGB;
+    int *SF_BL_matrix;
+    int *TF_BL_matrix;
+};
+/*
+typedef struct Ldim_dev_s{
+    int reg_LD_pic_RowMax;
+	int reg_LD_pic_ColMax;
+	int reg_LD_BLK_Vnum;
+	int reg_LD_BLK_Hnum;
+	int reg_LD_BackLit_mode;
+	int reg_LD_BkLit_Celnum;
+	int reg_LD_STAhist_Hidx[];
+	int reg_LD_STAhist_Vidx[];
+	int reg_LD_Reflect_Hnum;
+	int reg_LD_Reflect_Vnum;
+	int reg_LD_BLK_Hidx[];
+	int reg_LD_BLK_Vidx[];
+	int reg_LD_Hgain;
+	int reg_LD_Vgain;
+	int reg_LD_STAhist_LPF;
+	int reg_LD_X_LUT_interp_mode[0];
+	int reg_LD_X_LUT_interp_mode[1];
+	int reg_LD_X_LUT_interp_mode[2];
+
+}Ldim_dev_t;*/
+
+
+//#define LDIM_STTS_HIST_REGION_IDX                  0x1aa0
+#define LOCAL_DIM_STATISTIC_EN_BIT          31
+#define LOCAL_DIM_STATISTIC_EN_WID           1
+#define EOL_EN_BIT                          28
+#define EOL_EN_WID                           1
+
+	//0: 17 pix, 1: 9 pix, 2: 5 pix, 3: 3 pix, 4: 0 pix
+#define HOVLP_NUM_SEL_BIT                   21
+#define HOVLP_NUM_SEL_WID                    2
+#define LPF_BEFORE_STATISTIC_EN_BIT         20
+#define LPF_BEFORE_STATISTIC_EN_WID          1
+
+#define BLK_HV_POS_IDXS_BIT                 16
+#define BLK_HV_POS_IDXS_WID                  4
+#define RD_INDEX_INC_MODE_BIT               14
+#define RD_INDEX_INC_MODE_WID                2
+#define REGION_RD_SUB_INDEX_BIT              8
+#define REGION_RD_SUB_INDEX_WID              4
+#define REGION_RD_INDEX_BIT                  0
+#define REGION_RD_INDEX_WID                  7
+
+//each base has 16 address space
+#define LD_CFG_BASE          0x00
+#define LD_RGB_IDX_BASE      0x10
+#define LD_RGB_NRMW_BASE     0x40
+#define LD_BLK_HIDX_BASE     0x50
+#define LD_BLK_VIDX_BASE     0x60
+#define LD_LUT_HDG_BASE      0x70
+#define LD_LUT_VHK_BASE      0x80
+#define LD_LUT_VDG_BASE      0x90
+#define LD_MATRIX_R0_BASE    0xa0
+#define LD_MATRIX_R1_BASE    0xb0
+#define LD_REFLECT_DGR_BASE  0xf0
+
+#define LD_RGB_LUT_BASE      0x2000
+
+
+#define LD_FRM_SIZE         0x0
+#define LD_RGB_MOD          0x1
+#define LD_BLK_HVNUM        0x2
+#define LD_HVGAIN           0x3
+#define LD_BKLIT_VLD        0x4
+#define LD_BKLIT_PARAM      0x5
+#define LD_LUT_XDG_LEXT     0x6
+#define LD_LIT_GAIN_COMP    0x7
+#define LD_FRM_RST_POS      0x8
+#define LD_FRM_BL_START_POS 0x9
+#define LD_MISC_CTRL0       0xa
+
+#define LD_BLK_LEN   17
+#define LD_LUT_LEN   32
+
+typedef struct _ldim_rgb_mode{
+    int RGBmapping_demo;  //u2: 0 no demo mode 1: display BL_fulpel on RGB
+    int b_ldlut_ip_mode;  //U1 0: using linear interpolation between to neighbour LUT; 1: use the nearest LUT results
+    int g_ldlut_ip_mode;
+    int r_ldlut_ip_mode;
+    int BkLit_LPFmod;  //u3: 0: no LPF, 1:[1 14 1]/16;2:[1 6 1]/8; 3: [1 2 1]/4; 4:[9 14 9]/32  5/6/7: [5 6 5]/16;
+    int BackLit_Xtlk;  //u1: 0 no block to block Xtalk model needed; 1: Xtalk model needed
+    int BkLit_Intmod;  //u1: 0: linear interpolation, 1 cubical interpolation
+    int BkLUT_Intmod;  //u1: 0: linear interpolation, 1 cubical interpolation
+    int BkLit_curmod;  //u1: 0: H/V separately, 1 Circle distribution
+    int BackLit_mode;  //u2: 0- LEFT/RIGHT Edge Lit; 1- Top/Bot Edge Lit; 2 - DirectLit modeled H/V independant;
+                       //    3- DirectLit modeled HV Circle distribution
+} sLDIM_RGB_MODE_Param;
+
+typedef struct _ldim_blk_hvnum{
+    int frm_hblank_num; //12bits
+    int Reflect_Vnum;   //3bits   //u3: numbers of band reflection considered in Horizontal direction; 0~4
+    int Reflect_Hnum;   //3bits   //u3: numbers of band reflection considered in Horizontal direction; 0~4
+    int BLK_Vnum;       //4bits
+    int BLK_Hnum;       //4bits
+} sLDIM_BLK_HVNUM_Param;
+
+void LDIM_Initial(int pic_h, int pic_v, int BLK_Vnum, int BLK_Hnum, int BackLit_mode, int ldim_bl_en, int ldim_hvcnt_bypass);
+void LDIM_Updata_LUT(int blk_idx_update, int hdg_vhk_vdg_update, int bl_matrix_update, int bl_matrix_AVG_update, int reflect_dgr_update, int ld_rgb_update);
+int  get_blMtxAvg(int size, int mode);
+void ld_fw_cfg_once(void);
+//int  ldim_round(int ix, int ib);
diff --git a/drivers/amlogic/display/backlight/iw7023_bl.c b/drivers/amlogic/display/backlight/iw7023_bl.c
old mode 100644
new mode 100755
index a612633c..bbb67992
--- a/drivers/amlogic/display/backlight/iw7023_bl.c
+++ b/drivers/amlogic/display/backlight/iw7023_bl.c
@@ -267,24 +267,24 @@ static const struct iwatt_reg_map usermode_map1_sky50[4] =
 static const struct iwatt_reg_map usermode_map2[17] =
 {
 	/* address, 2D value, 3D value */
-  	{0x054, 0x0066, 0x0066},	// td0:0.333ms	//4
-
-  	{0x055, 0x00E2, 0x00E2},	// 0.736ms	//5
-  	{0x056, 0x01D4, 0x01D4},	// 1.526ms	//6
-  	{0x057, 0x02C7, 0x02C7},	// 2.316ms	//7
-  	{0x058, 0x03B9, 0x03B9},	// 3.106ms	//8
-  	{0x059, 0x04AC, 0x04AC},	// 3.896ms	//9
-  	{0x05A, 0x059F, 0x059F},	// 4.686ms	//10
-  	{0x05B, 0x0691, 0x0691},	// 5.476ms	//11
-  	{0x05C, 0x0784, 0x0784},	// 6.266ms	//12
-  	{0x05D, 0x0784, 0x0784},	// 6.266ms	//13
-  	{0x05E, 0x0691, 0x0691},	// 5.476ms	//14
-  	{0x05F, 0x059F, 0x059F},	// 4.686ms
-  	{0x060, 0x04AC, 0x04AC},	// 3.896ms
-  	{0x061, 0x03B9, 0x03B9},	// 3.106ms
-  	{0x062, 0x02C7, 0x02C7},	// 2.316ms
-  	{0x063, 0x01D4, 0x01D4},	// 1.526ms
-  	{0x064, 0x00E2, 0x00E2},	// 0.736ms
+	{0x054, 0x0066, 0x0066},	// td0:0.333ms	//4
+
+	{0x055, 0x00E2, 0x00E2},	// 0.736ms	//5
+	{0x056, 0x01D4, 0x01D4},	// 1.526ms	//6
+	{0x057, 0x02C7, 0x02C7},	// 2.316ms	//7
+	{0x058, 0x03B9, 0x03B9},	// 3.106ms	//8
+	{0x059, 0x04AC, 0x04AC},	// 3.896ms	//9
+	{0x05A, 0x059F, 0x059F},	// 4.686ms	//10
+	{0x05B, 0x0691, 0x0691},	// 5.476ms	//11
+	{0x05C, 0x0784, 0x0784},	// 6.266ms	//12
+	{0x05D, 0x0784, 0x0784},	// 6.266ms	//13
+	{0x05E, 0x0691, 0x0691},	// 5.476ms	//14
+	{0x05F, 0x059F, 0x059F},	// 4.686ms
+	{0x060, 0x04AC, 0x04AC},	// 3.896ms
+	{0x061, 0x03B9, 0x03B9},	// 3.106ms
+	{0x062, 0x02C7, 0x02C7},	// 2.316ms
+	{0x063, 0x01D4, 0x01D4},	// 1.526ms
+	{0x064, 0x00E2, 0x00E2},	// 0.736ms
 };
 
 #define IW7023_USER_MODE_MAP2_SIZE ARRAY_SIZE(usermode_map2)
@@ -2232,4 +2232,3 @@ __setup ("panel=", iw7023_panel_setup);
 MODULE_DESCRIPTION("iW7023 LED Driver for LCD Panel Backlight");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Bobby Yang <bo.yang@amlogic.com>");
-
diff --git a/drivers/amlogic/display/backlight/iw7023_bl.h b/drivers/amlogic/display/backlight/iw7023_bl.h
old mode 100644
new mode 100755
index 93b43d8b..25d92968
--- a/drivers/amlogic/display/backlight/iw7023_bl.h
+++ b/drivers/amlogic/display/backlight/iw7023_bl.h
@@ -114,6 +114,3 @@ struct iwatt_reg_map
 
 
 #endif /* __IW7023_HW_H */
-
-
-
diff --git a/drivers/amlogic/display/backlight/iw7023_lpf.c b/drivers/amlogic/display/backlight/iw7023_lpf.c
old mode 100644
new mode 100755
index 1232e388..7b4a5031
--- a/drivers/amlogic/display/backlight/iw7023_lpf.c
+++ b/drivers/amlogic/display/backlight/iw7023_lpf.c
@@ -351,5 +351,3 @@ void lpf_work(void)
 	calculate_current();
 	calculate_final();
 }
-
-
diff --git a/drivers/amlogic/display/backlight/iw7023_lpf.h b/drivers/amlogic/display/backlight/iw7023_lpf.h
old mode 100644
new mode 100755
index 1031f20e..cfc5a79d
--- a/drivers/amlogic/display/backlight/iw7023_lpf.h
+++ b/drivers/amlogic/display/backlight/iw7023_lpf.h
@@ -42,4 +42,3 @@ void print_bri_final(void);
 
 
 #endif /* __IW7023_LPF_H */
-
diff --git a/drivers/amlogic/display/backlight/ld_notify.c b/drivers/amlogic/display/backlight/ld_notify.c
old mode 100644
new mode 100755
index e0b2029e..7bb1f2f7
--- a/drivers/amlogic/display/backlight/ld_notify.c
+++ b/drivers/amlogic/display/backlight/ld_notify.c
@@ -44,4 +44,3 @@ int ld_notifier_call_chain(unsigned long val, void *v)
 	return blocking_notifier_call_chain(&ld_notifier_list, val, v);
 }
 EXPORT_SYMBOL_GPL(ld_notifier_call_chain);
-
diff --git a/drivers/amlogic/display/backlight/localdimming.c b/drivers/amlogic/display/backlight/localdimming.c
old mode 100644
new mode 100755
index 4fc4c672..8baa4347
--- a/drivers/amlogic/display/backlight/localdimming.c
+++ b/drivers/amlogic/display/backlight/localdimming.c
@@ -53,6 +53,3 @@ int local_dimming_update(unsigned int *lumas, unsigned int size)
 	}
 	return 0;
 }
-
-
-
diff --git a/drivers/amlogic/display/ge2d/Kconfig b/drivers/amlogic/display/ge2d/Kconfig
index 41bcf9ec..87e35324 100755
--- a/drivers/amlogic/display/ge2d/Kconfig
+++ b/drivers/amlogic/display/ge2d/Kconfig
@@ -1,4 +1,4 @@
 config  AM_GE2D
 	tristate  "ge2d module"
-	help 
+	help
 		ge2d graphic  engine support
diff --git a/drivers/amlogic/display/ge2d/Makefile b/drivers/amlogic/display/ge2d/Makefile
index e4e0a759..06cf2420 100755
--- a/drivers/amlogic/display/ge2d/Makefile
+++ b/drivers/amlogic/display/ge2d/Makefile
@@ -1,13 +1,12 @@
-#makefile for apollo ge2d
-
-ge2d-objs=bitblt.o \
-				fillrect.o \
-				ge2d_hw.o \
-				ge2dgen.o\
-				ge2d_wq.o\
-				stretchblt.o\
-				ge2d_main.o\
-				blend.o
-obj-$(CONFIG_AM_GE2D) +=ge2d.o
-EXTRA_CFLAGS += -Iinclude/linux/ge2d/
-									
+#makefile for apollo ge2d
+
+ge2d-objs=bitblt.o \
+				fillrect.o \
+				ge2d_hw.o \
+				ge2dgen.o\
+				ge2d_wq.o\
+				stretchblt.o\
+				ge2d_main.o\
+				blend.o
+obj-$(CONFIG_AM_GE2D) +=ge2d.o
+EXTRA_CFLAGS += -Iinclude/linux/ge2d/
diff --git a/drivers/amlogic/display/ge2d/bitblt.c b/drivers/amlogic/display/ge2d/bitblt.c
old mode 100644
new mode 100755
index 0f5bbb86..01da6e86
--- a/drivers/amlogic/display/ge2d/bitblt.c
+++ b/drivers/amlogic/display/ge2d/bitblt.c
@@ -1,104 +1,104 @@
-#include <linux/amlogic/ge2d/ge2d.h>
-
-
-static void inline _bitblt(ge2d_context_t *wq,
-            int src_x, int src_y, int w, int h,
-            int dst_x, int dst_y, int block)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-            
-    ge2d_cmd_cfg->src1_x_start = src_x;
-    ge2d_cmd_cfg->src1_x_end   = src_x+w-1;
-    ge2d_cmd_cfg->src1_y_start = src_y;
-    ge2d_cmd_cfg->src1_y_end   = src_y+h-1;
-
-    ge2d_cmd_cfg->dst_x_start = dst_x;
-    ge2d_cmd_cfg->dst_x_end   = dst_x+w-1;
-    ge2d_cmd_cfg->dst_y_start = dst_y;
-    ge2d_cmd_cfg->dst_y_end   = dst_y+h-1;
-
-    ge2d_cmd_cfg->sc_hsc_en = 0;
-    ge2d_cmd_cfg->sc_vsc_en = 0;
-    ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
-    ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
-    ge2d_cmd_cfg->hsc_div_en = 0; 
-
-    ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
-    ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;  
-    ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
-    ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_COPY; 
-    ge2d_cmd_cfg->wait_done_flag   = block;
-
-    ge2d_wq_add_work(wq);
-}
-
-
-static void inline _bitblt_noalpha(ge2d_context_t *wq,
-                    int src_x, int src_y, int w, int h,
-                    int dst_x, int dst_y, int block)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-    ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
-
-    if(dp_gen_cfg->alu_const_color != 0xff)		
-    {
-    	dp_gen_cfg->alu_const_color = 0xff;
-	wq->config.update_flag |= UPDATE_DP_GEN;	
-    }
-    ge2d_cmd_cfg->src1_x_start = src_x;
-    ge2d_cmd_cfg->src1_x_end   = src_x+w-1;
-    ge2d_cmd_cfg->src1_y_start = src_y;
-    ge2d_cmd_cfg->src1_y_end   = src_y+h-1;
-
-    ge2d_cmd_cfg->dst_x_start  = dst_x;
-    ge2d_cmd_cfg->dst_x_end    = dst_x+w-1;
-    ge2d_cmd_cfg->dst_y_start  = dst_y;
-    ge2d_cmd_cfg->dst_y_end    = dst_y+h-1;
-
-    ge2d_cmd_cfg->sc_hsc_en = 0;
-    ge2d_cmd_cfg->sc_vsc_en = 0;
-    ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
-    ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
-    ge2d_cmd_cfg->hsc_div_en = 0; 
-
-    ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
-    ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;  
-    ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
-    ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_SET; 
-    ge2d_cmd_cfg->wait_done_flag   = block;
-
-    ge2d_wq_add_work(wq);
-}
-
-void bitblt(ge2d_context_t *wq,
-            int src_x, int src_y, int w, int h,
-            int dst_x, int dst_y)
-{
-    _bitblt(wq,
-        src_x, src_y, w, h, dst_x, dst_y, 1);
-}
-EXPORT_SYMBOL(bitblt);
-
-void bitblt_noblk(ge2d_context_t *wq,
-            int src_x, int src_y, int w, int h,
-            int dst_x, int dst_y)
-{
-    _bitblt(wq,
-        src_x, src_y, w, h, dst_x, dst_y, 0);
-}
-
-void bitblt_noalpha(ge2d_context_t *wq,
-                    int src_x, int src_y, int w, int h,
-                    int dst_x, int dst_y)
-{
-    _bitblt_noalpha(wq,
-        src_x, src_y, w, h, dst_x, dst_y, 1);
-}
-
-void bitblt_noalpha_noblk(ge2d_context_t *wq,
-                    int src_x, int src_y, int w, int h,
-                    int dst_x, int dst_y)
-{
-    _bitblt_noalpha(wq,
-        src_x, src_y, w, h, dst_x, dst_y, 0);
-}
+#include <linux/amlogic/ge2d/ge2d.h>
+
+
+static void inline _bitblt(ge2d_context_t *wq,
+            int src_x, int src_y, int w, int h,
+            int dst_x, int dst_y, int block)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+    ge2d_cmd_cfg->src1_x_start = src_x;
+    ge2d_cmd_cfg->src1_x_end   = src_x+w-1;
+    ge2d_cmd_cfg->src1_y_start = src_y;
+    ge2d_cmd_cfg->src1_y_end   = src_y+h-1;
+
+    ge2d_cmd_cfg->dst_x_start = dst_x;
+    ge2d_cmd_cfg->dst_x_end   = dst_x+w-1;
+    ge2d_cmd_cfg->dst_y_start = dst_y;
+    ge2d_cmd_cfg->dst_y_end   = dst_y+h-1;
+
+    ge2d_cmd_cfg->sc_hsc_en = 0;
+    ge2d_cmd_cfg->sc_vsc_en = 0;
+    ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+    ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+    ge2d_cmd_cfg->hsc_div_en = 0;
+
+    ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+    ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;
+    ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+    ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_COPY;
+    ge2d_cmd_cfg->wait_done_flag   = block;
+
+    ge2d_wq_add_work(wq);
+}
+
+
+static void inline _bitblt_noalpha(ge2d_context_t *wq,
+                    int src_x, int src_y, int w, int h,
+                    int dst_x, int dst_y, int block)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+    ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+
+    if(dp_gen_cfg->alu_const_color != 0xff)
+    {
+	dp_gen_cfg->alu_const_color = 0xff;
+	wq->config.update_flag |= UPDATE_DP_GEN;
+    }
+    ge2d_cmd_cfg->src1_x_start = src_x;
+    ge2d_cmd_cfg->src1_x_end   = src_x+w-1;
+    ge2d_cmd_cfg->src1_y_start = src_y;
+    ge2d_cmd_cfg->src1_y_end   = src_y+h-1;
+
+    ge2d_cmd_cfg->dst_x_start  = dst_x;
+    ge2d_cmd_cfg->dst_x_end    = dst_x+w-1;
+    ge2d_cmd_cfg->dst_y_start  = dst_y;
+    ge2d_cmd_cfg->dst_y_end    = dst_y+h-1;
+
+    ge2d_cmd_cfg->sc_hsc_en = 0;
+    ge2d_cmd_cfg->sc_vsc_en = 0;
+    ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+    ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+    ge2d_cmd_cfg->hsc_div_en = 0;
+
+    ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+    ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;
+    ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+    ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_SET;
+    ge2d_cmd_cfg->wait_done_flag   = block;
+
+    ge2d_wq_add_work(wq);
+}
+
+void bitblt(ge2d_context_t *wq,
+            int src_x, int src_y, int w, int h,
+            int dst_x, int dst_y)
+{
+    _bitblt(wq,
+        src_x, src_y, w, h, dst_x, dst_y, 1);
+}
+EXPORT_SYMBOL(bitblt);
+
+void bitblt_noblk(ge2d_context_t *wq,
+            int src_x, int src_y, int w, int h,
+            int dst_x, int dst_y)
+{
+    _bitblt(wq,
+        src_x, src_y, w, h, dst_x, dst_y, 0);
+}
+
+void bitblt_noalpha(ge2d_context_t *wq,
+                    int src_x, int src_y, int w, int h,
+                    int dst_x, int dst_y)
+{
+    _bitblt_noalpha(wq,
+        src_x, src_y, w, h, dst_x, dst_y, 1);
+}
+
+void bitblt_noalpha_noblk(ge2d_context_t *wq,
+                    int src_x, int src_y, int w, int h,
+                    int dst_x, int dst_y)
+{
+    _bitblt_noalpha(wq,
+        src_x, src_y, w, h, dst_x, dst_y, 0);
+}
diff --git a/drivers/amlogic/display/ge2d/blend.c b/drivers/amlogic/display/ge2d/blend.c
old mode 100644
new mode 100755
index 6019cc2e..6f56b72f
--- a/drivers/amlogic/display/ge2d/blend.c
+++ b/drivers/amlogic/display/ge2d/blend.c
@@ -1,122 +1,122 @@
-#include <linux/amlogic/ge2d/ge2d.h>
-
-
-void blend(ge2d_context_t *wq,
-           int src_x, int src_y, int src_w, int src_h, 
-           int src2_x, int src2_y, int src2_w, int src2_h,
-           int dst_x, int dst_y, int dst_w, int dst_h,
-           int op)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-            
-    ge2d_cmd_cfg->src1_x_start = src_x;
-    ge2d_cmd_cfg->src1_x_end   = src_x+src_w-1;
-    ge2d_cmd_cfg->src1_y_start = src_y;
-    ge2d_cmd_cfg->src1_y_end   = src_y+src_h-1;
-
-    ge2d_cmd_cfg->src2_x_start = src2_x;
-    ge2d_cmd_cfg->src2_x_end   = src2_x+src2_w-1;
-    ge2d_cmd_cfg->src2_y_start = src2_y;
-    ge2d_cmd_cfg->src2_y_end   = src2_y+src2_h-1;
-
-    ge2d_cmd_cfg->dst_x_start  = dst_x;
-    ge2d_cmd_cfg->dst_x_end    = dst_x+dst_w-1;
-    ge2d_cmd_cfg->dst_y_start  = dst_y;
-    ge2d_cmd_cfg->dst_y_end    = dst_y+dst_h-1;
-
-    //if ((dst_w != src_w) || (dst_h != src_h)) {
-    if (1) {
-        ge2d_cmd_cfg->sc_hsc_en = 1;
-        ge2d_cmd_cfg->sc_vsc_en = 1;
-        ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
-        ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
-        ge2d_cmd_cfg->hsc_div_en = 1; 
-    } else {
-        ge2d_cmd_cfg->sc_hsc_en = 0;
-        ge2d_cmd_cfg->sc_vsc_en = 0;
-        ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
-        ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
-        ge2d_cmd_cfg->hsc_div_en = 0; 
-    }
-    
-    ge2d_cmd_cfg->color_blend_mode = (op >> 24) & 0xff;
-    ge2d_cmd_cfg->color_src_blend_factor = (op >> 20) & 0xf;
-    ge2d_cmd_cfg->color_dst_blend_factor = (op >> 16) & 0xf;
-    ge2d_cmd_cfg->alpha_src_blend_factor = (op >>  4) & 0xf;
-    ge2d_cmd_cfg->alpha_dst_blend_factor = (op >>  0) & 0xf;
-
-    if (ge2d_cmd_cfg->color_blend_mode >= BLENDOP_LOGIC) {
-        ge2d_cmd_cfg->color_logic_op   = ge2d_cmd_cfg->color_blend_mode - BLENDOP_LOGIC;
-        ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
-    }
-    
-    ge2d_cmd_cfg->alpha_blend_mode = (op >> 8) & 0xff;
-    if (ge2d_cmd_cfg->alpha_blend_mode >= BLENDOP_LOGIC) {
-        ge2d_cmd_cfg->alpha_logic_op   = ge2d_cmd_cfg->alpha_blend_mode - BLENDOP_LOGIC;
-        ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
-    }
-
-    ge2d_cmd_cfg->wait_done_flag   = 1;
-
-    ge2d_wq_add_work(wq);
-}
-
-void blend_noblk(ge2d_context_t *wq,
-           int src_x, int src_y, int src_w, int src_h, 
-           int src2_x, int src2_y, int src2_w, int src2_h,
-           int dst_x, int dst_y, int dst_w, int dst_h,
-           int op)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-            
-    ge2d_cmd_cfg->src1_x_start = src_x;
-    ge2d_cmd_cfg->src1_x_end   = src_x+src_w-1;
-    ge2d_cmd_cfg->src1_y_start = src_y;
-    ge2d_cmd_cfg->src1_y_end   = src_y+src_h-1;
-
-    ge2d_cmd_cfg->src2_x_start = src2_x;
-    ge2d_cmd_cfg->src2_x_end   = src2_x+src2_w-1;
-    ge2d_cmd_cfg->src2_y_start = src2_y;
-    ge2d_cmd_cfg->src2_y_end   = src2_y+src2_h-1;
-
-    ge2d_cmd_cfg->dst_x_start  = dst_x;
-    ge2d_cmd_cfg->dst_x_end    = dst_x+dst_w-1;
-    ge2d_cmd_cfg->dst_y_start  = dst_y;
-    ge2d_cmd_cfg->dst_y_end    = dst_y+dst_h-1;
-
-    //if ((dst_w != src_w) || (dst_h != src_h)) {
-    if (1) {
-        ge2d_cmd_cfg->sc_hsc_en = 1;
-        ge2d_cmd_cfg->sc_vsc_en = 1;
-        ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
-        ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
-        ge2d_cmd_cfg->hsc_div_en = 1; 
-    } else {
-        ge2d_cmd_cfg->sc_hsc_en = 0;
-        ge2d_cmd_cfg->sc_vsc_en = 0;
-        ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
-        ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
-        ge2d_cmd_cfg->hsc_div_en = 0; 
-    }
-    
-    ge2d_cmd_cfg->color_blend_mode = (op >> 24) & 0xff;
-    ge2d_cmd_cfg->color_src_blend_factor = (op >> 20) & 0xf;
-    ge2d_cmd_cfg->color_dst_blend_factor = (op >> 16) & 0xf;
-    ge2d_cmd_cfg->alpha_src_blend_factor = (op >>  4) & 0xf;
-    ge2d_cmd_cfg->alpha_dst_blend_factor = (op >>  0) & 0xf;
-
-    if (ge2d_cmd_cfg->color_blend_mode >= BLENDOP_LOGIC) {
-        ge2d_cmd_cfg->color_logic_op   = ge2d_cmd_cfg->color_blend_mode - BLENDOP_LOGIC;
-        ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
-    }
-    
-    ge2d_cmd_cfg->alpha_blend_mode = (op >> 8) & 0xff;
-    if (ge2d_cmd_cfg->alpha_blend_mode >= BLENDOP_LOGIC) {
-        ge2d_cmd_cfg->alpha_logic_op   = ge2d_cmd_cfg->alpha_blend_mode - BLENDOP_LOGIC;
-        ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
-    }
-
-    ge2d_cmd_cfg->wait_done_flag   = 0;
-
-    ge2d_wq_add_work(wq);
-}
+#include <linux/amlogic/ge2d/ge2d.h>
+
+
+void blend(ge2d_context_t *wq,
+           int src_x, int src_y, int src_w, int src_h,
+           int src2_x, int src2_y, int src2_w, int src2_h,
+           int dst_x, int dst_y, int dst_w, int dst_h,
+           int op)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+    ge2d_cmd_cfg->src1_x_start = src_x;
+    ge2d_cmd_cfg->src1_x_end   = src_x+src_w-1;
+    ge2d_cmd_cfg->src1_y_start = src_y;
+    ge2d_cmd_cfg->src1_y_end   = src_y+src_h-1;
+
+    ge2d_cmd_cfg->src2_x_start = src2_x;
+    ge2d_cmd_cfg->src2_x_end   = src2_x+src2_w-1;
+    ge2d_cmd_cfg->src2_y_start = src2_y;
+    ge2d_cmd_cfg->src2_y_end   = src2_y+src2_h-1;
+
+    ge2d_cmd_cfg->dst_x_start  = dst_x;
+    ge2d_cmd_cfg->dst_x_end    = dst_x+dst_w-1;
+    ge2d_cmd_cfg->dst_y_start  = dst_y;
+    ge2d_cmd_cfg->dst_y_end    = dst_y+dst_h-1;
+
+    //if ((dst_w != src_w) || (dst_h != src_h)) {
+    if (1) {
+        ge2d_cmd_cfg->sc_hsc_en = 1;
+        ge2d_cmd_cfg->sc_vsc_en = 1;
+        ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+        ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+        ge2d_cmd_cfg->hsc_div_en = 1;
+    } else {
+        ge2d_cmd_cfg->sc_hsc_en = 0;
+        ge2d_cmd_cfg->sc_vsc_en = 0;
+        ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+        ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+        ge2d_cmd_cfg->hsc_div_en = 0;
+    }
+
+    ge2d_cmd_cfg->color_blend_mode = (op >> 24) & 0xff;
+    ge2d_cmd_cfg->color_src_blend_factor = (op >> 20) & 0xf;
+    ge2d_cmd_cfg->color_dst_blend_factor = (op >> 16) & 0xf;
+    ge2d_cmd_cfg->alpha_src_blend_factor = (op >>  4) & 0xf;
+    ge2d_cmd_cfg->alpha_dst_blend_factor = (op >>  0) & 0xf;
+
+    if (ge2d_cmd_cfg->color_blend_mode >= BLENDOP_LOGIC) {
+        ge2d_cmd_cfg->color_logic_op   = ge2d_cmd_cfg->color_blend_mode - BLENDOP_LOGIC;
+        ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+    }
+
+    ge2d_cmd_cfg->alpha_blend_mode = (op >> 8) & 0xff;
+    if (ge2d_cmd_cfg->alpha_blend_mode >= BLENDOP_LOGIC) {
+        ge2d_cmd_cfg->alpha_logic_op   = ge2d_cmd_cfg->alpha_blend_mode - BLENDOP_LOGIC;
+        ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+    }
+
+    ge2d_cmd_cfg->wait_done_flag   = 1;
+
+    ge2d_wq_add_work(wq);
+}
+
+void blend_noblk(ge2d_context_t *wq,
+           int src_x, int src_y, int src_w, int src_h,
+           int src2_x, int src2_y, int src2_w, int src2_h,
+           int dst_x, int dst_y, int dst_w, int dst_h,
+           int op)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+    ge2d_cmd_cfg->src1_x_start = src_x;
+    ge2d_cmd_cfg->src1_x_end   = src_x+src_w-1;
+    ge2d_cmd_cfg->src1_y_start = src_y;
+    ge2d_cmd_cfg->src1_y_end   = src_y+src_h-1;
+
+    ge2d_cmd_cfg->src2_x_start = src2_x;
+    ge2d_cmd_cfg->src2_x_end   = src2_x+src2_w-1;
+    ge2d_cmd_cfg->src2_y_start = src2_y;
+    ge2d_cmd_cfg->src2_y_end   = src2_y+src2_h-1;
+
+    ge2d_cmd_cfg->dst_x_start  = dst_x;
+    ge2d_cmd_cfg->dst_x_end    = dst_x+dst_w-1;
+    ge2d_cmd_cfg->dst_y_start  = dst_y;
+    ge2d_cmd_cfg->dst_y_end    = dst_y+dst_h-1;
+
+    //if ((dst_w != src_w) || (dst_h != src_h)) {
+    if (1) {
+        ge2d_cmd_cfg->sc_hsc_en = 1;
+        ge2d_cmd_cfg->sc_vsc_en = 1;
+        ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+        ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+        ge2d_cmd_cfg->hsc_div_en = 1;
+    } else {
+        ge2d_cmd_cfg->sc_hsc_en = 0;
+        ge2d_cmd_cfg->sc_vsc_en = 0;
+        ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+        ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+        ge2d_cmd_cfg->hsc_div_en = 0;
+    }
+
+    ge2d_cmd_cfg->color_blend_mode = (op >> 24) & 0xff;
+    ge2d_cmd_cfg->color_src_blend_factor = (op >> 20) & 0xf;
+    ge2d_cmd_cfg->color_dst_blend_factor = (op >> 16) & 0xf;
+    ge2d_cmd_cfg->alpha_src_blend_factor = (op >>  4) & 0xf;
+    ge2d_cmd_cfg->alpha_dst_blend_factor = (op >>  0) & 0xf;
+
+    if (ge2d_cmd_cfg->color_blend_mode >= BLENDOP_LOGIC) {
+        ge2d_cmd_cfg->color_logic_op   = ge2d_cmd_cfg->color_blend_mode - BLENDOP_LOGIC;
+        ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+    }
+
+    ge2d_cmd_cfg->alpha_blend_mode = (op >> 8) & 0xff;
+    if (ge2d_cmd_cfg->alpha_blend_mode >= BLENDOP_LOGIC) {
+        ge2d_cmd_cfg->alpha_logic_op   = ge2d_cmd_cfg->alpha_blend_mode - BLENDOP_LOGIC;
+        ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+    }
+
+    ge2d_cmd_cfg->wait_done_flag   = 0;
+
+    ge2d_wq_add_work(wq);
+}
diff --git a/drivers/amlogic/display/ge2d/fillrect.c b/drivers/amlogic/display/ge2d/fillrect.c
old mode 100644
new mode 100755
index bf6e115d..335ede17
--- a/drivers/amlogic/display/ge2d/fillrect.c
+++ b/drivers/amlogic/display/ge2d/fillrect.c
@@ -1,49 +1,49 @@
-#include <linux/amlogic/ge2d/ge2d.h>
-
-
-
-static void inline _fillrect(ge2d_context_t *wq,
-              int x, int y, int w, int h, unsigned color, int blk)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-            
-    ge2dgen_src_color(wq, color);
-
-    ge2d_cmd_cfg->src1_x_start = x;
-    ge2d_cmd_cfg->src1_x_end   = x+w-1;
-    ge2d_cmd_cfg->src1_y_start = y;
-    ge2d_cmd_cfg->src1_y_end   = y+h-1;
-
-    ge2d_cmd_cfg->dst_x_start  = x;
-    ge2d_cmd_cfg->dst_x_end    = x+w-1;
-    ge2d_cmd_cfg->dst_y_start  = y;
-    ge2d_cmd_cfg->dst_y_end    = y+h-1;
-
-    ge2d_cmd_cfg->sc_hsc_en = 0;
-    ge2d_cmd_cfg->sc_vsc_en = 0;
-    ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
-    ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
-    ge2d_cmd_cfg->hsc_div_en = 0; 
-
-    ge2d_cmd_cfg->src1_fill_color_en = 1;
-
-    ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
-    ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;  
-    ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
-    ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_COPY; 
-    ge2d_cmd_cfg->wait_done_flag   = 1;
-
-    ge2d_wq_add_work(wq);
-}
-
-void fillrect(ge2d_context_t *wq,
-              int x, int y, int w, int h, unsigned color)
-{
-    _fillrect(wq, x, y, w, h, color, 1);
-}
-EXPORT_SYMBOL(fillrect);
-void fillrect_noblk(ge2d_context_t *wq,
-              int x, int y, int w, int h, unsigned color)
-{
-    _fillrect(wq, x, y, w, h, color, 0);
-}
+#include <linux/amlogic/ge2d/ge2d.h>
+
+
+
+static void inline _fillrect(ge2d_context_t *wq,
+              int x, int y, int w, int h, unsigned color, int blk)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+    ge2dgen_src_color(wq, color);
+
+    ge2d_cmd_cfg->src1_x_start = x;
+    ge2d_cmd_cfg->src1_x_end   = x+w-1;
+    ge2d_cmd_cfg->src1_y_start = y;
+    ge2d_cmd_cfg->src1_y_end   = y+h-1;
+
+    ge2d_cmd_cfg->dst_x_start  = x;
+    ge2d_cmd_cfg->dst_x_end    = x+w-1;
+    ge2d_cmd_cfg->dst_y_start  = y;
+    ge2d_cmd_cfg->dst_y_end    = y+h-1;
+
+    ge2d_cmd_cfg->sc_hsc_en = 0;
+    ge2d_cmd_cfg->sc_vsc_en = 0;
+    ge2d_cmd_cfg->hsc_rpt_p0_num = 0;
+    ge2d_cmd_cfg->vsc_rpt_l0_num = 0;
+    ge2d_cmd_cfg->hsc_div_en = 0;
+
+    ge2d_cmd_cfg->src1_fill_color_en = 1;
+
+    ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+    ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;
+    ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+    ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_COPY;
+    ge2d_cmd_cfg->wait_done_flag   = 1;
+
+    ge2d_wq_add_work(wq);
+}
+
+void fillrect(ge2d_context_t *wq,
+              int x, int y, int w, int h, unsigned color)
+{
+    _fillrect(wq, x, y, w, h, color, 1);
+}
+EXPORT_SYMBOL(fillrect);
+void fillrect_noblk(ge2d_context_t *wq,
+              int x, int y, int w, int h, unsigned color)
+{
+    _fillrect(wq, x, y, w, h, color, 0);
+}
diff --git a/drivers/amlogic/display/ge2d/ge2d_dev.h b/drivers/amlogic/display/ge2d/ge2d_dev.h
old mode 100644
new mode 100755
index 65b51d36..239fe096
--- a/drivers/amlogic/display/ge2d/ge2d_dev.h
+++ b/drivers/amlogic/display/ge2d/ge2d_dev.h
@@ -19,9 +19,9 @@ static  ge2d_device_t  ge2d_device;
 static DEFINE_MUTEX(ge2d_mutex);
 static const struct file_operations ge2d_fops = {
 	.owner		= THIS_MODULE,
-	.open		=ge2d_open,  
+	.open		=ge2d_open,
 	.unlocked_ioctl		= ge2d_ioctl,
-	.release		= ge2d_release, 	
+	.release		= ge2d_release,
 };
 static struct class_attribute ge2d_class_attrs[] = {
 	__ATTR(wq_status,
diff --git a/drivers/amlogic/display/ge2d/ge2d_hw.c b/drivers/amlogic/display/ge2d/ge2d_hw.c
old mode 100644
new mode 100755
index f42ddea6..57a9f9de
--- a/drivers/amlogic/display/ge2d/ge2d_hw.c
+++ b/drivers/amlogic/display/ge2d/ge2d_hw.c
@@ -36,7 +36,7 @@ static const  unsigned int filt_coef0[] =   //bicubic
 			0xf84a45f9,
 			0xf84848f8
 			};
-			
+
 static const    unsigned int filt_coef1[] =  //2 point bilinear
 			{
 			0x00800000,
@@ -76,77 +76,77 @@ static const    unsigned int filt_coef1[] =  //2 point bilinear
 
 static const    unsigned int filt_coef2[] =  //3 point triangle
 			{
-            0x40400000, 
-            0x3f400100,  
+            0x40400000,
+            0x3f400100,
             0x3d410200,
-            0x3c410300, 
+            0x3c410300,
             0x3a420400,
             0x39420500,
             0x37430600,
-            0x36430700, 
-            0x35430800, 
+            0x36430700,
+            0x35430800,
             0x33450800,
-            0x32450900, 
-            0x31450a00, 
-            0x30450b00, 
-            0x2e460c00, 
-            0x2d460d00, 
-            0x2c470d00, 
-            0x2b470e00, 
-            0x29480f00, 
-            0x28481000, 
-            0x27481100, 
-            0x26491100, 
-            0x25491200, 
-            0x24491300, 
-            0x234a1300, 
-            0x224a1400, 
-            0x214a1500, 
-            0x204a1600, 
-            0x1f4b1600, 
-            0x1e4b1700, 
-            0x1d4b1800, 
-            0x1c4c1800, 
-            0x1b4c1900, 
+            0x32450900,
+            0x31450a00,
+            0x30450b00,
+            0x2e460c00,
+            0x2d460d00,
+            0x2c470d00,
+            0x2b470e00,
+            0x29480f00,
+            0x28481000,
+            0x27481100,
+            0x26491100,
+            0x25491200,
+            0x24491300,
+            0x234a1300,
+            0x224a1400,
+            0x214a1500,
+            0x204a1600,
+            0x1f4b1600,
+            0x1e4b1700,
+            0x1d4b1800,
+            0x1c4c1800,
+            0x1b4c1900,
             0x1a4c1a00
-            }; 
+            };
 static const        unsigned int filt_coef3[] =  //3 point triangle
 		{
-            0x20402000, 
-            0x00,  
+            0x20402000,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
+            0x00,
             0x00,
-            0x00, 
             0x00,
             0x00,
             0x00,
-            0x00, 
-            0x00, 
             0x00,
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
-            0x00, 
             0x00
-            };     
-			
+            };
+
 //####################################################################################################
 // ge2d_set_src1_data
 //####################################################################################################
@@ -158,25 +158,25 @@ void ge2d_set_src1_data (ge2d_src1_data_t *cfg)
    WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL1, cfg->ddr_burst_size_cb, 18, 2);
    WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL1, cfg->ddr_burst_size_cr, 16, 2);
 
-   WRITE_MPEG_REG(GE2D_SRC1_CANVAS, 
-   				  ((cfg->canaddr & 0xff) << 24) |
+   WRITE_MPEG_REG(GE2D_SRC1_CANVAS,
+				  ((cfg->canaddr & 0xff) << 24) |
                   (((cfg->canaddr >> 8) & 0xff) << 16) |
                   (((cfg->canaddr >> 16) & 0xff) << 8));
 
-   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, ((cfg->x_yc_ratio << 1) | cfg->y_yc_ratio), 10, 2);  
-   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->sep_en, 0, 1);  
-   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->endian, 7, 1);  
-   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->color_map, 3, 4);  
+   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, ((cfg->x_yc_ratio << 1) | cfg->y_yc_ratio), 10, 2);
+   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->sep_en, 0, 1);
+   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->endian, 7, 1);
+   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->color_map, 3, 4);
    WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->format, 0, 2);
    WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->mode_8b_sel, 5, 2);
    WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->lut_en, 3, 1);
 
    WRITE_MPEG_REG(GE2D_SRC1_DEF_COLOR, cfg->def_color);
-   if (cfg->x_yc_ratio) 
-     WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, 1, 18, 1); //horizontal formatter enable 
+   if (cfg->x_yc_ratio)
+     WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, 1, 18, 1); //horizontal formatter enable
    else
-     WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, 0, 18, 1); //horizontal formatter disable 
-   if (cfg->y_yc_ratio) 
+     WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, 0, 18, 1); //horizontal formatter disable
+   if (cfg->y_yc_ratio)
      WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, 1, 16, 1);  //vertical formatter enable
    else
      WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, 0, 16, 1);  //vertical formatter disable
@@ -186,9 +186,9 @@ void ge2d_set_src1_data (ge2d_src1_data_t *cfg)
 // ge2d_set_src1_scale_coef
 //####################################################################################################
 void ge2d_set_src1_scale_coef (unsigned v_filt_type, unsigned h_filt_type)
-{  
+{
     int i;
-   
+
     //write vert filter coefs
     WRITE_MPEG_REG(GE2D_SCALE_COEF_IDX, 0x0000);
 	for (i = 0; i < 33; i++)
@@ -221,8 +221,8 @@ void ge2d_set_src1_scale_coef (unsigned v_filt_type, unsigned h_filt_type)
             //todo
             WRITE_MPEG_REG(GE2D_SCALE_COEF, filt_coef3[i]);
         }
-    }			
-    
+    }
+
 }
 
 //####################################################################################################
@@ -230,28 +230,28 @@ void ge2d_set_src1_scale_coef (unsigned v_filt_type, unsigned h_filt_type)
 //####################################################################################################
 void ge2d_set_src1_gen (ge2d_src1_gen_t *cfg)
 {
-   WRITE_MPEG_REG(GE2D_SRC1_CLIPX_START_END, 
-                         (cfg->clipx_start_ex << 31) | 
+   WRITE_MPEG_REG(GE2D_SRC1_CLIPX_START_END,
+                         (cfg->clipx_start_ex << 31) |
                          (cfg->clipx_start << 16) |
                          (cfg->clipx_end_ex << 15) |
                          (cfg->clipx_end << 0)
-                         ); 
+                         );
 
-   WRITE_MPEG_REG(GE2D_SRC1_CLIPY_START_END, 
-                         (cfg->clipy_start_ex << 31) | 
+   WRITE_MPEG_REG(GE2D_SRC1_CLIPY_START_END,
+                         (cfg->clipy_start_ex << 31) |
                          (cfg->clipy_start << 16) |
                          (cfg->clipy_end_ex << 15) |
                          (cfg->clipy_end << 0)
-                         ); 
+                         );
 
-   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->pic_struct, 1, 2);  
-   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, (cfg->fill_mode & 0x1), 4, 1); 
+   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->pic_struct, 1, 2);
+   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, (cfg->fill_mode & 0x1), 4, 1);
 
-   WRITE_MPEG_REG_BITS (GE2D_SRC_OUTSIDE_ALPHA, ((cfg->fill_mode & 0x2) <<7) | 
+   WRITE_MPEG_REG_BITS (GE2D_SRC_OUTSIDE_ALPHA, ((cfg->fill_mode & 0x2) <<7) |
                                         cfg->outside_alpha, 0, 9);
-   
-   WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, cfg->chfmt_rpt_pix, 19, 1); 
-   WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, cfg->cvfmt_rpt_pix, 17, 1);   
+
+   WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, cfg->chfmt_rpt_pix, 19, 1);
+   WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, cfg->cvfmt_rpt_pix, 17, 1);
 }
 
 
@@ -269,21 +269,21 @@ void ge2d_set_src2_dst_data (ge2d_src2_dst_data_t *cfg)
 	WRITE_MPEG_REG(GE2D_SRC2_DST_CANVAS, (cfg->src2_canaddr << 8) |
 			 ((cfg->dst_canaddr & 0xff) << 0) |
 			 ((cfg->dst_canaddr & 0xff00) << 8)
-			 ); 
+			 );
 #else
 	WRITE_MPEG_REG(GE2D_SRC2_DST_CANVAS, (cfg->src2_canaddr << 8) |
 			 (cfg->dst_canaddr << 0)
-			 ); 
+			 );
 
 #endif
-	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->src2_endian, 15, 1);  
-	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->src2_color_map, 11, 4);  
-	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->src2_format, 8, 2);  
-	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->dst_endian, 23, 1);  
-	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->dst_color_map, 19, 4);  
-	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->dst_format, 16, 2);  
-	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->src2_mode_8b_sel, 15, 2);  
-	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->dst_mode_8b_sel, 24, 2); 
+	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->src2_endian, 15, 1);
+	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->src2_color_map, 11, 4);
+	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->src2_format, 8, 2);
+	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->dst_endian, 23, 1);
+	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->dst_color_map, 19, 4);
+	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL2, cfg->dst_format, 16, 2);
+	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->src2_mode_8b_sel, 15, 2);
+	WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->dst_mode_8b_sel, 24, 2);
 
 	/* only for m6 and later chips. */
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
@@ -301,35 +301,35 @@ void ge2d_set_src2_dst_data (ge2d_src2_dst_data_t *cfg)
 //####################################################################################################
 void ge2d_set_src2_dst_gen (ge2d_src2_dst_gen_t *cfg)
 {
-   WRITE_MPEG_REG(GE2D_SRC2_CLIPX_START_END, 
+   WRITE_MPEG_REG(GE2D_SRC2_CLIPX_START_END,
                          (cfg->src2_clipx_start << 16) |
                          (cfg->src2_clipx_end << 0)
-                         ); 
+                         );
 
-   WRITE_MPEG_REG(GE2D_SRC2_CLIPY_START_END, 
+   WRITE_MPEG_REG(GE2D_SRC2_CLIPY_START_END,
                          (cfg->src2_clipy_start << 16) |
                          (cfg->src2_clipy_end << 0)
-                         ); 
-                            
-   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->src2_pic_struct, 12, 2);  
-   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, (cfg->src2_fill_mode & 0x1), 14, 1);  
+                         );
+
+   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->src2_pic_struct, 12, 2);
+   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, (cfg->src2_fill_mode & 0x1), 14, 1);
 
-   WRITE_MPEG_REG_BITS (GE2D_SRC_OUTSIDE_ALPHA, ((cfg->src2_fill_mode & 0x2) <<7) | 
+   WRITE_MPEG_REG_BITS (GE2D_SRC_OUTSIDE_ALPHA, ((cfg->src2_fill_mode & 0x2) <<7) |
                                         cfg->src2_outside_alpha, 16, 9);
-   
 
-   WRITE_MPEG_REG(GE2D_DST_CLIPX_START_END, 
+
+   WRITE_MPEG_REG(GE2D_DST_CLIPX_START_END,
                          (cfg->dst_clipx_start << 16) |
                          (cfg->dst_clipx_end << 0)
-                         ); 
+                         );
 
-   WRITE_MPEG_REG(GE2D_DST_CLIPY_START_END, 
+   WRITE_MPEG_REG(GE2D_DST_CLIPY_START_END,
                          (cfg->dst_clipy_start << 16) |
                          (cfg->dst_clipy_end << 0)
-                         ); 
-  
-   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->dst_clip_mode,  23, 1);                              
-   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL1, cfg->dst_pic_struct, 14, 2);   
+                         );
+
+   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0, cfg->dst_clip_mode,  23, 1);
+   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL1, cfg->dst_pic_struct, 14, 2);
 }
 
 //####################################################################################################
@@ -344,22 +344,22 @@ void ge2d_set_dp_gen (ge2d_dp_gen_t *cfg)
     unsigned int antiflick_alpha_filter_n1[] = {0,    8,  16, 32};
     unsigned int antiflick_alpha_filter_n2[] = {128,112,  96, 64};
     unsigned int antiflick_alpha_filter_n3[] = {0,    8,  16, 32};
-    unsigned int antiflick_alpha_filter_th[] = {8, 16, 64};        
+    unsigned int antiflick_alpha_filter_th[] = {8, 16, 64};
 
     if( cfg->conv_matrix_en )
     {
-    	cfg->antiflick_ycbcr_rgb_sel = 0;  //0: yuv2rgb 1:rgb2rgb
-    	cfg->antiflick_cbcr_en = 1;
-    	cfg->antiflick_r_coef = 0; 
-    	cfg->antiflick_g_coef = 0;
-    	cfg->antiflick_b_coef = 0;
+	cfg->antiflick_ycbcr_rgb_sel = 0;  //0: yuv2rgb 1:rgb2rgb
+	cfg->antiflick_cbcr_en = 1;
+	cfg->antiflick_r_coef = 0;
+	cfg->antiflick_g_coef = 0;
+	cfg->antiflick_b_coef = 0;
      }else{
-       	cfg->antiflick_ycbcr_rgb_sel = 1;  	//0: yuv2rgb 1:rgb2rgb
-    	cfg->antiflick_cbcr_en = 1;
-    	cfg->antiflick_r_coef = 0x42;    	//0.257 
-    	cfg->antiflick_g_coef = 0x81;     	//0.504
-    	cfg->antiflick_b_coef = 0x19;     	//0.098
-     }   
+	cfg->antiflick_ycbcr_rgb_sel = 1;  	//0: yuv2rgb 1:rgb2rgb
+	cfg->antiflick_cbcr_en = 1;
+	cfg->antiflick_r_coef = 0x42;    	//0.257
+	cfg->antiflick_g_coef = 0x81;     	//0.504
+	cfg->antiflick_b_coef = 0x19;     	//0.098
+     }
     memcpy(cfg->antiflick_color_filter_n1, antiflick_color_filter_n1, 4 * sizeof(unsigned int));
     memcpy(cfg->antiflick_color_filter_n2, antiflick_color_filter_n2, 4 * sizeof(unsigned int));
     memcpy(cfg->antiflick_color_filter_n3, antiflick_color_filter_n3, 4 * sizeof(unsigned int));
@@ -367,23 +367,23 @@ void ge2d_set_dp_gen (ge2d_dp_gen_t *cfg)
     memcpy(cfg->antiflick_alpha_filter_n1, antiflick_alpha_filter_n1, 4 * sizeof(unsigned int));
     memcpy(cfg->antiflick_alpha_filter_n2, antiflick_alpha_filter_n2, 4 * sizeof(unsigned int));
     memcpy(cfg->antiflick_alpha_filter_n3, antiflick_alpha_filter_n3, 4 * sizeof(unsigned int));
-    memcpy(cfg->antiflick_alpha_filter_th, antiflick_alpha_filter_th, 3 * sizeof(unsigned int));    
+    memcpy(cfg->antiflick_alpha_filter_th, antiflick_alpha_filter_th, 3 * sizeof(unsigned int));
    cfg->src1_vsc_bank_length = 4;
    cfg->src1_hsc_bank_length = 4;
-   WRITE_MPEG_REG_BITS (GE2D_SC_MISC_CTRL, 
+   WRITE_MPEG_REG_BITS (GE2D_SC_MISC_CTRL,
                          ((cfg->src1_hsc_rpt_ctrl << 9) |
                          (cfg->src1_vsc_rpt_ctrl << 8) |
                          (cfg->src1_vsc_phase0_always_en << 7) |
                          (cfg->src1_vsc_bank_length << 4) |
                          (cfg->src1_hsc_phase0_always_en << 3) |
-                         (cfg->src1_hsc_bank_length << 0)),  0, 10); 
+                         (cfg->src1_hsc_bank_length << 0)),  0, 10);
 
    WRITE_MPEG_REG_BITS(GE2D_SC_MISC_CTRL, ((cfg->src1_vsc_nearest_en <<1) |
                                   (cfg->src1_hsc_nearest_en << 0)), 29, 2);
   if (cfg->antiflick_en == 1) {
-     //Wr(GE2D_ANTIFLICK_CTRL0, 0x81000100); 
-     WRITE_MPEG_REG(GE2D_ANTIFLICK_CTRL0, 0x80000000); 
-     WRITE_MPEG_REG(GE2D_ANTIFLICK_CTRL1, 
+     //Wr(GE2D_ANTIFLICK_CTRL0, 0x81000100);
+     WRITE_MPEG_REG(GE2D_ANTIFLICK_CTRL0, 0x80000000);
+     WRITE_MPEG_REG(GE2D_ANTIFLICK_CTRL1,
             (cfg->antiflick_ycbcr_rgb_sel << 25) |
             (cfg->antiflick_cbcr_en << 24) |
             ((cfg->antiflick_r_coef & 0xff) << 16) |
@@ -391,58 +391,58 @@ void ge2d_set_dp_gen (ge2d_dp_gen_t *cfg)
             ((cfg->antiflick_b_coef & 0xff) << 0)
             );
 
-     WRITE_MPEG_REG (GE2D_ANTIFLICK_COLOR_FILT0, 
-            ((cfg->antiflick_color_filter_th[0] & 0xff) << 24) | 
-            ((cfg->antiflick_color_filter_n3[0] & 0xff) << 16) | 
-            ((cfg->antiflick_color_filter_n2[0] & 0xff) << 8) | 
+     WRITE_MPEG_REG (GE2D_ANTIFLICK_COLOR_FILT0,
+            ((cfg->antiflick_color_filter_th[0] & 0xff) << 24) |
+            ((cfg->antiflick_color_filter_n3[0] & 0xff) << 16) |
+            ((cfg->antiflick_color_filter_n2[0] & 0xff) << 8) |
             ((cfg->antiflick_color_filter_n1[0] & 0xff) << 0)
             );
-            
-     WRITE_MPEG_REG (GE2D_ANTIFLICK_COLOR_FILT1, 
-            ((cfg->antiflick_color_filter_th[1] & 0xff) << 24) | 
-            ((cfg->antiflick_color_filter_n3[1] & 0xff) << 16) | 
-            ((cfg->antiflick_color_filter_n2[1] & 0xff) << 8) | 
+
+     WRITE_MPEG_REG (GE2D_ANTIFLICK_COLOR_FILT1,
+            ((cfg->antiflick_color_filter_th[1] & 0xff) << 24) |
+            ((cfg->antiflick_color_filter_n3[1] & 0xff) << 16) |
+            ((cfg->antiflick_color_filter_n2[1] & 0xff) << 8) |
             ((cfg->antiflick_color_filter_n1[1] & 0xff) << 0)
             );
 
-     WRITE_MPEG_REG (GE2D_ANTIFLICK_COLOR_FILT2, 
-            ((cfg->antiflick_color_filter_th[2] & 0xff) << 24) | 
-            ((cfg->antiflick_color_filter_n3[2] & 0xff) << 16) | 
-            ((cfg->antiflick_color_filter_n2[2] & 0xff) << 8) | 
+     WRITE_MPEG_REG (GE2D_ANTIFLICK_COLOR_FILT2,
+            ((cfg->antiflick_color_filter_th[2] & 0xff) << 24) |
+            ((cfg->antiflick_color_filter_n3[2] & 0xff) << 16) |
+            ((cfg->antiflick_color_filter_n2[2] & 0xff) << 8) |
             ((cfg->antiflick_color_filter_n1[2] & 0xff) << 0)
             );
 
-     WRITE_MPEG_REG (GE2D_ANTIFLICK_COLOR_FILT3, 
-            ((cfg->antiflick_color_filter_n3[3] & 0xff) << 16) | 
-            ((cfg->antiflick_color_filter_n2[3] & 0xff) << 8) | 
+     WRITE_MPEG_REG (GE2D_ANTIFLICK_COLOR_FILT3,
+            ((cfg->antiflick_color_filter_n3[3] & 0xff) << 16) |
+            ((cfg->antiflick_color_filter_n2[3] & 0xff) << 8) |
             ((cfg->antiflick_color_filter_n1[3] & 0xff) << 0)
             );
 
 
-     WRITE_MPEG_REG (GE2D_ANTIFLICK_ALPHA_FILT0, 
-            ((cfg->antiflick_alpha_filter_th[0] & 0xff) << 24) | 
-            ((cfg->antiflick_alpha_filter_n3[0] & 0xff) << 16) | 
-            ((cfg->antiflick_alpha_filter_n2[0] & 0xff) << 8) | 
+     WRITE_MPEG_REG (GE2D_ANTIFLICK_ALPHA_FILT0,
+            ((cfg->antiflick_alpha_filter_th[0] & 0xff) << 24) |
+            ((cfg->antiflick_alpha_filter_n3[0] & 0xff) << 16) |
+            ((cfg->antiflick_alpha_filter_n2[0] & 0xff) << 8) |
             ((cfg->antiflick_alpha_filter_n1[0] & 0xff) << 0)
             );
-            
-     WRITE_MPEG_REG (GE2D_ANTIFLICK_ALPHA_FILT1, 
-            ((cfg->antiflick_alpha_filter_th[1] & 0xff) << 24) | 
-            ((cfg->antiflick_alpha_filter_n3[1] & 0xff) << 16) | 
-            ((cfg->antiflick_alpha_filter_n2[1] & 0xff) << 8) | 
+
+     WRITE_MPEG_REG (GE2D_ANTIFLICK_ALPHA_FILT1,
+            ((cfg->antiflick_alpha_filter_th[1] & 0xff) << 24) |
+            ((cfg->antiflick_alpha_filter_n3[1] & 0xff) << 16) |
+            ((cfg->antiflick_alpha_filter_n2[1] & 0xff) << 8) |
             ((cfg->antiflick_alpha_filter_n1[1] & 0xff) << 0)
             );
 
-     WRITE_MPEG_REG (GE2D_ANTIFLICK_ALPHA_FILT2, 
-            ((cfg->antiflick_alpha_filter_th[2] & 0xff) << 24) | 
-            ((cfg->antiflick_alpha_filter_n3[2] & 0xff) << 16) | 
-            ((cfg->antiflick_alpha_filter_n2[2] & 0xff) << 8) | 
+     WRITE_MPEG_REG (GE2D_ANTIFLICK_ALPHA_FILT2,
+            ((cfg->antiflick_alpha_filter_th[2] & 0xff) << 24) |
+            ((cfg->antiflick_alpha_filter_n3[2] & 0xff) << 16) |
+            ((cfg->antiflick_alpha_filter_n2[2] & 0xff) << 8) |
             ((cfg->antiflick_alpha_filter_n1[2] & 0xff) << 0)
             );
 
-     WRITE_MPEG_REG (GE2D_ANTIFLICK_ALPHA_FILT3, 
-            ((cfg->antiflick_alpha_filter_n3[3] & 0xff) << 16) | 
-            ((cfg->antiflick_alpha_filter_n2[3] & 0xff) << 8) | 
+     WRITE_MPEG_REG (GE2D_ANTIFLICK_ALPHA_FILT3,
+            ((cfg->antiflick_alpha_filter_n3[3] & 0xff) << 16) |
+            ((cfg->antiflick_alpha_filter_n2[3] & 0xff) << 8) |
             ((cfg->antiflick_alpha_filter_n1[3] & 0xff) << 0)
             );
   }
@@ -511,74 +511,74 @@ void ge2d_set_dp_gen (ge2d_dp_gen_t *cfg)
      cfg->matrix_minus_16_ctrl = 0;
      cfg->matrix_sign_ctrl = 0x3;
   }
-                         
+
 	if (cfg->matrix_minus_16_ctrl) {
 		WRITE_MPEG_REG_BITS(GE2D_MATRIX_PRE_OFFSET, 0x1f0, 20, 9);
 	} else {
 		WRITE_MPEG_REG_BITS(GE2D_MATRIX_PRE_OFFSET, 0, 20, 9);
 	}
-	
+
 	if (cfg->matrix_sign_ctrl & 3) {
 		WRITE_MPEG_REG_BITS(GE2D_MATRIX_PRE_OFFSET, ((0x180 << 10) | 0x180), 0, 20);
 	} else {
 		WRITE_MPEG_REG_BITS(GE2D_MATRIX_PRE_OFFSET, 0, 0, 20);
 	}
-   WRITE_MPEG_REG(GE2D_MATRIX_COEF00_01, 
-                        (cfg->matrix_coef[0] << 16) | 
+   WRITE_MPEG_REG(GE2D_MATRIX_COEF00_01,
+                        (cfg->matrix_coef[0] << 16) |
                         (cfg->matrix_coef[1] << 0)
-                        ); 
-                                               
-   WRITE_MPEG_REG(GE2D_MATRIX_COEF02_10, 
-                        (cfg->matrix_coef[2] << 16) | 
+                        );
+
+   WRITE_MPEG_REG(GE2D_MATRIX_COEF02_10,
+                        (cfg->matrix_coef[2] << 16) |
                         (cfg->matrix_coef[3] << 0)
-                        ); 
+                        );
 
-   WRITE_MPEG_REG(GE2D_MATRIX_COEF11_12, 
-                        (cfg->matrix_coef[4] << 16) | 
+   WRITE_MPEG_REG(GE2D_MATRIX_COEF11_12,
+                        (cfg->matrix_coef[4] << 16) |
                         (cfg->matrix_coef[5] << 0)
-                        ); 
+                        );
 
-   WRITE_MPEG_REG(GE2D_MATRIX_COEF20_21, 
-                        (cfg->matrix_coef[6] << 16) | 
+   WRITE_MPEG_REG(GE2D_MATRIX_COEF20_21,
+                        (cfg->matrix_coef[6] << 16) |
                         (cfg->matrix_coef[7] << 0)
-                        ); 
-                         
-   WRITE_MPEG_REG(GE2D_MATRIX_COEF22_CTRL, 
-                        (cfg->matrix_coef[8] << 16) | 
+                        );
+
+   WRITE_MPEG_REG(GE2D_MATRIX_COEF22_CTRL,
+                        (cfg->matrix_coef[8] << 16) |
                         (cfg->matrix_sat_in_en << 7) |
 #if 0
                         (cfg->matrix_minus_16_ctrl << 4) |
                         (cfg->matrix_sign_ctrl << 1) |
 #endif
                         (cfg->conv_matrix_en << 0)
-                        ); 
+                        );
 
    WRITE_MPEG_REG(GE2D_MATRIX_OFFSET,
-                       (cfg->matrix_offset[0] << 20) |  
-                       (cfg->matrix_offset[1] << 10) |  
+                       (cfg->matrix_offset[0] << 20) |
+                       (cfg->matrix_offset[1] << 10) |
                        (cfg->matrix_offset[2] << 0)
-                       );  
+                       );
+
 
-                            
    WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL1, cfg->src1_gb_alpha, 0, 8);
-     
-   WRITE_MPEG_REG(GE2D_ALU_CONST_COLOR, cfg->alu_const_color);  
 
-   WRITE_MPEG_REG(GE2D_SRC1_KEY, cfg->src1_key);  
-   WRITE_MPEG_REG(GE2D_SRC1_KEY_MASK, cfg->src1_key_mask);  
+   WRITE_MPEG_REG(GE2D_ALU_CONST_COLOR, cfg->alu_const_color);
 
-   WRITE_MPEG_REG(GE2D_SRC2_KEY, cfg->src2_key);  
-   WRITE_MPEG_REG(GE2D_SRC2_KEY_MASK, cfg->src2_key_mask);  
+   WRITE_MPEG_REG(GE2D_SRC1_KEY, cfg->src1_key);
+   WRITE_MPEG_REG(GE2D_SRC1_KEY_MASK, cfg->src1_key_mask);
+
+   WRITE_MPEG_REG(GE2D_SRC2_KEY, cfg->src2_key);
+   WRITE_MPEG_REG(GE2D_SRC2_KEY_MASK, cfg->src2_key_mask);
+
+   WRITE_MPEG_REG(GE2D_DST_BITMASK, cfg->bitmask);
 
-   WRITE_MPEG_REG(GE2D_DST_BITMASK, cfg->bitmask);    
-   
    WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL0,
                     ((cfg->bytemask_only << 5) |
                      (cfg->bitmask_en << 4) |
                      (cfg->src2_key_en << 3) |
                      (cfg->src2_key_mode << 2) |
                      (cfg->src1_key_en << 1) |
-                     (cfg->src1_key_mode << 0)) , 26, 6); 
+                     (cfg->src1_key_mode << 0)) , 26, 6);
 }
 
 int ge2d_cmd_fifo_full(void)
@@ -598,14 +598,14 @@ void ge2d_set_cmd (ge2d_cmd_t *cfg)
     unsigned x_chr_phase = 0, y_chr_phase = 0;
     unsigned x_yc_ratio, y_yc_ratio;
     int sc_prehsc_en, sc_prevsc_en;
-    unsigned int src1_y_end=cfg->src1_y_end+1; //expand src region with one line. 	
-    
+    unsigned int src1_y_end=cfg->src1_y_end+1; //expand src region with one line.
+
     while ((READ_MPEG_REG(GE2D_STATUS0) & (1 << 1))) {}
-    
+
     x_yc_ratio = READ_MPEG_REG_BITS(GE2D_GEN_CTRL0, 11, 1);
     y_yc_ratio = READ_MPEG_REG_BITS(GE2D_GEN_CTRL0, 10, 1);
 
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6	
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
     if (x_yc_ratio) {
         if (cfg->src1_x_rev) {
             x_extra_bit_start = 0;
@@ -617,7 +617,7 @@ void ge2d_set_cmd (ge2d_cmd_t *cfg)
             x_chr_phase = 0x08;
         }
     }
-    
+
     if (y_yc_ratio) {
         if (cfg->src1_y_rev) {
             y_extra_bit_start = 2;
@@ -656,62 +656,62 @@ void ge2d_set_cmd (ge2d_cmd_t *cfg)
 
 #endif
 
-    WRITE_MPEG_REG(GE2D_SRC1_X_START_END, 
+    WRITE_MPEG_REG(GE2D_SRC1_X_START_END,
                          (x_extra_bit_start << 30) |  //x start extra
                          ((cfg->src1_x_start & 0x3fff) << 16) | // Limit the range in case of the sign bit extending to the top
                          (x_extra_bit_end << 14) |    //x end extra
                          ((cfg->src1_x_end & 0x3fff) << 0) // Limit the range in case of the sign bit extending to the top
-                         ); 
+                         );
 
-    WRITE_MPEG_REG(GE2D_SRC1_Y_START_END, 
+    WRITE_MPEG_REG(GE2D_SRC1_Y_START_END,
                          (y_extra_bit_start << 30) |  //y start extra
                          ((cfg->src1_y_start & 0x3fff) << 16) | // Limit the range in case of the sign bit extending to the top
                          (y_extra_bit_end << 14) |    //y end extra
                          ((src1_y_end & 0x3fff) << 0) // Limit the range in case of the sign bit extending to the top
-                         ); 
-
-    WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, x_chr_phase, 8, 8); 
-    WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, y_chr_phase, 0, 8); 
- 
- 
-    WRITE_MPEG_REG(GE2D_SRC2_X_START_END, 
-                         (cfg->src2_x_start << 16) | 
+                         );
+
+    WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, x_chr_phase, 8, 8);
+    WRITE_MPEG_REG_BITS (GE2D_SRC1_FMT_CTRL, y_chr_phase, 0, 8);
+
+
+    WRITE_MPEG_REG(GE2D_SRC2_X_START_END,
+                         (cfg->src2_x_start << 16) |
                          (cfg->src2_x_end << 0)
-                         ); 
- 
-    WRITE_MPEG_REG(GE2D_SRC2_Y_START_END, 
-                         (cfg->src2_y_start << 16) | 
+                         );
+
+    WRITE_MPEG_REG(GE2D_SRC2_Y_START_END,
+                         (cfg->src2_y_start << 16) |
                          (cfg->src2_y_end << 0)
-                         ); 
-  
-    WRITE_MPEG_REG(GE2D_DST_X_START_END, 
-                         (cfg->dst_x_start << 16) | 
+                         );
+
+    WRITE_MPEG_REG(GE2D_DST_X_START_END,
+                         (cfg->dst_x_start << 16) |
                          (cfg->dst_x_end << 0)
-                         ); 
- 
-    WRITE_MPEG_REG(GE2D_DST_Y_START_END, 
-                         (cfg->dst_y_start << 16) | 
+                         );
+
+    WRITE_MPEG_REG(GE2D_DST_Y_START_END,
+                         (cfg->dst_y_start << 16) |
                          (cfg->dst_y_end << 0)
-                         );            
-                         
+                         );
+
     widthi  = cfg->src1_x_end - cfg->src1_x_start + 1;
     heighti = cfg->src1_y_end - cfg->src1_y_start + 1;
- 
+
     widtho  = cfg->dst_xy_swap ? (cfg->dst_y_end - cfg->dst_y_start + 1): (cfg->dst_x_end - cfg->dst_x_start + 1);
     heighto = cfg->dst_xy_swap ? (cfg->dst_x_end - cfg->dst_x_start + 1): (cfg->dst_y_end - cfg->dst_y_start + 1);
- 
+
 	sc_prehsc_en = (widthi > widtho*2) ? 1 : 0;
 	sc_prevsc_en = (heighti > heighto*2) ? 1 : 0;
-    
-    tmp_widthi  = sc_prehsc_en ? ((widthi+1) >>1): widthi; 
-    tmp_heighti = sc_prevsc_en ? ((heighti+1) >>1): heighti; 
-   
+
+    tmp_widthi  = sc_prehsc_en ? ((widthi+1) >>1): widthi;
+    tmp_heighti = sc_prevsc_en ? ((heighti+1) >>1): heighti;
+
     if (cfg->hsc_phase_step == 0)
        cfg->hsc_phase_step = ((tmp_widthi << 18) / widtho) <<6;//width no more than 8192
 
     if (cfg->vsc_phase_step == 0)
        cfg->vsc_phase_step = ((tmp_heighti << 18) / heighto) << 6;//height no more than 8192
-       
+
     if ((cfg->sc_hsc_en) && (cfg->hsc_div_en)) {
         cfg->hsc_div_length = (124 << 24) / cfg->hsc_phase_step;
 
@@ -719,8 +719,8 @@ void ge2d_set_cmd (ge2d_cmd_t *cfg)
         cfg->hsc_adv_num   = multo >> 24;
         cfg->hsc_adv_phase = multo & 0xffffff;
     }
-       
-    WRITE_MPEG_REG_BITS (GE2D_SC_MISC_CTRL, 
+
+    WRITE_MPEG_REG_BITS (GE2D_SC_MISC_CTRL,
                         ((cfg->hsc_div_en << 17) |
                         (cfg->hsc_div_length << 4) |
                         (sc_prehsc_en << 3) |
@@ -728,32 +728,32 @@ void ge2d_set_cmd (ge2d_cmd_t *cfg)
                         (cfg->sc_vsc_en << 1) |
                         (cfg->sc_hsc_en << 0)), 11, 18);
 
-    WRITE_MPEG_REG(GE2D_HSC_ADV_CTRL, 
-                        (cfg->hsc_adv_num << 24) | 
+    WRITE_MPEG_REG(GE2D_HSC_ADV_CTRL,
+                        (cfg->hsc_adv_num << 24) |
                         (cfg->hsc_adv_phase << 0)
                         );
-   
+
     WRITE_MPEG_REG(GE2D_HSC_START_PHASE_STEP, cfg->hsc_phase_step);
 
     WRITE_MPEG_REG(GE2D_HSC_PHASE_SLOPE, cfg->hsc_phase_slope);
 
-    WRITE_MPEG_REG(GE2D_HSC_INI_CTRL, 
-                        (cfg->hsc_rpt_p0_num << 29) | 
+    WRITE_MPEG_REG(GE2D_HSC_INI_CTRL,
+                        (cfg->hsc_rpt_p0_num << 29) |
                         (cfg->hsc_ini_phase << 0)
                         );
-                        
+
 
     WRITE_MPEG_REG(GE2D_VSC_START_PHASE_STEP, cfg->vsc_phase_step);
 
     WRITE_MPEG_REG(GE2D_VSC_PHASE_SLOPE, cfg->vsc_phase_slope);
 
-    WRITE_MPEG_REG(GE2D_VSC_INI_CTRL, 
-                        (cfg->vsc_rpt_l0_num << 29) | 
+    WRITE_MPEG_REG(GE2D_VSC_INI_CTRL,
+                        (cfg->vsc_rpt_l0_num << 29) |
                         (cfg->vsc_ini_phase << 0)
                         );
-                        
-  
-    WRITE_MPEG_REG(GE2D_ALU_OP_CTRL, 
+
+
+    WRITE_MPEG_REG(GE2D_ALU_OP_CTRL,
                        (cfg->src1_cmult_asel << 25) |
                        (cfg->src2_cmult_asel << 24) |
                        (cfg->color_blend_mode << 20) |
@@ -762,9 +762,9 @@ void ge2d_set_cmd (ge2d_cmd_t *cfg)
                        (cfg->alpha_blend_mode << 8) |
                        (cfg->alpha_src_blend_factor << 4) |
                        (((cfg->alpha_blend_mode == 5) ? cfg->alpha_logic_op: cfg->alpha_dst_blend_factor) << 0)
-                       ); 
-                       
-    WRITE_MPEG_REG(GE2D_CMD_CTRL, 
+                       );
+
+    WRITE_MPEG_REG(GE2D_CMD_CTRL,
                        (cfg->src2_fill_color_en << 9) |
                        (cfg->src1_fill_color_en << 8) |
                        (cfg->dst_xy_swap << 7) |
@@ -775,18 +775,18 @@ void ge2d_set_cmd (ge2d_cmd_t *cfg)
                        (cfg->src1_x_rev << 2) |
                        (cfg->src1_y_rev << 1) |
                        1  << 0                  //start cmd
-                       );  
-    cfg->release_flag |= START_FLAG;                                        
+                       );
+    cfg->release_flag |= START_FLAG;
 }
 //####################################################################################################
 // ge2d_wait_done
 //####################################################################################################
 void ge2d_wait_done (void)
 {
-    while (READ_MPEG_REG(GE2D_STATUS0) & 1) 
+    while (READ_MPEG_REG(GE2D_STATUS0) & 1)
 	{
-		
-	}    
+
+	}
 }
 
 
@@ -795,7 +795,7 @@ void ge2d_wait_done (void)
 //####################################################################################################
 int ge2d_is_busy (void)
 {
-    return (READ_MPEG_REG(GE2D_STATUS0) & 1);   
+    return (READ_MPEG_REG(GE2D_STATUS0) & 1);
 }
 
 //####################################################################################################
@@ -812,14 +812,13 @@ void ge2d_soft_rst (void)
 //####################################################################################################
 void ge2d_set_gen (ge2d_gen_t *cfg)
 {
-   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL1, cfg->interrupt_ctrl, 24, 2);  
-   
-   WRITE_MPEG_REG(GE2D_DP_ONOFF_CTRL, 
+   WRITE_MPEG_REG_BITS (GE2D_GEN_CTRL1, cfg->interrupt_ctrl, 24, 2);
+
+   WRITE_MPEG_REG(GE2D_DP_ONOFF_CTRL,
                          (cfg->dp_onoff_mode << 31) |
                          (cfg->dp_on_cnt << 16) |
                          (cfg->vfmt_onoff_en << 15) |
                          (cfg->dp_off_cnt << 0)
-                         ); 
+                         );
 
 }
-
diff --git a/drivers/amlogic/display/ge2d/ge2d_log.h b/drivers/amlogic/display/ge2d/ge2d_log.h
old mode 100644
new mode 100755
index 26753b49..7fa73b5b
--- a/drivers/amlogic/display/ge2d/ge2d_log.h
+++ b/drivers/amlogic/display/ge2d/ge2d_log.h
@@ -1,28 +1,27 @@
-#ifndef  OSD_LOG_H
-#define OSD_LOG_H
-
-#define DEBUG
-#ifdef  DEBUG
-#define  AMLOG   1
-#define LOG_LEVEL_VAR amlog_level_ge2d
-#define LOG_MASK_VAR amlog_mask_ge2d
-#endif
-
-
-#define  	LOG_LEVEL_HIGH    		0x00f
-#define	LOG_LEVEL_1				0x001
-#define 	LOG_LEVEL_LOW			0x000
-
-#define LOG_LEVEL_DESC \
-"[0x00]LOW[0X01]LEVEL1[0xf]HIGH"	
-
-#define  	LOG_MASK_INIT			0x001
-#define	LOG_MASK_IOCTL			0x002
-#define	LOG_MASK_HARDWARE		0x004
-#define	LOG_MASK_CONFIG		0x008
-#define	LOG_MASK_WORK			0x010
-#define 	LOG_MASK_DESC \
-"[0x01]:INIT,[0x02]:IOCTL,[0x04]:HARDWARE,[0x08]LOG_MASK_CONFIG[0x10]LOG_MASK_WORK"
-
-#endif
-
+#ifndef  OSD_LOG_H
+#define OSD_LOG_H
+
+#define DEBUG
+#ifdef  DEBUG
+#define  AMLOG   1
+#define LOG_LEVEL_VAR amlog_level_ge2d
+#define LOG_MASK_VAR amlog_mask_ge2d
+#endif
+
+
+#define  	LOG_LEVEL_HIGH    		0x00f
+#define	LOG_LEVEL_1				0x001
+#define 	LOG_LEVEL_LOW			0x000
+
+#define LOG_LEVEL_DESC \
+"[0x00]LOW[0X01]LEVEL1[0xf]HIGH"
+
+#define  	LOG_MASK_INIT			0x001
+#define	LOG_MASK_IOCTL			0x002
+#define	LOG_MASK_HARDWARE		0x004
+#define	LOG_MASK_CONFIG		0x008
+#define	LOG_MASK_WORK			0x010
+#define 	LOG_MASK_DESC \
+"[0x01]:INIT,[0x02]:IOCTL,[0x04]:HARDWARE,[0x08]LOG_MASK_CONFIG[0x10]LOG_MASK_WORK"
+
+#endif
diff --git a/drivers/amlogic/display/ge2d/ge2d_main.c b/drivers/amlogic/display/ge2d/ge2d_main.c
old mode 100644
new mode 100755
index 034767ae..8a8a88f0
--- a/drivers/amlogic/display/ge2d/ge2d_main.c
+++ b/drivers/amlogic/display/ge2d/ge2d_main.c
@@ -1,307 +1,305 @@
-/*******************************************************************
- *
- *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
- *
- *  Description:
- *
- *  Author: Amlogic Software
- *  Created: 2010/4/1   19:46
- *
- *******************************************************************/
-#include <linux/amlogic/ge2d/ge2d_main.h>
-#include "ge2d_log.h"
-#include "ge2d_dev.h"
-#include <linux/amlogic/amlog.h>
+/*******************************************************************
+ *
+ *  Copyright C 2010 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *
+ *  Author: Amlogic Software
+ *  Created: 2010/4/1   19:46
+ *
+ *******************************************************************/
+#include <linux/amlogic/ge2d/ge2d_main.h>
+#include "ge2d_log.h"
+#include "ge2d_dev.h"
+#include <linux/amlogic/amlog.h>
 #include <mach/mod_gate.h>
-
-MODULE_AMLOG(AMLOG_DEFAULT_LEVEL, 0x00, LOG_LEVEL_DESC, LOG_MASK_DESC);
-
-/***********************************************************************
-*
-* file op section.
-*
-************************************************************************/
-static  bool   command_valid(unsigned int cmd)
+
+MODULE_AMLOG(AMLOG_DEFAULT_LEVEL, 0x00, LOG_LEVEL_DESC, LOG_MASK_DESC);
+
+/***********************************************************************
+*
+* file op section.
+*
+************************************************************************/
+static  bool   command_valid(unsigned int cmd)
+{
+    return (cmd <= GE2D_STRETCHBLIT_NOALPHA_NOBLOCK && cmd >= GE2D_ANTIFLICKER_ENABLE );
+}
+static int
+ge2d_open(struct inode *inode, struct file *file)
 {
-    return (cmd <= GE2D_STRETCHBLIT_NOALPHA_NOBLOCK && cmd >= GE2D_ANTIFLICKER_ENABLE );
-}
-static int 
-ge2d_open(struct inode *inode, struct file *file) 
-{
-	 ge2d_context_t *context;
+	 ge2d_context_t *context;
 	 //we create one ge2d workqueue for this file handler.
-	 
+
          //if (ge2d_device.open_count == 0)
          //       switch_mod_gate_by_name("ge2d", 1);
-	 if(NULL==(context=create_ge2d_work_queue()))
+	 if(NULL==(context=create_ge2d_work_queue()))
 	 {
-	 	amlog_level(LOG_LEVEL_HIGH,"can't create work queue \r\n");
-		return -1;		
-	 }
-	 //amlog_level(LOG_LEVEL_LOW,"open one ge2d device\n");
-	 file->private_data=context;
-	 ge2d_device.open_count++;
-	 return 0;
-}
-static long
-ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
+	 	amlog_level(LOG_LEVEL_HIGH,"can't create work queue\n");
+		return -1;
+	 }
+	 //amlog_level(LOG_LEVEL_LOW,"open one ge2d device\n");
+	 file->private_data=context;
+	 ge2d_device.open_count++;
+	 return 0;
+}
+static long
+ge2d_ioctl(struct file *filp,unsigned int cmd, unsigned long args)
 {
 
-	ge2d_context_t *context=(ge2d_context_t *)filp->private_data;
-	void  __user* argp =(void __user*)args;
-	config_para_t     ge2d_config;	
-	ge2d_para_t  para ;
-    config_para_ex_t  ge2d_config_ex;
-	int  ret=0;    	
-
-	if(!command_valid(cmd))  return -1;
-	switch (cmd)
-   	{
-		case  GE2D_CONFIG:
-		case  GE2D_SRCCOLORKEY:	
-		ret=copy_from_user(&ge2d_config,argp,sizeof(config_para_t));
-		break;
-		case  GE2D_CONFIG_EX:
-		ret=copy_from_user(&ge2d_config_ex,argp,sizeof(config_para_ex_t));
-		break;
-		case  GE2D_SET_COEF:
-		case  GE2D_ANTIFLICKER_ENABLE:	
-		break;
-		default :
-		ret=copy_from_user(&para,argp,sizeof(ge2d_para_t));	
+	ge2d_context_t *context=(ge2d_context_t *)filp->private_data;
+	void  __user* argp =(void __user*)args;
+	config_para_t     ge2d_config;
+	ge2d_para_t  para ;
+    config_para_ex_t  ge2d_config_ex;
+	int  ret=0;
+
+	if(!command_valid(cmd))  return -1;
+	switch (cmd)
+	{
+		case  GE2D_CONFIG:
+		case  GE2D_SRCCOLORKEY:
+		ret=copy_from_user(&ge2d_config,argp,sizeof(config_para_t));
+		break;
+		case  GE2D_CONFIG_EX:
+		ret=copy_from_user(&ge2d_config_ex,argp,sizeof(config_para_ex_t));
+		break;
+		case  GE2D_SET_COEF:
+		case  GE2D_ANTIFLICKER_ENABLE:
+		break;
+		default :
+		ret=copy_from_user(&para,argp,sizeof(ge2d_para_t));
+		break;
+
+	}
+	switch(cmd)
+	{
+		case GE2D_CONFIG:
+		ret=ge2d_context_config(context,&ge2d_config) ;
+		break;
+		case GE2D_CONFIG_EX:
+		ret=ge2d_context_config_ex(context,&ge2d_config_ex) ;
 		break;
-		
-   	}
-	switch(cmd)
-	{
-		case GE2D_CONFIG:
-		ret=ge2d_context_config(context,&ge2d_config) ;
-	  	break;
-		case GE2D_CONFIG_EX:
-		ret=ge2d_context_config_ex(context,&ge2d_config_ex) ;
-	  	break;
-		case GE2D_SET_COEF:
-		ge2d_wq_set_scale_coef(context,args&0xff,args>>16);
-		break;
-		case GE2D_ANTIFLICKER_ENABLE:
-		ge2d_antiflicker_enable(context,args);	
-		break;
-        case GE2D_SRCCOLORKEY:
-		ge2dgen_src_key(context , ge2d_config.src_key.key_enable,ge2d_config.src_key.key_color, ge2d_config.src_key.key_mask,ge2d_config.src_key.key_mode);  //RGBA MODE		
-		break;
-		case GE2D_FILLRECTANGLE:
-		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"fill rect...,x=%d,y=%d,w=%d,h=%d,color=0x%x\r\n",
-                   para.src1_rect.x, para.src1_rect.y,
+		case GE2D_SET_COEF:
+		ge2d_wq_set_scale_coef(context,args&0xff,args>>16);
+		break;
+		case GE2D_ANTIFLICKER_ENABLE:
+		ge2d_antiflicker_enable(context,args);
+		break;
+        case GE2D_SRCCOLORKEY:
+		ge2dgen_src_key(context , ge2d_config.src_key.key_enable,ge2d_config.src_key.key_color, ge2d_config.src_key.key_mask,ge2d_config.src_key.key_mode);  //RGBA MODE
+		break;
+		case GE2D_FILLRECTANGLE:
+		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"fill rect...,x=%d,y=%d,w=%d,h=%d,color=0x%x\n",
+                   para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.color);
 
-            	fillrect(context,
+		fillrect(context,
                      para.src1_rect.x, para.src1_rect.y,
                      para.src1_rect.w, para.src1_rect.h,
-                     para.color) ;	
-		break;
-		case GE2D_FILLRECTANGLE_NOBLOCK:
-		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"fill rect...,x=%d,y=%d,w=%d,h=%d,color=0x%x,noblk\r\n",
+                     para.color) ;
+		break;
+		case GE2D_FILLRECTANGLE_NOBLOCK:
+		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"fill rect...,x=%d,y=%d,w=%d,h=%d,color=0x%x,noblk\n",
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.color);
 
-            	fillrect_noblk(context,
+		fillrect_noblk(context,
                      para.src1_rect.x, para.src1_rect.y,
                      para.src1_rect.w, para.src1_rect.h,
-                     para.color) ;	
-		break;
-		case GE2D_STRETCHBLIT:
-		//stretch blit
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d\r\n",
+                     para.color) ;
+		break;
+		case GE2D_STRETCHBLIT:
+		//stretch blit
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d\n",
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.dst_rect.w, para.dst_rect.h);
 
-            	stretchblt(context ,
+		stretchblt(context ,
                        para.src1_rect.x, para.src1_rect.y, para.src1_rect.w, para.src1_rect.h,
-                       para.dst_rect.x,  para.dst_rect.y,  para.dst_rect.w,  para.dst_rect.h);	
-		break;
-		case GE2D_STRETCHBLIT_NOBLOCK:
-		//stretch blit
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d,noblk\r\n",
+                       para.dst_rect.x,  para.dst_rect.y,  para.dst_rect.w,  para.dst_rect.h);
+		break;
+		case GE2D_STRETCHBLIT_NOBLOCK:
+		//stretch blit
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d,noblk\n",
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.dst_rect.w, para.dst_rect.h);
 
-            	stretchblt_noblk(context ,
+		stretchblt_noblk(context ,
                        para.src1_rect.x, para.src1_rect.y, para.src1_rect.w, para.src1_rect.h,
-                       para.dst_rect.x,  para.dst_rect.y,  para.dst_rect.w,  para.dst_rect.h);	
-		break;
-		case GE2D_BLIT:
-		//bitblt
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit...\r\n");
+                       para.dst_rect.x,  para.dst_rect.y,  para.dst_rect.w,  para.dst_rect.h);
+		break;
+		case GE2D_BLIT:
+		//bitblt
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit...\n");
 
-            	bitblt(context ,
+		bitblt(context ,
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.dst_rect.x, para.dst_rect.y);
-           	break;
-		case GE2D_BLIT_NOBLOCK:
-		//bitblt
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit...,noblk\r\n");
+		break;
+		case GE2D_BLIT_NOBLOCK:
+		//bitblt
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit...,noblk\n");
 
-            	bitblt_noblk(context ,
+		bitblt_noblk(context ,
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.dst_rect.x, para.dst_rect.y);
-           	break;	
-		case GE2D_BLEND:
-		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blend ...\r\n");
-		blend(context,
-            		para.src1_rect.x, para.src1_rect.y,
-            		para.src1_rect.w, para.src1_rect.h,
-           		para.src2_rect.x, para.src2_rect.y,
-           		para.src2_rect.w, para.src2_rect.h,
-           		para.dst_rect.x, para.dst_rect.y,
-           		para.dst_rect.w, para.dst_rect.h,
-           		para.op) ;	
-		break;
-		case GE2D_BLEND_NOBLOCK:
-		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blend ...,noblk\r\n");
-		blend_noblk(context,
-            		para.src1_rect.x, para.src1_rect.y,
-            		para.src1_rect.w, para.src1_rect.h,
-           		para.src2_rect.x, para.src2_rect.y,
-           		para.src2_rect.w, para.src2_rect.h,
-           		para.dst_rect.x, para.dst_rect.y,
-           		para.dst_rect.w, para.dst_rect.h,
-           		para.op) ;	
-		break;
-		case GE2D_BLIT_NOALPHA:
-		//bitblt_noalpha
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit_noalpha...\r\n");
-            	bitblt_noalpha(context ,
+		break;
+		case GE2D_BLEND:
+		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blend ...\n");
+		blend(context,
+			para.src1_rect.x, para.src1_rect.y,
+			para.src1_rect.w, para.src1_rect.h,
+			para.src2_rect.x, para.src2_rect.y,
+			para.src2_rect.w, para.src2_rect.h,
+			para.dst_rect.x, para.dst_rect.y,
+			para.dst_rect.w, para.dst_rect.h,
+			para.op) ;
+		break;
+		case GE2D_BLEND_NOBLOCK:
+		amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blend ...,noblk\n");
+		blend_noblk(context,
+			para.src1_rect.x, para.src1_rect.y,
+			para.src1_rect.w, para.src1_rect.h,
+			para.src2_rect.x, para.src2_rect.y,
+			para.src2_rect.w, para.src2_rect.h,
+			para.dst_rect.x, para.dst_rect.y,
+			para.dst_rect.w, para.dst_rect.h,
+			para.op) ;
+		break;
+		case GE2D_BLIT_NOALPHA:
+		//bitblt_noalpha
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit_noalpha...\n");
+		bitblt_noalpha(context ,
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
-                   para.dst_rect.x, para.dst_rect.y);	
-		break;
-		case GE2D_BLIT_NOALPHA_NOBLOCK:
-		//bitblt_noalpha
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit_noalpha...,noblk\r\n");
-            	bitblt_noalpha_noblk(context ,
+                   para.dst_rect.x, para.dst_rect.y);
+		break;
+		case GE2D_BLIT_NOALPHA_NOBLOCK:
+		//bitblt_noalpha
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"blit_noalpha...,noblk\n");
+		bitblt_noalpha_noblk(context ,
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
-                   para.dst_rect.x, para.dst_rect.y);	
-		break;
-		case GE2D_STRETCHBLIT_NOALPHA:
-		//stretch blit
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt_noalpha...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d\r\n",
+                   para.dst_rect.x, para.dst_rect.y);
+		break;
+		case GE2D_STRETCHBLIT_NOALPHA:
+		//stretch blit
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt_noalpha...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d\n",
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.dst_rect.w, para.dst_rect.h);
 
-            	stretchblt_noalpha(context ,
+		stretchblt_noalpha(context ,
                        para.src1_rect.x, para.src1_rect.y, para.src1_rect.w, para.src1_rect.h,
-                       para.dst_rect.x,  para.dst_rect.y,  para.dst_rect.w,  para.dst_rect.h);	
-		break;
-		case GE2D_STRETCHBLIT_NOALPHA_NOBLOCK:
-		//stretch blit
-            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt_noalpha...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d,noblk\r\n",
+                       para.dst_rect.x,  para.dst_rect.y,  para.dst_rect.w,  para.dst_rect.h);
+		break;
+		case GE2D_STRETCHBLIT_NOALPHA_NOBLOCK:
+		//stretch blit
+            	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"stretchblt_noalpha...,x=%d,y=%d,w=%d,h=%d,dst.w=%d,dst.h=%d,noblk\n",
                    para.src1_rect.x, para.src1_rect.y,
                    para.src1_rect.w, para.src1_rect.h,
                    para.dst_rect.w, para.dst_rect.h);
 
-            	stretchblt_noalpha_noblk(context ,
+		stretchblt_noalpha_noblk(context ,
                        para.src1_rect.x, para.src1_rect.y, para.src1_rect.w, para.src1_rect.h,
-                       para.dst_rect.x,  para.dst_rect.y,  para.dst_rect.w,  para.dst_rect.h);	
-		break;
-	}
- 	return ret;
-}
-static int 
-ge2d_release(struct inode *inode, struct file *file)
-{
-	ge2d_context_t *context=(ge2d_context_t *)file->private_data;
-	
-	if(context && (0==destroy_ge2d_work_queue(context)))
-	{
-		ge2d_device.open_count--;
+                       para.dst_rect.x,  para.dst_rect.y,  para.dst_rect.w,  para.dst_rect.h);
+		break;
+	}
+	return ret;
+}
+static int
+ge2d_release(struct inode *inode, struct file *file)
+{
+	ge2d_context_t *context=(ge2d_context_t *)file->private_data;
+
+	if(context && (0==destroy_ge2d_work_queue(context)))
+	{
+		ge2d_device.open_count--;
 		//if (ge2d_device.open_count == 0)
 		//	switch_mod_gate_by_name("ge2d", 0);
-		return 0;
-	}
-	amlog_level(LOG_LEVEL_LOW,"release one ge2d device\n");
-	return -1;
-}
-
-
-/***********************************************************************
-*
-* module  section    (init&exit)
-*
-************************************************************************/
-static int  
-init_ge2d_device(void)
-{
-	int  ret=0;
-	
-	strcpy(ge2d_device.name,"ge2d");
-	ret=register_chrdev(0,ge2d_device.name,&ge2d_fops);
-	if(ret <=0) 
+		return 0;
+	}
+	amlog_level(LOG_LEVEL_LOW,"release one ge2d device\n");
+	return -1;
+}
+
+
+/***********************************************************************
+*
+* module  section    (init&exit)
+*
+************************************************************************/
+static int
+init_ge2d_device(void)
+{
+	int  ret=0;
+
+	strcpy(ge2d_device.name,"ge2d");
+	ret=register_chrdev(0,ge2d_device.name,&ge2d_fops);
+	if(ret <=0)
 	{
-		amlog_level(LOG_LEVEL_HIGH,"register ge2d device error\r\n");
+		amlog_level(LOG_LEVEL_HIGH,"register ge2d device error\n");
 		return  ret ;
 	}
-	ge2d_device.major=ret;
-	ge2d_device.dbg_enable=0;
-	amlog_level(LOG_LEVEL_LOW,"ge2d_dev major:%d\r\n",ret);
-	ret = class_register(&ge2d_class);
-	if(ret<0 )
-	{
-		amlog_level(LOG_LEVEL_HIGH,"error create ge2d class\r\n");
-		return ret;
-	}
-	ge2d_device.cla=&ge2d_class ;
-	ge2d_device.dev=device_create(ge2d_device.cla,NULL,MKDEV(ge2d_device.major,0),NULL,ge2d_device.name);
-	if (IS_ERR(ge2d_device.dev)) {
-		amlog_level(LOG_LEVEL_HIGH,"create ge2d device error\n");
-		class_unregister(ge2d_device.cla);
-		return -1 ;
-	}
-	return ge2d_setup();
-	
-}
-static int remove_ge2d_device(void)
-{
-	if(ge2d_device.cla)
-	{
-		if(ge2d_device.dev)
-		device_destroy(ge2d_device.cla, MKDEV(ge2d_device.major, 0));
-	    	class_unregister(ge2d_device.cla);
-	}
-	
-	unregister_chrdev(ge2d_device.major, ge2d_device.name);
-	ge2d_deinit();
-	return  0;
-}
-
-static int __init
-ge2d_init_module(void)
+	ge2d_device.major=ret;
+	ge2d_device.dbg_enable=0;
+	amlog_level(LOG_LEVEL_LOW,"ge2d_dev major:%d\n",ret);
+	ret = class_register(&ge2d_class);
+	if(ret<0 )
+	{
+		amlog_level(LOG_LEVEL_HIGH,"error create ge2d class\n");
+		return ret;
+	}
+	ge2d_device.cla=&ge2d_class ;
+	ge2d_device.dev=device_create(ge2d_device.cla,NULL,MKDEV(ge2d_device.major,0),NULL,ge2d_device.name);
+	if (IS_ERR(ge2d_device.dev)) {
+		amlog_level(LOG_LEVEL_HIGH,"create ge2d device error\n");
+		class_unregister(ge2d_device.cla);
+		return -1 ;
+	}
+	return ge2d_setup();
+
+}
+static int remove_ge2d_device(void)
 {
-   	amlog_level(LOG_LEVEL_HIGH,"ge2d_init\n");
-    	return init_ge2d_device();
-    	
+	if(ge2d_device.cla)
+	{
+		if(ge2d_device.dev)
+		device_destroy(ge2d_device.cla, MKDEV(ge2d_device.major, 0));
+		class_unregister(ge2d_device.cla);
+	}
+
+	unregister_chrdev(ge2d_device.major, ge2d_device.name);
+	ge2d_deinit();
+	return  0;
 }
-
+
+static int __init
+ge2d_init_module(void)
+{
+	amlog_level(LOG_LEVEL_HIGH,"ge2d_init\n");
+	return init_ge2d_device();
+
+}
+
 static void __exit
-ge2d_remove_module(void)
-{
-	remove_ge2d_device();
-    	amlog_level(LOG_LEVEL_HIGH,"ge2d module removed.\n");
-    
-}
-
-module_init(ge2d_init_module);
-module_exit(ge2d_remove_module);
-
-MODULE_DESCRIPTION("AMLOGIC  ge2d driver");
+ge2d_remove_module(void)
+{
+	remove_ge2d_device();
+	amlog_level(LOG_LEVEL_HIGH,"ge2d module removed.\n");
+
+}
+
+module_init(ge2d_init_module);
+module_exit(ge2d_remove_module);
+
+MODULE_DESCRIPTION("AMLOGIC  ge2d driver");
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("jianfeng <jianfeng.wang@amlogic.com>");
-
-
+MODULE_AUTHOR("jianfeng <jianfeng.wang@amlogic.com>");
diff --git a/drivers/amlogic/display/ge2d/ge2d_wq.c b/drivers/amlogic/display/ge2d/ge2d_wq.c
index 7b6e6aba..00a079be 100755
--- a/drivers/amlogic/display/ge2d/ge2d_wq.c
+++ b/drivers/amlogic/display/ge2d/ge2d_wq.c
@@ -1,985 +1,957 @@
-/*******************************************************************
- *
- *  Copyright C 2007 by Amlogic, Inc. All Rights Reserved.
- *
- *  Description:
- *
- *  Author: Amlogic Software
- *  Created: 2009/12/31   19:46
- *
- *******************************************************************/
-
-
-#include <linux/amlogic/ge2d/ge2d.h>
-#include <linux/interrupt.h>
-#include <mach/am_regs.h>
-#include <linux/amlogic/amports/canvas.h>
-#include <linux/fb.h>
-#include <linux/list.h>
-#include  <linux/spinlock.h>
-#include <linux/kthread.h>
-#include <mach/power_gate.h>
-#include <mach/irqs.h>
-#include "ge2d_log.h"
-#include <linux/amlogic/amlog.h>
-#include <mach/mod_gate.h>
-static  ge2d_manager_t  ge2d_manager;
-
-
-static int   get_queue_member_count(struct list_head  *head)
-{
-	int member_count=0;
-	ge2d_queue_item_t *pitem;
-	list_for_each_entry(pitem, head, list){
-		member_count++;
-		if(member_count>MAX_GE2D_CMD)//error has occured
-		break;	
-	}
-	return member_count;
-}
-ssize_t work_queue_status_show(struct class *cla,struct class_attribute *attr,char *buf)
-{
-	ge2d_context_t *wq=ge2d_manager.current_wq;
-	if (wq == 0) {
-		return 0;
-	}
-	return snprintf(buf,40,"cmd count in queue:%d\n",get_queue_member_count(&wq->work_queue));
-}
-ssize_t free_queue_status_show(struct class *cla,struct class_attribute *attr, char *buf)
-{
-	ge2d_context_t *wq=ge2d_manager.current_wq;
-	if (wq == 0) {
-		return 0;
-	}
-	return snprintf(buf, 40, "free space :%d\n",get_queue_member_count(&wq->free_queue));
-}
-
-static inline  int  work_queue_no_space(ge2d_context_t* queue)
-{
-	return  list_empty(&queue->free_queue) ;
-}
-
-static int ge2d_process_work_queue(ge2d_context_t *  wq)
-{
-	ge2d_config_t *cfg;
-	ge2d_queue_item_t *pitem;
-	unsigned int  mask=0x1;
-	struct list_head  *head=&wq->work_queue,*pos;
-	int ret=0;
-	unsigned int block_mode;
-
-	ge2d_manager.ge2d_state=GE2D_STATE_RUNNING;
-	pos = head->next;
-	if(pos != head) { //current work queue not empty.
-		if(wq != ge2d_manager.last_wq ) { //maybe 
-			pitem=(ge2d_queue_item_t *)pos;  //modify the first item .
-			if(pitem)
-				pitem->config.update_flag=UPDATE_ALL;
-			else {
-				amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_HIGH,"can't get pitem\r\n");	
-				ret=-1;
-				goto  exit;
-			}
-		} else
-			pitem=(ge2d_queue_item_t *)pos;  //modify the first item .
-		
-	} else {
-		ret =-1;
-		goto  exit;
-	}
-
-	do {
-	      	cfg = &pitem->config;
-		mask=0x1;	
-            	while(cfg->update_flag && mask <= UPDATE_SCALE_COEF ) //we do not change 
-		{
-			switch(cfg->update_flag & mask)
-			{
-				case UPDATE_SRC_DATA:
-				ge2d_set_src1_data(&cfg->src1_data);
-				break;
-				case UPDATE_SRC_GEN:
-				ge2d_set_src1_gen(&cfg->src1_gen);
-				break;
-				case UPDATE_DST_DATA:
-				ge2d_set_src2_dst_data(&cfg->src2_dst_data);	
-				break;
-				case UPDATE_DST_GEN:
-				ge2d_set_src2_dst_gen(&cfg->src2_dst_gen);
-				break;
-				case UPDATE_DP_GEN:
-				ge2d_set_dp_gen(&cfg->dp_gen);
-				break;
-				case UPDATE_SCALE_COEF:
-				ge2d_set_src1_scale_coef(cfg->v_scale_coef_type, cfg->h_scale_coef_type);
-				break;
-			}
-
-			cfg->update_flag &=~mask;
-			mask = mask <<1 ;
-		
-		}
-            	ge2d_set_cmd(&pitem->cmd);//set START_FLAG in this func.
-      		//remove item
-      		block_mode=pitem->cmd.wait_done_flag;
-      		//spin_lock(&wq->lock);
-		//pos=pos->next;	
-		//list_move_tail(&pitem->list,&wq->free_queue);
-		//spin_unlock(&wq->lock);
-		
-		while(ge2d_is_busy())
-		interruptible_sleep_on_timeout(&ge2d_manager.event.cmd_complete, 1);
-		//if block mode (cmd)
-		if(block_mode)
-		{
-			pitem->cmd.wait_done_flag = 0;
-			wake_up_interruptible(&wq->cmd_complete);
-		}
-		spin_lock(&wq->lock);
-		pos = pos->next;
-		list_move_tail(&pitem->list,&wq->free_queue);
-		spin_unlock(&wq->lock);
-
-		pitem=(ge2d_queue_item_t *)pos;
-	}while(pos!=head);
-	ge2d_manager.last_wq=wq;
-exit:
-	spin_lock(&ge2d_manager.state_lock);
-	if(ge2d_manager.ge2d_state==GE2D_STATE_REMOVING_WQ)
-	    complete(&ge2d_manager.event.process_complete);
-	ge2d_manager.ge2d_state=GE2D_STATE_IDLE;
-	spin_unlock(&ge2d_manager.state_lock);
-	return ret;	
-}
-
-                    
-static irqreturn_t ge2d_wq_handle(int  irq_number, void *para)
-{
-	wake_up(&ge2d_manager.event.cmd_complete) ;
-	return IRQ_HANDLED;
-
-
-}
-
-
-ge2d_src1_data_t *ge2d_wq_get_src_data(ge2d_context_t *wq)
-{
-    	return &wq->config.src1_data;
-}
-
-ge2d_src1_gen_t *ge2d_wq_get_src_gen(ge2d_context_t *wq)
-{
-   	return &wq->config.src1_gen;
-}
-
-ge2d_src2_dst_data_t *ge2d_wq_get_dst_data(ge2d_context_t *wq)
-{
-	return &wq->config.src2_dst_data;
-}
-
-ge2d_src2_dst_gen_t *ge2d_wq_get_dst_gen(ge2d_context_t *wq)
-{
-	return &wq->config.src2_dst_gen;
-}
-
-ge2d_dp_gen_t * ge2d_wq_get_dp_gen(ge2d_context_t *wq)
-{
-	return &wq->config.dp_gen;
-}
-
-ge2d_cmd_t * ge2d_wq_get_cmd(ge2d_context_t *wq)
-{
-	return &wq->cmd;
-}
-
-void ge2d_wq_set_scale_coef(ge2d_context_t *wq, unsigned v_scale_coef_type, unsigned h_scale_coef_type)
-{
-    	
-    	if (wq){
-        wq->config.v_scale_coef_type = v_scale_coef_type;
-        wq->config.h_scale_coef_type = h_scale_coef_type;
-        wq->config.update_flag |= UPDATE_SCALE_COEF;
-    	}
-}
- 
-/*********************************************************************
-**
-**
-** each  process has it's single  ge2d  op point 
-**
-**
-**********************************************************************/
-int ge2d_wq_add_work(ge2d_context_t *wq)
-{
-
-	ge2d_queue_item_t  *pitem ;
-    
-     	amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"add new work @@%s:%d\r\n",__func__,__LINE__)	; 
- 	if(work_queue_no_space(wq))
- 	{
- 		amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"work queue no space\r\n");
-		//we should wait for queue empty at this point.
-		while(work_queue_no_space(wq))
-		{
-			interruptible_sleep_on_timeout(&ge2d_manager.event.cmd_complete, 3);
-		}
-		amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"got free space\r\n");
-	}
-
-      pitem=list_entry(wq->free_queue.next,ge2d_queue_item_t,list); 
-	if(IS_ERR(pitem))
-	{
-		goto error;
-	}
-	memcpy(&pitem->cmd, &wq->cmd, sizeof(ge2d_cmd_t));
-      	memset(&wq->cmd, 0, sizeof(ge2d_cmd_t));
-      	memcpy(&pitem->config, &wq->config, sizeof(ge2d_config_t));
-	wq->config.update_flag =0;  //reset config set flag   
-	spin_lock(&wq->lock);
-	list_move_tail(&pitem->list,&wq->work_queue);
-	spin_unlock(&wq->lock);
-	amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"add new work ok\r\n"); 
-	if(ge2d_manager.event.cmd_in_sem.count == 0 )//only read not need lock
-	up(&ge2d_manager.event.cmd_in_sem) ;//new cmd come in	
-	//add block mode   if()
-	if(pitem->cmd.wait_done_flag)
-	{
-		wait_event_interruptible(wq->cmd_complete, pitem->cmd.wait_done_flag==0);
-		//interruptible_sleep_on(&wq->cmd_complete);
-	}
-	return 0;
-error:
- 	 return -1;	
-}
-
-
-
-
-
-
-static inline ge2d_context_t*  get_next_work_queue(ge2d_manager_t*  manager)
-{
-	ge2d_context_t* pcontext;
-
-	spin_lock(&ge2d_manager.event.sem_lock);
-	list_for_each_entry(pcontext,&manager->process_queue,list)
-	{
-		if(!list_empty(&pcontext->work_queue))	//not lock maybe delay to next time.
-		{									
-			list_move(&manager->process_queue,&pcontext->list);//move head .
-			spin_unlock(&ge2d_manager.event.sem_lock);
-			return pcontext;	
-		}	
-	}
-	spin_unlock(&ge2d_manager.event.sem_lock);
-	return NULL;
-}
-static int ge2d_monitor_thread(void *data)
-{
-
-	ge2d_manager_t*  manager = (  ge2d_manager_t*)data ;
-        int ret;
-	
- 	amlog_level(LOG_LEVEL_HIGH,"ge2d workqueue monitor start\r\n");
-	//setup current_wq here.
-	while(ge2d_manager.process_queue_state!=GE2D_PROCESS_QUEUE_STOP)
-	{
-		ret = down_interruptible(&manager->event.cmd_in_sem);
-		//got new cmd arrived in signal,
-		//CLK_GATE_ON(GE2D);
-		switch_mod_gate_by_name("ge2d", 1);
-		while((manager->current_wq=get_next_work_queue(manager))!=NULL)
-		{
-			ge2d_process_work_queue(manager->current_wq);
-		}
-		switch_mod_gate_by_name("ge2d", 0);
-		//CLK_GATE_OFF(GE2D);
-	}
-	amlog_level(LOG_LEVEL_HIGH,"exit ge2d_monitor_thread\r\n");
-	return 0;
-}
-static  int ge2d_start_monitor(void )
-{
-	int ret =0;
-	
-	amlog_level(LOG_LEVEL_HIGH,"ge2d start monitor\r\n");
-	ge2d_manager.process_queue_state=GE2D_PROCESS_QUEUE_START;
-	ge2d_manager.ge2d_thread=kthread_run(ge2d_monitor_thread,&ge2d_manager,"ge2d_monitor");
-	if (IS_ERR(ge2d_manager.ge2d_thread)) {
-		ret = PTR_ERR(ge2d_manager.ge2d_thread);
-		amlog_level(LOG_LEVEL_HIGH,"ge2d monitor : failed to start kthread (%d)\n", ret);
-	}
-	return ret;
-}
-static  int  ge2d_stop_monitor(void)
-{
-	amlog_level(LOG_LEVEL_HIGH,"stop ge2d monitor thread\n");
-	ge2d_manager.process_queue_state =GE2D_PROCESS_QUEUE_STOP;
-	up(&ge2d_manager.event.cmd_in_sem) ;
-	return  0;
-}
-/********************************************************************
-**																		 	**
-**																			**
-**  >>>>>>>>>>>>>		interface export to other parts	<<<<<<<<<<<<<			**
-**																			**
-**																			**
-*********************************************************************/
-
-
-/***********************************************************************
-** context  setup secion
-************************************************************************/
-static inline int bpp(unsigned format)
-{
-	switch (format & GE2D_BPP_MASK) {
-		case GE2D_BPP_8BIT:
-			return 8;
-		case GE2D_BPP_16BIT:
-			return 16;
-		case GE2D_BPP_24BIT:
-			return 24;
-		case GE2D_BPP_32BIT:
-		default:
-			return 32;
-	}
-}
-
-static void build_ge2d_config(config_para_t *cfg, src_dst_para_t *src, src_dst_para_t *dst,int index)
-{
-	index&=0xff;
-	if(src)
-	{
-		src->xres = cfg->src_planes[0].w;
-		src->yres = cfg->src_planes[0].h;
-//		src->canvas_index = (index+3)<<24|(index+2)<<16|(index+1)<<8|index;
-		src->ge2d_color_index = cfg->src_format;
-		src->bpp = bpp(cfg->src_format);
-		
-	    if(cfg->src_planes[0].addr &&
-			!cfg->src_planes[1].addr &&
-			!cfg->src_planes[2].addr &&
-			!cfg->src_planes[3].addr){
-	        src->canvas_index = index;
-    		canvas_config(index++,
-    			  cfg->src_planes[0].addr,
-				  cfg->src_planes[0].w * src->bpp / 8,
-				  cfg->src_planes[0].h,
-                  CANVAS_ADDR_NOWRAP,
-		          CANVAS_BLKMODE_LINEAR);
-	    }
-		else
-		{
-			src->canvas_index = index;
-			canvas_config(index++,
-				cfg->src_planes[0].addr,
-				cfg->src_planes[0].w,
-				cfg->src_planes[0].h,
-				CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_LINEAR);
-		}
-
-		/* multi-src_planes */
-		if(cfg->src_planes[1].addr){
-            src->canvas_index |= index<<8;
-            canvas_config(index++,
-            		  cfg->src_planes[1].addr,
-            		  cfg->src_planes[1].w,
-            		  cfg->src_planes[1].h,
-                	  CANVAS_ADDR_NOWRAP,
-                  	  CANVAS_BLKMODE_LINEAR);
-		 }
-		 if(cfg->src_planes[2].addr){
-		    src->canvas_index |= index<<16;
-    		canvas_config(index++,
-    				  cfg->src_planes[2].addr,
-					  cfg->src_planes[2].w,
-					  cfg->src_planes[2].h,
-	                  CANVAS_ADDR_NOWRAP,
-			          CANVAS_BLKMODE_LINEAR);
-        }
-        if(cfg->src_planes[3].addr){
-            src->canvas_index |= index<<24;
-		    canvas_config(index++,
-    				  cfg->src_planes[3].addr,
-					  cfg->src_planes[3].w,
-					  cfg->src_planes[3].h,
-                	  CANVAS_ADDR_NOWRAP,
-		          	  CANVAS_BLKMODE_LINEAR);
-		}
-	
-	}
-	if(dst)
-	{
-		dst->xres = cfg->dst_planes[0].w;
-		dst->yres = cfg->dst_planes[0].h;
-//		dst->canvas_index = (index+3)<<24|(index+2)<<16|(index+1)<<8|index;
-		dst->ge2d_color_index = cfg->dst_format;
-		dst->bpp = bpp(cfg->dst_format);
-		if(cfg->dst_planes[0].addr &&
-			!cfg->dst_planes[1].addr &&
-			!cfg->dst_planes[2].addr &&
-			!cfg->dst_planes[3].addr){
-		    dst->canvas_index = index;
-		    canvas_config(index++ & 0xff,
-			  cfg->dst_planes[0].addr,
-			  cfg->dst_planes[0].w * dst->bpp / 8,
-			  cfg->dst_planes[0].h,
-              CANVAS_ADDR_NOWRAP,
-	          CANVAS_BLKMODE_LINEAR);
-	    }
-		else
-		{
-			dst->canvas_index = index;
-			canvas_config(index++ & 0xff,
-				cfg->dst_planes[0].addr,
-				cfg->dst_planes[0].w,
-				cfg->dst_planes[0].h,
-				CANVAS_ADDR_NOWRAP,
-				CANVAS_BLKMODE_LINEAR);
-		}
-
-		/* multi-src_planes */
-        if(cfg->dst_planes[1].addr){
-            dst->canvas_index |= index<<8;
-            canvas_config(index++,
-                  cfg->dst_planes[1].addr,
-                  cfg->dst_planes[1].w,
-                  cfg->dst_planes[1].h,
-                  CANVAS_ADDR_NOWRAP,
-                  CANVAS_BLKMODE_LINEAR);
-        }
-        if(cfg->dst_planes[2].addr){
-            dst->canvas_index |= index<<16;	          	
-            canvas_config(index++,
-                cfg->dst_planes[2].addr,
-                cfg->dst_planes[2].w,
-                cfg->dst_planes[2].h,
-                CANVAS_ADDR_NOWRAP,
-                  CANVAS_BLKMODE_LINEAR);
-        }
-        if(cfg->dst_planes[3].addr){
-            dst->canvas_index |= index<<24;			        
-            canvas_config(index++,
-        		  cfg->dst_planes[3].addr,
-        		  cfg->dst_planes[3].w,
-        	  	  cfg->dst_planes[3].h,
-            	  CANVAS_ADDR_NOWRAP,
-              	  CANVAS_BLKMODE_LINEAR);
-        }
-	}
-}
-static  int  
-setup_display_property(src_dst_para_t *src_dst,int index)
-{
-#define   REG_OFFSET		(0x20<<2)
-	canvas_t   	canvas;
-	unsigned	int  	data32;
-	unsigned	int 	bpp;
-	unsigned int 	block_mode[]={2,4,8,16,16,32,0,24};
-
-	src_dst->canvas_index=index;
-	canvas_read(index,&canvas);
-
-	index=(index==OSD1_CANVAS_INDEX?0:1);
-	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"osd%d ",index);
-	data32=aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W0+ REG_OFFSET*index);
-	index=(data32>>8) & 0xf;
-	bpp=block_mode[index];  //OSD_BLK_MODE[8..11]
-	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"%d bpp \n",bpp);
-	if(bpp < 16) return -1;
-
-	src_dst->bpp=bpp;
-	src_dst->xres=canvas.width/(bpp>>3);
-	src_dst->yres=canvas.height;
-	if(index==3) //yuv422 32bit for two pixel.
-	{
-		src_dst->ge2d_color_index=	GE2D_FORMAT_S16_YUV422;
-	}
-	else  //for block mode=4,5,7
-	{
-		index=bpp-16 + ((data32>>2)&0xf); //color mode [2..5]
-		index=bpp_type_lut[index];  //get color mode 
-		src_dst->ge2d_color_index=default_ge2d_color_lut[index] ; //get matched ge2d color mode.
-	
-		if(src_dst->xres<=0 || src_dst->yres<=0 || src_dst->ge2d_color_index==0)
-		return -2;
-	}	
-	
-	return 0;	
-	
-}
-int	ge2d_antiflicker_enable(ge2d_context_t *context,unsigned long enable)
-{
-	/*********************************************************************
-	**	antiflicker used in cvbs mode, if antiflicker is enabled , it represent that we want 
-	**	this feature be enabled for all ge2d work
-	***********************************************************************/
-	ge2d_context_t* pcontext;
-
-	spin_lock(&ge2d_manager.event.sem_lock);
-	list_for_each_entry(pcontext,&ge2d_manager.process_queue,list)
-	{
-		ge2dgen_antiflicker(pcontext,enable);
-	}
-	spin_unlock(&ge2d_manager.event.sem_lock);
-	return 0;
-}
-int   ge2d_context_config(ge2d_context_t *context, config_para_t *ge2d_config)
-{
-	src_dst_para_t  src,dst,tmp;
-	int type=ge2d_config->src_dst_type;
-		
-	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW," ge2d init\r\n");
-	//setup src and dst  
-	switch (type)
-	{
-		case  OSD0_OSD0:
-		case  OSD0_OSD1:
-		case  OSD1_OSD0:
-		case ALLOC_OSD0:
-    	if(0>setup_display_property(&src,OSD1_CANVAS_INDEX))
-    	{
-    		return -1;
-    	}
-		break;
-		default:
-		break;
-	}
-	switch (type)
-	{
-		case  OSD0_OSD1:
-		case  OSD1_OSD1:
-		case  OSD1_OSD0:
-		case ALLOC_OSD1:
-    	if(0>setup_display_property(&dst,OSD2_CANVAS_INDEX))
-    	{
-    		return -1;
-    	}
-		break;
-		case ALLOC_ALLOC:
-		default:
-		break;
-	}
-	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"OSD ge2d type %d\r\n",type);
-	switch (type)
-	{
-		case  OSD0_OSD0:
-		dst=src;
-		break;
-		case  OSD0_OSD1:
-		break;
-		case  OSD1_OSD1:
-		src=dst;
-		break;
-		case  OSD1_OSD0:
-		tmp=src;
-		src=dst;
-		dst=tmp;
-		break;
-    		case ALLOC_OSD0:
-		dst=src;
-		build_ge2d_config(ge2d_config, &src, NULL,ALLOC_CANVAS_INDEX);
-		break;
-    		case ALLOC_OSD1:
-		build_ge2d_config(ge2d_config, &src, NULL,ALLOC_CANVAS_INDEX);
-		break;
-    		case ALLOC_ALLOC:
-		build_ge2d_config(ge2d_config, &src,&dst,ALLOC_CANVAS_INDEX);
-		break;
-	}
-	if(src.bpp < 16 || dst.bpp < 16 )
-	{
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"src dst bpp type, src=%d,dst=%d \r\n",src.bpp,dst.bpp);
-	}
-	
-	//next will config regs
-	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d xres %d yres %d : dst xres %d yres %d\n,src_format:0x%x,dst_format:0x%x\r\n",src.xres,src.yres,
-	dst.xres,dst.yres,src.ge2d_color_index, dst.ge2d_color_index);
-	
-	ge2dgen_src(context,src.canvas_index, src.ge2d_color_index);
-	ge2dgen_src_clip(context,
-                  0, 0,src.xres, src.yres);
-	ge2dgen_src2(context, dst.canvas_index, dst.ge2d_color_index);
-	ge2dgen_src2_clip(context,
-                            0, 0,  dst.xres, dst.yres);
-	ge2dgen_const_color(context,ge2d_config->alu_const_color);	 
-	ge2dgen_dst(context, dst.canvas_index,dst.ge2d_color_index);
- 	ge2dgen_dst_clip(context,
-                   0, 0, dst.xres, dst.yres, DST_CLIP_MODE_INSIDE);	
-	return  0;
-	
-}
-
-static int build_ge2d_config_ex(config_planes_t *plane, unsigned format, unsigned *canvas_index, int index,unsigned* r_offset)
-{
-	int bpp_value = bpp(format);
-	int ret = -1;
-	bpp_value /= 8;
-	index &= 0xff;
-	if(plane) {
-		if(plane[0].addr){
-			*canvas_index = index;
-			*r_offset += 1;
-			canvas_config(index++, plane[0].addr, plane[0].w * bpp_value, plane[0].h, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-			ret = 0;
-		}
-		/* multi-src_planes */
-		if(plane[1].addr){
-		    *canvas_index |= index<<8;
-		    *r_offset += 1;
-		    canvas_config(index++, plane[1].addr, plane[1].w * bpp_value, plane[1].h, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		}
-		if(plane[2].addr){
-		    *canvas_index |= index<<16;
-		    *r_offset += 1;
-		    canvas_config(index++, plane[2].addr, plane[2].w * bpp_value, plane[2].h, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		}
-		if(plane[3].addr){
-		    *canvas_index |= index<<24;
-		    *r_offset += 1;
-		    canvas_config(index++, plane[3].addr, plane[3].w * bpp_value, plane[3].h, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
-		}
-	}
-	return ret;
-}
-
-
-int ge2d_context_config_ex(ge2d_context_t *context, config_para_ex_t *ge2d_config)
-{
-	src_dst_para_t  tmp;
-	unsigned index = 0;
-	unsigned alloc_canvas_offset = 0;
-	ge2d_src1_gen_t *src1_gen_cfg  ;
-	ge2d_src2_dst_data_t *src2_dst_data_cfg;
-	ge2d_src2_dst_gen_t *src2_dst_gen_cfg;	
-	ge2d_dp_gen_t *dp_gen_cfg ;	
-	ge2d_cmd_t *ge2d_cmd_cfg ;
-	
-	//setup src and dst  
-	switch (ge2d_config->src_para.mem_type) {
-	case  CANVAS_OSD0:
-	case  CANVAS_OSD1:
-		if(setup_display_property(&tmp,(ge2d_config->src_para.mem_type==CANVAS_OSD0)?OSD1_CANVAS_INDEX:OSD2_CANVAS_INDEX)<0)
-			return -1;
-		ge2d_config->src_para.canvas_index = tmp.canvas_index;
-		ge2d_config->src_para.format = tmp.ge2d_color_index;
-
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src1-->type: osd%d, format: 0x%x !!\r\n",ge2d_config->src_para.mem_type - CANVAS_OSD0, ge2d_config->src_para.format);
-
-		if((ge2d_config->src_para.left+ge2d_config->src_para.width>tmp.xres)||(ge2d_config->src_para.top+ge2d_config->src_para.height>tmp.yres)){
-			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src1-->type: osd%d,  out of range \r\n",ge2d_config->src_para.mem_type - CANVAS_OSD0);
-			return -1;
-		}
-		break;
-	case  CANVAS_ALLOC:
-		if((ge2d_config->src_para.left+ge2d_config->src_para.width>ge2d_config->src_planes[0].w)
-		    ||(ge2d_config->src_para.top+ge2d_config->src_para.height>ge2d_config->src_planes[0].h)){
-			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src1-->type: alloc,  out of range \r\n");
-			return -1;
-		}
-		if(build_ge2d_config_ex(&ge2d_config->src_planes[0], ge2d_config->src_para.format, &index,ALLOC_CANVAS_INDEX+alloc_canvas_offset,&alloc_canvas_offset)<0)
-			return -1;
-		ge2d_config->src_para.canvas_index = index;
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src1--> type: alloc, canvas index : 0x%x,format :0x%x \r\n", index,ge2d_config->src_para.format);
-	default:
-		break;
-	}
-	
-	switch (ge2d_config->src2_para.mem_type){
-	case  CANVAS_OSD0:
-	case  CANVAS_OSD1:
-		if(setup_display_property(&tmp,(ge2d_config->src2_para.mem_type==CANVAS_OSD0)?OSD1_CANVAS_INDEX:OSD2_CANVAS_INDEX)<0)
-			return -1;
-		ge2d_config->src2_para.canvas_index = tmp.canvas_index;
-		ge2d_config->src2_para.format = tmp.ge2d_color_index;
-
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src2-->type: osd%d, format: 0x%x !!\r\n",ge2d_config->src2_para.mem_type - CANVAS_OSD0, ge2d_config->src2_para.format);
-
-		if((ge2d_config->src2_para.left+ge2d_config->src2_para.width>tmp.xres)||(ge2d_config->src2_para.top+ge2d_config->src2_para.height>tmp.yres)){
-			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src2-->type: osd%d,  out of range \r\n",ge2d_config->src2_para.mem_type - CANVAS_OSD0);
-			return -1;
-		}
-		break;
-	case  CANVAS_ALLOC:
-		if((ge2d_config->src2_para.left+ge2d_config->src2_para.width>ge2d_config->src2_planes[0].w)
-		    ||(ge2d_config->src2_para.top+ge2d_config->src2_para.height>ge2d_config->src2_planes[0].h)){
-			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src2-->type: alloc,  out of range \r\n");
-			return -1;
-		}
-		if(ge2d_config->src2_planes[0].addr == ge2d_config->src_planes[0].addr){
-			index = ge2d_config->src_para.canvas_index;
-		}else if (build_ge2d_config_ex(&ge2d_config->src2_planes[0], ge2d_config->src2_para.format, &index,ALLOC_CANVAS_INDEX+alloc_canvas_offset,&alloc_canvas_offset)<0){
-			return -1;
-		}
-		ge2d_config->src2_para.canvas_index = index;
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src2--> type: alloc, canvas index : 0x%x ,format :0x%x \r\n", index,ge2d_config->src2_para.format);
-	default:
-		break;
-	}
-
-	switch (ge2d_config->dst_para.mem_type){
-	case  CANVAS_OSD0:
-	case  CANVAS_OSD1:
-		if(setup_display_property(&tmp,(ge2d_config->dst_para.mem_type==CANVAS_OSD0)?OSD1_CANVAS_INDEX:OSD2_CANVAS_INDEX)<0)
-			return -1;
-		ge2d_config->dst_para.canvas_index = tmp.canvas_index;
-		ge2d_config->dst_para.format = tmp.ge2d_color_index;
-
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: dst-->type: osd%d, format: 0x%x !!\r\n",ge2d_config->dst_para.mem_type - CANVAS_OSD0, ge2d_config->dst_para.format);
-
-		if((ge2d_config->dst_para.left+ge2d_config->dst_para.width>tmp.xres)||(ge2d_config->dst_para.top+ge2d_config->dst_para.height>tmp.yres)){
-			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: dst-->type: osd%d,  out of range \r\n",ge2d_config->dst_para.mem_type - CANVAS_OSD0);
-			return -1;
-		}
-		break;
-	case  CANVAS_ALLOC:
-		if((ge2d_config->dst_para.left+ge2d_config->dst_para.width>ge2d_config->dst_planes[0].w)
-		    ||(ge2d_config->dst_para.top+ge2d_config->dst_para.height>ge2d_config->dst_planes[0].h)){
-			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: dst-->type: alloc,  out of range \r\n");
-			return -1;
-		}
-		if(ge2d_config->dst_planes[0].addr == ge2d_config->src_planes[0].addr)
-			index = ge2d_config->src_para.canvas_index;
-		else if(ge2d_config->dst_planes[0].addr == ge2d_config->src2_planes[0].addr)
-			index = ge2d_config->src2_para.canvas_index;
-		else if(build_ge2d_config_ex(&ge2d_config->dst_planes[0], ge2d_config->dst_para.format, &index,ALLOC_CANVAS_INDEX+alloc_canvas_offset,&alloc_canvas_offset)<0)
-			return -1;
-		ge2d_config->dst_para.canvas_index = index;
-		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: dst--> type: alloc, canvas index : 0x%x  ,format :0x%x \r\n",index,ge2d_config->dst_para.format);
-	default:
-		break;
-	}
-
-	ge2dgen_rendering_dir(context,ge2d_config->src_para.x_rev,ge2d_config->src_para.y_rev,
-			ge2d_config->dst_para.x_rev,ge2d_config->dst_para.y_rev,ge2d_config->dst_xy_swap);
-	ge2dgen_const_color(context,ge2d_config->alu_const_color);
-
-	ge2dgen_src(context, ge2d_config->src_para.canvas_index, ge2d_config->src_para.format);
-	ge2dgen_src_clip(context,ge2d_config->src_para.left, ge2d_config->src_para.top, ge2d_config->src_para.width, ge2d_config->src_para.height);
-	ge2dgen_src_key(context,ge2d_config->src_key.key_enable,ge2d_config->src_key.key_color,ge2d_config->src_key.key_mask,ge2d_config->src_key.key_mode);
-
-	ge2dgent_src_gbalpha(context, ge2d_config->src1_gb_alpha);
-	ge2dgen_src_color(context, ge2d_config->src_para.color);
-
-	ge2dgen_src2(context, ge2d_config->src2_para.canvas_index, ge2d_config->src2_para.format);
-	ge2dgen_src2_clip(context,ge2d_config->src2_para.left, ge2d_config->src2_para.top, ge2d_config->src2_para.width, ge2d_config->src2_para.height);     
-
-	ge2dgen_dst(context,ge2d_config->dst_para.canvas_index,ge2d_config->dst_para.format); 
-	ge2dgen_dst_clip(context,ge2d_config->dst_para.left, ge2d_config->dst_para.top, ge2d_config->dst_para.width, ge2d_config->dst_para.height, DST_CLIP_MODE_INSIDE); 
-
-	src1_gen_cfg = ge2d_wq_get_src_gen(context);     
-	src1_gen_cfg->fill_mode = ge2d_config->src_para.fill_mode;
-	src1_gen_cfg->chfmt_rpt_pix = 0;
-	src1_gen_cfg->cvfmt_rpt_pix = 0;
-	//src1_gen_cfg->clipx_start_ex = 0;
-	//src1_gen_cfg->clipx_end_ex = 1;
-	//src1_gen_cfg->clipy_start_ex = 1;
-	//src1_gen_cfg->clipy_end_ex = 1;
-
-	src2_dst_data_cfg = ge2d_wq_get_dst_data(context);
-	src2_dst_data_cfg->src2_def_color = ge2d_config->src2_para.color;
-
-	src2_dst_gen_cfg = ge2d_wq_get_dst_gen(context);
-	src2_dst_gen_cfg->src2_fill_mode = ge2d_config->src2_para.fill_mode;    
-
-	dp_gen_cfg = ge2d_wq_get_dp_gen(context);
-
-	dp_gen_cfg->src1_vsc_phase0_always_en = ge2d_config->src1_hsc_phase0_always_en;
-	dp_gen_cfg->src1_hsc_phase0_always_en = ge2d_config->src1_vsc_phase0_always_en;
-	dp_gen_cfg->src1_hsc_rpt_ctrl = ge2d_config->src1_hsc_rpt_ctrl;  //1bit, 0: using minus, 1: using repeat data
-	dp_gen_cfg->src1_vsc_rpt_ctrl = ge2d_config->src1_vsc_rpt_ctrl;  //1bit, 0: using minus  1: using repeat data
-
-	dp_gen_cfg->src2_key_en = ge2d_config->src2_key.key_enable;
-	dp_gen_cfg->src2_key_mode = ge2d_config->src2_key.key_mode; 
-	dp_gen_cfg->src2_key =   ge2d_config->src2_key.key_color;
-	dp_gen_cfg->src2_key_mask = ge2d_config->src2_key.key_mask;
-
-	dp_gen_cfg->bitmask_en = ge2d_config->bitmask_en;
-	dp_gen_cfg->bitmask= ge2d_config->bitmask;
-	dp_gen_cfg->bytemask_only = ge2d_config->bytemask_only;
-
-	ge2d_cmd_cfg = ge2d_wq_get_cmd(context);
-
-	ge2d_cmd_cfg->src1_fill_color_en = ge2d_config->src_para.fill_color_en;
-
-	ge2d_cmd_cfg->src2_x_rev = ge2d_config->src2_para.x_rev;
-	ge2d_cmd_cfg->src2_y_rev = ge2d_config->src2_para.y_rev;
-	ge2d_cmd_cfg->src2_fill_color_en = ge2d_config->src2_para.fill_color_en;
-
-	ge2d_cmd_cfg->vsc_phase_slope = ge2d_config->vsc_phase_slope;
-	ge2d_cmd_cfg->vsc_ini_phase = ge2d_config->vf_init_phase;
-	ge2d_cmd_cfg->vsc_phase_step = ge2d_config->vsc_start_phase_step;
-	ge2d_cmd_cfg->vsc_rpt_l0_num = ge2d_config->vf_rpt_num;
-
-	ge2d_cmd_cfg->hsc_phase_slope = ge2d_config->hsc_phase_slope;       //let internal decide
-	ge2d_cmd_cfg->hsc_ini_phase = ge2d_config->hf_init_phase;	
-	ge2d_cmd_cfg->hsc_phase_step = ge2d_config->hsc_start_phase_step;
-	ge2d_cmd_cfg->hsc_rpt_p0_num = ge2d_config->hf_rpt_num;
-
-	ge2d_cmd_cfg->src1_cmult_asel = 0;
-	ge2d_cmd_cfg->src2_cmult_asel = 0;    
-	context->config.update_flag = UPDATE_ALL;
-	//context->config.src1_data.ddr_burst_size_y = 3;
-	//context->config.src1_data.ddr_burst_size_cb = 3;
-	//context->config.src1_data.ddr_burst_size_cr = 3;
-	//context->config.src2_dst_data.ddr_burst_size= 3;
-	return  0;
-}
-
-/***********************************************************************
-** interface for init  create & destroy work_queue
-************************************************************************/
-ge2d_context_t* create_ge2d_work_queue(void)
-{
-	int  i;
-	ge2d_queue_item_t  *p_item;
-	ge2d_context_t  *ge2d_work_queue;
-	int  empty;
-	
-	ge2d_work_queue=kzalloc(sizeof(ge2d_context_t), GFP_KERNEL);
-	ge2d_work_queue->config.h_scale_coef_type=FILTER_TYPE_BILINEAR;
-	ge2d_work_queue->config.v_scale_coef_type=FILTER_TYPE_BILINEAR;
-	if(IS_ERR(ge2d_work_queue))
-	{
-		amlog_level(LOG_LEVEL_HIGH,"can't create work queue\r\n");
-		return NULL;
-	}
-	INIT_LIST_HEAD(&ge2d_work_queue->work_queue);
-	INIT_LIST_HEAD(&ge2d_work_queue->free_queue);
-	init_waitqueue_head (&ge2d_work_queue->cmd_complete);
-	spin_lock_init (&ge2d_work_queue->lock); //for process lock.
-	for(i=0;i<MAX_GE2D_CMD;i++)
-	{
-		p_item=(ge2d_queue_item_t*)kcalloc(1,sizeof(ge2d_queue_item_t),GFP_KERNEL);
-		if(IS_ERR(p_item))
-		{
-			amlog_level(LOG_LEVEL_HIGH,"can't request queue item memory\r\n");
-			return NULL;
-		}
-		list_add_tail(&p_item->list, &ge2d_work_queue->free_queue) ;
-	}
-	
-	//put this process queue  into manager queue list.
-	//maybe process queue is changing .
-	spin_lock(&ge2d_manager.event.sem_lock);
-	empty=list_empty(&ge2d_manager.process_queue);
-	list_add_tail(&ge2d_work_queue->list,&ge2d_manager.process_queue);
-	spin_unlock(&ge2d_manager.event.sem_lock);
-	return ge2d_work_queue; //find it 
-}
-int  destroy_ge2d_work_queue(ge2d_context_t* ge2d_work_queue)
-{
-	ge2d_queue_item_t    	*pitem,*tmp;
-	struct list_head  		*head;
-	int empty;
-	if (ge2d_work_queue) {
-		//first detatch  it from the process queue,then delete it .	
-		//maybe process queue is changing .so we lock it.
-		spin_lock(&ge2d_manager.event.sem_lock);
-		list_del(&ge2d_work_queue->list);
-		empty=list_empty(&ge2d_manager.process_queue);
-		spin_unlock(&ge2d_manager.event.sem_lock);
-		if((ge2d_manager.current_wq==ge2d_work_queue)&&(ge2d_manager.ge2d_state== GE2D_STATE_RUNNING))
-		{
-		        // check again with lock
-		        int wasRunning = 0;
-		        spin_lock(&ge2d_manager.state_lock);
-		        if (ge2d_manager.ge2d_state== GE2D_STATE_RUNNING)
-		        {
-			  ge2d_manager.ge2d_state=GE2D_STATE_REMOVING_WQ;
-			  wasRunning = 1;
-			}
-			spin_unlock(&ge2d_manager.state_lock);
-			if (wasRunning)
-			    wait_for_completion(&ge2d_manager.event.process_complete);
-			ge2d_manager.last_wq=NULL;  //condition so complex ,simplify it .
-		}//else we can delete it safely.
-		
-		head=&ge2d_work_queue->work_queue;
-		list_for_each_entry_safe(pitem,tmp,head,list){
-			if(pitem)  
-			{
-				list_del(&pitem->list );
-				kfree(pitem);
-			}
-		}
-		head=&ge2d_work_queue->free_queue;	
-		list_for_each_entry_safe(pitem,tmp,head,list){
-			if(pitem)  
-			{
-				list_del(&pitem->list );
-				kfree(pitem);
-			}
-		}
-		
-     		kfree(ge2d_work_queue);
-        	ge2d_work_queue=NULL;
-		return 0;
-    	}
-	
-    	return  -1;	
-}
-/***********************************************************************
-** interface for init and deinit section
-************************************************************************/
-int ge2d_wq_init(void)
-{
-   	ge2d_gen_t           ge2d_gen_cfg;
-	
-
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"enter %s line %d\r\n",__func__,__LINE__)	;    
-	
-    	if ((ge2d_manager.irq_num=request_irq(INT_GE2D, ge2d_wq_handle , IRQF_SHARED,"ge2d irq", (void *)&ge2d_manager))<0)
-   	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"ge2d request irq error\r\n")	;
-		return -1;
-	}
-	//prepare bottom half		
-	
-	spin_lock_init(&ge2d_manager.event.sem_lock);
-	spin_lock_init(&ge2d_manager.state_lock);
-	sema_init (&ge2d_manager.event.cmd_in_sem,1); 
-	init_waitqueue_head (&ge2d_manager.event.cmd_complete);
-	init_completion(&ge2d_manager.event.process_complete);
-	INIT_LIST_HEAD(&ge2d_manager.process_queue);
-	ge2d_manager.last_wq=NULL;
-	ge2d_manager.ge2d_thread=NULL;
-    	ge2d_soft_rst();
-    	ge2d_gen_cfg.interrupt_ctrl = 0x02;
-    	ge2d_gen_cfg.dp_on_cnt       = 0;
-    	ge2d_gen_cfg.dp_off_cnt      = 0;
-    	ge2d_gen_cfg.dp_onoff_mode   = 0;
-    	ge2d_gen_cfg.vfmt_onoff_en   = 0;
-    	ge2d_set_gen(&ge2d_gen_cfg);
-	if(ge2d_start_monitor())
- 	{
- 		amlog_level(LOG_LEVEL_HIGH,"ge2d create thread error\r\n");	
-		return -1;
- 	}	
-	return 0;
-}
-int   ge2d_setup(void)
-{
-	// do init work for ge2d.
-	if (ge2d_wq_init())
-      	{
-      		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"ge2d work queue init error \r\n");	
-		return -1;	
-      	}
- 	return  0;
-}
-EXPORT_SYMBOL(ge2d_setup);
-int   ge2d_deinit( void )
-{
-	ge2d_stop_monitor();
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"deinit ge2d device \r\n") ;
-	if (ge2d_manager.irq_num >= 0) {
-      		free_irq(INT_GE2D,&ge2d_manager);
-       	 ge2d_manager.irq_num= -1;
-    	}
-	return  0;
-}
-EXPORT_SYMBOL(ge2d_deinit);
-
-
+/*******************************************************************
+ *
+ *  Copyright C 2007 by Amlogic, Inc. All Rights Reserved.
+ *
+ *  Description:
+ *
+ *  Author: Amlogic Software
+ *  Created: 2009/12/31   19:46
+ *
+ *******************************************************************/
+
+
+#include <linux/amlogic/ge2d/ge2d.h>
+#include <linux/interrupt.h>
+#include <mach/am_regs.h>
+#include <linux/amlogic/amports/canvas.h>
+#include <linux/fb.h>
+#include <linux/list.h>
+#include  <linux/spinlock.h>
+#include <linux/kthread.h>
+#include <mach/power_gate.h>
+#include <mach/irqs.h>
+#include "ge2d_log.h"
+#include <linux/amlogic/amlog.h>
+#include <mach/mod_gate.h>
+static  ge2d_manager_t  ge2d_manager;
+
+
+static int   get_queue_member_count(struct list_head  *head)
+{
+	int member_count=0;
+	ge2d_queue_item_t *pitem;
+	list_for_each_entry(pitem, head, list){
+		member_count++;
+		if(member_count>MAX_GE2D_CMD)//error has occured
+		break;
+	}
+	return member_count;
+}
+ssize_t work_queue_status_show(struct class *cla,struct class_attribute *attr,char *buf)
+{
+	ge2d_context_t *wq=ge2d_manager.current_wq;
+	if (wq == 0) {
+		return 0;
+	}
+	return snprintf(buf,40,"cmd count in queue:%d\n",get_queue_member_count(&wq->work_queue));
+}
+ssize_t free_queue_status_show(struct class *cla,struct class_attribute *attr, char *buf)
+{
+	ge2d_context_t *wq=ge2d_manager.current_wq;
+	if (wq == 0) {
+		return 0;
+	}
+	return snprintf(buf, 40, "free space :%d\n",get_queue_member_count(&wq->free_queue));
+}
+
+static inline  int  work_queue_no_space(ge2d_context_t* queue)
+{
+	return  list_empty(&queue->free_queue) ;
+}
+
+static int ge2d_process_work_queue(ge2d_context_t *  wq)
+{
+	ge2d_config_t *cfg;
+	ge2d_queue_item_t *pitem;
+	unsigned int  mask=0x1;
+	struct list_head  *head=&wq->work_queue,*pos;
+	int ret=0;
+	unsigned int block_mode;
+
+	ge2d_manager.ge2d_state=GE2D_STATE_RUNNING;
+	pos = head->next;
+	if(pos != head) { //current work queue not empty.
+		if(wq != ge2d_manager.last_wq ) { //maybe
+			pitem=(ge2d_queue_item_t *)pos;  //modify the first item .
+			if(pitem)
+				pitem->config.update_flag=UPDATE_ALL;
+			else {
+				amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_HIGH,"can't get pitem\n");	
+				ret=-1;
+				goto  exit;
+			}
+		} else
+			pitem=(ge2d_queue_item_t *)pos;  //modify the first item .
+
+	} else {
+		ret =-1;
+		goto  exit;
+	}
+
+	do {
+		cfg = &pitem->config;
+		mask=0x1;
+		while(cfg->update_flag && mask <= UPDATE_SCALE_COEF ) //we do not change
+		{
+			switch(cfg->update_flag & mask)
+			{
+				case UPDATE_SRC_DATA:
+				ge2d_set_src1_data(&cfg->src1_data);
+				break;
+				case UPDATE_SRC_GEN:
+				ge2d_set_src1_gen(&cfg->src1_gen);
+				break;
+				case UPDATE_DST_DATA:
+				ge2d_set_src2_dst_data(&cfg->src2_dst_data);
+				break;
+				case UPDATE_DST_GEN:
+				ge2d_set_src2_dst_gen(&cfg->src2_dst_gen);
+				break;
+				case UPDATE_DP_GEN:
+				ge2d_set_dp_gen(&cfg->dp_gen);
+				break;
+				case UPDATE_SCALE_COEF:
+				ge2d_set_src1_scale_coef(cfg->v_scale_coef_type, cfg->h_scale_coef_type);
+				break;
+			}
+
+			cfg->update_flag &=~mask;
+			mask = mask <<1 ;
+
+		}
+		ge2d_set_cmd(&pitem->cmd);//set START_FLAG in this func.
+		//remove item
+		block_mode=pitem->cmd.wait_done_flag;
+		//spin_lock(&wq->lock);
+		//pos=pos->next;
+		//list_move_tail(&pitem->list,&wq->free_queue);
+		//spin_unlock(&wq->lock);
+
+		while(ge2d_is_busy())
+		interruptible_sleep_on_timeout(&ge2d_manager.event.cmd_complete, 1);
+		//if block mode (cmd)
+		if(block_mode)
+		{
+			pitem->cmd.wait_done_flag = 0;
+			wake_up_interruptible(&wq->cmd_complete);
+		}
+		spin_lock(&wq->lock);
+		pos = pos->next;
+		list_move_tail(&pitem->list,&wq->free_queue);
+		spin_unlock(&wq->lock);
+
+		pitem=(ge2d_queue_item_t *)pos;
+	}while(pos!=head);
+	ge2d_manager.last_wq=wq;
+exit:
+	spin_lock(&ge2d_manager.state_lock);
+	if(ge2d_manager.ge2d_state==GE2D_STATE_REMOVING_WQ)
+	    complete(&ge2d_manager.event.process_complete);
+	ge2d_manager.ge2d_state=GE2D_STATE_IDLE;
+	spin_unlock(&ge2d_manager.state_lock);
+	return ret;
+}
+
+
+static irqreturn_t ge2d_wq_handle(int  irq_number, void *para)
+{
+	wake_up(&ge2d_manager.event.cmd_complete) ;
+	return IRQ_HANDLED;
+
+
+}
+
+
+ge2d_src1_data_t *ge2d_wq_get_src_data(ge2d_context_t *wq)
+{
+	return &wq->config.src1_data;
+}
+
+ge2d_src1_gen_t *ge2d_wq_get_src_gen(ge2d_context_t *wq)
+{
+	return &wq->config.src1_gen;
+}
+
+ge2d_src2_dst_data_t *ge2d_wq_get_dst_data(ge2d_context_t *wq)
+{
+	return &wq->config.src2_dst_data;
+}
+
+ge2d_src2_dst_gen_t *ge2d_wq_get_dst_gen(ge2d_context_t *wq)
+{
+	return &wq->config.src2_dst_gen;
+}
+
+ge2d_dp_gen_t * ge2d_wq_get_dp_gen(ge2d_context_t *wq)
+{
+	return &wq->config.dp_gen;
+}
+
+ge2d_cmd_t * ge2d_wq_get_cmd(ge2d_context_t *wq)
+{
+	return &wq->cmd;
+}
+
+void ge2d_wq_set_scale_coef(ge2d_context_t *wq, unsigned v_scale_coef_type, unsigned h_scale_coef_type)
+{
+
+	if (wq){
+        wq->config.v_scale_coef_type = v_scale_coef_type;
+        wq->config.h_scale_coef_type = h_scale_coef_type;
+        wq->config.update_flag |= UPDATE_SCALE_COEF;
+	}
+}
+
+/*********************************************************************
+**
+**
+** each  process has it's single  ge2d  op point
+**
+**
+**********************************************************************/
+int ge2d_wq_add_work(ge2d_context_t *wq)
+{
+
+	ge2d_queue_item_t  *pitem ;
+
+     	amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"add new work @@%s:%d\n",__func__,__LINE__)	; 
+	if(work_queue_no_space(wq))
+	{
+ 		amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"work queue no space\n");
+		//we should wait for queue empty at this point.
+		while(work_queue_no_space(wq))
+		{
+			interruptible_sleep_on_timeout(&ge2d_manager.event.cmd_complete, 3);
+		}
+		amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"got free space\n");
+	}
+
+      pitem=list_entry(wq->free_queue.next,ge2d_queue_item_t,list);
+	if(IS_ERR(pitem))
+	{
+		goto error;
+	}
+	memcpy(&pitem->cmd, &wq->cmd, sizeof(ge2d_cmd_t));
+	memset(&wq->cmd, 0, sizeof(ge2d_cmd_t));
+	memcpy(&pitem->config, &wq->config, sizeof(ge2d_config_t));
+	wq->config.update_flag =0;  //reset config set flag
+	spin_lock(&wq->lock);
+	list_move_tail(&pitem->list,&wq->work_queue);
+	spin_unlock(&wq->lock);
+	amlog_mask_level(LOG_MASK_WORK,LOG_LEVEL_LOW,"add new work ok\n"); 
+	if(ge2d_manager.event.cmd_in_sem.count == 0 )//only read not need lock
+	up(&ge2d_manager.event.cmd_in_sem) ;//new cmd come in
+	//add block mode   if()
+	if(pitem->cmd.wait_done_flag)
+	{
+		wait_event_interruptible(wq->cmd_complete, pitem->cmd.wait_done_flag==0);
+		//interruptible_sleep_on(&wq->cmd_complete);
+	}
+	return 0;
+error:
+	 return -1;
+}
+
+
+
+
+
+
+static inline ge2d_context_t*  get_next_work_queue(ge2d_manager_t*  manager)
+{
+	ge2d_context_t* pcontext;
+
+	spin_lock(&ge2d_manager.event.sem_lock);
+	list_for_each_entry(pcontext,&manager->process_queue,list)
+	{
+		if(!list_empty(&pcontext->work_queue))	//not lock maybe delay to next time.
+		{
+			list_move(&manager->process_queue,&pcontext->list);//move head .
+			spin_unlock(&ge2d_manager.event.sem_lock);
+			return pcontext;
+		}
+	}
+	spin_unlock(&ge2d_manager.event.sem_lock);
+	return NULL;
+}
+static int ge2d_monitor_thread(void *data)
+{
+
+	ge2d_manager_t*  manager = (  ge2d_manager_t*)data ;
+        int ret;
+
+ 	amlog_level(LOG_LEVEL_HIGH,"ge2d workqueue monitor start\n");
+	//setup current_wq here.
+	while(ge2d_manager.process_queue_state!=GE2D_PROCESS_QUEUE_STOP)
+	{
+		ret = down_interruptible(&manager->event.cmd_in_sem);
+		//got new cmd arrived in signal,
+		//CLK_GATE_ON(GE2D);
+		switch_mod_gate_by_name("ge2d", 1);
+		while((manager->current_wq=get_next_work_queue(manager))!=NULL)
+		{
+			ge2d_process_work_queue(manager->current_wq);
+		}
+		switch_mod_gate_by_name("ge2d", 0);
+		//CLK_GATE_OFF(GE2D);
+	}
+	amlog_level(LOG_LEVEL_HIGH,"exit ge2d_monitor_thread\n");
+	return 0;
+}
+static  int ge2d_start_monitor(void )
+{
+	int ret =0;
+
+	amlog_level(LOG_LEVEL_HIGH,"ge2d start monitor\n");
+	ge2d_manager.process_queue_state=GE2D_PROCESS_QUEUE_START;
+	ge2d_manager.ge2d_thread=kthread_run(ge2d_monitor_thread,&ge2d_manager,"ge2d_monitor");
+	if (IS_ERR(ge2d_manager.ge2d_thread)) {
+		ret = PTR_ERR(ge2d_manager.ge2d_thread);
+		amlog_level(LOG_LEVEL_HIGH,"ge2d monitor : failed to start kthread (%d)\n", ret);
+	}
+	return ret;
+}
+static  int  ge2d_stop_monitor(void)
+{
+	amlog_level(LOG_LEVEL_HIGH,"stop ge2d monitor thread\n");
+	ge2d_manager.process_queue_state =GE2D_PROCESS_QUEUE_STOP;
+	up(&ge2d_manager.event.cmd_in_sem) ;
+	return  0;
+}
+/********************************************************************
+**																		 	**
+**																			**
+**  >>>>>>>>>>>>>		interface export to other parts	<<<<<<<<<<<<<			**
+**																			**
+**																			**
+*********************************************************************/
+
+
+/***********************************************************************
+** context  setup secion
+************************************************************************/
+static inline int bpp(unsigned format)
+{
+	switch (format & GE2D_BPP_MASK) {
+		case GE2D_BPP_8BIT:
+			return 8;
+		case GE2D_BPP_16BIT:
+			return 16;
+		case GE2D_BPP_24BIT:
+			return 24;
+		case GE2D_BPP_32BIT:
+		default:
+			return 32;
+	}
+}
+
+static void build_ge2d_config(config_para_t *cfg, src_dst_para_t *src, src_dst_para_t *dst,int index)
+{
+	index&=0xff;
+	if(src)
+	{
+		src->xres = cfg->src_planes[0].w;
+		src->yres = cfg->src_planes[0].h;
+//		src->canvas_index = (index+3)<<24|(index+2)<<16|(index+1)<<8|index;
+		src->ge2d_color_index = cfg->src_format;
+		src->bpp = bpp(cfg->src_format);
+
+	    if(cfg->src_planes[0].addr){
+	        src->canvas_index = index;
+		canvas_config(index++,
+			  cfg->src_planes[0].addr,
+				  cfg->src_planes[0].w * src->bpp / 8,
+				  cfg->src_planes[0].h,
+                  CANVAS_ADDR_NOWRAP,
+		          CANVAS_BLKMODE_LINEAR);
+	    }
+		/* multi-src_planes */
+		if(cfg->src_planes[1].addr){
+            src->canvas_index |= index<<8;
+            canvas_config(index++,
+			  cfg->src_planes[1].addr,
+			  cfg->src_planes[1].w * src->bpp / 8,
+			  cfg->src_planes[1].h,
+			  CANVAS_ADDR_NOWRAP,
+			  CANVAS_BLKMODE_LINEAR);
+		 }
+		 if(cfg->src_planes[2].addr){
+		    src->canvas_index |= index<<16;
+		canvas_config(index++,
+				  cfg->src_planes[2].addr,
+					  cfg->src_planes[2].w * src->bpp / 8,
+					  cfg->src_planes[2].h,
+	                  CANVAS_ADDR_NOWRAP,
+			          CANVAS_BLKMODE_LINEAR);
+        }
+        if(cfg->src_planes[3].addr){
+            src->canvas_index |= index<<24;
+		    canvas_config(index++,
+				  cfg->src_planes[3].addr,
+					  cfg->src_planes[3].w * src->bpp / 8,
+					  cfg->src_planes[3].h,
+			  CANVAS_ADDR_NOWRAP,
+				  CANVAS_BLKMODE_LINEAR);
+		}
+
+	}
+	if(dst)
+	{
+		dst->xres = cfg->dst_planes[0].w;
+		dst->yres = cfg->dst_planes[0].h;
+//		dst->canvas_index = (index+3)<<24|(index+2)<<16|(index+1)<<8|index;
+		dst->ge2d_color_index = cfg->dst_format;
+		dst->bpp = bpp(cfg->dst_format);
+		if(cfg->dst_planes[0].addr){
+		    dst->canvas_index = index;
+		    canvas_config(index++ & 0xff,
+			  cfg->dst_planes[0].addr,
+			  cfg->dst_planes[0].w * dst->bpp / 8,
+			  cfg->dst_planes[0].h,
+              CANVAS_ADDR_NOWRAP,
+	          CANVAS_BLKMODE_LINEAR);
+	    }
+
+
+		/* multi-src_planes */
+        if(cfg->dst_planes[1].addr){
+            dst->canvas_index |= index<<8;
+            canvas_config(index++,
+                  cfg->dst_planes[1].addr,
+                  cfg->dst_planes[1].w * dst->bpp / 8,
+                  cfg->dst_planes[1].h,
+                  CANVAS_ADDR_NOWRAP,
+                  CANVAS_BLKMODE_LINEAR);
+        }
+        if(cfg->dst_planes[2].addr){
+            dst->canvas_index |= index<<16;
+            canvas_config(index++,
+                cfg->dst_planes[2].addr,
+                cfg->dst_planes[2].w * dst->bpp / 8,
+                cfg->dst_planes[2].h,
+                CANVAS_ADDR_NOWRAP,
+                  CANVAS_BLKMODE_LINEAR);
+        }
+        if(cfg->dst_planes[3].addr){
+            dst->canvas_index |= index<<24;
+            canvas_config(index++,
+			  cfg->dst_planes[3].addr,
+			  cfg->dst_planes[3].w * dst->bpp / 8,
+			  cfg->dst_planes[3].h,
+		  CANVAS_ADDR_NOWRAP,
+		  CANVAS_BLKMODE_LINEAR);
+        }
+	}
+}
+static  int
+setup_display_property(src_dst_para_t *src_dst,int index)
+{
+#define   REG_OFFSET		(0x20<<2)
+	canvas_t   	canvas;
+	unsigned	int  	data32;
+	unsigned	int 	bpp;
+	unsigned int 	block_mode[]={2,4,8,16,16,32,0,24};
+
+	src_dst->canvas_index=index;
+	canvas_read(index,&canvas);
+
+	index=(index==OSD1_CANVAS_INDEX?0:1);
+	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"osd%d ",index);
+	data32=aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W0+ REG_OFFSET*index);
+	index=(data32>>8) & 0xf;
+	bpp=block_mode[index];  //OSD_BLK_MODE[8..11]
+	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"%d bpp \n",bpp);
+	if(bpp < 16) return -1;
+
+	src_dst->bpp=bpp;
+	src_dst->xres=canvas.width/(bpp>>3);
+	src_dst->yres=canvas.height;
+	if(index==3) //yuv422 32bit for two pixel.
+	{
+		src_dst->ge2d_color_index=	GE2D_FORMAT_S16_YUV422;
+	}
+	else  //for block mode=4,5,7
+	{
+		index=bpp-16 + ((data32>>2)&0xf); //color mode [2..5]
+		index=bpp_type_lut[index];  //get color mode
+		src_dst->ge2d_color_index=default_ge2d_color_lut[index] ; //get matched ge2d color mode.
+
+		if(src_dst->xres<=0 || src_dst->yres<=0 || src_dst->ge2d_color_index==0)
+		return -2;
+	}
+
+	return 0;
+
+}
+int	ge2d_antiflicker_enable(ge2d_context_t *context,unsigned long enable)
+{
+	/*********************************************************************
+	**	antiflicker used in cvbs mode, if antiflicker is enabled , it represent that we want
+	**	this feature be enabled for all ge2d work
+	***********************************************************************/
+	ge2d_context_t* pcontext;
+
+	spin_lock(&ge2d_manager.event.sem_lock);
+	list_for_each_entry(pcontext,&ge2d_manager.process_queue,list)
+	{
+		ge2dgen_antiflicker(pcontext,enable);
+	}
+	spin_unlock(&ge2d_manager.event.sem_lock);
+	return 0;
+}
+int   ge2d_context_config(ge2d_context_t *context, config_para_t *ge2d_config)
+{
+	src_dst_para_t  src,dst,tmp;
+	int type=ge2d_config->src_dst_type;
+
+	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW," ge2d init\n");
+	//setup src and dst
+	switch (type)
+	{
+		case  OSD0_OSD0:
+		case  OSD0_OSD1:
+		case  OSD1_OSD0:
+		case ALLOC_OSD0:
+	if(0>setup_display_property(&src,OSD1_CANVAS_INDEX))
+	{
+		return -1;
+	}
+		break;
+		default:
+		break;
+	}
+	switch (type)
+	{
+		case  OSD0_OSD1:
+		case  OSD1_OSD1:
+		case  OSD1_OSD0:
+		case ALLOC_OSD1:
+	if(0>setup_display_property(&dst,OSD2_CANVAS_INDEX))
+	{
+		return -1;
+	}
+		break;
+		case ALLOC_ALLOC:
+		default:
+		break;
+	}
+	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"OSD ge2d type %d\n",type);
+	switch (type)
+	{
+		case  OSD0_OSD0:
+		dst=src;
+		break;
+		case  OSD0_OSD1:
+		break;
+		case  OSD1_OSD1:
+		src=dst;
+		break;
+		case  OSD1_OSD0:
+		tmp=src;
+		src=dst;
+		dst=tmp;
+		break;
+		case ALLOC_OSD0:
+		dst=src;
+		build_ge2d_config(ge2d_config, &src, NULL,ALLOC_CANVAS_INDEX);
+		break;
+		case ALLOC_OSD1:
+		build_ge2d_config(ge2d_config, &src, NULL,ALLOC_CANVAS_INDEX);
+		break;
+		case ALLOC_ALLOC:
+		build_ge2d_config(ge2d_config, &src,&dst,ALLOC_CANVAS_INDEX);
+		break;
+	}
+	if(src.bpp < 16 || dst.bpp < 16 )
+	{
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"src dst bpp type, src=%d,dst=%d\n",src.bpp,dst.bpp);
+	}
+
+	//next will config regs
+	amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d xres %d yres %d : dst xres %d yres %d\n,src_format:0x%x,dst_format:0x%x\n",src.xres,src.yres,
+	dst.xres,dst.yres,src.ge2d_color_index, dst.ge2d_color_index);
+
+	ge2dgen_src(context,src.canvas_index, src.ge2d_color_index);
+	ge2dgen_src_clip(context,
+                  0, 0,src.xres, src.yres);
+	ge2dgen_src2(context, dst.canvas_index, dst.ge2d_color_index);
+	ge2dgen_src2_clip(context,
+                            0, 0,  dst.xres, dst.yres);
+	ge2dgen_const_color(context,ge2d_config->alu_const_color);
+	ge2dgen_dst(context, dst.canvas_index,dst.ge2d_color_index);
+	ge2dgen_dst_clip(context,
+                   0, 0, dst.xres, dst.yres, DST_CLIP_MODE_INSIDE);
+	return  0;
+
+}
+
+static int build_ge2d_config_ex(config_planes_t *plane, unsigned format, unsigned *canvas_index, int index,unsigned* r_offset)
+{
+	int bpp_value = bpp(format);
+	int ret = -1;
+	bpp_value /= 8;
+	index &= 0xff;
+	if(plane) {
+		if(plane[0].addr){
+			*canvas_index = index;
+			*r_offset += 1;
+			canvas_config(index++, plane[0].addr, plane[0].w * bpp_value, plane[0].h, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+			ret = 0;
+		}
+		/* multi-src_planes */
+		if(plane[1].addr){
+		    *canvas_index |= index<<8;
+		    *r_offset += 1;
+		    canvas_config(index++, plane[1].addr, plane[1].w * bpp_value, plane[1].h, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+		}
+		if(plane[2].addr){
+		    *canvas_index |= index<<16;
+		    *r_offset += 1;
+		    canvas_config(index++, plane[2].addr, plane[2].w * bpp_value, plane[2].h, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+		}
+		if(plane[3].addr){
+		    *canvas_index |= index<<24;
+		    *r_offset += 1;
+		    canvas_config(index++, plane[3].addr, plane[3].w * bpp_value, plane[3].h, CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+		}
+	}
+	return ret;
+}
+
+
+int ge2d_context_config_ex(ge2d_context_t *context, config_para_ex_t *ge2d_config)
+{
+	src_dst_para_t  tmp;
+	unsigned index = 0;
+	unsigned alloc_canvas_offset = 0;
+	ge2d_src1_gen_t *src1_gen_cfg  ;
+	ge2d_src2_dst_data_t *src2_dst_data_cfg;
+	ge2d_src2_dst_gen_t *src2_dst_gen_cfg;
+	ge2d_dp_gen_t *dp_gen_cfg ;
+	ge2d_cmd_t *ge2d_cmd_cfg ;
+
+	//setup src and dst
+	switch (ge2d_config->src_para.mem_type) {
+	case  CANVAS_OSD0:
+	case  CANVAS_OSD1:
+		if(setup_display_property(&tmp,(ge2d_config->src_para.mem_type==CANVAS_OSD0)?OSD1_CANVAS_INDEX:OSD2_CANVAS_INDEX)<0)
+			return -1;
+		ge2d_config->src_para.canvas_index = tmp.canvas_index;
+		ge2d_config->src_para.format = tmp.ge2d_color_index;
+
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src1-->type: osd%d, format: 0x%x !!\n",ge2d_config->src_para.mem_type - CANVAS_OSD0, ge2d_config->src_para.format);
+
+		if((ge2d_config->src_para.left+ge2d_config->src_para.width>tmp.xres)||(ge2d_config->src_para.top+ge2d_config->src_para.height>tmp.yres)){
+			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src1-->type: osd%d,  out of range\n",ge2d_config->src_para.mem_type - CANVAS_OSD0);
+			return -1;
+		}
+		break;
+	case  CANVAS_ALLOC:
+		if((ge2d_config->src_para.left+ge2d_config->src_para.width>ge2d_config->src_planes[0].w)
+		    ||(ge2d_config->src_para.top+ge2d_config->src_para.height>ge2d_config->src_planes[0].h)){
+			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src1-->type: alloc,  out of range\n");
+			return -1;
+		}
+		if(build_ge2d_config_ex(&ge2d_config->src_planes[0], ge2d_config->src_para.format, &index,ALLOC_CANVAS_INDEX+alloc_canvas_offset,&alloc_canvas_offset)<0)
+			return -1;
+		ge2d_config->src_para.canvas_index = index;
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src1--> type: alloc, canvas index : 0x%x,format :0x%x\n", index,ge2d_config->src_para.format);
+	default:
+		break;
+	}
+
+	switch (ge2d_config->src2_para.mem_type){
+	case  CANVAS_OSD0:
+	case  CANVAS_OSD1:
+		if(setup_display_property(&tmp,(ge2d_config->src2_para.mem_type==CANVAS_OSD0)?OSD1_CANVAS_INDEX:OSD2_CANVAS_INDEX)<0)
+			return -1;
+		ge2d_config->src2_para.canvas_index = tmp.canvas_index;
+		ge2d_config->src2_para.format = tmp.ge2d_color_index;
+
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src2-->type: osd%d, format: 0x%x !!\n",ge2d_config->src2_para.mem_type - CANVAS_OSD0, ge2d_config->src2_para.format);
+
+		if((ge2d_config->src2_para.left+ge2d_config->src2_para.width>tmp.xres)||(ge2d_config->src2_para.top+ge2d_config->src2_para.height>tmp.yres)){
+			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src2-->type: osd%d,  out of range\n",ge2d_config->src2_para.mem_type - CANVAS_OSD0);
+			return -1;
+		}
+		break;
+	case  CANVAS_ALLOC:
+		if((ge2d_config->src2_para.left+ge2d_config->src2_para.width>ge2d_config->src2_planes[0].w)
+		    ||(ge2d_config->src2_para.top+ge2d_config->src2_para.height>ge2d_config->src2_planes[0].h)){
+			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: src2-->type: alloc,  out of range\n");
+			return -1;
+		}
+		if(ge2d_config->src2_planes[0].addr == ge2d_config->src_planes[0].addr){
+			index = ge2d_config->src_para.canvas_index;
+		}else if (build_ge2d_config_ex(&ge2d_config->src2_planes[0], ge2d_config->src2_para.format, &index,ALLOC_CANVAS_INDEX+alloc_canvas_offset,&alloc_canvas_offset)<0){
+			return -1;
+		}
+		ge2d_config->src2_para.canvas_index = index;
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: src2--> type: alloc, canvas index : 0x%x ,format :0x%x\n", index,ge2d_config->src2_para.format);
+	default:
+		break;
+	}
+
+	switch (ge2d_config->dst_para.mem_type){
+	case  CANVAS_OSD0:
+	case  CANVAS_OSD1:
+		if(setup_display_property(&tmp,(ge2d_config->dst_para.mem_type==CANVAS_OSD0)?OSD1_CANVAS_INDEX:OSD2_CANVAS_INDEX)<0)
+			return -1;
+		ge2d_config->dst_para.canvas_index = tmp.canvas_index;
+		ge2d_config->dst_para.format = tmp.ge2d_color_index;
+
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: dst-->type: osd%d, format: 0x%x !!\n",ge2d_config->dst_para.mem_type - CANVAS_OSD0, ge2d_config->dst_para.format);
+
+		if((ge2d_config->dst_para.left+ge2d_config->dst_para.width>tmp.xres)||(ge2d_config->dst_para.top+ge2d_config->dst_para.height>tmp.yres)){
+			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: dst-->type: osd%d,  out of range\n",ge2d_config->dst_para.mem_type - CANVAS_OSD0);
+			return -1;
+		}
+		break;
+	case  CANVAS_ALLOC:
+		if((ge2d_config->dst_para.left+ge2d_config->dst_para.width>ge2d_config->dst_planes[0].w)
+		    ||(ge2d_config->dst_para.top+ge2d_config->dst_para.height>ge2d_config->dst_planes[0].h)){
+			amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_HIGH,"ge2d error: dst-->type: alloc,  out of range\n");
+			return -1;
+		}
+		if(ge2d_config->dst_planes[0].addr == ge2d_config->src_planes[0].addr)
+			index = ge2d_config->src_para.canvas_index;
+		else if(ge2d_config->dst_planes[0].addr == ge2d_config->src2_planes[0].addr)
+			index = ge2d_config->src2_para.canvas_index;
+		else if(build_ge2d_config_ex(&ge2d_config->dst_planes[0], ge2d_config->dst_para.format, &index,ALLOC_CANVAS_INDEX+alloc_canvas_offset,&alloc_canvas_offset)<0)
+			return -1;
+		ge2d_config->dst_para.canvas_index = index;
+		amlog_mask_level(LOG_MASK_CONFIG,LOG_LEVEL_LOW,"ge2d: dst--> type: alloc, canvas index : 0x%x  ,format :0x%x\n",index,ge2d_config->dst_para.format);
+	default:
+		break;
+	}
+
+	ge2dgen_rendering_dir(context,ge2d_config->src_para.x_rev,ge2d_config->src_para.y_rev,
+			ge2d_config->dst_para.x_rev,ge2d_config->dst_para.y_rev,ge2d_config->dst_xy_swap);
+	ge2dgen_const_color(context,ge2d_config->alu_const_color);
+
+	ge2dgen_src(context, ge2d_config->src_para.canvas_index, ge2d_config->src_para.format);
+	ge2dgen_src_clip(context,ge2d_config->src_para.left, ge2d_config->src_para.top, ge2d_config->src_para.width, ge2d_config->src_para.height);
+	ge2dgen_src_key(context,ge2d_config->src_key.key_enable,ge2d_config->src_key.key_color,ge2d_config->src_key.key_mask,ge2d_config->src_key.key_mode);
+
+	ge2dgent_src_gbalpha(context, ge2d_config->src1_gb_alpha);
+	ge2dgen_src_color(context, ge2d_config->src_para.color);
+
+	ge2dgen_src2(context, ge2d_config->src2_para.canvas_index, ge2d_config->src2_para.format);
+	ge2dgen_src2_clip(context,ge2d_config->src2_para.left, ge2d_config->src2_para.top, ge2d_config->src2_para.width, ge2d_config->src2_para.height);
+
+	ge2dgen_dst(context,ge2d_config->dst_para.canvas_index,ge2d_config->dst_para.format);
+	ge2dgen_dst_clip(context,ge2d_config->dst_para.left, ge2d_config->dst_para.top, ge2d_config->dst_para.width, ge2d_config->dst_para.height, DST_CLIP_MODE_INSIDE);
+
+	src1_gen_cfg = ge2d_wq_get_src_gen(context);
+	src1_gen_cfg->fill_mode = ge2d_config->src_para.fill_mode;
+	src1_gen_cfg->chfmt_rpt_pix = 0;
+	src1_gen_cfg->cvfmt_rpt_pix = 0;
+	//src1_gen_cfg->clipx_start_ex = 0;
+	//src1_gen_cfg->clipx_end_ex = 1;
+	//src1_gen_cfg->clipy_start_ex = 1;
+	//src1_gen_cfg->clipy_end_ex = 1;
+
+	src2_dst_data_cfg = ge2d_wq_get_dst_data(context);
+	src2_dst_data_cfg->src2_def_color = ge2d_config->src2_para.color;
+
+	src2_dst_gen_cfg = ge2d_wq_get_dst_gen(context);
+	src2_dst_gen_cfg->src2_fill_mode = ge2d_config->src2_para.fill_mode;
+
+	dp_gen_cfg = ge2d_wq_get_dp_gen(context);
+
+	dp_gen_cfg->src1_vsc_phase0_always_en = ge2d_config->src1_hsc_phase0_always_en;
+	dp_gen_cfg->src1_hsc_phase0_always_en = ge2d_config->src1_vsc_phase0_always_en;
+	dp_gen_cfg->src1_hsc_rpt_ctrl = ge2d_config->src1_hsc_rpt_ctrl;  //1bit, 0: using minus, 1: using repeat data
+	dp_gen_cfg->src1_vsc_rpt_ctrl = ge2d_config->src1_vsc_rpt_ctrl;  //1bit, 0: using minus  1: using repeat data
+
+	dp_gen_cfg->src2_key_en = ge2d_config->src2_key.key_enable;
+	dp_gen_cfg->src2_key_mode = ge2d_config->src2_key.key_mode;
+	dp_gen_cfg->src2_key =   ge2d_config->src2_key.key_color;
+	dp_gen_cfg->src2_key_mask = ge2d_config->src2_key.key_mask;
+
+	dp_gen_cfg->bitmask_en = ge2d_config->bitmask_en;
+	dp_gen_cfg->bitmask= ge2d_config->bitmask;
+	dp_gen_cfg->bytemask_only = ge2d_config->bytemask_only;
+
+	ge2d_cmd_cfg = ge2d_wq_get_cmd(context);
+
+	ge2d_cmd_cfg->src1_fill_color_en = ge2d_config->src_para.fill_color_en;
+
+	ge2d_cmd_cfg->src2_x_rev = ge2d_config->src2_para.x_rev;
+	ge2d_cmd_cfg->src2_y_rev = ge2d_config->src2_para.y_rev;
+	ge2d_cmd_cfg->src2_fill_color_en = ge2d_config->src2_para.fill_color_en;
+
+	ge2d_cmd_cfg->vsc_phase_slope = ge2d_config->vsc_phase_slope;
+	ge2d_cmd_cfg->vsc_ini_phase = ge2d_config->vf_init_phase;
+	ge2d_cmd_cfg->vsc_phase_step = ge2d_config->vsc_start_phase_step;
+	ge2d_cmd_cfg->vsc_rpt_l0_num = ge2d_config->vf_rpt_num;
+
+	ge2d_cmd_cfg->hsc_phase_slope = ge2d_config->hsc_phase_slope;       //let internal decide
+	ge2d_cmd_cfg->hsc_ini_phase = ge2d_config->hf_init_phase;
+	ge2d_cmd_cfg->hsc_phase_step = ge2d_config->hsc_start_phase_step;
+	ge2d_cmd_cfg->hsc_rpt_p0_num = ge2d_config->hf_rpt_num;
+
+	ge2d_cmd_cfg->src1_cmult_asel = 0;
+	ge2d_cmd_cfg->src2_cmult_asel = 0;
+	context->config.update_flag = UPDATE_ALL;
+	//context->config.src1_data.ddr_burst_size_y = 3;
+	//context->config.src1_data.ddr_burst_size_cb = 3;
+	//context->config.src1_data.ddr_burst_size_cr = 3;
+	//context->config.src2_dst_data.ddr_burst_size= 3;
+	return  0;
+}
+
+/***********************************************************************
+** interface for init  create & destroy work_queue
+************************************************************************/
+ge2d_context_t* create_ge2d_work_queue(void)
+{
+	int  i;
+	ge2d_queue_item_t  *p_item;
+	ge2d_context_t  *ge2d_work_queue;
+	int  empty;
+
+	ge2d_work_queue=kzalloc(sizeof(ge2d_context_t), GFP_KERNEL);
+	ge2d_work_queue->config.h_scale_coef_type=FILTER_TYPE_BILINEAR;
+	ge2d_work_queue->config.v_scale_coef_type=FILTER_TYPE_BILINEAR;
+	if(IS_ERR(ge2d_work_queue))
+	{
+		amlog_level(LOG_LEVEL_HIGH,"can't create work queue\n");
+		return NULL;
+	}
+	INIT_LIST_HEAD(&ge2d_work_queue->work_queue);
+	INIT_LIST_HEAD(&ge2d_work_queue->free_queue);
+	init_waitqueue_head (&ge2d_work_queue->cmd_complete);
+	spin_lock_init (&ge2d_work_queue->lock); //for process lock.
+	for(i=0;i<MAX_GE2D_CMD;i++)
+	{
+		p_item=(ge2d_queue_item_t*)kcalloc(1,sizeof(ge2d_queue_item_t),GFP_KERNEL);
+		if(IS_ERR(p_item))
+		{
+			amlog_level(LOG_LEVEL_HIGH,"can't request queue item memory\n");
+			return NULL;
+		}
+		list_add_tail(&p_item->list, &ge2d_work_queue->free_queue) ;
+	}
+
+	//put this process queue  into manager queue list.
+	//maybe process queue is changing .
+	spin_lock(&ge2d_manager.event.sem_lock);
+	empty=list_empty(&ge2d_manager.process_queue);
+	list_add_tail(&ge2d_work_queue->list,&ge2d_manager.process_queue);
+	spin_unlock(&ge2d_manager.event.sem_lock);
+	return ge2d_work_queue; //find it
+}
+int  destroy_ge2d_work_queue(ge2d_context_t* ge2d_work_queue)
+{
+	ge2d_queue_item_t    	*pitem,*tmp;
+	struct list_head  		*head;
+	int empty;
+	if (ge2d_work_queue) {
+		//first detatch  it from the process queue,then delete it .
+		//maybe process queue is changing .so we lock it.
+		spin_lock(&ge2d_manager.event.sem_lock);
+		list_del(&ge2d_work_queue->list);
+		empty=list_empty(&ge2d_manager.process_queue);
+		spin_unlock(&ge2d_manager.event.sem_lock);
+		if((ge2d_manager.current_wq==ge2d_work_queue)&&(ge2d_manager.ge2d_state== GE2D_STATE_RUNNING))
+		{
+		        // check again with lock
+		        int wasRunning = 0;
+		        spin_lock(&ge2d_manager.state_lock);
+		        if (ge2d_manager.ge2d_state== GE2D_STATE_RUNNING)
+		        {
+			  ge2d_manager.ge2d_state=GE2D_STATE_REMOVING_WQ;
+			  wasRunning = 1;
+			}
+			spin_unlock(&ge2d_manager.state_lock);
+			if (wasRunning)
+			    wait_for_completion(&ge2d_manager.event.process_complete);
+			ge2d_manager.last_wq=NULL;  //condition so complex ,simplify it .
+		}//else we can delete it safely.
+
+		head=&ge2d_work_queue->work_queue;
+		list_for_each_entry_safe(pitem,tmp,head,list){
+			if(pitem)
+			{
+				list_del(&pitem->list );
+				kfree(pitem);
+			}
+		}
+		head=&ge2d_work_queue->free_queue;
+		list_for_each_entry_safe(pitem,tmp,head,list){
+			if(pitem)
+			{
+				list_del(&pitem->list );
+				kfree(pitem);
+			}
+		}
+
+		kfree(ge2d_work_queue);
+		ge2d_work_queue=NULL;
+		return 0;
+	}
+
+	return  -1;
+}
+/***********************************************************************
+** interface for init and deinit section
+************************************************************************/
+int ge2d_wq_init(void)
+{
+	ge2d_gen_t           ge2d_gen_cfg;
+
+
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"enter %s line %d\n",__func__,__LINE__)	;    
+
+	if ((ge2d_manager.irq_num=request_irq(INT_GE2D, ge2d_wq_handle , IRQF_SHARED,"ge2d irq", (void *)&ge2d_manager))<0)
+	{
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"ge2d request irq error\n")	;
+		return -1;
+	}
+	//prepare bottom half
+
+	spin_lock_init(&ge2d_manager.event.sem_lock);
+	spin_lock_init(&ge2d_manager.state_lock);
+	sema_init (&ge2d_manager.event.cmd_in_sem,1);
+	init_waitqueue_head (&ge2d_manager.event.cmd_complete);
+	init_completion(&ge2d_manager.event.process_complete);
+	INIT_LIST_HEAD(&ge2d_manager.process_queue);
+	ge2d_manager.last_wq=NULL;
+	ge2d_manager.ge2d_thread=NULL;
+	ge2d_soft_rst();
+	ge2d_gen_cfg.interrupt_ctrl = 0x02;
+	ge2d_gen_cfg.dp_on_cnt       = 0;
+	ge2d_gen_cfg.dp_off_cnt      = 0;
+	ge2d_gen_cfg.dp_onoff_mode   = 0;
+	ge2d_gen_cfg.vfmt_onoff_en   = 0;
+	ge2d_set_gen(&ge2d_gen_cfg);
+	if(ge2d_start_monitor())
+	{
+ 		amlog_level(LOG_LEVEL_HIGH,"ge2d create thread error\n");	
+		return -1;
+	}
+	return 0;
+}
+int   ge2d_setup(void)
+{
+	// do init work for ge2d.
+	if (ge2d_wq_init())
+	{
+      		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"ge2d work queue init error\n");	
+		return -1;
+	}
+	return  0;
+}
+EXPORT_SYMBOL(ge2d_setup);
+int   ge2d_deinit( void )
+{
+	ge2d_stop_monitor();
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"deinit ge2d device\n") ;
+	if (ge2d_manager.irq_num >= 0) {
+		free_irq(INT_GE2D,&ge2d_manager);
+	 ge2d_manager.irq_num= -1;
+	}
+	return  0;
+}
+EXPORT_SYMBOL(ge2d_deinit);
diff --git a/drivers/amlogic/display/ge2d/ge2dgen.c b/drivers/amlogic/display/ge2d/ge2dgen.c
old mode 100644
new mode 100755
index a76c1b83..fab61fdd
--- a/drivers/amlogic/display/ge2d/ge2dgen.c
+++ b/drivers/amlogic/display/ge2d/ge2dgen.c
@@ -1,349 +1,349 @@
-#include <linux/amlogic/ge2d/ge2d.h>
-
-static inline void _set_src1_format(ge2d_src1_data_t *src1_data_cfg,
-                                     ge2d_src1_gen_t *src1_gen_cfg,
-                                     ge2d_dp_gen_t *dp_gen_cfg,
-                                     unsigned format_src,
-                                     unsigned format_dst)
-{
-    src1_data_cfg->format_all  = format_src;
-
-    src1_data_cfg->format      = (format_src >> 8) & 3;
-    src1_data_cfg->mode_8b_sel = (format_src >> 6) & 3;
-    src1_data_cfg->lut_en      = (format_src >> 5) & 1;
-    src1_data_cfg->sep_en      = (format_src >> 2) & 1;
-
-	src1_data_cfg->endian      = (format_src & GE2D_ENDIAN_MASK) >> GE2D_ENDIAN_SHIFT;
-	src1_data_cfg->color_map   = (format_src & GE2D_COLOR_MAP_MASK) >> GE2D_COLOR_MAP_SHIFT;
-   
-
-    src1_gen_cfg->pic_struct   = (format_src >> 3) & 3;
-    src1_data_cfg->x_yc_ratio  = (format_src >> 1) & 1;
-    src1_data_cfg->y_yc_ratio  = (format_src >> 0) & 1;
-    
-    if ((format_src & GE2D_FORMAT_YUV) &&
-        ((format_dst & GE2D_FORMAT_YUV) == 0)) {
-        dp_gen_cfg->use_matrix_default = (format_src & GE2D_FORMAT_COMP_RANGE) ? MATRIX_FULL_RANGE_YCC_TO_RGB : MATRIX_YCC_TO_RGB;
-        dp_gen_cfg->conv_matrix_en = 1;
-    }
-    else if (((format_src & GE2D_FORMAT_YUV) == 0) &&
-             (format_dst & GE2D_FORMAT_YUV)) {
-        dp_gen_cfg->use_matrix_default = MATRIX_RGB_TO_YCC;
-        dp_gen_cfg->conv_matrix_en = 1;
-    }
-    else {
-        dp_gen_cfg->conv_matrix_en = 0;
-    }
-}
-
-static inline void _set_src2_format(ge2d_src2_dst_data_t *src2_dst_data_cfg,
-                             ge2d_src2_dst_gen_t *src2_dst_gen_cfg,
-                             unsigned format)
-{
-    src2_dst_data_cfg->src2_format_all  = format;
-
-    src2_dst_data_cfg->src2_format      = (format >> 8) & 3;
-	src2_dst_data_cfg->src2_endian      = (format & GE2D_ENDIAN_MASK) >> GE2D_ENDIAN_SHIFT;
-	src2_dst_data_cfg->src2_color_map   = (format & GE2D_COLOR_MAP_MASK) >> GE2D_COLOR_MAP_SHIFT;
-   
-    src2_dst_data_cfg->src2_mode_8b_sel = (format >> 6) & 3;
-
-    src2_dst_gen_cfg->src2_pic_struct   = (format >> 3) & 3;
-}
-
-static inline void _set_dst_format(ge2d_src2_dst_data_t *src2_dst_data_cfg,
-                             ge2d_src2_dst_gen_t *src2_dst_gen_cfg,
-                             ge2d_dp_gen_t *dp_gen_cfg,
-                             unsigned format_src,
-                             unsigned format_dst)
-{
-	src2_dst_data_cfg->dst_format_all  = format_dst;
-
-	src2_dst_data_cfg->dst_format      = (format_dst >> 8) & 3;
-
-	src2_dst_data_cfg->dst_endian      = (format_dst & GE2D_ENDIAN_MASK) >> GE2D_ENDIAN_SHIFT;
-	src2_dst_data_cfg->dst_color_map   = (format_dst & GE2D_COLOR_MAP_MASK) >> GE2D_COLOR_MAP_SHIFT;
-
-	src2_dst_data_cfg->dst_mode_8b_sel = (format_dst >> 6) & 3;
-
-	src2_dst_gen_cfg->dst_pic_struct   = (format_dst >> 3) & 3;
-
-	if ((format_src & GE2D_FORMAT_YUV) && 
-				((format_dst & GE2D_FORMAT_YUV) == 0)) {
-		dp_gen_cfg->use_matrix_default = (format_src & GE2D_FORMAT_COMP_RANGE) ? MATRIX_FULL_RANGE_YCC_TO_RGB : MATRIX_YCC_TO_RGB;
-		dp_gen_cfg->conv_matrix_en = 1;
-	}
-	else if (((format_src & GE2D_FORMAT_YUV) == 0) &&
-			(format_dst & GE2D_FORMAT_YUV)) {
-		dp_gen_cfg->use_matrix_default = MATRIX_RGB_TO_YCC;
-		dp_gen_cfg->conv_matrix_en = 1;
-	}
-	else {
-		dp_gen_cfg->conv_matrix_en = 0;
-	}
-
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
-	/* for dest is nv21 or nv12 in m6. */
-	if((format_dst & GE2D_FORMAT_YUV) && ((src2_dst_data_cfg->dst_color_map|1)==15)) {
-		src2_dst_data_cfg->dst_format = 0;
-		src2_dst_data_cfg->dst_mode_8b_sel = 0;
-		src2_dst_data_cfg->dst2_pixel_byte_width = 1;
-		src2_dst_data_cfg->dst2_discard_mode = 0xf;
-		src2_dst_data_cfg->dst2_enable = 1;
-		src2_dst_data_cfg->dst2_color_map = src2_dst_data_cfg->dst_color_map - 5;
-	} else 
-		src2_dst_data_cfg->dst2_enable = 0;
-#endif
-}
-void ge2dgen_src(ge2d_context_t *wq,
-                 unsigned canvas_addr,
-                 unsigned format)
-{
-    ge2d_src1_data_t *src1_data_cfg = ge2d_wq_get_src_data(wq);
-    ge2d_src1_gen_t *src1_gen_cfg = ge2d_wq_get_src_gen(wq);
-    ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
-    ge2d_src2_dst_data_t *src2_dst_data_cfg = ge2d_wq_get_dst_data(wq);
-
-    if ((format != src1_data_cfg->format_all) ||
-        (canvas_addr != src1_data_cfg->canaddr)) {
-        src1_data_cfg->canaddr = canvas_addr;
-
-        _set_src1_format(src1_data_cfg, src1_gen_cfg, dp_gen_cfg,
-            format, src2_dst_data_cfg->dst_format_all);
-	  wq->config.update_flag |= UPDATE_SRC_DATA;
-	  wq->config.update_flag |= UPDATE_SRC_GEN;
-	  wq->config.update_flag |= UPDATE_DP_GEN;
-    }
-}
-
-void ge2dgen_antiflicker(ge2d_context_t *wq,unsigned long enable)
-{
-	ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
-
-	enable = enable?1:0;  
-
-	if(dp_gen_cfg->antiflick_en != enable)
-	{
-		dp_gen_cfg->antiflick_en=enable;
-		wq->config.update_flag |= UPDATE_DP_GEN;
-	}
-}
-void ge2dgen_post_release_src1buf(ge2d_context_t *wq, unsigned buffer)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-
-    ge2d_cmd_cfg->src1_buffer = buffer;
-    ge2d_cmd_cfg->release_flag |= RELEASE_SRC1_BUFFER;
-}
-
-void ge2dgen_post_release_src1canvas(ge2d_context_t *wq)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-
-    ge2d_cmd_cfg->release_flag |= RELEASE_SRC1_CANVAS;
-}
-
-void ge2dgen_post_release_src2buf(ge2d_context_t *wq, unsigned buffer)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-
-    ge2d_cmd_cfg->src2_buffer = buffer;
-    ge2d_cmd_cfg->release_flag |= RELEASE_SRC2_BUFFER;
-}
-
-void ge2dgen_post_release_src2canvas(ge2d_context_t *wq)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-
-    ge2d_cmd_cfg->release_flag |= RELEASE_SRC2_CANVAS;
-}
-
-void ge2dgen_cb(ge2d_context_t *wq, int (*cmd_cb)(unsigned), unsigned param)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-
-    ge2d_cmd_cfg->cmd_cb = cmd_cb;
-    ge2d_cmd_cfg->cmd_cb_param = param;
-    ge2d_cmd_cfg->release_flag |= RELEASE_CB;
-}
-
-void ge2dgen_src2(ge2d_context_t *wq,
-                  unsigned canvas_addr,
-                  unsigned format)
-{
-    ge2d_src2_dst_data_t *src2_dst_data_cfg = ge2d_wq_get_dst_data(wq);
-    ge2d_src2_dst_gen_t *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
-
-    if ((format != src2_dst_data_cfg->src2_format_all) ||
-        (canvas_addr != src2_dst_data_cfg->src2_canaddr)) {
-
-        src2_dst_data_cfg->src2_canaddr = canvas_addr;
-
-        _set_src2_format(src2_dst_data_cfg, src2_dst_gen_cfg, format);
-	 wq->config.update_flag |= UPDATE_DST_DATA;
-	 wq->config.update_flag |= UPDATE_DST_GEN;
-    }
-}
-
-void ge2dgen_dst(ge2d_context_t *wq,
-                 unsigned canvas_addr,
-                 unsigned format)
-{
-    ge2d_src1_data_t *src1_data_cfg = ge2d_wq_get_src_data(wq);
-    ge2d_src2_dst_data_t *src2_dst_data_cfg = ge2d_wq_get_dst_data(wq);
-    ge2d_src2_dst_gen_t *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
-    ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
-
-    if ((format != src2_dst_data_cfg->dst_format_all) ||
-        (canvas_addr != src2_dst_data_cfg->dst_canaddr)) {
-        src2_dst_data_cfg->dst_canaddr = canvas_addr;
-
-      	_set_dst_format(src2_dst_data_cfg, src2_dst_gen_cfg, dp_gen_cfg,
-            src1_data_cfg->format_all, format);
-	wq->config.update_flag |= UPDATE_DST_DATA;
-      	wq->config.update_flag |= UPDATE_DST_GEN;
-	wq->config.update_flag |= UPDATE_DP_GEN;  
-    }
-}
-
-void ge2dgen_src_clip(ge2d_context_t *wq,
-                      int x, int y, int w, int h)
-{
-    	ge2d_src1_gen_t *src1_gen_cfg = ge2d_wq_get_src_gen(wq);
-	//adjust w->x_end h->y_end
-	w=x+w-1 ;
-	h=y+h-1 ;
-	if(src1_gen_cfg->clipx_start != x || src1_gen_cfg->clipx_end   != w||
-			src1_gen_cfg->clipy_start != y ||src1_gen_cfg->clipy_end   != h)
-	{
-    		src1_gen_cfg->clipx_start = x;
-    		src1_gen_cfg->clipx_end   = w;
-    		src1_gen_cfg->clipy_start = y;
-    		src1_gen_cfg->clipy_end   = h;
-		wq->config.update_flag |= UPDATE_SRC_GEN;	
-	}
-}
-
-void ge2dgen_src2_clip(ge2d_context_t *wq,
-                      int x, int y, int w, int h)
-{
-    	ge2d_src2_dst_gen_t *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
-
-	//adjust w->x_end h->y_end
-	w=x+w-1 ;
-	h=y+h-1 ;
-	if(src2_dst_gen_cfg->src2_clipx_start != x || src2_dst_gen_cfg->src2_clipx_end   != w ||
-			src2_dst_gen_cfg->src2_clipy_start != y || src2_dst_gen_cfg->src2_clipy_end   != h)
-	{
-    		src2_dst_gen_cfg->src2_clipx_start = x;
-    		src2_dst_gen_cfg->src2_clipx_end   = w;
-    		src2_dst_gen_cfg->src2_clipy_start = y;
-    		src2_dst_gen_cfg->src2_clipy_end   = h;
-		wq->config.update_flag |= UPDATE_DST_GEN;
-	}
-}
-
-void ge2dgen_src_key(ge2d_context_t *wq,
-                     int en, int key, int keymask,int keymode)
-{
-    	ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
-	if(dp_gen_cfg->src1_key_en != en || dp_gen_cfg->src1_key != key || dp_gen_cfg->src1_key_mask != keymask ||
-		dp_gen_cfg->src1_key_mode != keymode)      
-	{
-    		dp_gen_cfg->src1_key_en = en&0x1;
-    		dp_gen_cfg->src1_key = key;
-    		dp_gen_cfg->src1_key_mask = keymask;
-		dp_gen_cfg->src1_key_mode=keymode&0x1;	
-
-		dp_gen_cfg->src1_vsc_bank_length = 4;
-    		dp_gen_cfg->src1_hsc_bank_length = 4;
-		wq->config.update_flag |= UPDATE_DP_GEN;	
-	}
-}
-EXPORT_SYMBOL(ge2dgen_src_key);
-void ge2dgent_src_gbalpha(ge2d_context_t *wq,
-                          unsigned char alpha)
-{
-    	ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
-	if(dp_gen_cfg->src1_gb_alpha != alpha)
-	{
-    		dp_gen_cfg->src1_gb_alpha = alpha;
-		wq->config.update_flag |= UPDATE_DP_GEN;
-	}
-}
-
-void ge2dgen_src_color(ge2d_context_t *wq,
-                       unsigned color)
-{
-    	ge2d_src1_data_t *src1_data_cfg = ge2d_wq_get_src_data(wq);
-
-    	if(src1_data_cfg->def_color != color)	
-    	{
-    		src1_data_cfg->def_color = color;
-    		wq->config.update_flag |= UPDATE_SRC_DATA;	
-    	}
-
-}
-
-void ge2dgen_rendering_dir(ge2d_context_t *wq,
-                           int src_x_dir, int src_y_dir,
-                           int dst_x_dir, int dst_y_dir,
-                           int dst_xy_swap)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-
-    ge2d_cmd_cfg->src1_x_rev = src_x_dir;
-    ge2d_cmd_cfg->src1_y_rev = src_y_dir;
-    ge2d_cmd_cfg->dst_x_rev  = dst_x_dir;
-    ge2d_cmd_cfg->dst_y_rev  = dst_y_dir;
-    ge2d_cmd_cfg->dst_xy_swap  =  dst_xy_swap;
-}
-
-void ge2dgen_dst_clip(ge2d_context_t *wq,
-                      int x, int y, int w, int h, int mode)
-{
-    	ge2d_src2_dst_gen_t *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
-	//adjust w->x_end h->y_end
-	w=x+w-1 ;
-	h=y+h-1 ;
-	if(src2_dst_gen_cfg->dst_clipx_start != x || src2_dst_gen_cfg->dst_clipx_end   != w||
-		src2_dst_gen_cfg->dst_clipy_start != y || src2_dst_gen_cfg->dst_clipy_end   != h ||
-		src2_dst_gen_cfg->dst_clip_mode   != mode)
-	{
-    		src2_dst_gen_cfg->dst_clipx_start = x;
-    		src2_dst_gen_cfg->dst_clipx_end   = w;
-    		src2_dst_gen_cfg->dst_clipy_start = y;
-    		src2_dst_gen_cfg->dst_clipy_end   = h;
-    		src2_dst_gen_cfg->dst_clip_mode   = mode;
-		wq->config.update_flag |= UPDATE_DST_GEN;	
-	}
-}
-
-void ge2dgent_src2_clip(ge2d_context_t *wq,
-                        int x, int y, int w, int h)
-{
-    	ge2d_src2_dst_gen_t *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
-	//adjust w->x_end h->y_end
-	w=x+w-1 ;
-	h=y+h-1 ;
-	if(src2_dst_gen_cfg->src2_clipx_start != x||src2_dst_gen_cfg->src2_clipx_end   != w||
-		src2_dst_gen_cfg->src2_clipy_start != y || src2_dst_gen_cfg->src2_clipy_end   != h)
-	{
-    		src2_dst_gen_cfg->src2_clipx_start = x;
-    		src2_dst_gen_cfg->src2_clipx_end   = w;
-    		src2_dst_gen_cfg->src2_clipy_start = y;
-    		src2_dst_gen_cfg->src2_clipy_end   = h;
-		wq->config.update_flag |= UPDATE_DST_GEN;
-	}
-}
-
-void ge2dgen_const_color(ge2d_context_t *wq,
-                       unsigned color)
-{
-    	ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
-	if(dp_gen_cfg->alu_const_color != color)
-	{
-    		dp_gen_cfg->alu_const_color = color;
-		wq->config.update_flag |= UPDATE_DP_GEN;	
-	}
-}
+#include <linux/amlogic/ge2d/ge2d.h>
+
+static inline void _set_src1_format(ge2d_src1_data_t *src1_data_cfg,
+                                     ge2d_src1_gen_t *src1_gen_cfg,
+                                     ge2d_dp_gen_t *dp_gen_cfg,
+                                     unsigned format_src,
+                                     unsigned format_dst)
+{
+    src1_data_cfg->format_all  = format_src;
+
+    src1_data_cfg->format      = (format_src >> 8) & 3;
+    src1_data_cfg->mode_8b_sel = (format_src >> 6) & 3;
+    src1_data_cfg->lut_en      = (format_src >> 5) & 1;
+    src1_data_cfg->sep_en      = (format_src >> 2) & 1;
+
+	src1_data_cfg->endian      = (format_src & GE2D_ENDIAN_MASK) >> GE2D_ENDIAN_SHIFT;
+	src1_data_cfg->color_map   = (format_src & GE2D_COLOR_MAP_MASK) >> GE2D_COLOR_MAP_SHIFT;
+
+
+    src1_gen_cfg->pic_struct   = (format_src >> 3) & 3;
+    src1_data_cfg->x_yc_ratio  = (format_src >> 1) & 1;
+    src1_data_cfg->y_yc_ratio  = (format_src >> 0) & 1;
+
+    if ((format_src & GE2D_FORMAT_YUV) &&
+        ((format_dst & GE2D_FORMAT_YUV) == 0)) {
+        dp_gen_cfg->use_matrix_default = (format_src & GE2D_FORMAT_COMP_RANGE) ? MATRIX_FULL_RANGE_YCC_TO_RGB : MATRIX_YCC_TO_RGB;
+        dp_gen_cfg->conv_matrix_en = 1;
+    }
+    else if (((format_src & GE2D_FORMAT_YUV) == 0) &&
+             (format_dst & GE2D_FORMAT_YUV)) {
+        dp_gen_cfg->use_matrix_default = MATRIX_RGB_TO_YCC;
+        dp_gen_cfg->conv_matrix_en = 1;
+    }
+    else {
+        dp_gen_cfg->conv_matrix_en = 0;
+    }
+}
+
+static inline void _set_src2_format(ge2d_src2_dst_data_t *src2_dst_data_cfg,
+                             ge2d_src2_dst_gen_t *src2_dst_gen_cfg,
+                             unsigned format)
+{
+    src2_dst_data_cfg->src2_format_all  = format;
+
+    src2_dst_data_cfg->src2_format      = (format >> 8) & 3;
+	src2_dst_data_cfg->src2_endian      = (format & GE2D_ENDIAN_MASK) >> GE2D_ENDIAN_SHIFT;
+	src2_dst_data_cfg->src2_color_map   = (format & GE2D_COLOR_MAP_MASK) >> GE2D_COLOR_MAP_SHIFT;
+
+    src2_dst_data_cfg->src2_mode_8b_sel = (format >> 6) & 3;
+
+    src2_dst_gen_cfg->src2_pic_struct   = (format >> 3) & 3;
+}
+
+static inline void _set_dst_format(ge2d_src2_dst_data_t *src2_dst_data_cfg,
+                             ge2d_src2_dst_gen_t *src2_dst_gen_cfg,
+                             ge2d_dp_gen_t *dp_gen_cfg,
+                             unsigned format_src,
+                             unsigned format_dst)
+{
+	src2_dst_data_cfg->dst_format_all  = format_dst;
+
+	src2_dst_data_cfg->dst_format      = (format_dst >> 8) & 3;
+
+	src2_dst_data_cfg->dst_endian      = (format_dst & GE2D_ENDIAN_MASK) >> GE2D_ENDIAN_SHIFT;
+	src2_dst_data_cfg->dst_color_map   = (format_dst & GE2D_COLOR_MAP_MASK) >> GE2D_COLOR_MAP_SHIFT;
+
+	src2_dst_data_cfg->dst_mode_8b_sel = (format_dst >> 6) & 3;
+
+	src2_dst_gen_cfg->dst_pic_struct   = (format_dst >> 3) & 3;
+
+	if ((format_src & GE2D_FORMAT_YUV) &&
+				((format_dst & GE2D_FORMAT_YUV) == 0)) {
+		dp_gen_cfg->use_matrix_default = (format_src & GE2D_FORMAT_COMP_RANGE) ? MATRIX_FULL_RANGE_YCC_TO_RGB : MATRIX_YCC_TO_RGB;
+		dp_gen_cfg->conv_matrix_en = 1;
+	}
+	else if (((format_src & GE2D_FORMAT_YUV) == 0) &&
+			(format_dst & GE2D_FORMAT_YUV)) {
+		dp_gen_cfg->use_matrix_default = MATRIX_RGB_TO_YCC;
+		dp_gen_cfg->conv_matrix_en = 1;
+	}
+	else {
+		dp_gen_cfg->conv_matrix_en = 0;
+	}
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
+	/* for dest is nv21 or nv12 in m6. */
+	if((format_dst & GE2D_FORMAT_YUV) && ((src2_dst_data_cfg->dst_color_map|1)==15)) {
+		src2_dst_data_cfg->dst_format = 0;
+		src2_dst_data_cfg->dst_mode_8b_sel = 0;
+		src2_dst_data_cfg->dst2_pixel_byte_width = 1;
+		src2_dst_data_cfg->dst2_discard_mode = 0xf;
+		src2_dst_data_cfg->dst2_enable = 1;
+		src2_dst_data_cfg->dst2_color_map = src2_dst_data_cfg->dst_color_map - 5;
+	} else
+		src2_dst_data_cfg->dst2_enable = 0;
+#endif
+}
+void ge2dgen_src(ge2d_context_t *wq,
+                 unsigned canvas_addr,
+                 unsigned format)
+{
+    ge2d_src1_data_t *src1_data_cfg = ge2d_wq_get_src_data(wq);
+    ge2d_src1_gen_t *src1_gen_cfg = ge2d_wq_get_src_gen(wq);
+    ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+    ge2d_src2_dst_data_t *src2_dst_data_cfg = ge2d_wq_get_dst_data(wq);
+
+    if ((format != src1_data_cfg->format_all) ||
+        (canvas_addr != src1_data_cfg->canaddr)) {
+        src1_data_cfg->canaddr = canvas_addr;
+
+        _set_src1_format(src1_data_cfg, src1_gen_cfg, dp_gen_cfg,
+            format, src2_dst_data_cfg->dst_format_all);
+	  wq->config.update_flag |= UPDATE_SRC_DATA;
+	  wq->config.update_flag |= UPDATE_SRC_GEN;
+	  wq->config.update_flag |= UPDATE_DP_GEN;
+    }
+}
+
+void ge2dgen_antiflicker(ge2d_context_t *wq,unsigned long enable)
+{
+	ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+
+	enable = enable?1:0;
+
+	if(dp_gen_cfg->antiflick_en != enable)
+	{
+		dp_gen_cfg->antiflick_en=enable;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+}
+void ge2dgen_post_release_src1buf(ge2d_context_t *wq, unsigned buffer)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+    ge2d_cmd_cfg->src1_buffer = buffer;
+    ge2d_cmd_cfg->release_flag |= RELEASE_SRC1_BUFFER;
+}
+
+void ge2dgen_post_release_src1canvas(ge2d_context_t *wq)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+    ge2d_cmd_cfg->release_flag |= RELEASE_SRC1_CANVAS;
+}
+
+void ge2dgen_post_release_src2buf(ge2d_context_t *wq, unsigned buffer)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+    ge2d_cmd_cfg->src2_buffer = buffer;
+    ge2d_cmd_cfg->release_flag |= RELEASE_SRC2_BUFFER;
+}
+
+void ge2dgen_post_release_src2canvas(ge2d_context_t *wq)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+    ge2d_cmd_cfg->release_flag |= RELEASE_SRC2_CANVAS;
+}
+
+void ge2dgen_cb(ge2d_context_t *wq, int (*cmd_cb)(unsigned), unsigned param)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+    ge2d_cmd_cfg->cmd_cb = cmd_cb;
+    ge2d_cmd_cfg->cmd_cb_param = param;
+    ge2d_cmd_cfg->release_flag |= RELEASE_CB;
+}
+
+void ge2dgen_src2(ge2d_context_t *wq,
+                  unsigned canvas_addr,
+                  unsigned format)
+{
+    ge2d_src2_dst_data_t *src2_dst_data_cfg = ge2d_wq_get_dst_data(wq);
+    ge2d_src2_dst_gen_t *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
+
+    if ((format != src2_dst_data_cfg->src2_format_all) ||
+        (canvas_addr != src2_dst_data_cfg->src2_canaddr)) {
+
+        src2_dst_data_cfg->src2_canaddr = canvas_addr;
+
+        _set_src2_format(src2_dst_data_cfg, src2_dst_gen_cfg, format);
+	 wq->config.update_flag |= UPDATE_DST_DATA;
+	 wq->config.update_flag |= UPDATE_DST_GEN;
+    }
+}
+
+void ge2dgen_dst(ge2d_context_t *wq,
+                 unsigned canvas_addr,
+                 unsigned format)
+{
+    ge2d_src1_data_t *src1_data_cfg = ge2d_wq_get_src_data(wq);
+    ge2d_src2_dst_data_t *src2_dst_data_cfg = ge2d_wq_get_dst_data(wq);
+    ge2d_src2_dst_gen_t *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
+    ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+
+    if ((format != src2_dst_data_cfg->dst_format_all) ||
+        (canvas_addr != src2_dst_data_cfg->dst_canaddr)) {
+        src2_dst_data_cfg->dst_canaddr = canvas_addr;
+
+	_set_dst_format(src2_dst_data_cfg, src2_dst_gen_cfg, dp_gen_cfg,
+            src1_data_cfg->format_all, format);
+	wq->config.update_flag |= UPDATE_DST_DATA;
+	wq->config.update_flag |= UPDATE_DST_GEN;
+	wq->config.update_flag |= UPDATE_DP_GEN;
+    }
+}
+
+void ge2dgen_src_clip(ge2d_context_t *wq,
+                      int x, int y, int w, int h)
+{
+	ge2d_src1_gen_t *src1_gen_cfg = ge2d_wq_get_src_gen(wq);
+	//adjust w->x_end h->y_end
+	w=x+w-1 ;
+	h=y+h-1 ;
+	if(src1_gen_cfg->clipx_start != x || src1_gen_cfg->clipx_end   != w||
+			src1_gen_cfg->clipy_start != y ||src1_gen_cfg->clipy_end   != h)
+	{
+		src1_gen_cfg->clipx_start = x;
+		src1_gen_cfg->clipx_end   = w;
+		src1_gen_cfg->clipy_start = y;
+		src1_gen_cfg->clipy_end   = h;
+		wq->config.update_flag |= UPDATE_SRC_GEN;
+	}
+}
+
+void ge2dgen_src2_clip(ge2d_context_t *wq,
+                      int x, int y, int w, int h)
+{
+	ge2d_src2_dst_gen_t *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
+
+	//adjust w->x_end h->y_end
+	w=x+w-1 ;
+	h=y+h-1 ;
+	if(src2_dst_gen_cfg->src2_clipx_start != x || src2_dst_gen_cfg->src2_clipx_end   != w ||
+			src2_dst_gen_cfg->src2_clipy_start != y || src2_dst_gen_cfg->src2_clipy_end   != h)
+	{
+		src2_dst_gen_cfg->src2_clipx_start = x;
+		src2_dst_gen_cfg->src2_clipx_end   = w;
+		src2_dst_gen_cfg->src2_clipy_start = y;
+		src2_dst_gen_cfg->src2_clipy_end   = h;
+		wq->config.update_flag |= UPDATE_DST_GEN;
+	}
+}
+
+void ge2dgen_src_key(ge2d_context_t *wq,
+                     int en, int key, int keymask,int keymode)
+{
+	ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+	if(dp_gen_cfg->src1_key_en != en || dp_gen_cfg->src1_key != key || dp_gen_cfg->src1_key_mask != keymask ||
+		dp_gen_cfg->src1_key_mode != keymode)
+	{
+		dp_gen_cfg->src1_key_en = en&0x1;
+		dp_gen_cfg->src1_key = key;
+		dp_gen_cfg->src1_key_mask = keymask;
+		dp_gen_cfg->src1_key_mode=keymode&0x1;
+
+		dp_gen_cfg->src1_vsc_bank_length = 4;
+		dp_gen_cfg->src1_hsc_bank_length = 4;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+}
+EXPORT_SYMBOL(ge2dgen_src_key);
+void ge2dgent_src_gbalpha(ge2d_context_t *wq,
+                          unsigned char alpha)
+{
+	ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+	if(dp_gen_cfg->src1_gb_alpha != alpha)
+	{
+		dp_gen_cfg->src1_gb_alpha = alpha;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+}
+
+void ge2dgen_src_color(ge2d_context_t *wq,
+                       unsigned color)
+{
+	ge2d_src1_data_t *src1_data_cfg = ge2d_wq_get_src_data(wq);
+
+	if(src1_data_cfg->def_color != color)
+	{
+		src1_data_cfg->def_color = color;
+		wq->config.update_flag |= UPDATE_SRC_DATA;
+	}
+
+}
+
+void ge2dgen_rendering_dir(ge2d_context_t *wq,
+                           int src_x_dir, int src_y_dir,
+                           int dst_x_dir, int dst_y_dir,
+                           int dst_xy_swap)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+    ge2d_cmd_cfg->src1_x_rev = src_x_dir;
+    ge2d_cmd_cfg->src1_y_rev = src_y_dir;
+    ge2d_cmd_cfg->dst_x_rev  = dst_x_dir;
+    ge2d_cmd_cfg->dst_y_rev  = dst_y_dir;
+    ge2d_cmd_cfg->dst_xy_swap  =  dst_xy_swap;
+}
+
+void ge2dgen_dst_clip(ge2d_context_t *wq,
+                      int x, int y, int w, int h, int mode)
+{
+	ge2d_src2_dst_gen_t *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
+	//adjust w->x_end h->y_end
+	w=x+w-1 ;
+	h=y+h-1 ;
+	if(src2_dst_gen_cfg->dst_clipx_start != x || src2_dst_gen_cfg->dst_clipx_end   != w||
+		src2_dst_gen_cfg->dst_clipy_start != y || src2_dst_gen_cfg->dst_clipy_end   != h ||
+		src2_dst_gen_cfg->dst_clip_mode   != mode)
+	{
+		src2_dst_gen_cfg->dst_clipx_start = x;
+		src2_dst_gen_cfg->dst_clipx_end   = w;
+		src2_dst_gen_cfg->dst_clipy_start = y;
+		src2_dst_gen_cfg->dst_clipy_end   = h;
+		src2_dst_gen_cfg->dst_clip_mode   = mode;
+		wq->config.update_flag |= UPDATE_DST_GEN;
+	}
+}
+
+void ge2dgent_src2_clip(ge2d_context_t *wq,
+                        int x, int y, int w, int h)
+{
+	ge2d_src2_dst_gen_t *src2_dst_gen_cfg = ge2d_wq_get_dst_gen(wq);
+	//adjust w->x_end h->y_end
+	w=x+w-1 ;
+	h=y+h-1 ;
+	if(src2_dst_gen_cfg->src2_clipx_start != x||src2_dst_gen_cfg->src2_clipx_end   != w||
+		src2_dst_gen_cfg->src2_clipy_start != y || src2_dst_gen_cfg->src2_clipy_end   != h)
+	{
+		src2_dst_gen_cfg->src2_clipx_start = x;
+		src2_dst_gen_cfg->src2_clipx_end   = w;
+		src2_dst_gen_cfg->src2_clipy_start = y;
+		src2_dst_gen_cfg->src2_clipy_end   = h;
+		wq->config.update_flag |= UPDATE_DST_GEN;
+	}
+}
+
+void ge2dgen_const_color(ge2d_context_t *wq,
+                       unsigned color)
+{
+	ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+	if(dp_gen_cfg->alu_const_color != color)
+	{
+		dp_gen_cfg->alu_const_color = color;
+		wq->config.update_flag |= UPDATE_DP_GEN;
+	}
+}
diff --git a/drivers/amlogic/display/ge2d/stretchblt.c b/drivers/amlogic/display/ge2d/stretchblt.c
old mode 100644
new mode 100755
index 431d6f1f..de2d4c78
--- a/drivers/amlogic/display/ge2d/stretchblt.c
+++ b/drivers/amlogic/display/ge2d/stretchblt.c
@@ -1,108 +1,108 @@
-#include <linux/amlogic/ge2d/ge2d.h>
-
-static inline void _stretchblt(ge2d_context_t *wq,
-                int src_x, int src_y, int src_w, int src_h,
-                int dst_x, int dst_y, int dst_w, int dst_h, int block)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-            
-    ge2d_cmd_cfg->src1_x_start = src_x;
-    ge2d_cmd_cfg->src1_x_end   = src_x+src_w-1;
-    ge2d_cmd_cfg->src1_y_start = src_y;
-    ge2d_cmd_cfg->src1_y_end   = src_y+src_h-1;
-
-    ge2d_cmd_cfg->dst_x_start  = dst_x;
-    ge2d_cmd_cfg->dst_x_end    = dst_x+dst_w-1;
-    ge2d_cmd_cfg->dst_y_start  = dst_y;
-    ge2d_cmd_cfg->dst_y_end    = dst_y+dst_h-1;
-
-    ge2d_cmd_cfg->sc_hsc_en = 1;
-    ge2d_cmd_cfg->sc_vsc_en = 1;
-    ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
-    ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
-    ge2d_cmd_cfg->hsc_div_en = 1; 
-    
-    ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
-    ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;  
-    ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
-    ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_COPY; 
-    ge2d_cmd_cfg->wait_done_flag   = block;
-
-    ge2d_wq_add_work(wq);
-}
-
-void stretchblt(ge2d_context_t *wq,
-                int src_x, int src_y, int src_w, int src_h,
-                int dst_x, int dst_y, int dst_w, int dst_h)
-{
-    _stretchblt(wq,
-                src_x, src_y, src_w, src_h,
-                dst_x, dst_y, dst_w, dst_h, 1);
-}
-EXPORT_SYMBOL(stretchblt);
-void stretchblt_noblk(ge2d_context_t *wq,
-                int src_x, int src_y, int src_w, int src_h,
-                int dst_x, int dst_y, int dst_w, int dst_h)
-{
-    _stretchblt(wq,
-                src_x, src_y, src_w, src_h,
-                dst_x, dst_y, dst_w, dst_h, 0);
-}
-
-static inline void _stretchblt_noalpha(ge2d_context_t *wq,
-                        int src_x, int src_y, int src_w, int src_h,
-                        int dst_x, int dst_y, int dst_w, int dst_h, int blk)
-{
-    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
-    ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
-
-    if( dp_gen_cfg->alu_const_color != 0xff)	
-    {
-    	dp_gen_cfg->alu_const_color = 0xff;
-	wq->config.update_flag |= UPDATE_DP_GEN;		
-    }
-
-    
-            
-    ge2d_cmd_cfg->src1_x_start = src_x;
-    ge2d_cmd_cfg->src1_x_end   = src_x+src_w-1;
-    ge2d_cmd_cfg->src1_y_start = src_y;
-    ge2d_cmd_cfg->src1_y_end   = src_y+src_h-1;
-
-    ge2d_cmd_cfg->dst_x_start  = dst_x;
-    ge2d_cmd_cfg->dst_x_end    = dst_x+dst_w-1;
-    ge2d_cmd_cfg->dst_y_start  = dst_y;
-    ge2d_cmd_cfg->dst_y_end    = dst_y+dst_h-1;
-
-    ge2d_cmd_cfg->sc_hsc_en = 1;
-    ge2d_cmd_cfg->sc_vsc_en = 1;
-    ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
-    ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
-    ge2d_cmd_cfg->hsc_div_en = 1; 
-    
-    ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
-    ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;  
-    ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
-    ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_SET; 
-    ge2d_cmd_cfg->wait_done_flag   = 1;
-
-    ge2d_wq_add_work(wq);
-}
-
-void stretchblt_noalpha(ge2d_context_t *wq,
-                        int src_x, int src_y, int src_w, int src_h,
-                        int dst_x, int dst_y, int dst_w, int dst_h)
-{
-    _stretchblt_noalpha(wq,
-                        src_x, src_y, src_w, src_h,
-                        dst_x, dst_y, dst_w, dst_h, 1);
-}
-
-void stretchblt_noalpha_noblk(ge2d_context_t *wq,
-                        int src_x, int src_y, int src_w, int src_h,
-                        int dst_x, int dst_y, int dst_w, int dst_h)
-{
-    _stretchblt_noalpha(wq,
-                        src_x, src_y, src_w, src_h,
-                        dst_x, dst_y, dst_w, dst_h, 0);
-}
+#include <linux/amlogic/ge2d/ge2d.h>
+
+static inline void _stretchblt(ge2d_context_t *wq,
+                int src_x, int src_y, int src_w, int src_h,
+                int dst_x, int dst_y, int dst_w, int dst_h, int block)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+
+    ge2d_cmd_cfg->src1_x_start = src_x;
+    ge2d_cmd_cfg->src1_x_end   = src_x+src_w-1;
+    ge2d_cmd_cfg->src1_y_start = src_y;
+    ge2d_cmd_cfg->src1_y_end   = src_y+src_h-1;
+
+    ge2d_cmd_cfg->dst_x_start  = dst_x;
+    ge2d_cmd_cfg->dst_x_end    = dst_x+dst_w-1;
+    ge2d_cmd_cfg->dst_y_start  = dst_y;
+    ge2d_cmd_cfg->dst_y_end    = dst_y+dst_h-1;
+
+    ge2d_cmd_cfg->sc_hsc_en = 1;
+    ge2d_cmd_cfg->sc_vsc_en = 1;
+    ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+    ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+    ge2d_cmd_cfg->hsc_div_en = 1;
+
+    ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+    ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;
+    ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+    ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_COPY;
+    ge2d_cmd_cfg->wait_done_flag   = block;
+
+    ge2d_wq_add_work(wq);
+}
+
+void stretchblt(ge2d_context_t *wq,
+                int src_x, int src_y, int src_w, int src_h,
+                int dst_x, int dst_y, int dst_w, int dst_h)
+{
+    _stretchblt(wq,
+                src_x, src_y, src_w, src_h,
+                dst_x, dst_y, dst_w, dst_h, 1);
+}
+EXPORT_SYMBOL(stretchblt);
+void stretchblt_noblk(ge2d_context_t *wq,
+                int src_x, int src_y, int src_w, int src_h,
+                int dst_x, int dst_y, int dst_w, int dst_h)
+{
+    _stretchblt(wq,
+                src_x, src_y, src_w, src_h,
+                dst_x, dst_y, dst_w, dst_h, 0);
+}
+
+static inline void _stretchblt_noalpha(ge2d_context_t *wq,
+                        int src_x, int src_y, int src_w, int src_h,
+                        int dst_x, int dst_y, int dst_w, int dst_h, int blk)
+{
+    ge2d_cmd_t *ge2d_cmd_cfg = ge2d_wq_get_cmd(wq);
+    ge2d_dp_gen_t *dp_gen_cfg = ge2d_wq_get_dp_gen(wq);
+
+    if( dp_gen_cfg->alu_const_color != 0xff)
+    {
+	dp_gen_cfg->alu_const_color = 0xff;
+	wq->config.update_flag |= UPDATE_DP_GEN;
+    }
+
+
+
+    ge2d_cmd_cfg->src1_x_start = src_x;
+    ge2d_cmd_cfg->src1_x_end   = src_x+src_w-1;
+    ge2d_cmd_cfg->src1_y_start = src_y;
+    ge2d_cmd_cfg->src1_y_end   = src_y+src_h-1;
+
+    ge2d_cmd_cfg->dst_x_start  = dst_x;
+    ge2d_cmd_cfg->dst_x_end    = dst_x+dst_w-1;
+    ge2d_cmd_cfg->dst_y_start  = dst_y;
+    ge2d_cmd_cfg->dst_y_end    = dst_y+dst_h-1;
+
+    ge2d_cmd_cfg->sc_hsc_en = 1;
+    ge2d_cmd_cfg->sc_vsc_en = 1;
+    ge2d_cmd_cfg->hsc_rpt_p0_num = 1;
+    ge2d_cmd_cfg->vsc_rpt_l0_num = 1;
+    ge2d_cmd_cfg->hsc_div_en = 1;
+
+    ge2d_cmd_cfg->color_blend_mode = OPERATION_LOGIC;
+    ge2d_cmd_cfg->color_logic_op   = LOGIC_OPERATION_COPY;
+    ge2d_cmd_cfg->alpha_blend_mode = OPERATION_LOGIC;
+    ge2d_cmd_cfg->alpha_logic_op   = LOGIC_OPERATION_SET;
+    ge2d_cmd_cfg->wait_done_flag   = 1;
+
+    ge2d_wq_add_work(wq);
+}
+
+void stretchblt_noalpha(ge2d_context_t *wq,
+                        int src_x, int src_y, int src_w, int src_h,
+                        int dst_x, int dst_y, int dst_w, int dst_h)
+{
+    _stretchblt_noalpha(wq,
+                        src_x, src_y, src_w, src_h,
+                        dst_x, dst_y, dst_w, dst_h, 1);
+}
+
+void stretchblt_noalpha_noblk(ge2d_context_t *wq,
+                        int src_x, int src_y, int src_w, int src_h,
+                        int dst_x, int dst_y, int dst_w, int dst_h)
+{
+    _stretchblt_noalpha(wq,
+                        src_x, src_y, src_w, src_h,
+                        dst_x, dst_y, dst_w, dst_h, 0);
+}
diff --git a/drivers/amlogic/display/lcd/Kconfig b/drivers/amlogic/display/lcd/Kconfig
index 7e3ff3a2..acc8b79d 100755
--- a/drivers/amlogic/display/lcd/Kconfig
+++ b/drivers/amlogic/display/lcd/Kconfig
@@ -11,4 +11,12 @@ config AML_TV_LCD
 	  Enable this to choose the drivers for controlling the
 	  the LCD panel on TV.
 
+config AML_TV_LCD_V2
+	bool "Amlogic TV LCD Driver V2"
+	default n
+	help
+	  Enable this to choose the drivers for controlling the
+	  the LCD panel on TV.
+
+
 endmenu
diff --git a/drivers/amlogic/display/lcd/Makefile b/drivers/amlogic/display/lcd/Makefile
index 656d56f9..69299983 100755
--- a/drivers/amlogic/display/lcd/Makefile
+++ b/drivers/amlogic/display/lcd/Makefile
@@ -3,4 +3,4 @@
 #
 
 obj-$(CONFIG_AML_TV_LCD)		+= aml_lcd.o
-
+obj-$(CONFIG_AML_TV_LCD_V2)		+= aml_lcd_v2.o
diff --git a/drivers/amlogic/display/lcd/aml_lcd.c b/drivers/amlogic/display/lcd/aml_lcd.c
old mode 100644
new mode 100755
index d944e756..b4c08a05
--- a/drivers/amlogic/display/lcd/aml_lcd.c
+++ b/drivers/amlogic/display/lcd/aml_lcd.c
@@ -1131,7 +1131,7 @@ static void venc_set_lvds(Lcd_Config_t *pConf)
 	aml_write_reg32(P_ENCL_VIDEO_MODE_ADV,     0x0418); // Sampling rate: 1
 
 	// bypass filter
- 	aml_write_reg32(P_ENCL_VIDEO_FILT_CTRL	,0x1000);
+	aml_write_reg32(P_ENCL_VIDEO_FILT_CTRL	,0x1000);
 
 	aml_write_reg32(P_ENCL_VIDEO_MAX_PXCNT,	pConf->lcd_basic.h_period - 1);
 if(cur_lvds_index)
@@ -1179,7 +1179,7 @@ static void venc_set_mlvds(Lcd_Config_t *pConf)
 	aml_write_reg32(P_ENCL_VIDEO_MODE_ADV,         0x0008); // Sampling rate: 1
 
 	// bypass filter
- 	aml_write_reg32(P_ENCL_VIDEO_FILT_CTRL,	0x1000);
+	aml_write_reg32(P_ENCL_VIDEO_FILT_CTRL,	0x1000);
 
 	aml_write_reg32(P_ENCL_VIDEO_YFP1_HTIME,       active_h_start);
 	aml_write_reg32(P_ENCL_VIDEO_YFP2_HTIME,       active_h_start + width);
@@ -1229,7 +1229,7 @@ static void set_control_lvds(Lcd_Config_t *pConf)
 	if(port_reverse_flag)
 	port_reverse = (pConf->lvds_mlvds_config.lvds_config->port_reverse) & 0x1;
     if(bit_num_flag)
-    	{
+	{
 		switch(pConf->lcd_basic.lcd_bits)
 			{
 			case 10:
@@ -1248,7 +1248,7 @@ static void set_control_lvds(Lcd_Config_t *pConf)
 				bit_num=1;
 				break;
 			}
-    	}
+	}
 	aml_write_reg32(P_MLVDS_CONTROL,  (aml_read_reg32(P_MLVDS_CONTROL) & ~(1 << 0)));  //disable mlvds
 
 	aml_write_reg32(P_LVDS_PACK_CNTL_ADDR,
@@ -1415,10 +1415,10 @@ static inline void _init_display_driver(Lcd_Config_t *pConf)
 			set_tcon_ttl(pConf);
             break;
         case LCD_DIGITAL_LVDS:
-        	set_pll_lvds(pConf);
+		set_pll_lvds(pConf);
             venc_set_lvds(pConf);
-        	set_control_lvds(pConf);
-        	init_lvds_phy(pConf);
+		set_control_lvds(pConf);
+		init_lvds_phy(pConf);
 			set_tcon_lvds(pConf);
             break;
         case LCD_DIGITAL_MINILVDS:
@@ -1518,15 +1518,15 @@ static void _lcd_module_enable(void)
 static const vinfo_t *lcd_get_current_info(void)
 {
     if(cur_lvds_index)
-    	{
-    	pDev->lcd_info.name = "lvds1080p50hz";
+	{
+	pDev->lcd_info.name = "lvds1080p50hz";
 		pDev->lcd_info.mode = VMODE_LVDS_1080P_50HZ;
 		pDev->lcd_info.sync_duration_num = 50;
 		pDev->lcd_info.sync_duration_den = 1;
-    	}
+	}
 	else
 		{
-    	pDev->lcd_info.name = "lvds1080p";
+	pDev->lcd_info.name = "lvds1080p";
 		pDev->lcd_info.mode = VMODE_LVDS_1080P;
 		pDev->lcd_info.sync_duration_num = 60;
 		pDev->lcd_info.sync_duration_den = 1;
@@ -1580,8 +1580,11 @@ static int lcd_module_disable(vmode_t cur_vmod)
     return 0;
 }
 #ifdef  CONFIG_PM
-static int lcd_suspend(void)
+static int lcd_suspend(int pm_event)
 {
+    /* in freeze process do not turn off the display devices */
+    if (pm_event == PM_EVENT_FREEZE)
+        return 0;
     BUG_ON(pDev==NULL);
     PRINT_INFO("lcd_suspend \n");
     //_disable_backlight();
@@ -1597,9 +1600,13 @@ static int lcd_suspend(void)
    // panel_power_off();
     return 0;
 }
-static int lcd_resume(void)
+static int lcd_resume(int pm_event)
 {
     PRINT_INFO("lcd_resume\n");
+    /* in thaw/restore process do not reset the display mode */
+    if (pm_event == PM_EVENT_THAW
+            || pm_event == PM_EVENT_RESTORE)
+        return 0;
 
     //panel_power_on();
    // mdelay(panel_power_on_delay);
diff --git a/drivers/amlogic/display/lcd/aml_lcd_v2.c b/drivers/amlogic/display/lcd/aml_lcd_v2.c
new file mode 100644
index 00000000..bb2b4113
--- /dev/null
+++ b/drivers/amlogic/display/lcd/aml_lcd_v2.c
@@ -0,0 +1,1583 @@
+/*
+ * Amlogic LCD Driver
+ *
+ * Author:
+ *
+ * Copyright (C) 2012 Amlogic Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/amlogic/vout/lcd.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/amlogic/vout/lcd_aml.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <mach/am_regs.h>
+#include <mach/mlvds_regs.h>
+#include <mach/clock.h>
+#include <asm/fiq.h>
+#include <linux/delay.h>
+#include <plat/regops.h>
+#include <mach/am_regs.h>
+#include <mach/hw_enc_clk_config.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/gpio.h>
+#include <linux/amlogic/panel.h>
+#include <linux/of.h>
+
+static struct class *aml_lcd_clsp;
+
+#define PANEL_NAME	"panel"
+
+#define CLOCK_ENABLE_DELAY			500
+#define CLOCK_DISABLE_DELAY			50
+#define PWM_ENABLE_DELAY			20
+#define PWM_DISABLE_DELAY			20
+#define PANEL_POWER_ON_DELAY		50
+#define PANEL_POWER_OFF_DELAY		0
+#define BACKLIGHT_POWER_ON_DELAY	0
+#define BACKLIGHT_POWER_OFF_DELAY	200
+
+#define H_ACTIVE			1920
+#define V_ACTIVE			1080
+#define H_PERIOD			2200
+#define V_PERIOD			1125
+#define VIDEO_ON_PIXEL	148
+#define VIDEO_ON_LINE	41
+#define CLK_UTIL_VID_PLL_DIV_1      0
+#define CLK_UTIL_VID_PLL_DIV_2      1
+#define CLK_UTIL_VID_PLL_DIV_3      2
+#define CLK_UTIL_VID_PLL_DIV_3p5    3
+#define CLK_UTIL_VID_PLL_DIV_3p75   4
+#define CLK_UTIL_VID_PLL_DIV_4      5
+#define CLK_UTIL_VID_PLL_DIV_5      6
+#define CLK_UTIL_VID_PLL_DIV_6      7
+#define CLK_UTIL_VID_PLL_DIV_6p25   8
+#define CLK_UTIL_VID_PLL_DIV_7      9
+#define CLK_UTIL_VID_PLL_DIV_7p5    10
+#define CLK_UTIL_VID_PLL_DIV_12     11
+#define CLK_UTIL_VID_PLL_DIV_14     12
+#define CLK_UTIL_VID_PLL_DIV_15     13
+
+/* defines for bits&width */
+#define VBO_VIN_YUV_GBR 0
+#define VBO_VIN_YVU_GRB 1
+#define VBO_VIN_UYV_BGR 2
+#define VBO_VIN_UVY_BRG 3
+#define VBO_VIN_VYU_RGB 4
+#define VBO_VIN_VUY_RBG 5
+
+#define VBO_VIN_30BPP	0
+#define VBO_VIN_24BPP   1
+#define VBO_VIN_18BPP   2
+
+//VBYONE_CTRL_L
+//`define VBO_CTRL_L             8'h60
+    #define VBO_ENABLE_BIT  0
+    #define VBO_EBABLE_WID  1
+
+    #define VBO_ALN_SHIFT_BIT     1
+    #define VBO_ALN_SHIFT_WID     1
+
+    #define VBO_LFSR_BYPASS_BIT   2
+    #define VBO_LFSR_BYPASS_WID   1
+
+    #define VBO_VDE_EXTEND_BIT    3
+    #define VBO_VDE_EXTEND_WID    1
+
+    #define VBO_HSYNC_SYNC_MODE_BIT   4
+    #define VBO_HSYNC_SYNC_MODE_WID   2
+
+    #define VBO_VSYNC_SYNC_MODE_BIT   6
+    #define VBO_VSYNC_SYNC_MODE_WID   2
+
+    #define VBO_FSM_CTRL_BIT      8
+    #define VBO_FSM_CTRL_WID      3
+
+    #define VBO_CTL_MODE_BIT      11
+    #define VBO_CTL_MODE_WID      5
+
+//`define VBO_CTRL_H             8'h61
+    #define VBO_CTL_MODE2_BIT     0
+    #define VBO_CTL_MODE2_WID     4
+
+    #define VBO_B8B10_CTRL_BIT    4
+    #define VBO_B8B10_CTRL_WID    3
+
+    #define VBO_VIN2ENC_TMSYNC_MODE_BIT 8
+    #define VBO_VIN2ENC_TMSYNC_MODE_WID 1
+
+    #define VBO_VIN2ENC_HVSYNC_DLY_BIT  9
+    #define VBO_VIN2ENC_HVSYNC_DLY_WID  1
+
+    #define VBO_POWER_ON_BIT  12
+    #define VBO_POWER_ON_WID  1
+
+    #define VBO_PLL_LOCK_BIT  13
+    #define VBO_PLL_LOCK_WID  1
+
+//`define VBO_SOFT_RST           8'h62
+   #define  VBO_SOFT_RST_BIT      0
+   #define  VBO_SOFT_RST_WID      9
+
+//`define VBO_LANES              8'h63
+   #define  VBO_LANE_NUM_BIT      0
+   #define  VBO_LANE_NUM_WID      3
+
+   #define  VBO_LANE_REGION_BIT   4
+   #define  VBO_LANE_REGION_WID   2
+
+   #define  VBO_SUBLANE_NUM_BIT   8
+   #define  VBO_SUBLANE_NUM_WID   3
+
+   #define  VBO_BYTE_MODE_BIT     11
+   #define  VBO_BYTE_MODE_WID     2
+
+//`define VBO_VIN_CTRL           8'h64
+   #define  VBO_VIN_SYNC_CTRL_BIT 0
+   #define  VBO_VIN_SYNC_CTRL_WID 2
+
+   #define  VBO_VIN_HSYNC_POL_BIT 4
+   #define  VBO_VIN_HSYNC_POL_WID 1
+
+   #define  VBO_VIN_VSYNC_POL_BIT 5
+   #define  VBO_VIN_VSYNC_POL_WID 1
+
+   #define  VBO_VOUT_HSYNC_POL_BIT 6
+   #define  VBO_VOUT_HSYNC_POL_WID 1
+
+   #define  VBO_VOUT_VSYNC_POL_BIT 7
+   #define  VBO_VOUT_VSYNC_POL_WID 1
+
+   #define  VBO_VIN_PACK_BIT      8
+   #define  VBO_VIN_PACK_WID      3
+
+   #define  VBO_VIN_BPP_BIT      11
+   #define  VBO_VIN_BPP_WID       2
+
+//`define VBO_ACT_VSIZE          8'h65
+//`define VBO_REGION_00          8'h66
+//`define VBO_REGION_01          8'h67
+//`define VBO_REGION_02          8'h68
+//`define VBO_REGION_03          8'h69
+//`define VBO_VBK_CTRL_0         8'h6a
+//`define VBO_VBK_CTRL_1         8'h6b
+//`define VBO_HBK_CTRL           8'h6c
+//`define VBO_PXL_CTRL           8'h6d
+    #define  VBO_PXL_CTR0_BIT     0
+    #define  VBO_PXL_CTR0_WID     4
+    #define  VBO_PXL_CTR1_BIT     4
+    #define  VBO_PXL_CTR1_WID     4
+
+//`define VBO_LANE_SKEW_L        8'h6e
+//`define VBO_LANE_SKEW_H        8'h6f
+//`define VBO_GCLK_LANE_CTRL_L   8'h70
+//`define VBO_GCLK_LANE_CTRL_H   8'h71
+//`define VBO_GCLK_MAIN_CTRL     8'h72
+//`define VBO_STATUS_L           8'h73
+//`define VBO_STATUS_H           8'h74
+
+//`define LCD_PORT_SWAP          8'h75
+typedef struct {
+	Lcd_Config_t conf;
+	vinfo_t lcd_info;
+} lcd_dev_t;
+static lcd_dev_t *pDev = NULL;
+
+static vmode_t cur_vmode = VMODE_1080P;
+
+static int pn_swap = 0;
+MODULE_PARM_DESC(pn_swap, "\n pn_swap \n");
+module_param(pn_swap, int, 0664);
+
+static int dual_port = 1;
+MODULE_PARM_DESC(dual_port, "\n dual_port \n");
+module_param(dual_port, int, 0664);
+
+static int bit_num_flag = 1;
+static int bit_num = 1;
+MODULE_PARM_DESC(bit_num, "\n bit_num \n");
+module_param(bit_num, int, 0664);
+
+static int lvds_repack_flag = 1;
+static int lvds_repack = 1;
+MODULE_PARM_DESC(lvds_repack, "\n lvds_repack \n");
+module_param(lvds_repack, int, 0664);
+
+static int port_reverse_flag = 1;
+static int port_reverse = 1;
+MODULE_PARM_DESC(port_reverse, "\n port_reverse \n");
+module_param(port_reverse, int, 0664);
+
+int flaga = 0;
+MODULE_PARM_DESC(flaga, "\n flaga \n");
+module_param(flaga, int, 0664);
+EXPORT_SYMBOL(flaga);
+
+int flagb = 0;
+MODULE_PARM_DESC(flagb, "\n flagb \n");
+module_param(flagb, int, 0664);
+EXPORT_SYMBOL(flagb);
+
+int flagc = 0;
+MODULE_PARM_DESC(flagc, "\n flagc \n");
+module_param(flagc, int, 0664);
+EXPORT_SYMBOL(flagc);
+
+int flagd = 0;
+MODULE_PARM_DESC(flagd, "\n flagd \n");
+module_param(flagd, int, 0664);
+EXPORT_SYMBOL(flagd);
+
+
+void vclk_set_encl_ttl(vmode_t vmode)
+{
+	int hdmi_clk_out;
+	//int hdmi_vx1_clk_od1;
+	int vx1_phy_div;
+	int encl_div;
+	unsigned int xd;
+	//no used, od2 must >= od3.
+	//hdmi_vx1_clk_od1 = 1; //OD1 always 1
+
+	//pll_video.pl 3500 pll_out
+	switch(vmode) {
+		case VMODE_720P: //total: 1650*750 pixel clk = 74.25MHz,phy_clk(s)=(pclk*7)= 519.75 = 1039.5/2
+			hdmi_clk_out = 1039.5;
+			vx1_phy_div  = 2/2;
+			encl_div     = vx1_phy_div*7;
+			break;
+
+		default:
+			pr_err("Error video format!\n");
+			return;
+	}
+	//if(set_hdmi_dpll(hdmi_clk_out,hdmi_vx1_clk_od1)) {
+	if(set_hdmi_dpll(hdmi_clk_out,0)) {
+		pr_err("Unsupported HDMI_DPLL out frequency!\n");
+		return;
+	}
+
+	//configure vid_clk_div_top
+	if((encl_div%14)==0){//7*even
+		clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_14);
+		xd = encl_div/14;
+	}else if((encl_div%7)==0){ //7*odd
+		clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_7);
+		xd = encl_div/7;
+	}else{ //3.5*odd
+		clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_3p5);
+		xd = encl_div/3.5;
+	}
+
+	//configure crt_video
+	set_crt_video_enc(0,0,xd);  //configure crt_video V1: inSel=vid_pll_clk(0),DivN=xd)
+	enable_crt_video_encl(1,0); //select and enable the output
+}
+
+
+static void set_pll_ttl(Lcd_Config_t *pConf)
+{
+	vclk_set_encl_ttl(pDev->lcd_info.mode);
+//	set_video_spread_spectrum(pll_sel, ss_level);
+}
+
+static void venc_set_ttl(Lcd_Config_t *pConf)
+{
+	printk("%s\n", __FUNCTION__);
+	aml_write_reg32(P_ENCL_VIDEO_EN,           0);
+	aml_write_reg32(P_VPU_VIU_VENC_MUX_CTRL,
+	   (0<<0) |    // viu1 select ENCL
+	   (0<<2)      // viu2 select ENCL
+	);
+	aml_write_reg32(P_ENCL_VIDEO_MODE,        0);
+	aml_write_reg32(P_ENCL_VIDEO_MODE_ADV,    0x0418);
+
+	// bypass filter
+	aml_write_reg32(P_ENCL_VIDEO_FILT_CTRL,    0x1000);
+	aml_write_reg32(P_VENC_DVI_SETTING,        0x11);
+	aml_write_reg32(P_VENC_VIDEO_PROG_MODE,    0x100);
+
+	aml_write_reg32(P_ENCL_VIDEO_MAX_PXCNT,    pConf->lcd_basic.h_period - 1);
+	aml_write_reg32(P_ENCL_VIDEO_MAX_LNCNT,    pConf->lcd_basic.v_period - 1);
+
+	aml_write_reg32(P_ENCL_VIDEO_HAVON_BEGIN,  pConf->lcd_timing.video_on_pixel);
+	aml_write_reg32(P_ENCL_VIDEO_HAVON_END,    pConf->lcd_basic.h_active - 1 + pConf->lcd_timing.video_on_pixel);
+	aml_write_reg32(P_ENCL_VIDEO_VAVON_BLINE,  pConf->lcd_timing.video_on_line);
+	aml_write_reg32(P_ENCL_VIDEO_VAVON_ELINE,  pConf->lcd_basic.v_active + 3  + pConf->lcd_timing.video_on_line);
+
+	aml_write_reg32(P_ENCL_VIDEO_HSO_BEGIN,    15);
+	aml_write_reg32(P_ENCL_VIDEO_HSO_END,      31);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_BEGIN,    15);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_END,      31);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_BLINE,    0);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_ELINE,    2);
+
+	// enable ENCL
+	aml_write_reg32(P_ENCL_VIDEO_EN,           1);
+}
+
+static void set_tcon_ttl(Lcd_Config_t *pConf)
+{
+	Lcd_Timing_t *tcon_adr = &(pConf->lcd_timing);
+
+	//set_lcd_gamma_table_ttl(pConf->lcd_effect.GammaTableR, LCD_H_SEL_R);
+	//set_lcd_gamma_table_ttl(pConf->lcd_effect.GammaTableG, LCD_H_SEL_G);
+	//set_lcd_gamma_table_ttl(pConf->lcd_effect.GammaTableB, LCD_H_SEL_B);
+
+	aml_write_reg32(P_L_GAMMA_CNTL_PORT, 0);//pConf->lcd_effect.gamma_cntl_port);
+	//aml_write_reg32(P_GAMMA_VCOM_HSWITCH_ADDR, pConf->lcd_effect.gamma_vcom_hswitch_addr);
+
+	aml_write_reg32(P_L_RGB_BASE_ADDR,   0xf0);//pConf->lcd_effect.rgb_base_addr);
+	aml_write_reg32(P_L_RGB_COEFF_ADDR,  0x74a);//pConf->lcd_effect.rgb_coeff_addr);
+	//aml_write_reg32(P_POL_CNTL_ADDR,   pConf->lcd_timing.pol_cntl_addr);
+	if(pConf->lcd_basic.lcd_bits == 8)
+		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0x400);
+	else
+		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0x600);
+
+	aml_write_reg32(P_L_STH1_HS_ADDR,    tcon_adr->sth1_hs_addr);
+	aml_write_reg32(P_L_STH1_HE_ADDR,    tcon_adr->sth1_he_addr);
+	aml_write_reg32(P_L_STH1_VS_ADDR,    tcon_adr->sth1_vs_addr);
+	aml_write_reg32(P_L_STH1_VE_ADDR,    tcon_adr->sth1_ve_addr);
+
+	aml_write_reg32(P_L_OEH_HS_ADDR,     tcon_adr->oeh_hs_addr);
+	aml_write_reg32(P_L_OEH_HE_ADDR,     tcon_adr->oeh_he_addr);
+	aml_write_reg32(P_L_OEH_VS_ADDR,     tcon_adr->oeh_vs_addr);
+	aml_write_reg32(P_L_OEH_VE_ADDR,     tcon_adr->oeh_ve_addr);
+
+	aml_write_reg32(P_L_VCOM_HSWITCH_ADDR, tcon_adr->vcom_hswitch_addr);
+	aml_write_reg32(P_L_VCOM_VS_ADDR,    tcon_adr->vcom_vs_addr);
+	aml_write_reg32(P_L_VCOM_VE_ADDR,    tcon_adr->vcom_ve_addr);
+
+	aml_write_reg32(P_L_CPV1_HS_ADDR,    tcon_adr->cpv1_hs_addr);
+	aml_write_reg32(P_L_CPV1_HE_ADDR,    tcon_adr->cpv1_he_addr);
+	aml_write_reg32(P_L_CPV1_VS_ADDR,    tcon_adr->cpv1_vs_addr);
+	aml_write_reg32(P_L_CPV1_VE_ADDR,    tcon_adr->cpv1_ve_addr);
+
+	aml_write_reg32(P_L_STV1_HS_ADDR,    tcon_adr->stv1_hs_addr);
+	aml_write_reg32(P_L_STV1_HE_ADDR,    tcon_adr->stv1_he_addr);
+	aml_write_reg32(P_L_STV1_VS_ADDR,    tcon_adr->stv1_vs_addr);
+	aml_write_reg32(P_L_STV1_VE_ADDR,    tcon_adr->stv1_ve_addr);
+
+	aml_write_reg32(P_L_OEV1_HS_ADDR,    tcon_adr->oev1_hs_addr);
+	aml_write_reg32(P_L_OEV1_HE_ADDR,    tcon_adr->oev1_he_addr);
+	aml_write_reg32(P_L_OEV1_VS_ADDR,    tcon_adr->oev1_vs_addr);
+	aml_write_reg32(P_L_OEV1_VE_ADDR,    tcon_adr->oev1_ve_addr);
+
+	aml_write_reg32(P_L_INV_CNT_ADDR,    tcon_adr->inv_cnt_addr);
+	aml_write_reg32(P_L_TCON_MISC_SEL_ADDR,     tcon_adr->tcon_misc_sel_addr);
+	aml_write_reg32(P_L_DUAL_PORT_CNTL_ADDR, tcon_adr->dual_port_cntl_addr);
+
+	aml_write_reg32(P_VPP_MISC, aml_read_reg32(P_VPP_MISC) & ~(VPP_OUT_SATURATE));
+}
+
+void set_ttl_pinmux(void)
+{
+	aml_set_reg32_bits(P_PERIPHS_PIN_MUX_0, 0x3f, 0, 6);
+	//aml_set_reg32_bits(P_PERIPHS_PIN_MUX_0, 0x3, 18, 2);
+	//aml_set_reg32_bits(P_PERIPHS_PIN_MUX_0, 0x1, 29, 1);
+	aml_set_reg32_bits(P_PERIPHS_PIN_MUX_8, 0x7, 22, 3);
+	aml_set_reg32_bits(P_PERIPHS_PIN_MUX_8, 0x1, 28, 1);
+
+	//aml_set_reg32_bits(P_PAD_PULL_UP_EN_REG4, 0x1, 26, 1);
+	//aml_set_reg32_bits(P_PAD_PULL_UP_REG4, 0x1, 26, 1);
+}
+
+void vpp_set_matrix_ycbcr2rgb (int vd1_or_vd2_or_post, int mode)
+{
+	if (vd1_or_vd2_or_post == 0){ //vd1
+		aml_set_reg32_bits (P_VPP_MATRIX_CTRL, 1, 5, 1);
+		aml_set_reg32_bits (P_VPP_MATRIX_CTRL, 1, 8, 2);
+	}else if (vd1_or_vd2_or_post == 1){ //vd2
+		aml_set_reg32_bits (P_VPP_MATRIX_CTRL, 1, 4, 1);
+		aml_set_reg32_bits (P_VPP_MATRIX_CTRL, 2, 8, 2);
+	}else{
+		aml_set_reg32_bits (P_VPP_MATRIX_CTRL, 1, 0, 1);
+		aml_set_reg32_bits (P_VPP_MATRIX_CTRL, 0, 8, 2);
+		if (mode == 0){
+			aml_set_reg32_bits(P_VPP_MATRIX_CTRL, 1, 1, 2);
+		}else if (mode == 1){
+			aml_set_reg32_bits(P_VPP_MATRIX_CTRL, 0, 1, 2);
+		}
+	}
+
+	if (mode == 0){ //ycbcr not full range, 601 conversion
+		aml_write_reg32(P_VPP_MATRIX_PRE_OFFSET0_1, 0x0064C8FF);
+		aml_write_reg32(P_VPP_MATRIX_PRE_OFFSET2, 0x006400C8);
+
+		//1.164     0       1.596
+		//1.164   -0.392    -0.813
+		//1.164   2.017     0
+		aml_write_reg32(P_VPP_MATRIX_COEF00_01, 0x04000000);
+		aml_write_reg32(P_VPP_MATRIX_COEF02_10, 0x059C0400);
+		aml_write_reg32(P_VPP_MATRIX_COEF11_12, 0x1EA01D24);
+		aml_write_reg32(P_VPP_MATRIX_COEF20_21, 0x04000718);
+		aml_write_reg32(P_VPP_MATRIX_COEF22, 0x00000000);
+		aml_write_reg32(P_VPP_MATRIX_OFFSET0_1, 0x00000000);
+		aml_write_reg32(P_VPP_MATRIX_OFFSET2, 0x00000000);
+		aml_write_reg32(P_VPP_MATRIX_PRE_OFFSET0_1, 0x00000E00);
+		aml_write_reg32(P_VPP_MATRIX_PRE_OFFSET2, 0x00000E00);
+	}else if (mode == 1) {//ycbcr full range, 601 conversion
+		aml_write_reg32(P_VPP_MATRIX_PRE_OFFSET0_1, 0x0000600);
+		aml_write_reg32(P_VPP_MATRIX_PRE_OFFSET2, 0x0600);
+
+		//1     0       1.402
+		//1   -0.34414  -0.71414
+		//1   1.772     0
+		aml_write_reg32(P_VPP_MATRIX_COEF00_01, (0x400 << 16) |0);
+		aml_write_reg32(P_VPP_MATRIX_COEF02_10, (0x59c << 16) |0x400);
+		aml_write_reg32(P_VPP_MATRIX_COEF11_12, (0x1ea0 << 16) |0x1d25);
+		aml_write_reg32(P_VPP_MATRIX_COEF20_21, (0x400 << 16) |0x717);
+		aml_write_reg32(P_VPP_MATRIX_COEF22, 0x0);
+		aml_write_reg32(P_VPP_MATRIX_OFFSET0_1, 0x0);
+		aml_write_reg32(P_VPP_MATRIX_OFFSET2, 0x0);
+	}
+}
+
+static void set_tcon_lvds(Lcd_Config_t *pConf)
+{
+	vpp_set_matrix_ycbcr2rgb(2, 0);
+	aml_write_reg32(P_ENCL_VIDEO_RGBIN_CTRL, 3);
+	aml_write_reg32(P_L_RGB_BASE_ADDR, 0);
+	aml_write_reg32(P_L_RGB_COEFF_ADDR, 0x400);
+
+	if(pConf->lcd_basic.lcd_bits == 8)
+		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0x400);
+	else if(pConf->lcd_basic.lcd_bits == 6)
+		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0x600);
+	else
+		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0);
+
+	aml_write_reg32(P_VPP_MISC, aml_read_reg32(P_VPP_MISC) & ~(VPP_OUT_SATURATE));
+}
+
+
+
+//new lvd_vx1_phy config
+void lvds_phy_config(int lvds_vx1_sel)
+{
+	//debug
+	aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 7);
+	aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
+	aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
+	//debug
+
+	if(lvds_vx1_sel == 0){ //lvds
+		aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL1, 0x6c6cca80);
+		aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
+		aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);
+		//od   clk 1039.5 / 2 = 519.75 = 74.25*7
+		aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL0, 0x0fff0040);
+	}else{
+
+	}
+
+}
+
+void vclk_set_encl_lvds(vmode_t vmode, int lvds_ports)
+{
+	int hdmi_clk_out;
+	//int hdmi_vx1_clk_od1;
+	int vx1_phy_div;
+	int encl_div;
+	unsigned int xd;
+	//no used, od2 must >= od3.
+	//hdmi_vx1_clk_od1 = 1; //OD1 always 1
+
+	if(lvds_ports<2){
+		//pll_video.pl 3500 pll_out
+		switch(vmode) {
+			case VMODE_1080P: //total: 2200x1125 pixel clk = 148.5MHz,phy_clk(s)=(pclk*7)= 1039.5 = 2079/2
+			case VMODE_1080P_50HZ:
+				hdmi_clk_out = 2079;
+				vx1_phy_div  = 2/2;
+				encl_div     = vx1_phy_div*7;
+				break;
+			default:
+				pr_err("Error video format!\n");
+				return;
+		}
+		//if(set_hdmi_dpll(hdmi_clk_out,hdmi_vx1_clk_od1)) {
+		if(set_hdmi_dpll(hdmi_clk_out,0)) {
+			pr_err("Unsupported HDMI_DPLL out frequency!\n");
+			return;
+		}
+
+		if(lvds_ports==1) //dual port
+			vx1_phy_div = vx1_phy_div*2;
+	}else if(lvds_ports>=2) {
+		pr_err("Quad-LVDS is not supported!\n");
+		return;
+	}
+
+	//configure vid_clk_div_top
+	if((encl_div%14)==0){//7*even
+		clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_14);
+		xd = encl_div/14;
+	}else if((encl_div%7)==0){ //7*odd
+		clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_7);
+		xd = encl_div/7;
+	}else{ //3.5*odd
+		clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_3p5);
+		xd = encl_div/3.5;
+	}
+	//for lvds phy clock and enable decoupling FIFO
+	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL1,((3<<6)|((vx1_phy_div-1)<<1)|1)<<24);
+
+	//config lvds phy
+	lvds_phy_config(0);
+	//configure crt_video
+	set_crt_video_enc(0,0,xd);  //configure crt_video V1: inSel=vid_pll_clk(0),DivN=xd)
+	enable_crt_video_encl(1,0); //select and enable the output
+}
+
+static void set_pll_lvds(Lcd_Config_t *pConf)
+{
+	pr_info("%s\n", __FUNCTION__);
+
+	vclk_set_encl_lvds(pDev->lcd_info.mode, pConf->lvds_mlvds_config.lvds_config->dual_port);
+	aml_write_reg32( P_HHI_VIID_DIVIDER_CNTL, ((aml_read_reg32(P_HHI_VIID_DIVIDER_CNTL) & ~(0x7 << 8)) | (2 << 8) | (0<<10)) );
+	aml_write_reg32(P_LVDS_GEN_CNTL, (aml_read_reg32(P_LVDS_GEN_CNTL)| (1 << 3) | (3<< 0)));
+}
+
+static void venc_set_lvds(Lcd_Config_t *pConf)
+{
+	pr_info("%s\n", __FUNCTION__);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6TV
+	aml_write_reg32(P_VPU_VIU_VENC_MUX_CTRL, (0<<0) |    // viu1 select encl
+											(0<<2) );    // viu2 select encl
+#endif
+	aml_write_reg32(P_ENCL_VIDEO_EN, 0);
+	//int havon_begin = 80;
+	aml_write_reg32(P_VPU_VIU_VENC_MUX_CTRL, (0<<0) |    // viu1 select encl
+											(0<<2) );     // viu2 select encl
+	aml_write_reg32(P_ENCL_VIDEO_MODE, 0); // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+	aml_write_reg32(P_ENCL_VIDEO_MODE_ADV,     0x0418); // Sampling rate: 1
+
+	// bypass filter
+	aml_write_reg32(P_ENCL_VIDEO_FILT_CTRL, 0x1000);
+
+	aml_write_reg32(P_ENCL_VIDEO_MAX_PXCNT, pConf->lcd_basic.h_period - 1);
+	if(cur_vmode == VMODE_1080P_50HZ)
+		aml_write_reg32(P_ENCL_VIDEO_MAX_LNCNT, 1350 - 1);
+	else
+		aml_write_reg32(P_ENCL_VIDEO_MAX_LNCNT, pConf->lcd_basic.v_period - 1);
+
+	aml_write_reg32(P_ENCL_VIDEO_HAVON_BEGIN, pConf->lcd_timing.video_on_pixel);
+	aml_write_reg32(P_ENCL_VIDEO_HAVON_END, pConf->lcd_basic.h_active - 1 + pConf->lcd_timing.video_on_pixel);
+	aml_write_reg32(P_ENCL_VIDEO_VAVON_BLINE,	pConf->lcd_timing.video_on_line);
+	aml_write_reg32(P_ENCL_VIDEO_VAVON_ELINE,	pConf->lcd_basic.v_active - 1  + pConf->lcd_timing.video_on_line);
+
+	aml_write_reg32(P_ENCL_VIDEO_HSO_BEGIN,	pConf->lcd_timing.sth1_hs_addr);//10);
+	aml_write_reg32(P_ENCL_VIDEO_HSO_END,	pConf->lcd_timing.sth1_he_addr);//20);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_BEGIN,	pConf->lcd_timing.stv1_hs_addr);//10);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_END,	pConf->lcd_timing.stv1_he_addr);//20);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_BLINE,	pConf->lcd_timing.stv1_vs_addr);//2);
+	aml_write_reg32(P_ENCL_VIDEO_VSO_ELINE,	pConf->lcd_timing.stv1_ve_addr);//4);
+		aml_write_reg32(P_ENCL_VIDEO_RGBIN_CTRL, 0);
+
+		// enable encl
+		aml_write_reg32(P_ENCL_VIDEO_EN, 1);
+	}
+
+
+static void venc_set_vx1(Lcd_Config_t *pConf)
+{
+	pr_info("%s\n", __FUNCTION__);
+	if (cur_vmode == VMODE_4K2K_60HZ) {
+		aml_write_reg32(P_ENCL_VIDEO_EN, 0);
+		//int havon_begin = 80;
+		aml_write_reg32(P_VPU_VIU_VENC_MUX_CTRL, (0<<0) |    // viu1 select encl
+												(3<<2) );     // viu2 select encl
+		aml_write_reg32(P_ENCL_VIDEO_MODE, 40);//0); // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+		aml_write_reg32(P_ENCL_VIDEO_MODE_ADV,     0x18);//0x0418); // Sampling rate: 1
+
+		// bypass filter
+		aml_write_reg32(P_ENCL_VIDEO_FILT_CTRL, 0x1000); //??
+
+		aml_write_reg32(P_ENCL_VIDEO_MAX_PXCNT, 3840+560-1);//pConf->lcd_basic.h_period - 1);
+		aml_write_reg32(P_ENCL_VIDEO_MAX_LNCNT, 2160+90-1);//pConf->lcd_basic.v_period - 1);
+
+		aml_write_reg32(P_ENCL_VIDEO_HAVON_BEGIN, 560-3);//pConf->lcd_timing.video_on_pixel);
+		aml_write_reg32(P_ENCL_VIDEO_HAVON_END, 3839+560-3);//pConf->lcd_basic.h_active - 1 + pConf->lcd_timing.video_on_pixel);
+		aml_write_reg32(P_ENCL_VIDEO_VAVON_BLINE,	90);//pConf->lcd_timing.video_on_line);
+		aml_write_reg32(P_ENCL_VIDEO_VAVON_ELINE,	2159+90);//pConf->lcd_basic.v_active - 1  + pConf->lcd_timing.video_on_line);
+
+		aml_write_reg32(P_ENCL_VIDEO_HSO_BEGIN,48-1);//	pConf->lcd_timing.sth1_hs_addr);//10);
+		aml_write_reg32(P_ENCL_VIDEO_HSO_END,	48-1+32);//pConf->lcd_timing.sth1_he_addr);//20);
+		aml_write_reg32(P_ENCL_VIDEO_VSO_BEGIN,	48-1);//pConf->lcd_timing.stv1_hs_addr);//10);
+		aml_write_reg32(P_ENCL_VIDEO_VSO_END,	48-1);//pConf->lcd_timing.stv1_he_addr);//20);
+		aml_write_reg32(P_ENCL_VIDEO_VSO_BLINE,	3);//pConf->lcd_timing.stv1_vs_addr);//2);
+		aml_write_reg32(P_ENCL_VIDEO_VSO_ELINE,	9);//pConf->lcd_timing.stv1_ve_addr);//4);
+	}else if (cur_vmode == VMODE_4K2K_50HZ) {
+		aml_write_reg32(P_ENCL_VIDEO_EN, 0);
+		//int havon_begin = 80;
+		aml_write_reg32(P_VPU_VIU_VENC_MUX_CTRL, (0<<0) |    // viu1 select encl
+												(3<<2) );     // viu2 select encl
+		aml_write_reg32(P_ENCL_VIDEO_MODE, 40);//0); // Enable Hsync and equalization pulse switch in center; bit[14] cfg_de_v = 1
+		aml_write_reg32(P_ENCL_VIDEO_MODE_ADV,     0x18);//0x0418); // Sampling rate: 1
+
+		// bypass filter
+		aml_write_reg32(P_ENCL_VIDEO_FILT_CTRL, 0x1000); //??
+
+		aml_write_reg32(P_ENCL_VIDEO_MAX_PXCNT, 3840+1440-1);//pConf->lcd_basic.h_period - 1);
+		aml_write_reg32(P_ENCL_VIDEO_MAX_LNCNT, 2160+90-1);//pConf->lcd_basic.v_period - 1);
+
+		aml_write_reg32(P_ENCL_VIDEO_HAVON_BEGIN, 1440-3);//pConf->lcd_timing.video_on_pixel);
+		aml_write_reg32(P_ENCL_VIDEO_HAVON_END, 3839+1440-3);//pConf->lcd_basic.h_active - 1 + pConf->lcd_timing.video_on_pixel);
+		aml_write_reg32(P_ENCL_VIDEO_VAVON_BLINE,	90);//pConf->lcd_timing.video_on_line);
+		aml_write_reg32(P_ENCL_VIDEO_VAVON_ELINE,	2159+90);//pConf->lcd_basic.v_active - 1  + pConf->lcd_timing.video_on_line);
+
+		aml_write_reg32(P_ENCL_VIDEO_HSO_BEGIN,48-1);//	pConf->lcd_timing.sth1_hs_addr);//10);
+		aml_write_reg32(P_ENCL_VIDEO_HSO_END,	48-1+32);//pConf->lcd_timing.sth1_he_addr);//20);
+		aml_write_reg32(P_ENCL_VIDEO_VSO_BEGIN,	48-1);//pConf->lcd_timing.stv1_hs_addr);//10);
+		aml_write_reg32(P_ENCL_VIDEO_VSO_END,	48-1);//pConf->lcd_timing.stv1_he_addr);//20);
+		aml_write_reg32(P_ENCL_VIDEO_VSO_BLINE,	3);//pConf->lcd_timing.stv1_vs_addr);//2);
+		aml_write_reg32(P_ENCL_VIDEO_VSO_ELINE,	9);//pConf->lcd_timing.stv1_ve_addr);//4);
+	}
+
+	aml_write_reg32(P_ENCL_VIDEO_RGBIN_CTRL, 0);
+
+	// enable encl
+	aml_write_reg32(P_ENCL_VIDEO_EN, 1);
+}
+
+static void set_control_lvds(Lcd_Config_t *pConf)
+{
+	pr_info("%s\n", __FUNCTION__);
+
+	if(lvds_repack_flag)
+		lvds_repack = (pConf->lvds_mlvds_config.lvds_config->lvds_repack) & 0x1;
+	pn_swap = (pConf->lvds_mlvds_config.lvds_config->pn_swap) & 0x1;
+	dual_port = (pConf->lvds_mlvds_config.lvds_config->dual_port) & 0x1;
+	if(port_reverse_flag)
+		port_reverse = (pConf->lvds_mlvds_config.lvds_config->port_reverse) & 0x1;
+
+	if(bit_num_flag){
+		switch(pConf->lcd_basic.lcd_bits) {
+			case 10: bit_num=0; break;
+			case 8: bit_num=1; break;
+			case 6: bit_num=2; break;
+			case 4: bit_num=3; break;
+			default: bit_num=1; break;
+		}
+	}
+
+	aml_write_reg32(P_MLVDS_CONTROL,  (aml_read_reg32(P_MLVDS_CONTROL) & ~(1 << 0)));  //disable mlvds
+	aml_write_reg32(P_LVDS_PACK_CNTL_ADDR,
+					( lvds_repack<<0 ) | // repack
+					( port_reverse?(0<<2):(1<<2)) | // odd_even
+					( 0<<3 ) | // reserve
+					( 0<<4 ) | // lsb first
+					( pn_swap<<5 ) | // pn swap
+					( dual_port<<6 ) | // dual port
+					( 0<<7 ) | // use tcon control
+					( bit_num<<8 ) | // 0:10bits, 1:8bits, 2:6bits, 3:4bits.
+					( 0<<10 ) | //r_select  //0:R, 1:G, 2:B, 3:0
+					( 1<<12 ) | //g_select  //0:R, 1:G, 2:B, 3:0
+					( 2<<14 ));  //b_select  //0:R, 1:G, 2:B, 3:0;
+}
+
+static void init_lvds_phy(Lcd_Config_t *pConf)
+{
+	//debug
+	aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 7);
+	aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
+	aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
+	//debug
+	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL1, 0x6c6cca80);
+	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL2, 0x0000006c);
+	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL3, 0x0fff0800);
+	//od   clk 1039.5 / 2 = 519.75 = 74.25*7
+	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL0, 0x0fff0040);
+}
+
+int config_vbyone(int lane, int byte, int region, int hsize, int vsize)
+{
+   int sublane_num;
+   int region_size[4];
+   int tmp;
+
+   if((lane == 0) || (lane == 3) || (lane == 5) || (lane == 6) || (lane == 7) || (lane>8))
+      return 1;
+   if((region ==0) || (region==3) || (region>4))
+      return 1;
+   if(lane%region)
+      return 1;
+   if((byte<3) || (byte>4))
+      return 1;
+
+   sublane_num = lane/region;
+   aml_set_reg32_bits(P_VBO_LANES,lane-1,  VBO_LANE_NUM_BIT,    VBO_LANE_NUM_WID);
+   aml_set_reg32_bits(P_VBO_LANES,region-1,VBO_LANE_REGION_BIT, VBO_LANE_REGION_WID);
+   aml_set_reg32_bits(P_VBO_LANES,sublane_num-1,VBO_SUBLANE_NUM_BIT, VBO_SUBLANE_NUM_WID);
+   aml_set_reg32_bits(P_VBO_LANES,byte-1,VBO_BYTE_MODE_BIT, VBO_BYTE_MODE_WID);
+
+   if(region>1)
+   {
+       region_size[3] = (hsize/lane)*sublane_num;
+       tmp = (hsize%lane);
+       region_size[0] = region_size[3] + (((tmp/sublane_num)>0) ? sublane_num : (tmp%sublane_num));
+       region_size[1] = region_size[3] + (((tmp/sublane_num)>1) ? sublane_num : (tmp%sublane_num));
+       region_size[2] = region_size[3] + (((tmp/sublane_num)>2) ? sublane_num : (tmp%sublane_num));
+       aml_write_reg32(P_VBO_REGION_00,region_size[0]);
+       aml_write_reg32(P_VBO_REGION_01,region_size[1]);
+       aml_write_reg32(P_VBO_REGION_02,region_size[2]);
+       aml_write_reg32(P_VBO_REGION_03,region_size[3]);
+   }
+   aml_write_reg32(P_VBO_ACT_VSIZE,vsize);
+   //aml_set_reg32_bits(P_VBO_CTRL_H,0x80,VBO_CTL_MODE_BIT,VBO_CTL_MODE_WID);  // different from FBC code!!!
+   aml_set_reg32_bits(P_VBO_CTRL_H,0x0,VBO_CTL_MODE2_BIT,VBO_CTL_MODE2_WID); // different from simulation code!!!
+   aml_set_reg32_bits(P_VBO_CTRL_H,0x1,VBO_VIN2ENC_HVSYNC_DLY_BIT,VBO_VIN2ENC_HVSYNC_DLY_WID);
+   //aml_set_reg32_bits(P_VBO_CTRL_L,enable,VBO_ENABLE_BIT,VBO_EBABLE_WID);
+
+   return 0;
+}
+
+void set_vbyone_ctlbits(int p3d_en, int p3d_lr, int mode)
+{
+	if(mode==0)  //insert at the first pixel
+		aml_set_reg32_bits(P_VBO_PXL_CTRL,(1<<p3d_en)|(p3d_lr&0x1),VBO_PXL_CTR0_BIT,VBO_PXL_CTR0_WID);
+	else
+		aml_set_reg32_bits(P_VBO_VBK_CTRL_0,(1<<p3d_en)|(p3d_lr&0x1),0,2);
+}
+
+void set_vbyone_sync_pol(int hsync_pol, int vsync_pol)
+{
+    aml_set_reg32_bits(P_VBO_VIN_CTRL,hsync_pol,VBO_VIN_HSYNC_POL_BIT,VBO_VIN_HSYNC_POL_WID);
+    aml_set_reg32_bits(P_VBO_VIN_CTRL,vsync_pol,VBO_VIN_VSYNC_POL_BIT,VBO_VIN_VSYNC_POL_WID);
+
+    aml_set_reg32_bits(P_VBO_VIN_CTRL,hsync_pol,VBO_VOUT_HSYNC_POL_BIT,VBO_VOUT_HSYNC_POL_WID);
+    aml_set_reg32_bits(P_VBO_VIN_CTRL,vsync_pol,VBO_VOUT_VSYNC_POL_BIT,VBO_VOUT_VSYNC_POL_WID);
+}
+
+static void set_control_vbyone(Lcd_Config_t *pConf)
+{
+    int lane, byte, region,  hsize, vsize;//color_fmt,
+    int vin_color, vin_bpp;
+
+    hsize = 3840;//pConf->lcd_basic.h_active;
+	vsize = 2160;//pConf->lcd_basic.v_active;
+    lane = 8;//byte_num;
+	byte = 4;//byte_num;
+	region = 2;//region_num;
+	vin_color = 4;
+	vin_bpp   = 0;
+    //switch (color_fmt) {
+    //    case 0:   //SDVT_VBYONE_18BPP_RGB
+    //              vin_color = 4;
+    //              vin_bpp   = 2;
+    //              break;
+    //    case 1:   //SDVT_VBYONE_18BPP_YCBCR444
+    //              vin_color = 0;
+    //              vin_bpp   = 2;
+    //              break;
+    //    case 2:   //SDVT_VBYONE_24BPP_RGB
+    //              vin_color = 4;
+    //              vin_bpp   = 1;
+    //              break;
+    //    case 3:   //SDVT_VBYONE_24BPP_YCBCR444
+    //              vin_color = 0;
+    //              vin_bpp   = 1;
+    //              break;
+    //    case 4:   //SDVT_VBYONE_30BPP_RGB
+                  //vin_color = 4;
+                  //vin_bpp   = 0;
+    //              break;
+    //    case 5:   //SDVT_VBYONE_30BPP_YCBCR444
+    //              vin_color = 0;
+    //              vin_bpp   = 0;
+    //              break;
+    //    default:
+    //        printk( "Error VBYONE_COLOR_FORMAT!\n");
+    //              return;
+    //}
+    // clock seting for VX1
+    //vclk_set_encl_vx1(vfromat, lane, byte);
+
+    // set encl format
+    //set_tv_encl (TV_ENC_LCD3840x2160p_vic03,1,0,0);
+
+    // vpu clock setting
+    //aml_set_reg32(P_HHI_VPU_CLK_CNTL,   (0 << 9)    |   // vpu   clk_sel
+    //                        (0 << 0) );     // vpu   clk_div
+    //aml_set_reg32(P_HHI_VPU_CLK_CNTL, (Rd(HHI_VPU_CLK_CNTL) | (1 << 8)) );
+
+    //PIN_MUX for VX1 need to add this to dtd
+    printk("Set VbyOne PIN MUX ......\n");
+    aml_set_reg32_bits(P_PERIPHS_PIN_MUX_3,3,8,2);
+
+    // set Vbyone
+    printk("VbyOne Configuration ......\n");
+    //set_vbyone_vfmt(vin_color,vin_bpp);
+    aml_set_reg32_bits(P_VBO_VIN_CTRL, vin_color, VBO_VIN_PACK_BIT,VBO_VIN_PACK_WID);
+    aml_set_reg32_bits(P_VBO_VIN_CTRL,vin_bpp,  VBO_VIN_BPP_BIT,VBO_VIN_BPP_WID);
+    config_vbyone(lane, byte, region, hsize, vsize);
+    set_vbyone_sync_pol(0, 0); //set hsync/vsync polarity to let the polarity is low active inside the VbyOne
+
+    // below line copy from simulation
+    aml_set_reg32_bits(P_VBO_VIN_CTRL, 1, 0, 2); //gate the input when vsync asserted
+    ///aml_set_reg32(P_VBO_VBK_CTRL_0,0x13);
+    //aml_set_reg32(P_VBO_VBK_CTRL_1,0x56);
+    //aml_set_reg32(P_VBO_HBK_CTRL,0x3478);
+    //aml_set_reg32_bits(P_VBO_PXL_CTRL,0x2,VBO_PXL_CTR0_BIT,VBO_PXL_CTR0_WID);
+    //aml_set_reg32_bits(P_VBO_PXL_CTRL,0x3,VBO_PXL_CTR1_BIT,VBO_PXL_CTR1_WID);
+    //set_vbyone_ctlbits(1,0,0);
+    //set fifo_clk_sel: 3 for 10-bits
+    aml_set_reg32_bits(P_HHI_LVDS_TX_PHY_CNTL0,3,6,2);
+
+    //PAD select:
+	if((lane == 1) || (lane == 2)) {
+		aml_set_reg32_bits(P_LCD_PORT_SWAP,1,9,2);
+    } else if(lane == 4) {
+    	aml_set_reg32_bits(P_LCD_PORT_SWAP,2,9,2);
+    } else {
+    	aml_set_reg32_bits(P_LCD_PORT_SWAP,0,9,2);
+    }
+    //aml_set_reg32_bits(P_LCD_PORT_SWAP, 1, 8, 1);//reverse lane output order
+
+    // Mux pads in combo-phy: 0 for dsi; 1 for lvds or vbyone; 2 for edp
+    aml_write_reg32(P_HHI_DSI_LVDS_EDP_CNTL0, 0x1); // Select vbyone in combo-phy
+    aml_set_reg32_bits(P_VBO_CTRL_L, 1, VBO_ENABLE_BIT, VBO_EBABLE_WID);
+
+    //force vencl clk enable, otherwise, it might auto turn off by mipi DSI
+    //WRITE_VCBUS_REG_BITS(VPU_MISC_CTRL, 1, 0, 1);
+
+    printk("VbyOne is In Normal Status ......\n");
+}
+static void init_vbyone_phy(Lcd_Config_t *pConf)
+{
+    printk("%s\n", __FUNCTION__);
+	//debug
+	aml_write_reg32(P_VPU_VLOCK_GCLK_EN, 7);
+	aml_write_reg32(P_VPU_VLOCK_ADJ_EN_SYNC_CTRL, 0x108010ff);
+	aml_write_reg32(P_VPU_VLOCK_CTRL, 0xe0f50f1b);
+	//debug
+	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL1, 0x6e0ec918);
+	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL2, 0x00000a7c);
+	aml_write_reg32(P_HHI_DIF_CSI_PHY_CNTL3, 0x00ff0800);
+	//od   clk 2970 / 5 = 594
+	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL0, 0xfff00c0);
+	//clear lvds fifo od (/2)
+	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL1, 0xc1000000);
+
+}
+static void set_tcon_vbyone(Lcd_Config_t *pConf)
+{
+    //Lcd_Timing_t *tcon_adr = &(pConf->lcd_timing);
+
+    vpp_set_matrix_ycbcr2rgb(2, 0);
+    aml_write_reg32(P_ENCL_VIDEO_RGBIN_CTRL, 3);
+    aml_write_reg32(P_L_RGB_BASE_ADDR, 0);
+    aml_write_reg32(P_L_RGB_COEFF_ADDR, 0x400);
+    //aml_write_reg32(P_L_POL_CNTL_ADDR,  3);
+    //aml_write_reg32(P_L_DUAL_PORT_CNTL_ADDR, (0x1 << LCD_TTL_SEL));
+//	if(pConf->lcd_basic.lcd_bits == 8)
+//		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0x400);
+//	else if(pConf->lcd_basic.lcd_bits == 6)
+//		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0x600);
+//	else
+//		aml_write_reg32(P_L_DITH_CNTL_ADDR,  0);
+    //PRINT_INFO("final LVDS_FIFO_CLK = %d\n", clk_util_clk_msr(24));
+	//PRINT_INFO("final cts_encl_clk = %d\n", clk_util_clk_msr(9));
+    aml_write_reg32(P_VPP_MISC, aml_read_reg32(P_VPP_MISC) & ~(VPP_OUT_SATURATE));
+}
+
+//clock seting for VX1
+static void set_pll_vbyone(Lcd_Config_t *pConf)
+{
+    int  lane, byte;//vfromat,
+	//int hdmi_clk_out;
+	int hdmi_vx1_clk_od1;
+	int pclk_div;
+	int phy_div;
+	int xd;
+	int minlane;
+
+    lane = 8;//lane_num;
+    byte = 4;//byte_num;
+	//phy_clk = pixel_clk*10*byte_num/lane_num;
+	//                                   lane_num      byte_num      phy_clk
+	//TV_ENC_LCD720x480:(pclk=27M) 858x525  8            3            101.25      (pclk*3.75)
+	//                                      4            3            202.5       (pclk*7.5)
+	//                                      2            3            405         (pclk*15)
+	//                                      1            3            810         (pclk*30)
+	//                                      8            4            135         (pclk*5)
+	//                                      4            4            270         (pclk*10)
+	//                                      2            4            540         (pclk*20)
+	//                                      1            4            1080        (pclk*40)
+	//                                   lane_num      byte_num      phy_clk
+	//TV_ENC_LCD1920x1080:(pclk=148.5M)     8            3            556.875     (pclk*3.75)
+	//                      2200x1125       4            3            1113.75     (pclk*7.5)
+	//                                      2            3            2227.5      (pclk*15)
+	//                                      1            3            4455        (pclk*30)
+	//                                      8            4            742.5       (pclk*5)
+	//                                      4            4            1485        (pclk*10)
+	//                                      2            4            2970        (pclk*20)
+	//                                      1            4            5940        (pclk*40)
+	//                                   lane_num      byte_num      phy_clk
+	//TV_ENC_LCD3840x2160p:(pclk=594M)      8            3            2227.5      (pclk*3.75)
+	//                      4400x2250       4            3            4455        (pclk*7.5)
+	//                                      2            3            8910        (pclk*15)
+	//                                      1            3           17820        (pclk*30)
+	//                                      8            4            2970        (pclk*5)
+	//                                      4            4            5940        (pclk*10)
+	//                                      2            4           11880        (pclk*20)
+	//                                      1            4           23760        (pclk*40)
+    //if (byte_num == 3)
+    //	hdmi_clk_out = 2227.5*2;  //OD1 = 1
+    //else //4
+    //	hdmi_clk_out = 2970*2;    //OD1 = 1
+    minlane = 8;
+    //hdmi_vx1_clk_od1 = 1;
+
+	if (lane < minlane) {
+		printk("VX1 cannot support this configuration!\n");
+		return;
+	}
+
+	phy_div = lane/minlane; //1,2,4,8
+	if (phy_div == 8) {
+    	phy_div = phy_div/2;
+    	if(hdmi_vx1_clk_od1 != 0) {
+    		printk("VX1 cannot support this configuration!\n");
+    		return;
+    	}
+    //	hdmi_vx1_clk_od1=1;
+	}
+	//need check whether we need to set this dpll !!!!!!!
+	//if (set_hdmi_dpll(hdmi_clk_out,hdmi_vx1_clk_od1)){
+    //   printk("Unsupported HDMI_DPLL out frequency!\n");
+    //    return;
+    //}
+
+   pclk_div = (((byte==3) ? 30:40)*100)/minlane;
+   printk("vbyone byte:%d, lane:%d, pclk:%d, phy_div:%d \n", byte, lane, pclk_div, phy_div);
+   //configure vid_clk_div_top
+   if (byte == 3) {
+	   if (pclk_div == 375) {
+		   clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_3p75);
+		   xd = 1;
+	   } else if (pclk_div == 750) {
+		   clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_7p5);
+		   xd = 1;
+	   } else {
+		   clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_15);
+		   xd = pclk_div/100/15;
+	   }
+	} else if (byte == 4) {
+		clocks_set_vid_clk_div(CLK_UTIL_VID_PLL_DIV_5);
+		xd = pclk_div/100/5;
+	}
+
+	//for lvds phy clock and enable decoupling FIFO
+	aml_write_reg32(P_HHI_LVDS_TX_PHY_CNTL1,((3<<6)|((phy_div-1)<<1)|1)<<24);
+
+	//configure crt_video
+	//set_crt_video_enc(0, 0, xd);  //configure crt_video V1: inSel=vid_pll_clk(0),DivN=xd)
+	//if (vidx == 0)
+	{ //V1
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0, 19, 1); //[19] -disable clk_div0
+		udelay(2);  //delay 2uS
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0,   16, 3); // [18:16] - cntl_clk_in_sel
+		aml_set_reg32_bits(P_HHI_VID_CLK_DIV, (xd-1), 0, 8); // [7:0]   - cntl_xd0
+		udelay(5);  // delay 5uS
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 1, 19, 1); //[19] -enable clk_div0
+	}
+    //else { //V2
+	//	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 0, 19, 1); //[19] -disable clk_div0
+	//	udelay(2);  //delay 2uS
+	//	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, insel,  16, 3); // [18:16] - cntl_clk_in_sel
+	//	aml_set_reg32_bits(P_HHI_VIID_CLK_DIV, (divn-1),0, 8); // [7:0]   - cntl_xd0
+	//	udelay(5);  // delay 5uS
+	//	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 1, 19, 1); //[19] -enable clk_div0
+	//}
+	udelay(5);  // delay 5uS
+	//enable_crt_video_encl(1, 0); //select and enable the output
+	aml_set_reg32_bits(P_HHI_VIID_CLK_DIV, 0,  12, 4); //encl_clk_sel:hi_viid_clk_div[15:12]
+	//if(inSel<=4) //V1
+	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL,1, 0, 1);
+	//else
+	//	aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL,1, (inSel-5),1);
+
+	aml_set_reg32_bits(P_HHI_VID_CLK_CNTL2, 1, 3, 1); //gclk_encl_clk:hi_vid_clk_cntl2[3]
+}
+
+void set_vx1_pinmux(void)
+{
+	//VX1_LOCKN && VX1_HTPDN
+	aml_set_reg32_bits(P_PERIPHS_PIN_MUX_7, 3, 18, 2);
+}
+
+static void _init_display_driver(Lcd_Config_t *pConf)
+{
+	switch (pDev->conf.lcd_basic.lcd_type) {
+		case LCD_DIGITAL_TTL:
+			printk("ttl mode is selected!\n");
+			set_pll_ttl(pConf);
+			venc_set_ttl(pConf);
+			set_tcon_ttl(pConf);
+			set_ttl_pinmux();
+			break;
+		case LCD_DIGITAL_LVDS:
+			printk("lvds mode is selected!\n");
+			set_pll_lvds(pConf);
+			venc_set_lvds(pConf);
+			set_control_lvds(pConf);
+			init_lvds_phy(pConf);
+			set_tcon_lvds(pConf);
+			break;
+		case LCD_DIGITAL_VBYONE:
+			printk("vx1 mode is selected!\n");
+			set_pll_vbyone(pConf);
+			venc_set_vx1(pConf);
+			set_control_vbyone(pConf);
+			init_vbyone_phy(pConf);
+			set_tcon_vbyone(pConf);
+			set_vx1_pinmux();
+			break;
+		default:
+			pr_err("Invalid LCD type.\n");
+			break;
+	}
+}
+
+static inline void _disable_display_driver(void)
+{
+	int vclk_sel;
+
+	vclk_sel = 0;//((pConf->lcd_timing.clk_ctrl) >>4) & 0x1;
+
+	aml_set_reg32_bits(P_HHI_VIID_DIVIDER_CNTL, 0, 11, 1);	//close lvds phy clk gate: 0x104c[11]
+
+	aml_write_reg32(P_ENCL_VIDEO_EN, 0);	//disable ENCL
+	aml_write_reg32(P_ENCL_VIDEO_EN, 0);	//disable encl
+
+	if (vclk_sel)
+		aml_set_reg32_bits(P_HHI_VIID_CLK_CNTL, 0, 0, 5);		//close vclk2 gate: 0x104b[4:0]
+	else
+		aml_set_reg32_bits(P_HHI_VID_CLK_CNTL, 0, 0, 5);		//close vclk1 gate: 0x105f[4:0]
+
+	pr_info("disable lcd display driver.\n");
+}
+
+static inline void _enable_vsync_interrupt(void)
+{
+	if ((aml_read_reg32(P_ENCL_VIDEO_EN) & 1) || (aml_read_reg32(P_ENCL_VIDEO_EN) & 1)) {
+		aml_write_reg32(P_VENC_INTCTRL, 0x200);
+	}else{
+		aml_write_reg32(P_VENC_INTCTRL, 0x2);
+	}
+}
+static void _lcd_module_enable(void)
+{
+	BUG_ON(pDev==NULL);
+	_init_display_driver(&pDev->conf);
+	_enable_vsync_interrupt();
+}
+
+static void change_panel(lcd_dev_t *pDev)
+{
+	pDev->lcd_info.name = PANEL_NAME;
+	pDev->lcd_info.width = pDev->conf.lcd_basic.h_active;
+	pDev->lcd_info.height = pDev->conf.lcd_basic.v_active;
+	pDev->lcd_info.field_height = pDev->conf.lcd_basic.v_active;
+	pDev->lcd_info.aspect_ratio_num = pDev->conf.lcd_basic.screen_ratio_width;
+	pDev->lcd_info.aspect_ratio_den = pDev->conf.lcd_basic.screen_ratio_height;
+	pDev->lcd_info.screen_real_width= pDev->conf.lcd_basic.screen_actual_width;
+	pDev->lcd_info.screen_real_height= pDev->conf.lcd_basic.screen_actual_height;
+	pDev->lcd_info.sync_duration_num = pDev->conf.lcd_timing.sync_duration_num;
+	pDev->lcd_info.sync_duration_den = pDev->conf.lcd_timing.sync_duration_den;
+
+	if((cur_vmode == VMODE_1080P)||
+		(cur_vmode == VMODE_1080P_50HZ))
+	{
+		pDev->conf.lcd_basic.lcd_type = LCD_DIGITAL_LVDS;
+	}else if((cur_vmode == VMODE_4K2K_60HZ)||(cur_vmode == VMODE_4K2K_50HZ))
+	{
+		pDev->conf.lcd_basic.lcd_type = LCD_DIGITAL_VBYONE;
+	}else if(cur_vmode == VMODE_720P)
+	{
+		pDev->conf.lcd_basic.lcd_type = LCD_DIGITAL_TTL;
+	}
+}
+
+static void _init_vout(lcd_dev_t *pDev)
+{
+	change_panel(pDev);
+//	vout_register_server(&lcd_vout_server);
+}
+
+static void _lcd_init(Lcd_Config_t *pConf)
+{
+	 _init_vout(pDev);
+	 _lcd_module_enable();
+}
+
+
+static struct notifier_block lcd_reboot_nb;
+
+static int lcd_reboot_notifier(struct notifier_block *nb, unsigned long state, void *cmd)
+ {
+	if (state == SYS_RESTART){
+		pr_info("shut down lcd...\n");
+	}
+
+	return NOTIFY_DONE;
+}
+
+
+void panel_power_on(void)
+{
+	pr_info("%s\n", __func__);
+}
+void panel_power_off(void)
+{
+	pr_info("%s\n", __func__);
+}
+static ssize_t power_show(struct class *cls,
+			struct class_attribute *attr, char *buf)
+{
+	int ret = 0;
+	bool status = false;
+	int value;
+
+	status = true;//gpio_get_status(PAD_GPIOZ_5);
+	ret = sprintf(buf, "PAD_GPIOZ_5 gpio_get_status %s\n", (status?"true":"false"));
+	ret = sprintf(buf, "\n");
+
+	value = 0;//gpio_in_get(PAD_GPIOZ_5);
+	ret = sprintf(buf, "PAD_GPIOZ_5 gpio_in_get %d\n", value);
+	ret = sprintf(buf, "\n");
+
+	return ret;
+}
+static ssize_t power_store(struct class *cls, struct class_attribute *attr,
+			 const char *buf, size_t count)
+{
+	int ret = 0;
+	int status = 0;
+	status = simple_strtol(buf, NULL, 0);
+	pr_info("input status %d\n", status);
+
+	if (status != 0) {
+		panel_power_off();
+		pr_info("lvds_power_off\n");
+	}else {
+		panel_power_on();
+		pr_info("lvds_power_on\n");
+	}
+
+	return ret;
+}
+static CLASS_ATTR(power, S_IWUSR | S_IRUGO, power_show, power_store);
+
+static inline int _get_lcd_default_config(struct platform_device *pdev)
+{
+	int ret = 0;
+	unsigned int lvds_para[14];
+	if (!pdev->dev.of_node){
+		pr_err("\n can't get dev node---error----%s----%d",__FUNCTION__,__LINE__);
+	}
+
+	ret = of_property_read_u32_array(pdev->dev.of_node,"basic_setting",&lvds_para[0], 10);
+	if(ret){
+		pr_err("don't find to match basic_setting, use default setting.\n");
+	}else{
+		pr_info("get basic_setting ok.\n");
+		pDev->conf.lcd_basic.h_active = lvds_para[0];
+		pDev->conf.lcd_basic.v_active = lvds_para[1];
+		pDev->conf.lcd_basic.h_period= lvds_para[2];
+		pDev->conf.lcd_basic.v_period= lvds_para[3];
+		pDev->conf.lcd_basic.screen_ratio_width = lvds_para[4];
+		pDev->conf.lcd_basic.screen_ratio_height = lvds_para[5];
+		pDev->conf.lcd_basic.screen_actual_width = lvds_para[6];
+		pDev->conf.lcd_basic.screen_actual_height = lvds_para[7];
+		pDev->conf.lcd_basic.lcd_type = lvds_para[8];
+		pDev->conf.lcd_basic.lcd_bits = lvds_para[9];
+	}
+	ret = of_property_read_u32_array(pdev->dev.of_node,"lcd_timing",&lvds_para[0], 14);
+	if(ret){
+		pr_err("don't find to match lcd_timing, use default setting.\n");
+	}else{
+		pr_info("get lcd_timing ok.\n");
+		pDev->conf.lcd_timing.video_on_pixel = lvds_para[0];
+		pDev->conf.lcd_timing.video_on_line = lvds_para[1];
+		pDev->conf.lcd_timing.sth1_hs_addr = lvds_para[2];
+		pDev->conf.lcd_timing.sth1_he_addr = lvds_para[3];
+		pDev->conf.lcd_timing.sth1_vs_addr = lvds_para[4];
+		pDev->conf.lcd_timing.sth1_ve_addr = lvds_para[5];
+		pDev->conf.lcd_timing.stv1_hs_addr = lvds_para[6];
+		pDev->conf.lcd_timing.stv1_he_addr = lvds_para[7];
+		pDev->conf.lcd_timing.stv1_vs_addr = lvds_para[8];
+		pDev->conf.lcd_timing.stv1_ve_addr = lvds_para[9];
+		pDev->conf.lcd_timing.oeh_hs_addr = lvds_para[10];
+		pDev->conf.lcd_timing.oeh_he_addr = lvds_para[11];
+		pDev->conf.lcd_timing.oeh_vs_addr = lvds_para[12];
+		pDev->conf.lcd_timing.oeh_ve_addr = lvds_para[13];		
+	}
+	ret = of_property_read_u32_array(pdev->dev.of_node,"delay_setting",&lvds_para[0], 8);
+	if(ret){
+		pr_err("don't find to match delay_setting, use default setting.\n");
+	}else{
+		pDev->conf.lcd_sequence.clock_enable_delay = lvds_para[0];
+		pDev->conf.lcd_sequence.clock_disable_delay = lvds_para[1];
+		pDev->conf.lcd_sequence.pwm_enable_delay= lvds_para[2];
+		pDev->conf.lcd_sequence.pwm_disable_delay= lvds_para[3];
+		pDev->conf.lcd_sequence.panel_power_on_delay = lvds_para[4];
+		pDev->conf.lcd_sequence.panel_power_off_delay = lvds_para[5];
+		pDev->conf.lcd_sequence.backlight_power_on_delay = lvds_para[6];
+		pDev->conf.lcd_sequence.backlight_power_off_delay = lvds_para[7];
+	}
+	return ret;
+}
+
+// Define LVDS physical PREM SWING VCM REF
+static Lvds_Phy_Control_t lcd_lvds_phy_control = {
+	.lvds_prem_ctl  = 0x4,
+	.lvds_swing_ctl = 0x2,
+	.lvds_vcm_ctl   = 0x4,
+	.lvds_ref_ctl   = 0x15,
+	.lvds_phy_ctl0  = 0x0002,
+	.lvds_fifo_wr_mode = 0x3,
+};
+//Define LVDS data mapping, pn swap.
+static Lvds_Config_t lcd_lvds_config = {
+	.lvds_repack    = 1,   //data mapping  //0:JEDIA mode, 1:VESA mode
+	.pn_swap    = 0,       //0:normal, 1:swap
+	.dual_port  = 1,
+	.port_reverse   = 1,
+};
+static Lcd_Config_t m6tv_lvds_config = {
+	// Refer to LCD Spec
+	.lcd_basic = {
+		.h_active = H_ACTIVE,
+		.v_active = V_ACTIVE,
+		.h_period = H_PERIOD,
+		.v_period = V_PERIOD,
+		.screen_ratio_width   = 16,
+		.screen_ratio_height  = 9,
+		.screen_actual_width  = 127, //this is value for 160 dpi please set real value according to spec.
+		.screen_actual_height = 203, //
+		.lcd_type = LCD_DIGITAL_LVDS,   //LCD_DIGITAL_TTL  //LCD_DIGITAL_LVDS  //LCD_DIGITAL_MINILVDS
+		.lcd_bits = 8,  //8  //6
+	},
+	.lcd_timing = {
+		.pll_ctrl = 0x40050c82,//0x400514d0, //
+		.div_ctrl = 0x00010803,
+		.clk_ctrl = 0x1111,  //[19:16]ss_ctrl, [12]pll_sel, [8]div_sel, [4]vclk_sel, [3:0]xd
+		//.sync_duration_num = 501,
+		//.sync_duration_den = 10,
+
+		.video_on_pixel = VIDEO_ON_PIXEL,
+		.video_on_line  = VIDEO_ON_LINE,
+
+		.sth1_hs_addr = 44,
+		.sth1_he_addr = 2156,
+		.sth1_vs_addr = 0,
+		.sth1_ve_addr = V_PERIOD - 1,
+		.stv1_hs_addr = 2100,
+		.stv1_he_addr = 2164,
+		.stv1_vs_addr = 3,
+		.stv1_ve_addr = 5,
+		.oeh_hs_addr = VIDEO_ON_PIXEL+19,
+		.oeh_he_addr = VIDEO_ON_PIXEL+19+H_ACTIVE,
+		.oeh_vs_addr = VIDEO_ON_LINE,
+		.oeh_ve_addr = VIDEO_ON_LINE+V_ACTIVE-1,
+
+		.pol_cntl_addr = (0x0 << LCD_CPH1_POL) |(0x0 << LCD_HS_POL) | (0x1 << LCD_VS_POL),
+		.inv_cnt_addr = (0<<LCD_INV_EN) | (0<<LCD_INV_CNT),
+		.tcon_misc_sel_addr = (1<<LCD_STV1_SEL) | (1<<LCD_STV2_SEL),
+		.dual_port_cntl_addr = (1<<LCD_TTL_SEL) | (1<<LCD_ANALOG_SEL_CPH3) | (1<<LCD_ANALOG_3PHI_CLK_SEL) | (0<<LCD_RGB_SWP) | (0<<LCD_BIT_SWP),
+	},
+	.lcd_sequence = {
+		.clock_enable_delay        = CLOCK_ENABLE_DELAY,
+		.clock_disable_delay       = CLOCK_DISABLE_DELAY,
+		.pwm_enable_delay          = PWM_ENABLE_DELAY,
+		.pwm_disable_delay         = PWM_DISABLE_DELAY,
+		.panel_power_on_delay      = PANEL_POWER_ON_DELAY,
+		.panel_power_off_delay     = PANEL_POWER_OFF_DELAY,
+		.backlight_power_on_delay  = BACKLIGHT_POWER_ON_DELAY,
+		.backlight_power_off_delay = BACKLIGHT_POWER_OFF_DELAY,
+	},
+	.lvds_mlvds_config = {
+		.lvds_config = &lcd_lvds_config,
+		.lvds_phy_control = &lcd_lvds_phy_control,
+	},
+};
+
+#ifdef CONFIG_USE_OF
+static struct aml_lcd_platform m6tv_lvds_device = {
+	.lcd_conf = &m6tv_lvds_config,
+};
+#define AMLOGIC_LVDS_DRV_DATA ((kernel_ulong_t)&m6tv_lvds_device)
+static const struct of_device_id lvds_dt_match[]={
+	{
+		.compatible = "amlogic,lvds",
+		.data = (void *)AMLOGIC_LVDS_DRV_DATA
+	},
+	{},
+};
+#else
+#define lvds_dt_match NULL
+#endif
+
+#ifdef CONFIG_USE_OF
+static inline struct aml_lcd_platform *lvds_get_driver_data(struct platform_device *pdev)
+{
+	const struct of_device_id *match;
+
+	if(pdev->dev.of_node) {
+		match = of_match_node(lvds_dt_match, pdev->dev.of_node);
+		return (struct aml_lcd_platform *)match->data;
+	}else
+		pr_err("\n ERROR get data %d",__LINE__);
+	return NULL;
+}
+#endif
+
+static void lcd_output_mode_info(void)
+{
+	const vinfo_t *info;
+	info = get_current_vinfo();
+	if(info){
+		if(strncmp(info->name, "720p", 4) == 0){
+			cur_vmode = VMODE_720P;	
+		}else if(strncmp(info->name, "1080p", 5) == 0){
+			cur_vmode = VMODE_1080P;
+		}else if(strncmp(info->name, "1080p50hz", 5) == 0){
+			cur_vmode = VMODE_1080P_50HZ;
+		}else if(strncmp(info->name, "4k2k60hz", 8) == 0){
+			cur_vmode = VMODE_4K2K_60HZ;
+		}else if(strncmp(info->name, "4k2k50hz", 8) == 0){
+			cur_vmode = VMODE_4K2K_50HZ;
+		}else{
+			cur_vmode = VMODE_1080P;
+			printk("the output mode is not support,use default mode!\n");
+		}
+	}
+	_lcd_init(&pDev->conf);
+}
+
+static int lcd_notify_callback_v(struct notifier_block *block, unsigned long cmd , void *para)
+{
+    if (cmd != VOUT_EVENT_MODE_CHANGE)
+        return 0;
+
+    lcd_output_mode_info();
+    return 0;
+}
+
+static struct notifier_block lcd_mode_notifier_nb_v = {
+    .notifier_call    = lcd_notify_callback_v,
+};
+
+static int lcd_probe(struct platform_device *pdev)
+{
+	struct aml_lcd_platform *pdata;
+	int err;
+
+#ifdef CONFIG_USE_OF
+	pdata = lvds_get_driver_data(pdev);
+#else
+	pdata = pdev->dev.platform_data;
+#endif
+
+	pDev = (lcd_dev_t *)kmalloc(sizeof(lcd_dev_t), GFP_KERNEL);
+	if (!pDev) {
+		pr_err("[tcon]: Not enough memory.\n");
+		return -ENOMEM;
+	}
+
+	pDev->lcd_info.mode = cur_vmode;
+	pDev->conf = *(Lcd_Config_t *)(pdata->lcd_conf);        //*(Lcd_Config_t *)(s->start);
+
+#ifdef CONFIG_USE_OF
+	_get_lcd_default_config(pdev);
+#endif
+
+	printk("LCD probe ok\n");
+	vout_register_client(&lcd_mode_notifier_nb_v);
+	//lcd_output_mode_info();
+	lcd_reboot_nb.notifier_call = lcd_reboot_notifier;
+	err = register_reboot_notifier(&lcd_reboot_nb);
+	if (err) {
+		pr_err("notifier register lcd_reboot_notifier fail!\n");
+	}
+
+	return 0;
+}
+
+static int lcd_remove(struct platform_device *pdev)
+{
+	unregister_reboot_notifier(&lcd_reboot_nb);
+	kfree(pDev);
+
+	return 0;
+}
+
+#ifdef CONFIG_PM
+static int lcd_drv_suspend(struct platform_device *pdev, pm_message_t state)
+{
+	pr_info("%s\n", __func__);
+	return 0;
+}
+static int lcd_drv_resume(struct platform_device *pdev)
+{
+	pr_info("%s\n", __func__);
+	return 0;
+}
+#endif /* CONFIG_PM */
+
+static struct platform_driver lcd_driver = {
+	.probe = lcd_probe,
+	.remove = lcd_remove,
+	.driver = {
+		.name = "mesonlcd",
+		.of_match_table = lvds_dt_match,
+	},
+#ifdef CONFIG_PM
+	.suspend = lcd_drv_suspend,
+	.resume = lcd_drv_resume,
+#endif
+};
+
+static int __init lcd_init(void)
+{
+	int ret;
+	printk("TV LCD driver init\n");
+
+	if (platform_driver_register(&lcd_driver)) {
+		pr_err("failed to register tcon driver module\n");
+		return -ENODEV;
+	}
+
+	aml_lcd_clsp = class_create(THIS_MODULE, "aml_lcd");
+	ret = class_create_file(aml_lcd_clsp, &class_attr_power);
+
+	return 0;
+}
+
+static void __exit lcd_exit(void)
+{
+	class_remove_file(aml_lcd_clsp, &class_attr_power);
+	class_destroy(aml_lcd_clsp);
+	platform_driver_unregister(&lcd_driver);
+}
+
+subsys_initcall(lcd_init);
+module_exit(lcd_exit);
+
+int __init outputmode_setup(char *s)
+{
+	if(!strcmp(s,"1080p")){
+		cur_vmode = VMODE_1080P;
+	}else  if(!strcmp(s,"1080p50hz")){
+	        cur_vmode = VMODE_1080P_50HZ;
+	}else  if(!strcmp(s,"4k2k60hz")){
+		cur_vmode = VMODE_4K2K_60HZ;
+	}else  if(!strcmp(s,"4k2k50hz")){
+		cur_vmode = VMODE_4K2K_50HZ;
+	}else  if(!strcmp(s,"720p")){
+		cur_vmode = VMODE_720P;
+	}else{
+		cur_vmode = VMODE_INIT_NULL;
+		printk("the output mode is not support!\n");
+	}
+	printk("the output mode is %d\n",cur_vmode);
+	return 0;	
+}
+__setup("vmode=",outputmode_setup) ;
+
+ int __init lvds_boot_para_setup(char *s)
+{
+	unsigned char* ptr;
+	unsigned char flag_buf[16];
+	int i;
+
+	pr_info("LVDS boot args: %s\n", s);
+
+	if(strstr(s, "10bit")){
+		bit_num_flag = 0;
+		bit_num = 0;
+	}
+	if(strstr(s, "8bit")){
+		bit_num_flag = 0;
+		bit_num = 1;
+	}
+	if(strstr(s, "6bit")){
+		bit_num_flag = 0;
+		bit_num = 2;
+	}
+	if(strstr(s, "4bit")){
+		bit_num_flag = 0;
+		bit_num = 3;
+	}
+	if(strstr(s, "jeida")){
+		lvds_repack_flag = 0;
+		lvds_repack = 0;
+	}
+	if(strstr(s, "port_reverse")){
+		port_reverse_flag = 0;
+		port_reverse = 0;
+	}
+	if(strstr(s, "flaga")){
+		i=0;
+		ptr=strstr(s,"flaga")+5;
+		while((*ptr) && ((*ptr)!=',') && (i<10)){
+			flag_buf[i]=*ptr;
+			ptr++; i++;
+		}
+		flag_buf[i]=0;
+		flaga = simple_strtoul(flag_buf, NULL, 10);
+	}
+	if(strstr(s, "flagb")){
+		i=0;
+		ptr=strstr(s,"flagb")+5;
+		while((*ptr) && ((*ptr)!=',') && (i<10)){
+			flag_buf[i]=*ptr;
+			ptr++; i++;
+		}
+		flag_buf[i]=0;
+		flagb = simple_strtoul(flag_buf, NULL, 10);
+	}
+	if(strstr(s, "flagc")){
+		i=0;
+		ptr=strstr(s,"flagc")+5;
+		while((*ptr) && ((*ptr)!=',') && (i<10)){
+			flag_buf[i]=*ptr;
+			ptr++; i++;
+		}
+		flag_buf[i]=0;
+		flagc = simple_strtoul(flag_buf, NULL, 10);
+	}
+	if(strstr(s, "flagd")){
+		i=0;
+		ptr=strstr(s,"flagd")+5;
+		while((*ptr) && ((*ptr)!=',') && (i<10)){
+			flag_buf[i]=*ptr;
+			ptr++; i++;
+		}
+		flag_buf[i]=0;
+		flagd = simple_strtoul(flag_buf, NULL, 10);
+	}
+	return 0;
+}
+__setup("lvds=",lvds_boot_para_setup);
+
+MODULE_DESCRIPTION("Meson LCD Panel Driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Amlogic, Inc.");
+
diff --git a/drivers/amlogic/display/osd/Kconfig b/drivers/amlogic/display/osd/Kconfig
index 5830f861..034ffd0e 100755
--- a/drivers/amlogic/display/osd/Kconfig
+++ b/drivers/amlogic/display/osd/Kconfig
@@ -13,11 +13,18 @@ config FB_AM
 	help
 	  This is the frame buffer device driver.
 
+config FB_OSD_SUPPORT_SYNC_FENCE
+	bool "OSD SYNC FENCE"
+	default y
+	depends on  FB_AM
+	help
+	  Select to enable OSD SYNC FENCE.
+
 config FB_OSD2_ENABLE
 	bool "osd2 layer enable"
 	default y
 	depends on  FB_AM
-	help  
+	help
 		if enable osd2 then we will have two OSD op layer
 
 config FB_OSD2_CURSOR
@@ -26,6 +33,7 @@ config FB_OSD2_CURSOR
 	default n
 	help
 		Enables support for a mouse cursor using OSD2.
+
 config FB_OSD2_DEFAULT_BITS_PER_PIXEL
 	depends on FB_OSD2_ENABLE
 	int "default OSD2 BPP"
@@ -103,11 +111,4 @@ config FB_OSD1_DEFAULT_HEIGHT_VIRTUAL
 	---help---
 	  The default osd1/fb0 virtual height. Does not affect ability to change height using fbset or FBIOPUT ioctl.
 
-config FB_AMLOGIC_UMP
-   bool "amlogic ump"
-   default y
-   depends on  FB_AM
-   help
-                enable osd ump when we use mali for x11
-
-endmenu	
+endmenu
diff --git a/drivers/amlogic/display/osd/Makefile b/drivers/amlogic/display/osd/Makefile
index 821ba2f7..33fe59e7 100755
--- a/drivers/amlogic/display/osd/Makefile
+++ b/drivers/amlogic/display/osd/Makefile
@@ -3,7 +3,7 @@
 #
 
 
-obj-$(CONFIG_FB_AM) += fb.o 
+obj-$(CONFIG_FB_AM) += fb.o
 
 fb-objs =  osd_hw.o osd_main.o osd_dev.o  osd_antiflicker.o osd_clone.o
 
@@ -13,12 +13,6 @@ endif
 
 obj-$(CONFIG_VSYNC_RDMA) += osd_rdma.o
 
-EXTRA_CFLAGS += -Iinclude/linux/amlogic/osd/
-ifeq ($(CONFIG_FB_AMLOGIC_UMP),y)
-fb-objs += osd_ump.o
-endif
+obj-$(CONFIG_HIBERNATION) +=  osd_progressbar.o
 
-ifeq ($(CONFIG_FB_AMLOGIC_UMP),y)
-EXTRA_CFLAGS += -I../hardware/arm/gpu/ump/include/
-endif
- 
+EXTRA_CFLAGS += -Iinclude/linux/amlogic/osd/ -Idrivers/staging/android/
diff --git a/drivers/amlogic/display/osd/osd_antiflicker.c b/drivers/amlogic/display/osd/osd_antiflicker.c
old mode 100644
new mode 100755
index cb2617dd..211b530a
--- a/drivers/amlogic/display/osd/osd_antiflicker.c
+++ b/drivers/amlogic/display/osd/osd_antiflicker.c
@@ -325,4 +325,3 @@ void osd_antiflicker_task_stop(void)
 	ge2d_osd_antiflicker.inited = false;
 }
 #endif
-
diff --git a/drivers/amlogic/display/osd/osd_antiflicker.h b/drivers/amlogic/display/osd/osd_antiflicker.h
old mode 100644
new mode 100755
index 6c6c6385..35c1f022
--- a/drivers/amlogic/display/osd/osd_antiflicker.h
+++ b/drivers/amlogic/display/osd/osd_antiflicker.h
@@ -21,31 +21,30 @@
  *
  */
 
-#ifndef _OSD_ANTIFLICKER_H_
-#define _OSD_ANTIFLICKER_H_
+#ifndef _OSD_ANTIFLICKER_H_
+#define _OSD_ANTIFLICKER_H_
 
 #ifdef CONFIG_AM_GE2D
-#define OSD_GE2D_ANTIFLICKER_SUPPORT 1
+#define OSD_GE2D_ANTIFLICKER_SUPPORT 1
 #endif
 
-#ifdef OSD_GE2D_ANTIFLICKER_SUPPORT
-extern void osd_antiflicker_update_pan(u32 yoffset, u32 yres);
-extern int osd_antiflicker_task_start(void);
-extern void osd_antiflicker_task_stop(void);
-extern void osd_antiflicker_enable(u32 enable);
-#else
-static inline void  osd_antiflicker_enable(u32 enable){}
-static inline void osd_antiflicker_update_pan(u32 yoffset, u32 yres){}
-static inline int osd_antiflicker_task_start(void)
+#ifdef OSD_GE2D_ANTIFLICKER_SUPPORT
+extern void osd_antiflicker_update_pan(u32 yoffset, u32 yres);
+extern int osd_antiflicker_task_start(void);
+extern void osd_antiflicker_task_stop(void);
+extern void osd_antiflicker_enable(u32 enable);
+#else
+static inline void  osd_antiflicker_enable(u32 enable){}
+static inline void osd_antiflicker_update_pan(u32 yoffset, u32 yres){}
+static inline int osd_antiflicker_task_start(void)
 {
-	printk("++ osd_antiflicker depends on GE2D module!\n");
+	printk("++ osd_antiflicker depends on GE2D module!\n");
 	return 0;
 }
-static inline void osd_antiflicker_task_stop(void)
+static inline void osd_antiflicker_task_stop(void)
 {
-	printk("-- osd_antiflicker depends on GE2D module!\n");
+	printk("-- osd_antiflicker depends on GE2D module!\n");
 }
 #endif
 
 #endif
-
diff --git a/drivers/amlogic/display/osd/osd_clone.c b/drivers/amlogic/display/osd/osd_clone.c
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/display/osd/osd_clone.h b/drivers/amlogic/display/osd/osd_clone.h
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/display/osd/osd_dev.c b/drivers/amlogic/display/osd/osd_dev.c
old mode 100644
new mode 100755
index 794262cc..635e3884
--- a/drivers/amlogic/display/osd/osd_dev.c
+++ b/drivers/amlogic/display/osd/osd_dev.c
@@ -213,7 +213,14 @@ void osddev_set_window_axis(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
 {
 	osd_set_window_axis_hw(index, x0, y0, x1, y1);
 }
-
+int osddev_sync_request( struct fb_info * info,u32 xoffset, u32 yoffset,s32 in_fence_fd)
+{
+	return osd_sync_request(info->node, info->var.yres,xoffset ,yoffset ,in_fence_fd);
+}
+int osddev_wait_for_vsync(void)
+{
+	return osd_wait_vsync_event();
+}
 void osddev_get_osd_info(u32 index, s32 (*posdval)[4], u32 (*posdreg)[5], s32 info_flag)
 {
 	osd_get_osd_info_hw(index, posdval, posdreg, info_flag);
@@ -259,6 +266,16 @@ void osddev_set_osd_antiflicker(u32 index, u32 vmode, u32 yres)
         osd_set_osd_antiflicker_hw(index, vmode, yres);
 }
 
+void osddev_get_update_state(u32 index, u32 *up_free)
+{
+        osd_get_osd_updatestate_hw(index, up_free);
+}
+
+void osddev_set_update_state(u32 index, u32 up_free)
+{
+        osd_set_osd_updatestate_hw(index, up_free);
+}
+
 void osddev_get_osd_angle(u32 index, u32 *angle)
 {
         osd_get_osd_angle_hw(index, angle);
@@ -343,15 +360,6 @@ void osddev_cursor(struct myfb_dev *fbdev, s16 x, s16 y, s16 xstart, s16 ystart,
 }
 #endif
 
-int osddev_copy_data_tocursor(myfb_dev_t *g_fbi, aml_hwc_addr_t *cursor_mem)
-{
-	if (cursor_mem == NULL){
-		return 0;
-	}
-	osddev_copy_data_tocursor_hw((u32)g_fbi->fb_mem_vaddr, cursor_mem);
-	return 1;
-}
-
 void  osddev_set_colorkey(u32 index,u32 bpp,u32 colorkey )
 {
 	osd_set_colorkey_hw( index, bpp, colorkey );
@@ -376,3 +384,21 @@ void osddev_resume(void)
 {
 	osd_resume_hw();
 }
+#ifdef CONFIG_HIBERNATION
+extern void  osd_freeze_hw(void);
+extern void  osd_thaw_hw(void);
+extern void  osd_restore_hw(void);
+
+void  osddev_freeze(void)
+{
+	osd_freeze_hw();
+}
+void osddev_thaw(void)
+{
+	osd_thaw_hw();
+}
+void osddev_restore(void)
+{
+	osd_restore_hw();
+}
+#endif
diff --git a/drivers/amlogic/display/osd/osd_hw.c b/drivers/amlogic/display/osd/osd_hw.c
index 0d98f90b..e35cf6df 100644
--- a/drivers/amlogic/display/osd/osd_hw.c
+++ b/drivers/amlogic/display/osd/osd_hw.c
@@ -34,6 +34,12 @@
 #include <linux/amlogic/osd/osd.h>
 #include <linux/amlogic/vout/vout_notify.h>
 #include <linux/amlogic/amports/canvas.h>
+#include <linux/fdtable.h>
+#include <linux/file.h>
+#include <linux/list.h>
+#include <linux/kthread.h>
+#include <sw_sync.h>
+#include <sync.h>
 #include "osd_log.h"
 #include <linux/amlogic/amlog.h>
 #include <linux/amlogic/amports/vframe_receiver.h>
@@ -42,25 +48,58 @@
 #include "osd_antiflicker.h"
 #include "osd_clone.h"
 
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV
+#include <mach/vpu.h>
+#define OSD_SUPER_SCALER_MEM_POWER_ON() \
+	do { \
+		switch_vpu_mem_pd_vmod(VPU_VIU_OSD_SCALE, VPU_MEM_POWER_ON); \
+	} while (0)
+#define OSD_SUPER_SCALER_MEM_POWER_OFF() \
+	do { \
+		switch_vpu_mem_pd_vmod(VPU_VIU_OSD_SCALE, VPU_MEM_POWER_DOWN); \
+	} while (0)
+#endif
+
+
 #ifdef CONFIG_AML_VSYNC_FIQ_ENABLE
 #define  FIQ_VSYNC
 #endif
 
+
 #ifdef CONFIG_VSYNC_RDMA
 int reset_rdma(void);
 int osd_rdma_enable(u32  enable);
+int read_rdma_table(void);
 #endif
 
+static DEFINE_MUTEX(osd_mutex);
 static DEFINE_SPINLOCK(osd_onoff_lock);
 static DECLARE_WAIT_QUEUE_HEAD(osd_vsync_wq);
 
 static bool vsync_hit = false;
 static bool osd_vf_need_update = false;
+static bool osd_update_window_axis = false;
 #ifdef CONFIG_AM_FB_EXT
 extern void osd_ext_clone_pan(u32 index);
 #endif
 extern void osd_clone_pan(u32 index, u32 yoffset, int debug_flag);
 
+#ifdef  CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
+//add sync fence relative varible here.
+//we will limit all fence relative code in this driver file.
+static int  timeline_created = 0;
+static struct  sw_sync_timeline *timeline;
+static u32  cur_streamline_val;
+//thread control part
+struct kthread_worker buffer_toggle_worker;
+struct task_struct *buffer_toggle_thread;
+struct kthread_work buffer_toggle_work;
+struct list_head	post_fence_list;
+struct mutex		post_fence_list_lock;
+
+void osd_pan_display_fence(osd_fence_map_t *fence_map);
+#endif
+
 static struct vframe_provider_s osd_vf_prov;
 static int  g_vf_visual_width;
 static int  g_vf_width;
@@ -73,125 +112,292 @@ static int osd_v_filter_mode = 1;
 static int use_h_filter_mode = -1;
 static int use_v_filter_mode = -1;
 static unsigned int osd_filter_coefs_bicubic_sharp[] = {
-    0x01fa008c, 0x01fa0100, 0xff7f0200, 0xfe7f0300,
-    0xfd7e0500, 0xfc7e0600, 0xfb7d0800, 0xfb7c0900,
-    0xfa7b0b00, 0xfa7a0dff, 0xf9790fff, 0xf97711ff,
-    0xf87613ff, 0xf87416fe, 0xf87218fe, 0xf8701afe,
-    0xf76f1dfd, 0xf76d1ffd, 0xf76b21fd, 0xf76824fd,
-    0xf76627fc, 0xf76429fc, 0xf7612cfc, 0xf75f2ffb,
-    0xf75d31fb, 0xf75a34fb, 0xf75837fa, 0xf7553afa,
-    0xf8523cfa, 0xf8503ff9, 0xf84d42f9, 0xf84a45f9,
-    0xf84848f8
+	0x01fa008c, 0x01fa0100, 0xff7f0200, 0xfe7f0300,
+	0xfd7e0500, 0xfc7e0600, 0xfb7d0800, 0xfb7c0900,
+	0xfa7b0b00, 0xfa7a0dff, 0xf9790fff, 0xf97711ff,
+	0xf87613ff, 0xf87416fe, 0xf87218fe, 0xf8701afe,
+	0xf76f1dfd, 0xf76d1ffd, 0xf76b21fd, 0xf76824fd,
+	0xf76627fc, 0xf76429fc, 0xf7612cfc, 0xf75f2ffb,
+	0xf75d31fb, 0xf75a34fb, 0xf75837fa, 0xf7553afa,
+	0xf8523cfa, 0xf8503ff9, 0xf84d42f9, 0xf84a45f9,
+	0xf84848f8
 };
 
-static unsigned int osd_filter_coefs_bicubic[] =   //bicubic	coef0
-{
-    0x00800000, 0x007f0100, 0xff7f0200, 0xfe7f0300, 0xfd7e0500, 0xfc7e0600,
-    0xfb7d0800, 0xfb7c0900, 0xfa7b0b00, 0xfa7a0dff, 0xf9790fff, 0xf97711ff,
-    0xf87613ff, 0xf87416fe, 0xf87218fe, 0xf8701afe, 0xf76f1dfd, 0xf76d1ffd,
-    0xf76b21fd, 0xf76824fd, 0xf76627fc, 0xf76429fc, 0xf7612cfc, 0xf75f2ffb,
-    0xf75d31fb, 0xf75a34fb, 0xf75837fa, 0xf7553afa, 0xf8523cfa, 0xf8503ff9,
-    0xf84d42f9, 0xf84a45f9, 0xf84848f8
+static unsigned int osd_filter_coefs_bicubic[] = { //bicubic	coef0
+	0x00800000, 0x007f0100, 0xff7f0200, 0xfe7f0300, 0xfd7e0500, 0xfc7e0600,
+	0xfb7d0800, 0xfb7c0900, 0xfa7b0b00, 0xfa7a0dff, 0xf9790fff, 0xf97711ff,
+	0xf87613ff, 0xf87416fe, 0xf87218fe, 0xf8701afe, 0xf76f1dfd, 0xf76d1ffd,
+	0xf76b21fd, 0xf76824fd, 0xf76627fc, 0xf76429fc, 0xf7612cfc, 0xf75f2ffb,
+	0xf75d31fb, 0xf75a34fb, 0xf75837fa, 0xf7553afa, 0xf8523cfa, 0xf8503ff9,
+	0xf84d42f9, 0xf84a45f9, 0xf84848f8
 };
 
-static unsigned int osd_filter_coefs_bilinear[] =  //2 point bilinear	coef1
-{
-    0x00800000, 0x007e0200, 0x007c0400, 0x007a0600, 0x00780800, 0x00760a00,
-    0x00740c00, 0x00720e00, 0x00701000, 0x006e1200, 0x006c1400, 0x006a1600,
-    0x00681800, 0x00661a00, 0x00641c00, 0x00621e00, 0x00602000, 0x005e2200,
-    0x005c2400, 0x005a2600, 0x00582800, 0x00562a00, 0x00542c00, 0x00522e00,
-    0x00503000, 0x004e3200, 0x004c3400, 0x004a3600, 0x00483800, 0x00463a00,
-    0x00443c00, 0x00423e00, 0x00404000
+static unsigned int osd_filter_coefs_bilinear[] = { //2 point bilinear	coef1
+	0x00800000, 0x007e0200, 0x007c0400, 0x007a0600, 0x00780800, 0x00760a00,
+	0x00740c00, 0x00720e00, 0x00701000, 0x006e1200, 0x006c1400, 0x006a1600,
+	0x00681800, 0x00661a00, 0x00641c00, 0x00621e00, 0x00602000, 0x005e2200,
+	0x005c2400, 0x005a2600, 0x00582800, 0x00562a00, 0x00542c00, 0x00522e00,
+	0x00503000, 0x004e3200, 0x004c3400, 0x004a3600, 0x00483800, 0x00463a00,
+	0x00443c00, 0x00423e00, 0x00404000
 };
 
-static unsigned int osd_filter_coefs_2point_binilear[] =  //2 point bilinear, bank_length == 2	coef2
-{
-    0x80000000, 0x7e020000, 0x7c040000, 0x7a060000, 0x78080000, 0x760a0000,
-    0x740c0000, 0x720e0000, 0x70100000, 0x6e120000, 0x6c140000, 0x6a160000,
-    0x68180000, 0x661a0000, 0x641c0000, 0x621e0000, 0x60200000, 0x5e220000,
-    0x5c240000, 0x5a260000, 0x58280000, 0x562a0000, 0x542c0000, 0x522e0000,
-    0x50300000, 0x4e320000, 0x4c340000, 0x4a360000, 0x48380000, 0x463a0000,
-    0x443c0000, 0x423e0000, 0x40400000
+static unsigned int osd_filter_coefs_2point_binilear[]
+= { //2 point bilinear, bank_length == 2	coef2
+	0x80000000, 0x7e020000, 0x7c040000, 0x7a060000, 0x78080000, 0x760a0000,
+	0x740c0000, 0x720e0000, 0x70100000, 0x6e120000, 0x6c140000, 0x6a160000,
+	0x68180000, 0x661a0000, 0x641c0000, 0x621e0000, 0x60200000, 0x5e220000,
+	0x5c240000, 0x5a260000, 0x58280000, 0x562a0000, 0x542c0000, 0x522e0000,
+	0x50300000, 0x4e320000, 0x4c340000, 0x4a360000, 0x48380000, 0x463a0000,
+	0x443c0000, 0x423e0000, 0x40400000
 };
 
 //filt_triangle, point_num =3, filt_len =2.6, group_num = 64
 static unsigned int osd_filter_coefs_3point_triangle_sharp[] = {
-    0x40400000, 0x3e420000, 0x3d430000, 0x3b450000,
-    0x3a460000, 0x38480000, 0x37490000, 0x354b0000,
-    0x344c0000, 0x324e0000, 0x314f0000, 0x2f510000,
-    0x2e520000, 0x2c540000, 0x2b550000, 0x29570000,
-    0x28580000, 0x265a0000, 0x245c0000, 0x235d0000,
-    0x215f0000, 0x20600000, 0x1e620000, 0x1d620100,
-    0x1b620300, 0x19630400, 0x17630600, 0x15640700,
-    0x14640800, 0x12640a00, 0x11640b00, 0x0f650c00,
-    0x0d660d00
+	0x40400000, 0x3e420000, 0x3d430000, 0x3b450000,
+	0x3a460000, 0x38480000, 0x37490000, 0x354b0000,
+	0x344c0000, 0x324e0000, 0x314f0000, 0x2f510000,
+	0x2e520000, 0x2c540000, 0x2b550000, 0x29570000,
+	0x28580000, 0x265a0000, 0x245c0000, 0x235d0000,
+	0x215f0000, 0x20600000, 0x1e620000, 0x1d620100,
+	0x1b620300, 0x19630400, 0x17630600, 0x15640700,
+	0x14640800, 0x12640a00, 0x11640b00, 0x0f650c00,
+	0x0d660d00
 };
 
 static unsigned int osd_filter_coefs_3point_triangle[] = {
-    0x40400000, 0x3f400100, 0x3d410200, 0x3c410300,
-    0x3a420400, 0x39420500, 0x37430600, 0x36430700,
-    0x35430800, 0x33450800, 0x32450900, 0x31450a00,
-    0x30450b00, 0x2e460c00, 0x2d460d00, 0x2c470d00,
-    0x2b470e00, 0x29480f00, 0x28481000, 0x27481100,
-    0x26491100, 0x25491200, 0x24491300, 0x234a1300,
-    0x224a1400, 0x214a1500, 0x204a1600, 0x1f4b1600,
-    0x1e4b1700, 0x1d4b1800, 0x1c4c1800, 0x1b4c1900,
-    0x1a4c1a00
+	0x40400000, 0x3f400100, 0x3d410200, 0x3c410300,
+	0x3a420400, 0x39420500, 0x37430600, 0x36430700,
+	0x35430800, 0x33450800, 0x32450900, 0x31450a00,
+	0x30450b00, 0x2e460c00, 0x2d460d00, 0x2c470d00,
+	0x2b470e00, 0x29480f00, 0x28481000, 0x27481100,
+	0x26491100, 0x25491200, 0x24491300, 0x234a1300,
+	0x224a1400, 0x214a1500, 0x204a1600, 0x1f4b1600,
+	0x1e4b1700, 0x1d4b1800, 0x1c4c1800, 0x1b4c1900,
+	0x1a4c1a00
 };
 
 static unsigned int osd_filter_coefs_4point_triangle[] = {
-    0x20402000, 0x20402000, 0x1f3f2101, 0x1f3f2101,
-    0x1e3e2202, 0x1e3e2202, 0x1d3d2303, 0x1d3d2303,
-    0x1c3c2404, 0x1c3c2404, 0x1b3b2505, 0x1b3b2505,
-    0x1a3a2606, 0x1a3a2606, 0x19392707, 0x19392707,
-    0x18382808, 0x18382808, 0x17372909, 0x17372909,
-    0x16362a0a, 0x16362a0a, 0x15352b0b, 0x15352b0b,
-    0x14342c0c, 0x14342c0c, 0x13332d0d, 0x13332d0d,
-    0x12322e0e, 0x12322e0e, 0x11312f0f, 0x11312f0f,
-    0x10303010
+	0x20402000, 0x20402000, 0x1f3f2101, 0x1f3f2101,
+	0x1e3e2202, 0x1e3e2202, 0x1d3d2303, 0x1d3d2303,
+	0x1c3c2404, 0x1c3c2404, 0x1b3b2505, 0x1b3b2505,
+	0x1a3a2606, 0x1a3a2606, 0x19392707, 0x19392707,
+	0x18382808, 0x18382808, 0x17372909, 0x17372909,
+	0x16362a0a, 0x16362a0a, 0x15352b0b, 0x15352b0b,
+	0x14342c0c, 0x14342c0c, 0x13332d0d, 0x13332d0d,
+	0x12322e0e, 0x12322e0e, 0x11312f0f, 0x11312f0f,
+	0x10303010
 };
 
 // 4th order (cubic) b-spline
 //filt_cubic point_num =4, filt_len =4, group_num = 64
 static unsigned int vpp_filter_coefs_4point_bspline[] = {
-    0x15561500, 0x14561600, 0x13561700, 0x12561800,
-    0x11551a00, 0x11541b00, 0x10541c00, 0x0f541d00,
-    0x0f531e00, 0x0e531f00, 0x0d522100, 0x0c522200,
-    0x0b522300, 0x0b512400, 0x0a502600, 0x0a4f2700,
-    0x094e2900, 0x084e2a00, 0x084d2b00, 0x074c2c01,
-    0x074b2d01, 0x064a2f01, 0x06493001, 0x05483201,
-    0x05473301, 0x05463401, 0x04453601, 0x04433702,
-    0x04423802, 0x03413a02, 0x03403b02, 0x033f3c02,
-    0x033d3d03
+	0x15561500, 0x14561600, 0x13561700, 0x12561800,
+	0x11551a00, 0x11541b00, 0x10541c00, 0x0f541d00,
+	0x0f531e00, 0x0e531f00, 0x0d522100, 0x0c522200,
+	0x0b522300, 0x0b512400, 0x0a502600, 0x0a4f2700,
+	0x094e2900, 0x084e2a00, 0x084d2b00, 0x074c2c01,
+	0x074b2d01, 0x064a2f01, 0x06493001, 0x05483201,
+	0x05473301, 0x05463401, 0x04453601, 0x04433702,
+	0x04423802, 0x03413a02, 0x03403b02, 0x033f3c02,
+	0x033d3d03
 };
 
 //filt_quadratic, point_num =3, filt_len =3, group_num = 64
 static unsigned int osd_filter_coefs_3point_bspline[] = {
-    0x40400000, 0x3e420000, 0x3c440000, 0x3a460000,
-    0x38480000, 0x364a0000, 0x344b0100, 0x334c0100,
-    0x314e0100, 0x304f0100, 0x2e500200, 0x2c520200,
-    0x2a540200, 0x29540300, 0x27560300, 0x26570300,
-    0x24580400, 0x23590400, 0x215a0500, 0x205b0500,
-    0x1e5c0600, 0x1d5c0700, 0x1c5d0700, 0x1a5e0800,
-    0x195e0900, 0x185e0a00, 0x175f0a00, 0x15600b00,
-    0x14600c00, 0x13600d00, 0x12600e00, 0x11600f00,
-    0x10601000
+	0x40400000, 0x3e420000, 0x3c440000, 0x3a460000,
+	0x38480000, 0x364a0000, 0x344b0100, 0x334c0100,
+	0x314e0100, 0x304f0100, 0x2e500200, 0x2c520200,
+	0x2a540200, 0x29540300, 0x27560300, 0x26570300,
+	0x24580400, 0x23590400, 0x215a0500, 0x205b0500,
+	0x1e5c0600, 0x1d5c0700, 0x1c5d0700, 0x1a5e0800,
+	0x195e0900, 0x185e0a00, 0x175f0a00, 0x15600b00,
+	0x14600c00, 0x13600d00, 0x12600e00, 0x11600f00,
+	0x10601000
 };
 
- static unsigned int *filter_table[] = {
-     osd_filter_coefs_bicubic_sharp,
-     osd_filter_coefs_bicubic,
-     osd_filter_coefs_bilinear,
-     osd_filter_coefs_2point_binilear,
-     osd_filter_coefs_3point_triangle_sharp,
-     osd_filter_coefs_3point_triangle,
-     osd_filter_coefs_4point_triangle,
-     vpp_filter_coefs_4point_bspline,
-     osd_filter_coefs_3point_bspline
- };
+static unsigned int *filter_table[] = {
+	osd_filter_coefs_bicubic_sharp,
+	osd_filter_coefs_bicubic,
+	osd_filter_coefs_bilinear,
+	osd_filter_coefs_2point_binilear,
+	osd_filter_coefs_3point_triangle_sharp,
+	osd_filter_coefs_3point_triangle,
+	osd_filter_coefs_4point_triangle,
+	vpp_filter_coefs_4point_bspline,
+	osd_filter_coefs_3point_bspline
+};
 
 #define OSD_TYPE_TOP_FIELD 0
 #define OSD_TYPE_BOT_FIELD 1
+
+/********************************************************************/
+/***********		osd fence relative code 	 			*****************/
+/********************************************************************/
+
+#ifdef  CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
+static inline  int  find_buf_num(u32 yres, u32 yoffset)
+{
+	int n = yres;
+	int i;
+	for (i = 0; i < MAX_BUF_NUM; i++) { //find current addr position.
+		if (yoffset  < (n))
+			break;
+		n += yres;
+	}
+	return i;
+}
+
+/*void osd_wait_vsync_hw(void)
+{
+        vsync_hit = false;
+        wait_event_interruptible_timeout(osd_vsync_wq, vsync_hit, HZ);
+}*/
+
+//next we will process two osd layer in toggle buffer.
+static void osd_toggle_buffer(struct kthread_work *work)
+{
+	osd_fence_map_t *data, *next;
+	struct list_head saved_list;
+
+	mutex_lock(&post_fence_list_lock);
+	saved_list = post_fence_list;
+	list_replace_init(&post_fence_list, &saved_list);
+	mutex_unlock(&post_fence_list_lock);
+
+	list_for_each_entry_safe(data, next, &saved_list, list) {
+		//printk("osd_toggle_buffer the save_list is not NULL\n");
+		osd_pan_display_fence(data);
+		if (data->in_fence)
+			sync_fence_put(data->in_fence);
+		if (data->in_fd > 0)
+			__close_fd(data->files, data->in_fd);
+		list_del(&data->list);
+		kfree(data);
+	}
+}
+
+static int out_fence_create(int *release_fence_fd, u32 *val, u32 buf_num)
+{
+	//the first time create out_fence_fd==0
+	//sw_sync_timeline_inc  will release fence and it's sync point
+	struct sync_pt *outer_sync_pt;
+	struct sync_fence *outer_fence;
+	int out_fence_fd = -1;
+
+	out_fence_fd = get_unused_fd();
+	if (out_fence_fd < 0) return -1; //no file descriptor could be used. Error.
+	if (!timeline_created) { //timeline has not been created
+		timeline = sw_sync_timeline_create("osd_timeline");
+		cur_streamline_val = 1;
+		if (NULL == timeline)
+			return -1;
+		init_kthread_worker(&buffer_toggle_worker);
+		buffer_toggle_thread = kthread_run(kthread_worker_fn,
+						   &buffer_toggle_worker, "aml_buf_toggle");
+		init_kthread_work(&buffer_toggle_work, osd_toggle_buffer);
+		timeline_created = 1;
+	}
+	//install fence map; first ,the simplest.
+	cur_streamline_val++;
+	*val = cur_streamline_val;
+
+	outer_sync_pt = sw_sync_pt_create(timeline, *val);
+	if (NULL == outer_sync_pt)
+		goto error_ret;
+
+	outer_fence = sync_fence_create("osd_fence_out",
+					outer_sync_pt); //fence object will be released when no point
+	if (NULL == outer_fence) {
+		sync_pt_free(outer_sync_pt); //free sync point.
+		goto error_ret;
+	}
+
+	sync_fence_install(outer_fence, out_fence_fd);
+	amlog_mask_level(LOG_MASK_HARDWARE, LOG_LEVEL_LOW,
+			 "---------------------------------------\n");
+	amlog_mask_level(LOG_MASK_HARDWARE, LOG_LEVEL_LOW, "return out fence fd:%d\n",
+			 out_fence_fd);
+	*release_fence_fd = out_fence_fd;
+	return out_fence_fd;
+
+error_ret:
+	cur_streamline_val--; //pt or fence fail,restore timeline value.
+	amlog_level(LOG_LEVEL_HIGH, "fence obj create fail\n");
+	put_unused_fd(out_fence_fd);
+	return -1;
+
+}
+
+int osd_sync_request(u32 index, u32 yres, u32 xoffset, u32 yoffset,
+		     s32 in_fence_fd)
+{
+	int out_fence_fd = -1;
+	int buf_num = 0;
+
+	osd_fence_map_t *fence_map = kzalloc(sizeof(osd_fence_map_t), GFP_KERNEL);
+	buf_num = find_buf_num(yres, yoffset);
+
+	if (!fence_map) {
+		printk("could not allocate osd_fence_map\n");
+		return -ENOMEM;
+	}
+
+	mutex_lock(&post_fence_list_lock);
+	fence_map->fb_index = index;
+	fence_map->buf_num = buf_num;
+	fence_map->yoffset = yoffset;
+	fence_map->xoffset = xoffset;
+	fence_map->yres = yres;
+	fence_map->in_fd = in_fence_fd;
+	fence_map->in_fence = sync_fence_fdget(in_fence_fd);
+	fence_map->files = current->files;
+
+	fence_map->out_fd = out_fence_create(&out_fence_fd, &fence_map->val, buf_num);
+	list_add_tail(&fence_map->list, &post_fence_list);
+	mutex_unlock(&post_fence_list_lock);
+
+	queue_kthread_work(&buffer_toggle_worker, &buffer_toggle_work);
+
+	return  out_fence_fd;
+}
+
+static int  osd_wait_buf_ready(osd_fence_map_t *fence_map)
+{
+	s32 ret = -1;
+	struct sync_fence *buf_ready_fence = NULL;
+
+	if (fence_map->in_fd <= 0) {
+		ret = -1;
+		return ret;
+	}
+
+	buf_ready_fence = fence_map->in_fence;
+	if (NULL == buf_ready_fence) {
+		ret = -1;//no fence ,output directly.
+		return ret;
+	}
+
+	ret = sync_fence_wait(buf_ready_fence, -1);
+	if (ret < 0) {
+		amlog_level(LOG_LEVEL_HIGH, "Sync Fence wait error:%d\n", ret);
+		printk("-----wait buf idx:[%d] ERROR\n-----on screen buf idx:[%d]\n",
+		       fence_map->buf_num, find_buf_num(fence_map->yres,
+							osd_hw.pandata[fence_map->fb_index].y_start));
+	} else
+		ret = 1;
+
+	return ret;
+}
+
+#else
+int osd_sync_request(u32 index, u32 yres, u32 xoffset, u32 yoffset,
+		     s32 in_fence_fd)
+{
+	amlog_level(LOG_LEVEL_HIGH, "osd_sync_request not supported\n");
+	return -5566;
+}
+#endif
+
 /********************************************************************/
 /***********		osd psedu frame provider 			*****************/
 /********************************************************************/
@@ -211,8 +417,7 @@ static vframe_t *osd_vf_get(void *arg)
 }
 
 #define PROVIDER_NAME   "osd"
-static const struct vframe_operations_s osd_vf_provider =
-{
+static const struct vframe_operations_s osd_vf_provider = {
 	.peek = osd_vf_peek,
 	.get  = osd_vf_get,
 	.put  = NULL,
@@ -222,16 +427,12 @@ static const struct vframe_operations_s osd_vf_provider =
 static unsigned char osd_vf_prov_init = 0;
 #endif
 
-static inline void  osd_update_3d_mode(int enable_osd1,int enable_osd2)
+static inline void  osd_update_3d_mode(int enable_osd1, int enable_osd2)
 {
-	if(enable_osd1)
-	{
+	if (enable_osd1)
 		osd1_update_disp_3d_mode();
-	}
-	if(enable_osd2)
-	{
+	if (enable_osd2)
 		osd2_update_disp_3d_mode();
-	}
 }
 
 static inline void wait_vsync_wakeup(void)
@@ -246,58 +447,44 @@ static irqreturn_t osd_rdma_isr(int irq, void *dev_id)
 #define  	VOUT_ENCI	1
 #define   	VOUT_ENCP	2
 #define	VOUT_ENCT	3
-	unsigned  int  fb0_cfg_w0,fb1_cfg_w0;
+	unsigned  int  fb0_cfg_w0, fb1_cfg_w0;
 	unsigned  int  odd_or_even_line;
 	unsigned  int  scan_line_number = 0;
-	unsigned  char output_type=0;
+	unsigned  char output_type = 0;
 
-	do{
-		if((aml_read_reg32(P_RDMA_STATUS)&0x0fffff0f) == 0){
-			break;
-		}
-	}while(1);
-
-#ifdef CONFIG_VSYNC_RDMA
 	reset_rdma();
-#endif
-
-	output_type=aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)&0x3;
-	osd_hw.scan_mode= SCAN_MODE_PROGRESSIVE;
-	switch(output_type)
-	{
-		case VOUT_ENCP:
-			if (aml_read_reg32(P_ENCP_VIDEO_MODE) & (1 << 12)) //1080i
-				osd_hw.scan_mode= SCAN_MODE_INTERLACE;
-			break;
-		case VOUT_ENCI:
-			if (aml_read_reg32(P_ENCI_VIDEO_EN) & 1)
-				osd_hw.scan_mode= SCAN_MODE_INTERLACE;
-			break;
+	read_rdma_table();
+	output_type = aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL) & 0x3;
+	osd_hw.scan_mode = SCAN_MODE_PROGRESSIVE;
+	switch (output_type) {
+	case VOUT_ENCP:
+		if (aml_read_reg32(P_ENCP_VIDEO_MODE) & (1 << 12)) //1080i
+			osd_hw.scan_mode = SCAN_MODE_INTERLACE;
+		break;
+	case VOUT_ENCI:
+		if (aml_read_reg32(P_ENCI_VIDEO_EN) & 1)
+			osd_hw.scan_mode = SCAN_MODE_INTERLACE;
+		break;
 	}
 
-	if(osd_hw.free_scale_enable[OSD1])
-	{
-		osd_hw.scan_mode= SCAN_MODE_PROGRESSIVE;
-	}
+	if (osd_hw.free_scale_enable[OSD1])
+		osd_hw.scan_mode = SCAN_MODE_PROGRESSIVE;
 
-	if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
-	{
-		fb0_cfg_w0=aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W0);
-		fb1_cfg_w0=aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W0+ REG_OFFSET);
-		if (aml_read_reg32(P_ENCP_VIDEO_MODE) & (1 << 12))
-		{
+	if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
+		fb0_cfg_w0 = aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W0);
+		fb1_cfg_w0 = aml_read_reg32(P_VIU_OSD2_BLK0_CFG_W0);
+		if (aml_read_reg32(P_ENCP_VIDEO_MODE) & (1 << 12)) {
 			/* 1080I */
-			scan_line_number = ((aml_read_reg32(P_ENCP_INFO_READ))&0x1fff0000)>>16;
-			if ((osd_hw.pandata[OSD1].y_start%2) == 0)
-			{
-				if (scan_line_number >= 562){
+			scan_line_number = ((aml_read_reg32(P_ENCP_INFO_READ)) & 0x1fff0000) >> 16;
+			if ((osd_hw.pandata[OSD1].y_start % 2) == 0) {
+				if (scan_line_number >= 562) {
 					/* bottom field, odd lines*/
 					odd_or_even_line = 0;	//vsync enable when the next vsync trigger
 				} else {
 					/* top field, even lines*/
 					odd_or_even_line = 1;
 				}
-			}else{
+			} else {
 				if (scan_line_number >= 562) {
 					/* top field, even lines*/
 					odd_or_even_line = 1;
@@ -307,41 +494,39 @@ static irqreturn_t osd_rdma_isr(int irq, void *dev_id)
 				}
 			}
 		} else {
-			if ((osd_hw.pandata[OSD1].y_start%2) == 1){
-				odd_or_even_line = (aml_read_reg32(P_ENCI_INFO_READ) & (1<<29)) ?
-									OSD_TYPE_BOT_FIELD : OSD_TYPE_TOP_FIELD;
-			}else{
-				odd_or_even_line = (aml_read_reg32(P_ENCI_INFO_READ) & (1<<29)) ?
-									OSD_TYPE_TOP_FIELD : OSD_TYPE_BOT_FIELD;
+			if ((osd_hw.pandata[OSD1].y_start % 2) == 1) {
+				odd_or_even_line = (aml_read_reg32(P_ENCI_INFO_READ) & (1 << 29)) ?
+						   OSD_TYPE_BOT_FIELD : OSD_TYPE_TOP_FIELD;
+			} else {
+				odd_or_even_line = (aml_read_reg32(P_ENCI_INFO_READ) & (1 << 29)) ?
+						   OSD_TYPE_TOP_FIELD : OSD_TYPE_BOT_FIELD;
 			}
 		}
 
-		fb0_cfg_w0 &=~1;
-		fb1_cfg_w0 &=~1;
-		fb0_cfg_w0 |=odd_or_even_line;
-		fb1_cfg_w0 |=odd_or_even_line;
+		fb0_cfg_w0 &= ~1;
+		fb1_cfg_w0 &= ~1;
+		fb0_cfg_w0 |= odd_or_even_line;
+		fb1_cfg_w0 |= odd_or_even_line;
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W0, fb0_cfg_w0);
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK1_CFG_W0, fb0_cfg_w0);
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK2_CFG_W0, fb0_cfg_w0);
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK3_CFG_W0, fb0_cfg_w0);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W0+ REG_OFFSET, fb1_cfg_w0);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK1_CFG_W0+ REG_OFFSET, fb1_cfg_w0);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK2_CFG_W0+ REG_OFFSET, fb1_cfg_w0);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK3_CFG_W0+ REG_OFFSET, fb1_cfg_w0);
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W0, fb1_cfg_w0);
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK1_CFG_W0, fb1_cfg_w0);
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK2_CFG_W0, fb1_cfg_w0);
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK3_CFG_W0, fb1_cfg_w0);
 	}
 
-	osd_update_3d_mode(osd_hw.mode_3d[OSD1].enable,osd_hw.mode_3d[OSD2].enable);
+	osd_update_3d_mode(osd_hw.mode_3d[OSD1].enable, osd_hw.mode_3d[OSD2].enable);
 
-	if (!vsync_hit)
-	{
+	if (!vsync_hit) {
 #ifdef FIQ_VSYNC
 		fiq_bridge_pulse_trigger(&osd_hw.fiq_handle_item);
 #else
 		wait_vsync_wakeup();
 #endif
 	}
-
-	aml_write_reg32(P_RDMA_CTRL, 1<<24);
+	aml_write_reg32(P_RDMA_CTRL, 1 << 24);
 
 	return IRQ_HANDLED;
 }
@@ -349,16 +534,13 @@ static irqreturn_t osd_rdma_isr(int irq, void *dev_id)
 
 static inline void  walk_through_update_list(void)
 {
-	u32  i,j;
-	for(i=0;i<HW_OSD_COUNT;i++)
-	{
-		j=0;
-		while(osd_hw.updated[i] && j<32)
-		{
-			if(osd_hw.updated[i]&(1<<j))
-			{
+	u32  i, j;
+	for (i = 0; i < HW_OSD_COUNT; i++) {
+		j = 0;
+		while (osd_hw.updated[i] && j < 32) {
+			if (osd_hw.updated[i] & (1 << j)) {
 				osd_hw.reg[i][j].update_func();
-				remove_from_update_list(i,j);
+				remove_from_update_list(i, j);
 			}
 			j++;
 		}
@@ -388,48 +570,42 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 #define   	VOUT_ENCP	2
 #define	VOUT_ENCT	3
 
-	unsigned  int  fb0_cfg_w0,fb1_cfg_w0;
+	unsigned  int  fb0_cfg_w0, fb1_cfg_w0;
 	unsigned  int  odd_or_even_line;
 	unsigned  int  scan_line_number = 0;
-	unsigned  char output_type=0;
+	unsigned  char output_type = 0;
 
-	output_type=aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)&0x3;
-	osd_hw.scan_mode= SCAN_MODE_PROGRESSIVE;
-	switch(output_type)
-	{
-		case VOUT_ENCP:
-			if (aml_read_reg32(P_ENCP_VIDEO_MODE) & (1 << 12)) //1080i
-				osd_hw.scan_mode= SCAN_MODE_INTERLACE;
-			break;
-		case VOUT_ENCI:
-			if (aml_read_reg32(P_ENCI_VIDEO_EN) & 1)
-				osd_hw.scan_mode= SCAN_MODE_INTERLACE;
-			break;
+	output_type = aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL) & 0x3;
+	osd_hw.scan_mode = SCAN_MODE_PROGRESSIVE;
+	switch (output_type) {
+	case VOUT_ENCP:
+		if (aml_read_reg32(P_ENCP_VIDEO_MODE) & (1 << 12)) //1080i
+			osd_hw.scan_mode = SCAN_MODE_INTERLACE;
+		break;
+	case VOUT_ENCI:
+		if (aml_read_reg32(P_ENCI_VIDEO_EN) & 1)
+			osd_hw.scan_mode = SCAN_MODE_INTERLACE;
+		break;
 	}
 
-	if(osd_hw.free_scale_enable[OSD1])
-	{
-		osd_hw.scan_mode= SCAN_MODE_PROGRESSIVE;
-	}
+	if (osd_hw.free_scale_enable[OSD1])
+		osd_hw.scan_mode = SCAN_MODE_PROGRESSIVE;
 
-	if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
-	{
-		fb0_cfg_w0=aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W0);
-		fb1_cfg_w0=aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W0+ REG_OFFSET);
-		if (aml_read_reg32(P_ENCP_VIDEO_MODE) & (1 << 12))
-		{
+	if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
+		fb0_cfg_w0 = aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W0);
+		fb1_cfg_w0 = aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W0 + REG_OFFSET);
+		if (aml_read_reg32(P_ENCP_VIDEO_MODE) & (1 << 12)) {
 			/* 1080I */
-			scan_line_number = ((aml_read_reg32(P_ENCP_INFO_READ))&0x1fff0000)>>16;
-			if ((osd_hw.pandata[OSD1].y_start%2) == 0)
-			{
-				if (scan_line_number >= 562){
+			scan_line_number = ((aml_read_reg32(P_ENCP_INFO_READ)) & 0x1fff0000) >> 16;
+			if ((osd_hw.pandata[OSD1].y_start % 2) == 0) {
+				if (scan_line_number >= 562) {
 					/* bottom field, odd lines*/
 					odd_or_even_line = 1;
 				} else {
 					/* top field, even lines*/
 					odd_or_even_line = 0;
 				}
-			}else{
+			} else {
 				if (scan_line_number >= 562) {
 					/* top field, even lines*/
 					odd_or_even_line = 0;
@@ -439,30 +615,29 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 				}
 			}
 		} else {
-			if ((osd_hw.pandata[OSD1].y_start%2) == 0){
+			if ((osd_hw.pandata[OSD1].y_start % 2) == 0)
 				odd_or_even_line = aml_read_reg32(P_ENCI_INFO_READ) & 1;
-			}else{
+			else
 				odd_or_even_line = !(aml_read_reg32(P_ENCI_INFO_READ) & 1);
-			}
 		}
 
-		fb0_cfg_w0 &=~1;
-		fb1_cfg_w0 &=~1;
-		fb0_cfg_w0 |=odd_or_even_line;
-		fb1_cfg_w0 |=odd_or_even_line;
+		fb0_cfg_w0 &= ~1;
+		fb1_cfg_w0 &= ~1;
+		fb0_cfg_w0 |= odd_or_even_line;
+		fb1_cfg_w0 |= odd_or_even_line;
 		aml_write_reg32(P_VIU_OSD1_BLK0_CFG_W0, fb0_cfg_w0);
 		aml_write_reg32(P_VIU_OSD1_BLK1_CFG_W0, fb0_cfg_w0);
 		aml_write_reg32(P_VIU_OSD1_BLK2_CFG_W0, fb0_cfg_w0);
 		aml_write_reg32(P_VIU_OSD1_BLK3_CFG_W0, fb0_cfg_w0);
-		aml_write_reg32(P_VIU_OSD1_BLK0_CFG_W0+ REG_OFFSET, fb1_cfg_w0);
-		aml_write_reg32(P_VIU_OSD1_BLK1_CFG_W0+ REG_OFFSET, fb1_cfg_w0);
-		aml_write_reg32(P_VIU_OSD1_BLK2_CFG_W0+ REG_OFFSET, fb1_cfg_w0);
-		aml_write_reg32(P_VIU_OSD1_BLK3_CFG_W0+ REG_OFFSET, fb1_cfg_w0);
+		aml_write_reg32(P_VIU_OSD1_BLK0_CFG_W0 + REG_OFFSET, fb1_cfg_w0);
+		aml_write_reg32(P_VIU_OSD1_BLK1_CFG_W0 + REG_OFFSET, fb1_cfg_w0);
+		aml_write_reg32(P_VIU_OSD1_BLK2_CFG_W0 + REG_OFFSET, fb1_cfg_w0);
+		aml_write_reg32(P_VIU_OSD1_BLK3_CFG_W0 + REG_OFFSET, fb1_cfg_w0);
 	}
 	//go through update list
 	walk_through_update_list();
 
-	osd_update_3d_mode(osd_hw.mode_3d[OSD1].enable,osd_hw.mode_3d[OSD2].enable);
+	osd_update_3d_mode(osd_hw.mode_3d[OSD1].enable, osd_hw.mode_3d[OSD2].enable);
 #endif
 
 #if 0
@@ -472,8 +647,7 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 #endif
 
 #ifndef CONFIG_VSYNC_RDMA
-	if (!vsync_hit)
-	{
+	if (!vsync_hit) {
 #ifdef FIQ_VSYNC
 		fiq_bridge_pulse_trigger(&osd_hw.fiq_handle_item);
 #else
@@ -490,13 +664,22 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 void osd_wait_vsync_hw(void)
 {
 	vsync_hit = false;
-
 	wait_event_interruptible_timeout(osd_vsync_wq, vsync_hit, HZ);
 }
 
-void osd_set_scan_mode(int index)
+s32 osd_wait_vsync_event(void)
+{
+	vsync_hit = false;
+	wait_event_interruptible_timeout(osd_vsync_wq, vsync_hit,
+					 1); //waiting for 10ms.
+	return 0;
+}
+
+int osd_set_scan_mode(int index)
 {
 	const vinfo_t *vinfo;
+	u32 data32 = 0x0;
+	int real_scan_mode;
 
 	osd_hw.scan_mode = SCAN_MODE_PROGRESSIVE;
 	vinfo = get_current_vinfo();
@@ -507,68 +690,72 @@ void osd_set_scan_mode(int index)
 		case VMODE_480CVBS:
 		case VMODE_576I:
 		case VMODE_576CVBS:
-			if(osd_hw.free_scale_mode[index]){
+			if (osd_hw.free_scale_mode[index]) {
 				osd_hw.field_out_en = 1;
 
-				if(osd_hw.free_scale_data[index].y_end == 719){
+				if (osd_hw.free_scale_data[index].y_end == 719)
 					osd_hw.bot_type = 2;
-				}else if(osd_hw.free_scale_data[index].y_end == 1079){
+				else if (osd_hw.free_scale_data[index].y_end == 1079)
 					osd_hw.bot_type = 3;
-				}else{
+				else
 					osd_hw.bot_type = 2;
-				}
 			}
-			osd_hw.scan_mode = SCAN_MODE_INTERLACE;
-		break;
+			osd_hw.scan_mode = real_scan_mode = SCAN_MODE_INTERLACE;
+			break;
 		case VMODE_1080I:
 		case VMODE_1080I_50HZ:
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 		case VMODE_1080I_59HZ:
 #endif
-			if(osd_hw.free_scale_mode[index]){
+			if (osd_hw.free_scale_mode[index]) {
 				osd_hw.field_out_en = 1;
 
-				if(osd_hw.free_scale_data[index].y_end == 719){
+				if (osd_hw.free_scale_data[index].y_end == 719)
 					osd_hw.bot_type = 1;
-				}else if(osd_hw.free_scale_data[index].y_end == 1079){
+				else if (osd_hw.free_scale_data[index].y_end == 1079)
 					osd_hw.bot_type = 2;
-				}else{
+				else
 					osd_hw.bot_type = 1;
-				}
 			}
-			osd_hw.scan_mode = SCAN_MODE_INTERLACE;
-		break;
+			osd_hw.scan_mode = real_scan_mode = SCAN_MODE_INTERLACE;
+			break;
 		case VMODE_4K2K_24HZ:
 		case VMODE_4K2K_25HZ:
 		case VMODE_4K2K_30HZ:
 		case VMODE_4K2K_SMPTE:
-			if(osd_hw.fb_for_4k2k){
-				if(osd_hw.free_scale_enable[index]){
+			if (osd_hw.fb_for_4k2k) {
+				if (osd_hw.free_scale_enable[index])
 					osd_hw.scale_workaround = 1;
-				}
 			}
 			osd_hw.field_out_en = 0;
-		break;
+			break;
 		default:
-			if(osd_hw.free_scale_mode[index]){
+			if (osd_hw.free_scale_mode[index])
 				osd_hw.field_out_en = 0;
-			}
-		break;
+			break;
 		}
 	}
 
-	if(osd_hw.free_scale_enable[OSD1] || osd_hw.free_scale_enable[OSD2]){
-		osd_hw.scan_mode= SCAN_MODE_PROGRESSIVE;
-	}
+	if (osd_hw.free_scale_enable[index])
+		osd_hw.scan_mode = SCAN_MODE_PROGRESSIVE;
+	if (index == OSD2) {
+		if (real_scan_mode == SCAN_MODE_INTERLACE)
+			return 1;
+		data32 = (aml_read_reg32(P_VIU_OSD2_BLK0_CFG_W0) & 3) >> 1;
+	} else
+		data32 = (aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W0) & 3) >> 1;
+	if (data32 == osd_hw.scan_mode)
+		return 1;
+	else
+		return 0;
 }
 
-void  osd_set_gbl_alpha_hw(u32 index,u32 gbl_alpha)
+void  osd_set_gbl_alpha_hw(u32 index, u32 gbl_alpha)
 {
-	if(osd_hw.gbl_alpha[index] != gbl_alpha)
-	{
+	if (osd_hw.gbl_alpha[index] != gbl_alpha) {
 
-		osd_hw.gbl_alpha[index]=gbl_alpha;
-		add_to_update_list(index,OSD_GBL_ALPHA);
+		osd_hw.gbl_alpha[index] = gbl_alpha;
+		add_to_update_list(index, OSD_GBL_ALPHA);
 
 		osd_wait_vsync_hw();
 	}
@@ -577,174 +764,183 @@ u32  osd_get_gbl_alpha_hw(u32  index)
 {
 	return osd_hw.gbl_alpha[index];
 }
-void  osd_set_colorkey_hw(u32 index,u32 color_index,u32 colorkey )
+void  osd_set_colorkey_hw(u32 index, u32 color_index, u32 colorkey)
 {
-	u8  r=0,g=0,b=0,a=(colorkey&0xff000000)>>24;
+	u8  r = 0, g = 0, b = 0, a = (colorkey & 0xff000000) >> 24;
 	u32	data32;
 
-	colorkey&=0x00ffffff;
-	switch(color_index)
-	{
-		case COLOR_INDEX_16_655:
-			r=(colorkey>>10&0x3f)<<2;
-			g=(colorkey>>5&0x1f)<<3;
-			b=(colorkey&0x1f)<<3;
-			break;
-		case COLOR_INDEX_16_844:
-			r=colorkey>>8&0xff;
-			g=(colorkey>>4&0xf)<<4;
-			b=(colorkey&0xf)<<4;
-			break;
-		case COLOR_INDEX_16_565:
-			r=(colorkey>>11&0x1f)<<3;
-			g=(colorkey>>5&0x3f)<<2;
-			b=(colorkey&0x1f)<<3;
-			break;
-		case COLOR_INDEX_24_888_B:
-			b=colorkey>>16&0xff;
-			g=colorkey>>8&0xff;
-			r=colorkey&0xff;
-			break;
-		case COLOR_INDEX_24_RGB:
-		case COLOR_INDEX_YUV_422:
-			r=colorkey>>16&0xff;
-			g=colorkey>>8&0xff;
-			b=colorkey&0xff;
-			break;
+	colorkey &= 0x00ffffff;
+	switch (color_index) {
+	case COLOR_INDEX_16_655:
+		r = (colorkey >> 10 & 0x3f) << 2;
+		g = (colorkey >> 5 & 0x1f) << 3;
+		b = (colorkey & 0x1f) << 3;
+		break;
+	case COLOR_INDEX_16_844:
+		r = colorkey >> 8 & 0xff;
+		g = (colorkey >> 4 & 0xf) << 4;
+		b = (colorkey & 0xf) << 4;
+		break;
+	case COLOR_INDEX_16_565:
+		r = (colorkey >> 11 & 0x1f) << 3;
+		g = (colorkey >> 5 & 0x3f) << 2;
+		b = (colorkey & 0x1f) << 3;
+		break;
+	case COLOR_INDEX_24_888_B:
+		b = colorkey >> 16 & 0xff;
+		g = colorkey >> 8 & 0xff;
+		r = colorkey & 0xff;
+		break;
+	case COLOR_INDEX_24_RGB:
+	case COLOR_INDEX_YUV_422:
+		r = colorkey >> 16 & 0xff;
+		g = colorkey >> 8 & 0xff;
+		b = colorkey & 0xff;
+		break;
 	}
-	data32=r<<24|g<<16|b<<8|a;
-	if( osd_hw.color_key[index]!=data32)
-	{
-		osd_hw.color_key[index]=data32;
-		amlog_mask_level(LOG_MASK_HARDWARE,LOG_LEVEL_LOW,"bpp:%d--r:0x%x g:0x%x b:0x%x ,a:0x%x\r\n",color_index,r,g,b,a);
-		add_to_update_list(index,OSD_COLOR_KEY);
+	data32 = r << 24 | g << 16 | b << 8 | a;
+	if (osd_hw.color_key[index] != data32) {
+		osd_hw.color_key[index] = data32;
+		amlog_mask_level(LOG_MASK_HARDWARE, LOG_LEVEL_LOW,
+				 "bpp:%d--r:0x%x g:0x%x b:0x%x ,a:0x%x\n", color_index, r, g, b, a);
+		add_to_update_list(index, OSD_COLOR_KEY);
 
 		osd_wait_vsync_hw();
 	}
 
 	return ;
 }
-void  osd_srckey_enable_hw(u32  index,u8 enable)
+void  osd_srckey_enable_hw(u32  index, u8 enable)
 {
-	if(enable != osd_hw.color_key_enable[index])
-	{
-		osd_hw.color_key_enable[index]=enable;
-		add_to_update_list(index,OSD_COLOR_KEY_ENABLE);
+	if (enable != osd_hw.color_key_enable[index]) {
+		osd_hw.color_key_enable[index] = enable;
+		add_to_update_list(index, OSD_COLOR_KEY_ENABLE);
 
 		osd_wait_vsync_hw();
 	}
 
 }
 
-void osd_set_color_mode(int index, const color_bit_define_t *color) {
-    if(color != osd_hw.color_info[index]) {
-        osd_hw.color_info[index] = color;
-        add_to_update_list(index, OSD_COLOR_MODE);
-    }
+void osd_set_color_mode(int index, const color_bit_define_t *color)
+{
+	if (color != osd_hw.color_info[index]) {
+		osd_hw.color_info[index] = color;
+		add_to_update_list(index, OSD_COLOR_MODE);
+	}
 }
 
 void osddev_update_disp_axis_hw(
-		u32 display_h_start,
-		u32 display_h_end,
-		u32 display_v_start,
-		u32 display_v_end,
-		u32 xoffset,
-		u32 yoffset,
-		u32 mode_change,
-		u32 index)
+	u32 display_h_start,
+	u32 display_h_end,
+	u32 display_v_start,
+	u32 display_v_end,
+	u32 xoffset,
+	u32 yoffset,
+	u32 mode_change,
+	u32 index)
 {
 	dispdata_t   disp_data;
 	pandata_t    pan_data;
 
-	if(NULL==osd_hw.color_info[index]) return ;
-	if(mode_change)  //modify pandata .
-	{
-		add_to_update_list(index,OSD_COLOR_MODE);
-	}
-	disp_data.x_start=display_h_start;
-	disp_data.y_start=display_v_start;
-	disp_data.x_end=display_h_end;
-	disp_data.y_end=display_v_end;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+	if (index == OSD2)
+		return;
+#endif
+
+	if (NULL == osd_hw.color_info[index]) return;
+
+	disp_data.x_start = display_h_start;
+	disp_data.y_start = display_v_start;
+	disp_data.x_end = display_h_end;
+	disp_data.y_end = display_v_end;
 
-	pan_data.x_start=xoffset;
-	pan_data.x_end=xoffset + (display_h_end - display_h_start);
-	pan_data.y_start=yoffset;
-	pan_data.y_end=yoffset + (display_v_end-display_v_start);
+	pan_data.x_start = xoffset;
+	pan_data.x_end = xoffset + (display_h_end - display_h_start);
+	pan_data.y_start = yoffset;
+	pan_data.y_end = yoffset + (display_v_end - display_v_start);
 
 	//if output mode change then reset pan ofFfset.
-	memcpy(&osd_hw.pandata[index],&pan_data,sizeof(pandata_t));
-	memcpy(&osd_hw.dispdata[index],&disp_data,sizeof(dispdata_t));
-	add_to_update_list(index,DISP_GEOMETRY);
+	memcpy(&osd_hw.pandata[index], &pan_data, sizeof(pandata_t));
+	memcpy(&osd_hw.dispdata[index], &disp_data, sizeof(dispdata_t));
+
+	spin_lock_irqsave(&osd_lock, lock_flags);
+	if (mode_change) //modify pandata .
+		osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+	osd_hw.reg[index][DISP_GEOMETRY].update_func();
+	spin_unlock_irqrestore(&osd_lock, lock_flags);
 	osd_wait_vsync_hw();
 
 }
+//now , we will do overwrite ,if call osd_setup multi times between two vsync.
+//and the BUFFER will be released one by one ,i.e. only release one BUFFER ervery VSYNC.
+//I think if not skip frame , It will be smooth and better.
 void osd_setup(struct osd_ctl_s *osd_ctl,
-		u32 xoffset,
-		u32 yoffset,
-		u32 xres,
-		u32 yres,
-		u32 xres_virtual,
-		u32 yres_virtual,
-		u32 disp_start_x,
-		u32 disp_start_y,
-		u32 disp_end_x,
-		u32 disp_end_y,
-		u32 fbmem,
-		const color_bit_define_t *color,
-		int index
+	       u32 xoffset,
+	       u32 yoffset,
+	       u32 xres,
+	       u32 yres,
+	       u32 xres_virtual,
+	       u32 yres_virtual,
+	       u32 disp_start_x,
+	       u32 disp_start_y,
+	       u32 disp_end_x,
+	       u32 disp_end_y,
+	       u32 fbmem,
+	       const color_bit_define_t *color,
+	       int index
 	      )
 {
-	u32  w=(color->bpp * xres_virtual + 7) >> 3;
+	u32  w = (color->bpp * xres_virtual + 7) >> 3;
 	dispdata_t   disp_data;
 	pandata_t    pan_data;
 #ifdef CONFIG_AM_LOGO
-	static u32	    logo_setup_ok=0;
+	static u32	    logo_setup_ok = 0;
 #endif
-
-	pan_data.x_start=xoffset;
-	pan_data.y_start=yoffset;
-	disp_data.x_start=disp_start_x;
-	disp_data.y_start=disp_start_y;
-
-	if(likely(osd_hw.free_scale_enable[OSD1] && index==OSD1))
-	{
-		if(!osd_hw.free_scale_mode[OSD1]){
-			pan_data.x_end=xoffset + g_vf_visual_width;
-			pan_data.y_end=yoffset + g_vf_height;
-			disp_data.x_end=disp_start_x + g_vf_width;
-			disp_data.y_end=disp_start_y + g_vf_height;
-		}else{
-			pan_data.x_end=xoffset + (disp_end_x-disp_start_x);
-			pan_data.y_end=yoffset + (disp_end_y-disp_start_y);
-			disp_data.x_end=disp_end_x;
-			disp_data.y_end=disp_end_y;
+	int update_color_mode = 0;
+	int update_geometry = 0;
+
+	pan_data.x_start = xoffset;
+	pan_data.y_start = yoffset;
+	disp_data.x_start = disp_start_x;
+	disp_data.y_start = disp_start_y;
+
+	if (likely(osd_hw.free_scale_enable[OSD1] && index == OSD1)) {
+		if (!(osd_hw.free_scale_mode[OSD1])) {
+			pan_data.x_end = xoffset + g_vf_visual_width;
+			pan_data.y_end = yoffset + g_vf_height;
+			disp_data.x_end = disp_start_x + g_vf_width;
+			disp_data.y_end = disp_start_y + g_vf_height;
+		} else {
+			pan_data.x_end = xoffset + (disp_end_x - disp_start_x);
+			pan_data.y_end = yoffset + (disp_end_y - disp_start_y);
+			disp_data.x_end = disp_end_x;
+			disp_data.y_end = disp_end_y;
 		}
-	}else{
-		pan_data.x_end=xoffset + (disp_end_x-disp_start_x);
-		pan_data.y_end=yoffset + (disp_end_y-disp_start_y);
-		if (likely(osd_hw.rotate[index].on_off && osd_hw.rotate[index].on_off > 0)){
+	} else {
+		pan_data.x_end = xoffset + (disp_end_x - disp_start_x);
+		pan_data.y_end = yoffset + (disp_end_y - disp_start_y);
+		if (likely(osd_hw.rotate[index].on_off && osd_hw.rotate[index].on_off > 0)) {
 			disp_data.x_end = disp_start_x + g_rotation_height;
 			disp_data.y_end = disp_start_y + g_rotation_width;
-		}else{
-			disp_data.x_end=disp_end_x;
-			disp_data.y_end=disp_end_y;
+		} else {
+			disp_data.x_end = disp_end_x;
+			disp_data.y_end = disp_end_y;
 		}
 	}
 
-	if( osd_hw.fb_gem[index].addr!=fbmem || osd_hw.fb_gem[index].width !=w ||  osd_hw.fb_gem[index].height !=yres_virtual)
-	{
-		osd_hw.fb_gem[index].addr=fbmem;
-		osd_hw.fb_gem[index].width=w;
-		osd_hw.fb_gem[index].height=yres_virtual;
+	if (osd_hw.fb_gem[index].addr != fbmem || osd_hw.fb_gem[index].width != w ||
+	    osd_hw.fb_gem[index].height != yres_virtual) {
+		osd_hw.fb_gem[index].addr = fbmem;
+		osd_hw.fb_gem[index].width = w;
+		osd_hw.fb_gem[index].height = yres_virtual;
 		canvas_config(osd_hw.fb_gem[index].canvas_idx, osd_hw.fb_gem[index].addr,
-				osd_hw.fb_gem[index].width, osd_hw.fb_gem[index].height,
-				CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
+			      osd_hw.fb_gem[index].width, osd_hw.fb_gem[index].height,
+			      CANVAS_ADDR_NOWRAP, CANVAS_BLKMODE_LINEAR);
 	}
 
-	if(color != osd_hw.color_info[index])
-	{
-		osd_hw.color_info[index]=color;
-		add_to_update_list(index,OSD_COLOR_MODE);
+	if (color != osd_hw.color_info[index]) {
+		update_color_mode = 1;
+		osd_hw.color_info[index] = color;
 	}
 	//osd blank only control by /sys/class/graphcis/fbx/blank
 	/*
@@ -754,192 +950,196 @@ void osd_setup(struct osd_ctl_s *osd_ctl,
 	   add_to_update_list(index,OSD_ENABLE);
 
 	   }*/
-	if(memcmp(&pan_data,&osd_hw.pandata[index],sizeof(pandata_t))!= 0 ||
-			memcmp(&disp_data,&osd_hw.dispdata[index],sizeof(dispdata_t))!=0)
-	{
-		//if(!osd_hw.free_scale_enable[OSD1]) //in free scale mode ,adjust geometry para is abandoned.
-		{
-			memcpy(&osd_hw.pandata[index],&pan_data,sizeof(pandata_t));
-			memcpy(&osd_hw.dispdata[index],&disp_data,sizeof(dispdata_t));
-			add_to_update_list(index,DISP_GEOMETRY);
-		}
+	if (memcmp(&pan_data, &osd_hw.pandata[index], sizeof(pandata_t)) != 0 ||
+	    memcmp(&disp_data, &osd_hw.dispdata[index], sizeof(dispdata_t)) != 0) {
+		update_geometry = 1;
+		memcpy(&osd_hw.pandata[index], &pan_data, sizeof(pandata_t));
+		memcpy(&osd_hw.dispdata[index], &disp_data, sizeof(dispdata_t));
 	}
 
+	spin_lock_irqsave(&osd_lock, lock_flags);
+	if (update_color_mode)
+		osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+	if (update_geometry)
+		osd_hw.reg[index][DISP_GEOMETRY].update_func();
+	spin_unlock_irqrestore(&osd_lock, lock_flags);
+
 #ifdef CONFIG_AM_LOGO
-	if(!logo_setup_ok)
-	{
+	if (!logo_setup_ok) {
 #ifdef FIQ_VSYNC
 		osd_fiq_isr();
 #else
-		vsync_isr(INT_VIU_VSYNC,NULL);
+		vsync_isr(INT_VIU_VSYNC, NULL);
 #endif
 		logo_setup_ok++;
 	}
 #endif
 
-	if(osd_hw.antiflicker_mode){
+	if (osd_hw.antiflicker_mode)
 		osd_antiflicker_update_pan(yoffset, yres);
-	}
 
-	if(osd_hw.clone){
+	if (osd_hw.clone)
 		osd_clone_pan(index, yoffset, 0);
-	}
 
 #ifdef CONFIG_AM_FB_EXT
 	osd_ext_clone_pan(index);
 #endif
-
 	osd_wait_vsync_hw();
 }
 
 void osd_setpal_hw(unsigned regno,
-		unsigned red,
-		unsigned green,
-		unsigned blue,
-		unsigned transp,
-		int index
-		)
+		   unsigned red,
+		   unsigned green,
+		   unsigned blue,
+		   unsigned transp,
+		   int index
+		  )
 {
 
 	if (regno < 256) {
 		u32 pal;
 		pal = ((red   & 0xff) << 24) |
-			((green & 0xff) << 16) |
-			((blue  & 0xff) <<  8) |
-			(transp & 0xff);
+		      ((green & 0xff) << 16) |
+		      ((blue  & 0xff) <<  8) |
+		      (transp & 0xff);
 
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_COLOR_ADDR+REG_OFFSET*index, regno);
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_COLOR+REG_OFFSET*index, pal);
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_COLOR_ADDR + REG_OFFSET * index, regno);
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_COLOR + REG_OFFSET * index, pal);
 	}
 }
 u32 osd_get_osd_order_hw(u32 index)
 {
-	return  osd_hw.osd_order&0x3;
+	return  osd_hw.osd_order & 0x3;
 }
-void osd_change_osd_order_hw(u32 index,u32 order)
+void osd_change_osd_order_hw(u32 index, u32 order)
 {
-	if((order != OSD_ORDER_01)&&(order != OSD_ORDER_10))
+	if ((order != OSD_ORDER_01) && (order != OSD_ORDER_10))
 		return ;
-	osd_hw.osd_order=order;
-	add_to_update_list(index,OSD_CHANGE_ORDER);
+	osd_hw.osd_order = order;
+	add_to_update_list(index, OSD_CHANGE_ORDER);
 	osd_wait_vsync_hw();
 }
 
-void osd_free_scale_enable_hw(u32 index,u32 enable)
+void osd_free_scale_enable_hw(u32 index, u32 enable)
 {
-	if (osd_hw.free_scale_mode[index]){
+	int ret = 0;
+	if (osd_hw.free_scale_mode[index]) {
 		unsigned int hfs_enable = 0;
 		unsigned int vfs_enable = 0;
 
-		hfs_enable = (enable&0xffff0000?1:0);
-		vfs_enable = (enable&0xffff?1:0);
+		hfs_enable = (enable & 0xffff0000 ? 1 : 0);
+		vfs_enable = (enable & 0xffff ? 1 : 0);
 		osd_hw.free_scale[index].hfs_enable = hfs_enable;
 		osd_hw.free_scale[index].vfs_enable = vfs_enable;
 
-		if (hfs_enable ||vfs_enable){
-			osd_hw.free_scale_enable[index] = 1;
-		}else if (!hfs_enable && !vfs_enable){
-			osd_hw.free_scale_enable[index] = 0;
-		}
-
-		if (osd_hw.free_scale_enable[index])
-		{
-			if ((osd_hw.free_scale_data[index].x_end > 0) && hfs_enable){
+		osd_hw.free_scale_enable[index] = enable;
+		if (osd_hw.free_scale_enable[index]) {
+			if ((osd_hw.free_scale_data[index].x_end > 0) && hfs_enable) {
 				osd_hw.free_scale_width[index] = osd_hw.free_scale_data[index].x_end - \
-								osd_hw.free_scale_data[index].x_start;
+								 osd_hw.free_scale_data[index].x_start + 1;
 			}
-
-			if ((osd_hw.free_scale_data[index].y_end > 0) && vfs_enable){
-				osd_hw.free_scale_height[index] = osd_hw.free_scale_data[index].y_end -\
-								 osd_hw.free_scale_data[index].y_start;
+			if ((osd_hw.free_scale_data[index].y_end > 0) && vfs_enable) {
+				osd_hw.free_scale_height[index] = osd_hw.free_scale_data[index].y_end - \
+								  osd_hw.free_scale_data[index].y_start + 1;
 			}
-			osd_set_scan_mode(index);
-			add_to_update_list(index,OSD_COLOR_MODE);
-			add_to_update_list(index,OSD_FREESCALE_COEF);
-			add_to_update_list(index,DISP_GEOMETRY);
-			add_to_update_list(index,DISP_FREESCALE_ENABLE);
-		}else{
-			osd_set_scan_mode(index);
-			add_to_update_list(index,OSD_COLOR_MODE);
-			add_to_update_list(index,DISP_GEOMETRY);
-			add_to_update_list(index,DISP_FREESCALE_ENABLE);
+			spin_lock_irqsave(&osd_lock, lock_flags);
+			ret = osd_set_scan_mode(index);
+			if (ret)
+				osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+			osd_hw.reg[index][OSD_FREESCALE_COEF].update_func();
+			osd_hw.reg[index][DISP_GEOMETRY].update_func();
+			osd_hw.reg[index][DISP_FREESCALE_ENABLE].update_func();
+			osd_hw.reg[index][OSD_ENABLE].update_func();
+			spin_unlock_irqrestore(&osd_lock, lock_flags);
+		} else {
+			spin_lock_irqsave(&osd_lock, lock_flags);
+			ret = osd_set_scan_mode(index);
+			if (ret)
+				osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+			osd_hw.reg[index][DISP_GEOMETRY].update_func();
+			osd_hw.reg[index][DISP_FREESCALE_ENABLE].update_func();
+			osd_hw.reg[index][OSD_ENABLE].update_func();
+			spin_unlock_irqrestore(&osd_lock, lock_flags);
 		}
-
-		osd_enable_hw(osd_hw.enable[index],index);
-	}else{
-		static  dispdata_t	save_disp_data={0,0,0,0};
+		osd_wait_vsync_hw();
+	} else {
+		static dispdata_t save_disp_data = {0, 0, 0, 0};
 #ifdef CONFIG_AM_VIDEO
 #ifdef CONFIG_POST_PROCESS_MANAGER
 		int mode_changed = 0;
-		if((index==OSD1)&&(osd_hw.free_scale_enable[index]!=enable))
+		if ((index == OSD1) && (osd_hw.free_scale_enable[index] != enable))
 			mode_changed = 1;
 #endif
 #endif
-
-		amlog_level(LOG_LEVEL_HIGH,"osd%d free scale %s\r\n",index,enable?"ENABLE":"DISABLE");
-		enable = (enable&0xffff?1:0);
-		osd_hw.free_scale_enable[index]=enable;
-		if (index==OSD1)
-		{
-			if(enable)
-			{
+		amlog_level(LOG_LEVEL_HIGH, "osd%d free scale %s\n", index,
+			    enable ? "ENABLE" : "DISABLE");
+		enable = (enable & 0xffff ? 1 : 0);
+		osd_hw.free_scale_enable[index] = enable;
+		if (index == OSD1) {
+			if (enable) {
 				osd_vf_need_update = true;
-				if ((osd_hw.free_scale_data[OSD1].x_end > 0) && (osd_hw.free_scale_data[OSD1].x_end > 0)) {
-					vf.width = osd_hw.free_scale_data[index].x_end - osd_hw.free_scale_data[index].x_start + 1;
-					vf.height = osd_hw.free_scale_data[index].y_end - osd_hw.free_scale_data[index].y_start + 1;
+				if ((osd_hw.free_scale_data[OSD1].x_end > 0) &&
+				    (osd_hw.free_scale_data[OSD1].x_end > 0)) {
+					vf.width = osd_hw.free_scale_data[index].x_end -
+						   osd_hw.free_scale_data[index].x_start + 1;
+					vf.height = osd_hw.free_scale_data[index].y_end -
+						    osd_hw.free_scale_data[index].y_start + 1;
 				} else {
-					vf.width=osd_hw.free_scale_width[OSD1];
-					vf.height=osd_hw.free_scale_height[OSD1];
+					vf.width = osd_hw.free_scale_width[OSD1];
+					vf.height = osd_hw.free_scale_height[OSD1];
 				}
-				//				vf.type = (osd_hw.scan_mode==SCAN_MODE_INTERLACE ?VIDTYPE_INTERLACE:VIDTYPE_PROGRESSIVE) | VIDTYPE_VIU_FIELD;
-				vf.type = (VIDTYPE_NO_VIDEO_ENABLE | VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD | VIDTYPE_VSCALE_DISABLE);
-				vf.ratio_control=DISP_RATIO_FORCECONFIG|DISP_RATIO_NO_KEEPRATIO;
+				vf.type = (VIDTYPE_NO_VIDEO_ENABLE | VIDTYPE_PROGRESSIVE | VIDTYPE_VIU_FIELD |
+					   VIDTYPE_VSCALE_DISABLE);
+				vf.ratio_control = DISP_RATIO_FORCECONFIG | DISP_RATIO_NO_KEEPRATIO;
 #ifdef CONFIG_AM_VIDEO
-				if(osd_vf_prov_init==0){
+				if (osd_vf_prov_init == 0) {
 					vf_provider_init(&osd_vf_prov, PROVIDER_NAME, &osd_vf_provider, NULL);
 					osd_vf_prov_init = 1;
 				}
 				vf_reg_provider(&osd_vf_prov);
 #endif
-				memcpy(&save_disp_data,&osd_hw.dispdata[OSD1],sizeof(dispdata_t));
-				g_vf_visual_width=vf.width-1-osd_hw.dispdata[OSD1].x_start ;
-				g_vf_width=vf.width-1;
-				g_vf_height=vf.height-1;
+				memcpy(&save_disp_data, &osd_hw.dispdata[OSD1], sizeof(dispdata_t));
+				g_vf_visual_width = vf.width - 1 - osd_hw.dispdata[OSD1].x_start ;
+				g_vf_width = vf.width - 1;
+				g_vf_height = vf.height - 1;
 
-				osd_hw.dispdata[OSD1].x_end =osd_hw.dispdata[OSD1].x_start + vf.width-1;
-				osd_hw.dispdata[OSD1].y_end =osd_hw.dispdata[OSD1].y_start + vf.height-1;
+				osd_hw.dispdata[OSD1].x_end = osd_hw.dispdata[OSD1].x_start + vf.width - 1;
+				osd_hw.dispdata[OSD1].y_end = osd_hw.dispdata[OSD1].y_start + vf.height - 1;
 
 				osd_set_scan_mode(index);
-				add_to_update_list(OSD1,DISP_GEOMETRY);
-				add_to_update_list(OSD1,OSD_COLOR_MODE);
-			}
-			else
-			{
+				spin_lock_irqsave(&osd_lock, lock_flags);
+				osd_hw.reg[index][DISP_GEOMETRY].update_func();
+				osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+				osd_hw.reg[index][OSD_ENABLE].update_func();
+				spin_unlock_irqrestore(&osd_lock, lock_flags);
+			} else {
 				osd_vf_need_update = false;
 				osd_set_scan_mode(index);
-				if(save_disp_data.x_end <= save_disp_data.x_start ||
-						save_disp_data.y_end <= save_disp_data.y_start)
-				{
+				if (save_disp_data.x_end <= save_disp_data.x_start ||
+				    save_disp_data.y_end <= save_disp_data.y_start)
 					return ;
-				}
-				memcpy(&osd_hw.dispdata[OSD1],&save_disp_data,sizeof(dispdata_t));
+				memcpy(&osd_hw.dispdata[OSD1], &save_disp_data, sizeof(dispdata_t));
 
-				add_to_update_list(OSD1,DISP_GEOMETRY);
-				add_to_update_list(OSD1,OSD_COLOR_MODE);
+				spin_lock_irqsave(&osd_lock, lock_flags);
+				osd_hw.reg[index][DISP_GEOMETRY].update_func();
+				osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+				osd_hw.reg[index][OSD_ENABLE].update_func();
+				spin_unlock_irqrestore(&osd_lock, lock_flags);
 #ifdef CONFIG_AM_VIDEO
 				vf_unreg_provider(&osd_vf_prov);
 #endif
 			}
+		} else {
+			spin_lock_irqsave(&osd_lock, lock_flags);
+			osd_hw.reg[index][DISP_GEOMETRY].update_func();
+			osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+			osd_hw.reg[index][OSD_ENABLE].update_func();
+			spin_unlock_irqrestore(&osd_lock, lock_flags);
 		}
-		else
-		{
-			add_to_update_list(OSD2,DISP_GEOMETRY);
-			add_to_update_list(OSD2,OSD_COLOR_MODE);
-		}
-		osd_enable_hw(osd_hw.enable[index],index);
+		osd_wait_vsync_hw();
 #ifdef CONFIG_AM_VIDEO
 #ifdef CONFIG_POST_PROCESS_MANAGER
-		if(mode_changed){
+		if (mode_changed) {
 			//vf_notify_receiver(PROVIDER_NAME,VFRAME_EVENT_PROVIDER_RESET,NULL);
 			extern void vf_ppmgr_reset(int type);
 			vf_ppmgr_reset(1);
@@ -954,7 +1154,7 @@ void osd_get_free_scale_enable_hw(u32 index, u32 *free_scale_enable)
 	*free_scale_enable = osd_hw.free_scale_enable[index];
 }
 
-void osd_free_scale_mode_hw(u32 index,u32 freescale_mode)
+void osd_free_scale_mode_hw(u32 index, u32 freescale_mode)
 {
 	osd_hw.free_scale_mode[index] = freescale_mode;
 }
@@ -969,11 +1169,11 @@ void osd_4k2k_fb_mode_hw(u32 fb_for_4k2k)
 	osd_hw.fb_for_4k2k = fb_for_4k2k;
 }
 
-void osd_free_scale_width_hw(u32 index,u32 width)
+void osd_free_scale_width_hw(u32 index, u32 width)
 {
-	osd_hw.free_scale_width[index]=width;
+	osd_hw.free_scale_width[index] = width;
 	if (osd_hw.free_scale_enable[index] &&
-			(!osd_hw.free_scale_mode[index])) {
+	    (!osd_hw.free_scale_mode[index])) {
 		osd_vf_need_update = true;
 		vf.width = osd_hw.free_scale_width[index];
 	}
@@ -984,11 +1184,11 @@ void osd_get_free_scale_width_hw(u32 index, u32 *free_scale_width)
 	*free_scale_width = osd_hw.free_scale_width[index];
 }
 
-void osd_free_scale_height_hw(u32 index,u32 height)
+void osd_free_scale_height_hw(u32 index, u32 height)
 {
-	osd_hw.free_scale_height[index]=height;
+	osd_hw.free_scale_height[index] = height;
 	if (osd_hw.free_scale_enable[index] &&
-			(!osd_hw.free_scale_mode[index])) {
+	    (!osd_hw.free_scale_mode[index])) {
 		osd_vf_need_update = true;
 		vf.height = osd_hw.free_scale_height[index];
 	}
@@ -1033,40 +1233,41 @@ void osd_set_scale_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
 
 void osd_get_window_axis_hw(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1)
 {
-    const vinfo_t *vinfo;
-    vinfo = get_current_vinfo();
-    if (vinfo) {
-        switch (vinfo->mode) {
- 		        case VMODE_480I:
- 		        case VMODE_480CVBS:
- 		        case VMODE_576I:
- 		        case VMODE_576CVBS:
- 		        case VMODE_1080I:
- 		        case VMODE_1080I_50HZ:
+	const vinfo_t *vinfo;
+	vinfo = get_current_vinfo();
+	if (vinfo) {
+		switch (vinfo->mode) {
+		case VMODE_480I:
+		case VMODE_480CVBS:
+		case VMODE_576I:
+		case VMODE_576CVBS:
+		case VMODE_1080I:
+		case VMODE_1080I_50HZ:
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-				case VMODE_1080I_59HZ:
+		case VMODE_1080I_59HZ:
 #endif
 
- 		        	  *y0 = osd_hw.free_dst_data[index].y_start*2;
- 			          *y1 = osd_hw.free_dst_data[index].y_end*2;
- 		        break;
- 		        default:
- 		        	  *y0 = osd_hw.free_dst_data[index].y_start;
- 			          *y1 = osd_hw.free_dst_data[index].y_end;
- 		        break;
-        }
-    }
+			*y0 = osd_hw.free_dst_data[index].y_start * 2;
+			*y1 = osd_hw.free_dst_data[index].y_end * 2;
+			break;
+		default:
+			*y0 = osd_hw.free_dst_data[index].y_start;
+			*y1 = osd_hw.free_dst_data[index].y_end;
+			break;
+		}
+	}
 
-	  *x0 = osd_hw.free_dst_data[index].x_start;
-	  *x1 = osd_hw.free_dst_data[index].x_end;
+	*x0 = osd_hw.free_dst_data[index].x_start;
+	*x1 = osd_hw.free_dst_data[index].x_end;
 }
 
 void osd_set_window_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
 {
 	const vinfo_t *vinfo;
+	mutex_lock(&osd_mutex);
 	vinfo = get_current_vinfo();
 	if (vinfo) {
-	switch (vinfo->mode) {
+		switch (vinfo->mode) {
 		case VMODE_480I:
 		case VMODE_480CVBS:
 		case VMODE_576I:
@@ -1076,21 +1277,18 @@ void osd_set_window_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 		case VMODE_1080I_59HZ:
 #endif
-		osd_hw.free_dst_data[index].y_start = y0/2;
-		osd_hw.free_dst_data[index].y_end = y1/2;
-		break;
+
+			osd_hw.free_dst_data[index].y_start = y0 / 2;
+			osd_hw.free_dst_data[index].y_end = y1 / 2;
+			break;
 		default:
-		osd_hw.free_dst_data[index].y_start = y0;
-		osd_hw.free_dst_data[index].y_end = y1;
-		break;
-	}
+			osd_hw.free_dst_data[index].y_start = y0;
+			osd_hw.free_dst_data[index].y_end = y1;
+			break;
+		}
 	}
 	osd_hw.free_dst_data[index].x_start = x0;
 	osd_hw.free_dst_data[index].x_end = x1;
-#if 0
-	osd_hw.free_dst_data[index].y_start = y0;
-	osd_hw.free_dst_data[index].y_end = y1/2;
-#endif
 
 #if defined(CONFIG_FB_OSD2_CURSOR)
 	osd_hw.cursor_dispdata[index].x_start = x0;
@@ -1098,12 +1296,15 @@ void osd_set_window_axis_hw(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
 	osd_hw.cursor_dispdata[index].y_start = y0;
 	osd_hw.cursor_dispdata[index].y_end = y1;
 #endif
+	osd_update_window_axis = true;
+	mutex_unlock(&osd_mutex);
 }
 
 
-void osd_get_osd_info_hw(u32 index, s32 (*posdval)[4], u32(*posdreg)[5], s32 info_flag)
+void osd_get_osd_info_hw(u32 index, s32(*posdval)[4], u32(*posdreg)[5],
+			 s32 info_flag)
 {
-	if(info_flag == 0){
+	if (info_flag == 0) {
 		posdval[0][0] = osd_hw.pandata[index].x_start;
 		posdval[0][1] = osd_hw.pandata[index].x_end;
 		posdval[0][2] = osd_hw.pandata[index].y_start;
@@ -1118,7 +1319,7 @@ void osd_get_osd_info_hw(u32 index, s32 (*posdval)[4], u32(*posdreg)[5], s32 inf
 		posdval[2][1] = osd_hw.scaledata[index].x_end;
 		posdval[2][2] = osd_hw.scaledata[index].y_start;
 		posdval[2][3] = osd_hw.scaledata[index].y_end;
-	}else if(info_flag == 1){
+	} else if (info_flag == 1) {
 		posdreg[0][0] = aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W0);
 		posdreg[0][1] = aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W1);
 		posdreg[0][2] = aml_read_reg32(P_VIU_OSD1_BLK0_CFG_W2);
@@ -1130,19 +1331,21 @@ void osd_get_osd_info_hw(u32 index, s32 (*posdval)[4], u32(*posdreg)[5], s32 inf
 		posdreg[1][2] = aml_read_reg32(P_VIU_OSD2_BLK0_CFG_W2);
 		posdreg[1][3] = aml_read_reg32(P_VIU_OSD2_BLK0_CFG_W3);
 		posdreg[1][4] = aml_read_reg32(P_VIU_OSD2_BLK0_CFG_W4);
-	}else{
+	} else {
 		;//ToDo
 	}
 }
 
 void osd_get_block_windows_hw(u32 index, u32 *windows)
 {
-	memcpy(windows, osd_hw.block_windows[index], sizeof(osd_hw.block_windows[index]));
+	memcpy(windows, osd_hw.block_windows[index],
+	       sizeof(osd_hw.block_windows[index]));
 }
 
 void osd_set_block_windows_hw(u32 index, u32 *windows)
 {
-	memcpy(osd_hw.block_windows[index], windows, sizeof(osd_hw.block_windows[index]));
+	memcpy(osd_hw.block_windows[index], windows,
+	       sizeof(osd_hw.block_windows[index]));
 	add_to_update_list(index, DISP_GEOMETRY);
 	osd_wait_vsync_hw();
 }
@@ -1159,58 +1362,60 @@ void osd_set_block_mode_hw(u32 index, u32 mode)
 	osd_wait_vsync_hw();
 }
 
-void osd_enable_3d_mode_hw(int index,int enable)
+void osd_enable_3d_mode_hw(int index, int enable)
 {
 	spin_lock_irqsave(&osd_lock, lock_flags);
-	osd_hw.mode_3d[index].enable=enable;
+	osd_hw.mode_3d[index].enable = enable;
 	spin_unlock_irqrestore(&osd_lock, lock_flags);
-	if(enable)  //when disable 3d mode ,we should return to stardard state.
-	{
-		osd_hw.mode_3d[index].left_right=LEFT;
-		osd_hw.mode_3d[index].l_start=osd_hw.pandata[index].x_start;
-		osd_hw.mode_3d[index].l_end= (osd_hw.pandata[index].x_end +  osd_hw.pandata[index].x_start)>>1;
-		osd_hw.mode_3d[index].r_start=osd_hw.mode_3d[index].l_end + 1;
-		osd_hw.mode_3d[index].r_end=osd_hw.pandata[index].x_end;
-		osd_hw.mode_3d[index].origin_scale.h_enable=osd_hw.scale[index].h_enable;
-		osd_hw.mode_3d[index].origin_scale.v_enable=osd_hw.scale[index].v_enable;
-		osd_set_2x_scale_hw(index,1,0);
-	}
-	else
-	{
+	if (enable) { //when disable 3d mode ,we should return to stardard state.
+		osd_hw.mode_3d[index].left_right = LEFT;
+		osd_hw.mode_3d[index].l_start = osd_hw.pandata[index].x_start;
+		osd_hw.mode_3d[index].l_end = (osd_hw.pandata[index].x_end +
+					       osd_hw.pandata[index].x_start) >> 1;
+		osd_hw.mode_3d[index].r_start = osd_hw.mode_3d[index].l_end + 1;
+		osd_hw.mode_3d[index].r_end = osd_hw.pandata[index].x_end;
+		osd_hw.mode_3d[index].origin_scale.h_enable = osd_hw.scale[index].h_enable;
+		osd_hw.mode_3d[index].origin_scale.v_enable = osd_hw.scale[index].v_enable;
+		osd_set_2x_scale_hw(index, 1, 0);
+	} else {
 
-		osd_set_2x_scale_hw(index,osd_hw.mode_3d[index].origin_scale.h_enable,
-				osd_hw.mode_3d[index].origin_scale.v_enable);
+		osd_set_2x_scale_hw(index, osd_hw.mode_3d[index].origin_scale.h_enable,
+				    osd_hw.mode_3d[index].origin_scale.v_enable);
 	}
 }
-void osd_enable_hw(int enable ,int index )
+void osd_enable_hw(int enable , int index)
 {
-	osd_hw.enable[index]=enable;
-	add_to_update_list(index,OSD_ENABLE);
+	osd_hw.enable[index] = enable;
+	add_to_update_list(index, OSD_ENABLE);
 
 	osd_wait_vsync_hw();
 }
 
-void osd_set_2x_scale_hw(u32 index,u16 h_scale_enable,u16 v_scale_enable)
+void osd_set_2x_scale_hw(u32 index, u16 h_scale_enable, u16 v_scale_enable)
 {
-	amlog_level(LOG_LEVEL_HIGH, "osd[%d] set scale, h_scale: %s, v_scale: %s\r\n",
-			index, h_scale_enable ? "ENABLE" : "DISABLE", v_scale_enable ? "ENABLE" : "DISABLE");
+	amlog_level(LOG_LEVEL_HIGH, "osd[%d] set scale, h_scale: %s, v_scale: %s\n",
+		    index, h_scale_enable ? "ENABLE" : "DISABLE",
+		    v_scale_enable ? "ENABLE" : "DISABLE");
 	amlog_level(LOG_LEVEL_HIGH, "osd[%d].scaledata: %d %d %d %d\n",
-			index,
-			osd_hw.scaledata[index].x_start,
-			osd_hw.scaledata[index].x_end,
-			osd_hw.scaledata[index].y_start,
-			osd_hw.scaledata[index].y_end);
+		    index,
+		    osd_hw.scaledata[index].x_start,
+		    osd_hw.scaledata[index].x_end,
+		    osd_hw.scaledata[index].y_start,
+		    osd_hw.scaledata[index].y_end);
 	amlog_level(LOG_LEVEL_HIGH, "osd[%d].pandata: %d %d %d %d\n",
-			index,
-			osd_hw.pandata[index].x_start,
-			osd_hw.pandata[index].x_end,
-			osd_hw.pandata[index].y_start,
-			osd_hw.pandata[index].y_end);
+		    index,
+		    osd_hw.pandata[index].x_start,
+		    osd_hw.pandata[index].x_end,
+		    osd_hw.pandata[index].y_start,
+		    osd_hw.pandata[index].y_end);
 
 	osd_hw.scale[index].h_enable = h_scale_enable;
 	osd_hw.scale[index].v_enable = v_scale_enable;
-	add_to_update_list(index, DISP_SCALE_ENABLE);
-	add_to_update_list(index, DISP_GEOMETRY);
+
+	spin_lock_irqsave(&osd_lock, lock_flags);
+	osd_hw.reg[index][DISP_SCALE_ENABLE].update_func();
+	osd_hw.reg[index][DISP_GEOMETRY].update_func();
+	spin_unlock_irqrestore(&osd_lock, lock_flags);
 
 	osd_wait_vsync_hw();
 }
@@ -1219,7 +1424,7 @@ void osd_get_flush_rate(u32 *break_rate)
 {
 	const vinfo_t *vinfo;
 	vinfo = get_current_vinfo();
-	*break_rate = vinfo->sync_duration_num /vinfo->sync_duration_den;
+	*break_rate = vinfo->sync_duration_num / vinfo->sync_duration_den;
 }
 
 void osd_set_osd_rotate_angle_hw(u32 index, u32 angle)
@@ -1229,7 +1434,7 @@ void osd_set_osd_rotate_angle_hw(u32 index, u32 angle)
 	osd_wait_vsync_hw();
 }
 
-void osd_get_osd_rotate_angle_hw(u32 index,u32 *angle)
+void osd_get_osd_rotate_angle_hw(u32 index, u32 *angle)
 {
 	*angle = osd_hw.rotate[index].angle;
 }
@@ -1239,53 +1444,53 @@ void osd_set_osd_rotate_on_hw(u32 index, u32 on_off)
 	//static dispdata_t save_disp_data2={0,0,0,0};
 	osd_hw.rotate[index].on_off = on_off;
 
-	if(on_off)
-	{
-		if(index == OSD1){
+	if (on_off) {
+		if (index == OSD1) {
 			//memcpy(&save_disp_data,&osd_hw.dispdata[index],sizeof(dispdata_t));
-		}else if(index == OSD2){
+		} else if (index == OSD2) {
 			//memcpy(&save_disp_data2,&osd_hw.dispdata[index],sizeof(dispdata_t));
 		}
-		g_rotation_width = osd_hw.rotation_pandata[index].x_end-osd_hw.rotation_pandata[index].x_start;
-		g_rotation_height = osd_hw.rotation_pandata[index].y_end-osd_hw.rotation_pandata[index].y_start;
-		osd_hw.dispdata[index].x_end = osd_hw.dispdata[OSD1].x_start+g_rotation_height;
-		osd_hw.dispdata[index].y_end = osd_hw.dispdata[OSD1].y_start+g_rotation_width;
-	}
-	else
-	{
+		g_rotation_width = osd_hw.rotation_pandata[index].x_end -
+				   osd_hw.rotation_pandata[index].x_start;
+		g_rotation_height = osd_hw.rotation_pandata[index].y_end -
+				    osd_hw.rotation_pandata[index].y_start;
+		osd_hw.dispdata[index].x_end = osd_hw.dispdata[OSD1].x_start +
+					       g_rotation_height;
+		osd_hw.dispdata[index].y_end = osd_hw.dispdata[OSD1].y_start + g_rotation_width;
+	} else {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-	{
-		if(IS_MESON_M8_CPU){
-			VSYNCOSD_SET_MPEG_REG_MASK(VPU_SW_RESET, 1<<8);
-			VSYNCOSD_CLR_MPEG_REG_MASK(VPU_SW_RESET, 1<<8);
+		{
+			if (IS_MESON_M8_CPU)
+			{
+				aml_set_reg32_mask(P_VPU_SW_RESET, 1 << 8);
+				aml_clr_reg32_mask(P_VPU_SW_RESET, 1 << 8);
+			}
 		}
-	}
 #endif
-		if(index == OSD1){
+		if (index == OSD1) {
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
-	{
-		if(IS_MESON_M8_CPU){
-			VSYNCOSD_SET_MPEG_REG_MASK(VIU_SW_RESET, 1<<0);
-			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_SW_RESET, 1<<0);
-		}
-	}
+			if (IS_MESON_M8_CPU) {
+				aml_set_reg32_mask(P_VIU_SW_RESET, 1 << 0);
+				aml_clr_reg32_mask(P_VIU_SW_RESET, 1 << 0);
+			}
 #endif
-			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_FIFO_CTRL_STAT, 1<<0);
-			//memcpy(&osd_hw.dispdata[index],&save_disp_data,sizeof(dispdata_t));
-		}else{
-			VSYNCOSD_SET_MPEG_REG_MASK(VIU_SW_RESET, 1<<1);
-			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_SW_RESET, 1<<1);
-			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_FIFO_CTRL_STAT, 1<<0);
+			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_FIFO_CTRL_STAT, 1 << 0);
+		} else {
+			aml_set_reg32_mask(P_VIU_SW_RESET, 1 << 1);
+			aml_clr_reg32_mask(P_VIU_SW_RESET, 1 << 1);
+			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_FIFO_CTRL_STAT, 1 << 0);
 			//memcpy(&osd_hw.dispdata[index],&save_disp_data2,sizeof(dispdata_t));
 		}
 	}
-	add_to_update_list(index,OSD_COLOR_MODE);
-	add_to_update_list(index, DISP_GEOMETRY);
-	add_to_update_list(index, DISP_OSD_ROTATE);
+	spin_lock_irqsave(&osd_lock, lock_flags);
+	osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+	osd_hw.reg[index][DISP_GEOMETRY].update_func();
+	osd_hw.reg[index][DISP_OSD_ROTATE].update_func();
+	spin_unlock_irqrestore(&osd_lock, lock_flags);
 	osd_wait_vsync_hw();
 }
 
-void osd_get_osd_rotate_on_hw(u32 index,u32 *on_off)
+void osd_get_osd_rotate_on_hw(u32 index, u32 *on_off)
 {
 	*on_off = osd_hw.rotate[index].on_off;
 }
@@ -1295,30 +1500,29 @@ void osd_set_osd_antiflicker_hw(u32 index, u32 vmode, u32 yres)
 	bool osd_need_antiflicker = false;
 
 	switch (vmode) {
-		case VMODE_480I:
-		case VMODE_480CVBS:
-		case VMODE_576I:
-		case VMODE_576CVBS:
-		case VMODE_1080I:
-		case VMODE_1080I_50HZ:
+	case VMODE_480I:
+	case VMODE_480CVBS:
+	case VMODE_576I:
+	case VMODE_576CVBS:
+	case VMODE_1080I:
+	case VMODE_1080I_50HZ:
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-		case VMODE_1080I_59HZ:
+	case VMODE_1080I_59HZ:
 #endif
-			osd_need_antiflicker = false;
+		osd_need_antiflicker = false;
 		break;
-		default:
+	default:
 		break;
 	}
 
-	if (osd_need_antiflicker){
+	if (osd_need_antiflicker) {
 		osd_hw.antiflicker_mode = 1;
 		osd_antiflicker_task_start();
 		osd_antiflicker_enable(1);
 		osd_antiflicker_update_pan(osd_hw.pandata[index].y_start, yres);
-	}else{
-		if(osd_hw.antiflicker_mode){
+	} else {
+		if (osd_hw.antiflicker_mode)
 			osd_antiflicker_task_stop();
-		}
 		osd_hw.antiflicker_mode = 0;
 	}
 }
@@ -1328,6 +1532,23 @@ void osd_get_osd_antiflicker_hw(u32 index, u32 *on_off)
 	*on_off = osd_hw.antiflicker_mode;
 }
 
+void osd_get_osd_updatestate_hw(u32 index, u32 *up_free)
+{
+	if (osd_vf_need_update)
+		*up_free = 1;
+	else
+		*up_free = 0;
+}
+
+void osd_set_osd_updatestate_hw(u32 index, u32 up_free)
+{
+	if (up_free > 0)
+		osd_vf_need_update = true;
+	else
+		osd_vf_need_update = false;
+}
+
+
 void osd_clone_pan(u32 index, u32 yoffset, int debug_flag)
 {
 	s32 offset = 0;
@@ -1335,47 +1556,45 @@ void osd_clone_pan(u32 index, u32 yoffset, int debug_flag)
 	s32 osd0_buffer_number = 0;
 	s32 height_osd1 = 0;
 
-	if(yoffset != 0){
-		index_buffer = osd_hw.fb_gem[index].height/yoffset;
-		if ( index_buffer == 3){
+	if (yoffset != 0) {
+		index_buffer = osd_hw.fb_gem[index].height / yoffset;
+		if (index_buffer == 3)
 			osd0_buffer_number = 1;
-		}else if (index_buffer == 1){
+		else if (index_buffer == 1)
 			osd0_buffer_number = 2;
-		}
-	}else{
+	} else
 		osd0_buffer_number = 0;
-	}
 
 	osd_clone_get_virtual_yres(&height_osd1);
 	if (osd_hw.clone) {
-		offset = osd0_buffer_number*height_osd1;
+		offset = osd0_buffer_number * height_osd1;
 
 		osd_hw.pandata[OSD2].y_start = offset;
-		osd_hw.pandata[OSD2].y_end = offset+height_osd1-1;
+		osd_hw.pandata[OSD2].y_end = offset + height_osd1 - 1;
 		if (osd_hw.angle[OSD2]) {
-			if(debug_flag){
+			if (debug_flag)
 				printk("++ osd_clone_pan start when enable clone\n");
-			}
 			osd_clone_update_pan(osd0_buffer_number);
 		}
 		add_to_update_list(OSD2, DISP_GEOMETRY);
-		osd_wait_vsync_hw();
 	}
 }
 
-void osd_set_osd_angle_hw(u32 index, u32 angle, u32  virtual_osd1_yres, u32 virtual_osd2_yres)
+void osd_set_osd_angle_hw(u32 index, u32 angle, u32  virtual_osd1_yres,
+			  u32 virtual_osd2_yres)
 {
 #ifndef OSD_GE2D_CLONE_SUPPORT
 	printk("++ osd_clone depends on GE2D module!\n");
 	return;
 #endif
 
-	if(angle > 4) {
+	if (angle > 4) {
 		printk("++ invalid angle: %d\n", angle);
 		return;
 	}
 
-	printk("++ virtual_osd1_yres is %d, virtual_osd2_yres is %d!\n", virtual_osd1_yres, virtual_osd2_yres);
+	printk("++ virtual_osd1_yres is %d, virtual_osd2_yres is %d!\n",
+	       virtual_osd1_yres, virtual_osd2_yres);
 	osd_clone_set_virtual_yres(virtual_osd1_yres, virtual_osd2_yres);
 	if (osd_hw.clone == 0) {
 		printk("++ set osd[%d]->angle: %d->%d\n", index, osd_hw.angle[index], angle);
@@ -1405,16 +1624,14 @@ void osd_set_osd_clone_hw(u32 index, u32 clone)
 		if (osd_hw.angle[index]) {
 			osd_hw.color_info[index] = osd_hw.color_info[OSD1];
 			ret = osd_clone_task_start();
-			if(ret){
+			if (ret)
 				osd_clone_pan(index, osd_hw.pandata[OSD1].y_start, 1);
-			}else{
+			else
 				printk("++ start clone error\n");
-			}
 		}
 	} else {
-		if (osd_hw.angle[index]) {
+		if (osd_hw.angle[index])
 			osd_clone_task_stop();
-		}
 	}
 	add_to_update_list(index, OSD_COLOR_MODE);
 }
@@ -1436,12 +1653,13 @@ void osd_set_osd_reverse_hw(u32 index, u32 reverse)
 	osd_wait_vsync_hw();
 }
 
-void osd_get_osd_reverse_hw(u32 index,u32 *reverse)
+void osd_get_osd_reverse_hw(u32 index, u32 *reverse)
 {
 	*reverse = osd_hw.osd_reverse[index];
 }
 
-void osd_set_prot_canvas_hw(u32 index, s32 x_start, s32 y_start, s32 x_end, s32 y_end)
+void osd_set_prot_canvas_hw(u32 index, s32 x_start, s32 y_start, s32 x_end,
+			    s32 y_end)
 {
 	osd_hw.rotation_pandata[index].x_start = x_start;
 	osd_hw.rotation_pandata[index].y_start = y_start;
@@ -1449,17 +1667,23 @@ void osd_set_prot_canvas_hw(u32 index, s32 x_start, s32 y_start, s32 x_end, s32
 	osd_hw.rotation_pandata[index].y_end = y_end;
 
 	if (osd_hw.rotate[index].on_off && osd_hw.rotate[index].angle > 0) {
-		g_rotation_width = osd_hw.rotation_pandata[index].x_end-osd_hw.rotation_pandata[index].x_start;
-		g_rotation_height = osd_hw.rotation_pandata[index].y_end-osd_hw.rotation_pandata[index].y_start;
-		osd_hw.dispdata[index].x_end = osd_hw.dispdata[OSD1].x_start+g_rotation_height;
-		osd_hw.dispdata[index].y_end = osd_hw.dispdata[OSD1].y_start+g_rotation_width;
+		g_rotation_width = osd_hw.rotation_pandata[index].x_end -
+				   osd_hw.rotation_pandata[index].x_start;
+		g_rotation_height = osd_hw.rotation_pandata[index].y_end -
+				    osd_hw.rotation_pandata[index].y_start;
+		osd_hw.dispdata[index].x_end = osd_hw.dispdata[OSD1].x_start +
+					       g_rotation_height;
+		osd_hw.dispdata[index].y_end = osd_hw.dispdata[OSD1].y_start + g_rotation_width;
 
-		add_to_update_list(index, DISP_GEOMETRY);
-		add_to_update_list(index, OSD_COLOR_MODE);
+		spin_lock_irqsave(&osd_lock, lock_flags);
+		osd_hw.reg[index][DISP_GEOMETRY].update_func();
+		osd_hw.reg[index][OSD_COLOR_MODE].update_func();
+		spin_unlock_irqrestore(&osd_lock, lock_flags);
 	}
 }
 
-void osd_get_prot_canvas_hw(u32 index, s32 *x_start, s32 *y_start, s32 *x_end, s32 *y_end)
+void osd_get_prot_canvas_hw(u32 index, s32 *x_start, s32 *y_start, s32 *x_end,
+			    s32 *y_end)
 {
 	*x_start = osd_hw.rotation_pandata[index].x_start;
 	*y_start = osd_hw.rotation_pandata[index].y_start;
@@ -1467,7 +1691,65 @@ void osd_get_prot_canvas_hw(u32 index, s32 *x_start, s32 *y_start, s32 *x_end, s
 	*y_end = osd_hw.rotation_pandata[index].y_end;
 }
 
-void osd_pan_display_hw(unsigned int xoffset, unsigned int yoffset,int index )
+#ifdef  CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
+void osd_pan_display_fence(osd_fence_map_t *fence_map)
+{
+	s32 ret = 1;
+	long diff_x, diff_y;
+	u32 index = fence_map->fb_index;
+	u32 xoffset = fence_map->xoffset;
+	u32 yoffset = fence_map->yoffset;
+
+	if (index >= 2)
+		return;
+
+	if (timeline_created) { //out fence created success.
+		ret = osd_wait_buf_ready(fence_map);
+		if (ret < 0)
+			amlog_mask_level(LOG_MASK_HARDWARE, LOG_LEVEL_LOW, "fence wait ret %d\n", ret);
+	}
+
+	if (ret) {
+		if (xoffset != osd_hw.pandata[index].x_start ||
+		    yoffset != osd_hw.pandata[index].y_start) {
+			spin_lock_irqsave(&osd_lock, lock_flags);
+			diff_x = xoffset - osd_hw.pandata[index].x_start;
+			diff_y = yoffset - osd_hw.pandata[index].y_start;
+
+			osd_hw.pandata[index].x_start += diff_x;
+			osd_hw.pandata[index].x_end   += diff_x;
+			osd_hw.pandata[index].y_start += diff_y;
+			osd_hw.pandata[index].y_end   += diff_y;
+			osd_hw.reg[index][DISP_GEOMETRY].update_func();
+			if (osd_hw.free_scale_enable[index] && osd_update_window_axis) {
+				osd_hw.reg[index][DISP_FREESCALE_ENABLE].update_func();
+				osd_update_window_axis = false;
+			}
+			spin_unlock_irqrestore(&osd_lock, lock_flags);
+			osd_wait_vsync_hw();
+		}
+	}
+
+	if (timeline_created) {
+		if (ret)
+			sw_sync_timeline_inc(timeline, 1);
+		else
+			printk("------NOT signal out_fence ERROR\n");
+	}
+#ifdef CONFIG_AM_FB_EXT
+	if (ret)
+		osd_ext_clone_pan(index);
+#endif
+
+	amlog_mask_level(LOG_MASK_HARDWARE, LOG_LEVEL_LOW,
+			 "offset[%d-%d]x[%d-%d]y[%d-%d]\n", \
+			 xoffset, yoffset, osd_hw.pandata[index].x_start , osd_hw.pandata[index].x_end ,
+			 \
+			 osd_hw.pandata[index].y_start , osd_hw.pandata[index].y_end);
+}
+#endif
+
+void osd_pan_display_hw(unsigned int xoffset, unsigned int yoffset, int index)
 {
 	long diff_x, diff_y;
 
@@ -1476,10 +1758,10 @@ void osd_pan_display_hw(unsigned int xoffset, unsigned int yoffset,int index )
 #else
 	if (index >= 2)
 #endif
-	return;
+		return;
 
-	if(xoffset!=osd_hw.pandata[index].x_start || yoffset !=osd_hw.pandata[index].y_start)
-	{
+	if (xoffset != osd_hw.pandata[index].x_start ||
+	    yoffset != osd_hw.pandata[index].y_start) {
 		diff_x = xoffset - osd_hw.pandata[index].x_start;
 		diff_y = yoffset - osd_hw.pandata[index].y_start;
 
@@ -1487,225 +1769,264 @@ void osd_pan_display_hw(unsigned int xoffset, unsigned int yoffset,int index )
 		osd_hw.pandata[index].x_end   += diff_x;
 		osd_hw.pandata[index].y_start += diff_y;
 		osd_hw.pandata[index].y_end   += diff_y;
-
-		add_to_update_list(index,DISP_GEOMETRY);
-#if 0
-
-#ifdef CONFIG_AM_FB_EXT
-		osd_ext_clone_pan(index);
-#endif
+		add_to_update_list(index, DISP_GEOMETRY);
 		osd_wait_vsync_hw();
-#endif
-		amlog_mask_level(LOG_MASK_HARDWARE,LOG_LEVEL_LOW,"offset[%d-%d]x[%d-%d]y[%d-%d]\n", \
-				xoffset,yoffset,osd_hw.pandata[index].x_start ,osd_hw.pandata[index].x_end , \
-				osd_hw.pandata[index].y_start ,osd_hw.pandata[index].y_end );
 	}
+#ifdef CONFIG_AM_FB_EXT
+	osd_ext_clone_pan(index);
+#endif
+	amlog_mask_level(LOG_MASK_HARDWARE, LOG_LEVEL_LOW,
+			 "offset[%d-%d]x[%d-%d]y[%d-%d]\n", \
+			 xoffset, yoffset, osd_hw.pandata[index].x_start , osd_hw.pandata[index].x_end ,
+			 \
+			 osd_hw.pandata[index].y_start , osd_hw.pandata[index].y_end);
 }
+
 static  void  osd1_update_disp_scale_enable(void)
 {
-	if(osd_hw.scale[OSD1].h_enable)
-	{
-		VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 3<<12);
-	}
+	if (osd_hw.scale[OSD1].h_enable)
+		VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 3 << 12);
 	else
-	{
-		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 3<<12);
-	}
-	if(osd_hw.scan_mode != SCAN_MODE_INTERLACE)
-	{
-		if(osd_hw.scale[OSD1].v_enable)
-		{
-			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 1<<14);
-		}
+		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 3 << 12);
+	if (osd_hw.scan_mode != SCAN_MODE_INTERLACE) {
+		if (osd_hw.scale[OSD1].v_enable)
+			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 1 << 14);
 		else
-		{
-			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 1<<14);
-		}
+			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 1 << 14);
 	}
 }
+
 static  void  osd2_update_disp_scale_enable(void)
 {
-	if(osd_hw.scale[OSD2].h_enable)
-	{
+	if (osd_hw.scale[OSD2].h_enable) {
 #if defined(CONFIG_FB_OSD2_CURSOR)
-		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 3<<12);
+		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 3 << 12);
 #else
-		VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 3<<12);
+		VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 3 << 12);
 #endif
-	}
-	else
-	{
-		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 3<<12);
-	}
-	if(osd_hw.scan_mode != SCAN_MODE_INTERLACE)
-	{
-		if(osd_hw.scale[OSD2].v_enable)
-		{
+	} else
+		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 3 << 12);
+	if (osd_hw.scan_mode != SCAN_MODE_INTERLACE) {
+		if (osd_hw.scale[OSD2].v_enable) {
 #if defined(CONFIG_FB_OSD2_CURSOR)
-			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 1<<14);
+			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 1 << 14);
 #else
-			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 1<<14);
+			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 1 << 14);
 #endif
-		}
-		else
-		{
-			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 1<<14);
-		}
+		} else
+			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 1 << 14);
 	}
 }
 
-static  void  osd1_update_disp_freescale_enable(void)
+static void osd1_update_disp_freescale_enable(void)
 {
 	int hf_phase_step, vf_phase_step;
-	int dst_w, dst_h;
+	int src_w, src_h, dst_w, dst_h;
 	int bot_ini_phase;
 	int vsc_ini_rcv_num, vsc_ini_rpt_p0_num;
-	int vsc_bot_rcv_num=0, vsc_bot_rpt_p0_num=0;
+	int vsc_bot_rcv_num = 0, vsc_bot_rpt_p0_num = 0;
 	int hsc_ini_rcv_num, hsc_ini_rpt_p0_num;
 
 	int hf_bank_len = 4;
 	int vf_bank_len = 0;
+	u32 data32 = 0x0;
 
-	if(osd_hw.scale_workaround){
+	if (osd_hw.scale_workaround)
 		vf_bank_len = 2;
-	}else{
+	else
 		vf_bank_len = 4;
-	}
 
-	if(osd_hw.bot_type == 1){
+	if (osd_hw.bot_type == 1) {
 		vsc_bot_rcv_num = 4;
 		vsc_bot_rpt_p0_num = 1;
-	}else if(osd_hw.bot_type == 2){
+	} else if (osd_hw.bot_type == 2) {
 		vsc_bot_rcv_num = 6;
 		vsc_bot_rpt_p0_num = 2;
-	}else if(osd_hw.bot_type == 3){
+	} else if (osd_hw.bot_type == 3) {
 		vsc_bot_rcv_num = 8;
 		vsc_bot_rpt_p0_num = 3;
 	}
 	hsc_ini_rcv_num = hf_bank_len;
 	vsc_ini_rcv_num = vf_bank_len;
-	hsc_ini_rpt_p0_num = (hf_bank_len/2 - 1) > 0 ?  (hf_bank_len/2 - 1): 0;
-	vsc_ini_rpt_p0_num = (vf_bank_len/2 - 1) > 0 ?  (vf_bank_len/2 - 1): 0;
+	hsc_ini_rpt_p0_num = (hf_bank_len / 2 - 1) > 0 ? (hf_bank_len / 2 - 1) : 0;
+	vsc_ini_rpt_p0_num = (vf_bank_len / 2 - 1) > 0 ? (vf_bank_len / 2 - 1) : 0;
+
+	src_w = osd_hw.free_scale_width[OSD1];
+	src_h = osd_hw.free_scale_height[OSD1];
+	dst_w = osd_hw.free_dst_data[OSD1].x_end - osd_hw.free_dst_data[OSD1].x_start +
+		1;
+	dst_h = osd_hw.free_dst_data[OSD1].y_end - osd_hw.free_dst_data[OSD1].y_start +
+		1;
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV
+	/* super scaler mode */
+	if (osd_hw.free_scale_mode[OSD1] & 0x2) {
+		if (osd_hw.free_scale_enable[OSD1]) {
+			OSD_SUPER_SCALER_MEM_POWER_ON();
+			/* enable osd scaler path */
+			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, 0x8);
+			/* enable osd super scaler */
+			data32 = (1 << 0)
+				 | (1 << 1)
+				 | (1 << 2);
+			VSYNCOSD_WR_MPEG_REG(OSDSR_CTRL_MODE, data32);
+
+			/* config osd super scaler setting */
+			VSYNCOSD_WR_MPEG_REG(OSDSR_UK_GRAD2DDIAG_LIMIT, 0xffffff);
+			VSYNCOSD_WR_MPEG_REG(OSDSR_UK_GRAD2DADJA_LIMIT, 0xffffff);
+			VSYNCOSD_WR_MPEG_REG(OSDSR_UK_BST_GAIN, 0x7a7a3a50);
+
+			/* config osd super scaler input size */
+			data32 = (src_h & 0x1fff) | (src_w & 0x1fff) << 16;
+			VSYNCOSD_WR_MPEG_REG(OSDSR_HV_SIZEIN, data32);
+
+			/* config osd super scaler output size */
+			data32 = ((osd_hw.free_dst_data[OSD1].x_end & 0xfff) |
+				  (osd_hw.free_dst_data[OSD1].x_start & 0xfff) << 16);
+			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_H_START_END, data32);
+
+			data32 = ((osd_hw.free_dst_data[OSD1].y_end & 0xfff) |
+				  (osd_hw.free_dst_data[OSD1].y_start & 0xfff) << 16);
+			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_V_START_END, data32);
+		} else {
+			/* disable osd scaler path */
+			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, 0);
+			/* disable osd super scaler */
+			VSYNCOSD_WR_MPEG_REG(OSDSR_HV_SIZEIN, 0);
+			VSYNCOSD_WR_MPEG_REG(OSDSR_CTRL_MODE, 0);
+			OSD_SUPER_SCALER_MEM_POWER_OFF();
+		}
+		remove_from_update_list(OSD1, DISP_FREESCALE_ENABLE);
+		return;
+	}
+#endif
 
-	dst_w = osd_hw.free_dst_data[OSD1].x_end -osd_hw.free_dst_data[OSD1].x_start+1;
-	hf_phase_step = ((osd_hw.free_scale_width[OSD1]+1)<< 18) / dst_w;
-	hf_phase_step = (hf_phase_step << 6);
+	data32 = 0x0;
+	if (osd_hw.free_scale_enable[OSD1]) {
+		/* enable osd scaler */
+		if (osd_hw.free_scale_mode[OSD1] & 0x1) {
+			data32 |= 1 << 2; //enable osd scaler
+			data32 |= 1 << 3; //enable osd scaler path
+			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, data32);
+		}
+	} else {
+		/* disable osd scaler path */
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, 0);
+	}
 
-	dst_h = osd_hw.free_dst_data[OSD1].y_end - osd_hw.free_dst_data[OSD1].y_start+1;
-	vf_phase_step = ((osd_hw.free_scale_height[OSD1]+1) << 20) / dst_h;
+	hf_phase_step = (src_w << 18) / dst_w;
+	hf_phase_step = (hf_phase_step << 6);
+	vf_phase_step = (src_h << 20) / dst_h;
 
-	if (osd_hw.field_out_en){  //interface output
-		bot_ini_phase = ((vf_phase_step/2) >> 4);
-	}else{
+	if (osd_hw.field_out_en)   //interface output
+		bot_ini_phase = ((vf_phase_step / 2) >> 4);
+	else
 		bot_ini_phase = 0;
-	}
-
 	vf_phase_step = (vf_phase_step << 4);
 
-	VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SC_DUMMY_DATA, 0x00808000, 0, 32);
-
-	if (osd_hw.free_scale_enable[OSD1]){
-		VSYNCOSD_WR_MPEG_REG_BITS (VPP_OSD_SC_CTRL0, 1, 3, 1);
-		VSYNCOSD_WR_MPEG_REG_BITS (VPP_OSD_SC_CTRL0, OSD1, 0, 2);
-		VSYNCOSD_WR_MPEG_REG_BITS (VPP_OSD_SC_CTRL0, 0, 4, 8);
-	}else{
-		VSYNCOSD_CLR_MPEG_REG_MASK (VPP_OSD_SC_CTRL0, 1<<3);
-	}
-
-	if (osd_hw.free_scale_enable[OSD1]){
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SCI_WH_M1, osd_hw.free_scale_width[OSD1], 16, 13);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SCI_WH_M1, osd_hw.free_scale_height[OSD1], 0,  13);
+	/* config osd scaler in/out hv size */
+	data32 = 0x0;
+	if (osd_hw.free_scale_enable[OSD1]) {
+		data32 = (((src_h - 1) & 0x1fff) | ((src_w - 1) & 0x1fff) << 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCI_WH_M1, data32);
 
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SCO_H_START_END, osd_hw.free_dst_data[OSD1].x_start, 16, 12);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SCO_H_START_END, osd_hw.free_dst_data[OSD1].x_end, 0, 12);
+		data32 = ((osd_hw.free_dst_data[OSD1].x_end & 0xfff) |
+			  (osd_hw.free_dst_data[OSD1].x_start & 0xfff) << 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_H_START_END, data32);
 
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SCO_V_START_END, osd_hw.free_dst_data[OSD1].y_start, 16, 12);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SCO_V_START_END, osd_hw.free_dst_data[OSD1].y_end, 0, 12);
+		data32 = ((osd_hw.free_dst_data[OSD1].y_end & 0xfff) |
+			  (osd_hw.free_dst_data[OSD1].y_start & 0xfff) << 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_V_START_END, data32);
 	}
 
-	if (osd_hw.free_scale[OSD1].vfs_enable){
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, vf_bank_len, 0, 3);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, vsc_ini_rcv_num, 3, 4);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, vsc_ini_rpt_p0_num, 8, 2);
-		if (osd_hw.field_out_en){  //interface output
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, vsc_bot_rcv_num, 11, 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, vsc_bot_rpt_p0_num, 16, 2);
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, 1, 23, 1);
-		}else{
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, 0, 11, 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, 0, 16, 2);
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, 0, 23, 1);
-		}
+	data32 = 0x0;
+	if (osd_hw.free_scale[OSD1].vfs_enable) {
+		data32 |= (vf_bank_len & 0x7) | ((vsc_ini_rcv_num & 0xf) << 3) | ((
+					vsc_ini_rpt_p0_num & 0x3) << 8);
+		if (osd_hw.field_out_en)
+			data32 |= ((vsc_bot_rcv_num & 0xf) << 11) | ((vsc_bot_rpt_p0_num & 0x3) << 16)
+				  | (1 << 23);
 
-		if(osd_hw.scale_workaround){
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, 0x1, 21, 1);
-		} else {
-			VSYNCOSD_CLR_MPEG_REG_MASK(VPP_OSD_VSC_CTRL0, 1<<21);
-		}
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, 1, 24, 1);
-	}else{
-		VSYNCOSD_CLR_MPEG_REG_MASK(VPP_OSD_VSC_CTRL0, 1<<24);
+		if (osd_hw.scale_workaround)
+			data32 |= 1 << 21;
+		data32 |= 1 << 24;
 	}
+	VSYNCOSD_WR_MPEG_REG(VPP_OSD_VSC_CTRL0, data32);
 
-	if (osd_hw.free_scale[OSD1].hfs_enable){
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_CTRL0, hf_bank_len, 0, 3);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_CTRL0, hsc_ini_rcv_num, 3, 3);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_CTRL0, hsc_ini_rpt_p0_num, 8, 2);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_CTRL0, 1, 22, 1);
-	}else{
-		VSYNCOSD_CLR_MPEG_REG_MASK(VPP_OSD_HSC_CTRL0, 1<<22);
+	data32 = 0x0;
+	if (osd_hw.free_scale[OSD1].hfs_enable) {
+		data32 |= (hf_bank_len & 0x7) | ((hsc_ini_rcv_num & 0xf) << 3) | ((
+					hsc_ini_rpt_p0_num & 0x3) << 8);
+		data32 |= 1 << 22;
 	}
+	VSYNCOSD_WR_MPEG_REG(VPP_OSD_HSC_CTRL0, data32);
 
-	if (osd_hw.free_scale_enable[OSD1]){
+	data32 = 0x0;
+	if (osd_hw.free_scale_enable[OSD1]) {
+		data32 |= (bot_ini_phase & 0xffff) << 16;
 		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_PHASE_STEP, hf_phase_step, 0, 28);
 		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_INI_PHASE, 0, 0, 16);
 
 		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_PHASE_STEP, vf_phase_step, 0, 28);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_INI_PHASE, 0, 0, 16);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_INI_PHASE, bot_ini_phase, 16, 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_VSC_INI_PHASE, data32);
 	}
 
-	remove_from_update_list(OSD1,DISP_FREESCALE_ENABLE);
+	remove_from_update_list(OSD1, DISP_FREESCALE_ENABLE);
 }
 
 static void osd1_update_coef(void)
 {
 	int i;
+	bool need_update_coef = false;
 	int hf_coef_wren = 1;
 	int vf_coef_wren = 1;
-
 	int *hf_coef, *vf_coef;
 
-	if(osd_hw.scale_workaround){
-		osd_v_filter_mode = 3;
+	if (osd_hw.scale_workaround) {
+		if (use_v_filter_mode != 3) {
+			use_v_filter_mode = 3;
+			need_update_coef = true;
+		} else
+			need_update_coef = false;
+	} else {
+		if (use_v_filter_mode != osd_v_filter_mode) {
+			use_v_filter_mode = osd_v_filter_mode;
+			need_update_coef = true;
+		} else
+			need_update_coef = false;
 	}
 
-	vf_coef = filter_table[osd_v_filter_mode];
+	if (need_update_coef) {
+		vf_coef = filter_table[use_v_filter_mode];
 
-	if (vf_coef_wren) {
-		VSYNCOSD_WR_MPEG_REG_BITS (VPP_OSD_SCALE_COEF_IDX, 0x0000, 0, 9);
-		for (i = 0; i < 33; i++)
-		{
-			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCALE_COEF, vf_coef[i]);
+		if (vf_coef_wren) {
+			aml_set_reg32_bits(P_VPP_OSD_SCALE_COEF_IDX, 0x0000, 0, 9);
+			for (i = 0; i < 33; i++)
+				aml_write_reg32(P_VPP_OSD_SCALE_COEF, vf_coef[i]);
 		}
 	}
 
-	hf_coef = filter_table[osd_h_filter_mode];
+	need_update_coef = false;
+	if (use_h_filter_mode != osd_h_filter_mode) {
+		use_h_filter_mode = osd_h_filter_mode;
+		need_update_coef = true;
+	}
+	hf_coef = filter_table[use_h_filter_mode];
 
-	if (hf_coef_wren) {
-		VSYNCOSD_WR_MPEG_REG_BITS (VPP_OSD_SCALE_COEF_IDX, 0x0100, 0, 9);
-		for (i = 0; i < 33; i++)
-		{
-			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCALE_COEF, hf_coef[i]);
+	if (need_update_coef) {
+		if (hf_coef_wren) {
+			aml_set_reg32_bits(P_VPP_OSD_SCALE_COEF_IDX, 0x0100, 0, 9);
+			for (i = 0; i < 33; i++)
+				aml_write_reg32(P_VPP_OSD_SCALE_COEF, hf_coef[i]);
 		}
 	}
-	remove_from_update_list(OSD1,OSD_FREESCALE_COEF);
+	remove_from_update_list(OSD1, OSD_FREESCALE_COEF);
 }
 
-static  void  osd2_update_disp_freescale_enable(void)
+static void osd2_update_disp_freescale_enable(void)
 {
 	int hf_phase_step, vf_phase_step;
-	int dst_w, dst_h;
+	int src_w, src_h, dst_w, dst_h;
 	int bot_ini_phase;
 	int vsc_ini_rcv_num, vsc_ini_rpt_p0_num;
 	int vsc_bot_rcv_num = 6, vsc_bot_rpt_p0_num = 2;
@@ -1713,362 +2034,382 @@ static  void  osd2_update_disp_freescale_enable(void)
 
 	int hf_bank_len = 4;
 	int vf_bank_len = 4;
+	u32 data32 = 0x0;
 
-	if(osd_hw.scale_workaround){
+	if (osd_hw.scale_workaround)
 		vf_bank_len = 2;
-	}
-    
+
 	hsc_ini_rcv_num = hf_bank_len;
 	vsc_ini_rcv_num = vf_bank_len;
-	hsc_ini_rpt_p0_num = (hf_bank_len/2 - 1) > 0 ?  (hf_bank_len/2 - 1): 0;
-	vsc_ini_rpt_p0_num = (vf_bank_len/2 - 1) > 0 ?  (vf_bank_len/2 - 1): 0;
+	hsc_ini_rpt_p0_num = (hf_bank_len / 2 - 1) > 0 ? (hf_bank_len / 2 - 1) : 0;
+	vsc_ini_rpt_p0_num = (vf_bank_len / 2 - 1) > 0 ? (vf_bank_len / 2 - 1) : 0;
+
+	src_w = osd_hw.free_scale_width[OSD2];
+	src_h = osd_hw.free_scale_height[OSD2];
+	dst_w = osd_hw.free_dst_data[OSD2].x_end - osd_hw.free_dst_data[OSD2].x_start +
+		1;
+	dst_h = osd_hw.free_dst_data[OSD2].y_end - osd_hw.free_dst_data[OSD2].y_start +
+		1;
+
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESONG9TV
+	/* super scaler mode */
+	if (osd_hw.free_scale_mode[OSD2] & 0x2) {
+		if (osd_hw.free_scale_enable[OSD2]) {
+			OSD_SUPER_SCALER_MEM_POWER_ON();
+			/* enable osd scaler path */
+			data32 = 1;       //select osd2 input
+			data32 |= 1 << 3; //enable osd scaler path
+			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, data32);
+			/* enable osd super scaler */
+			data32 = (1 << 0)
+				 | (1 << 1)
+				 | (1 << 2);
+			VSYNCOSD_WR_MPEG_REG(OSDSR_CTRL_MODE, data32);
+
+			/* config osd super scaler setting */
+			VSYNCOSD_WR_MPEG_REG(OSDSR_UK_GRAD2DDIAG_LIMIT, 0xffffff);
+			VSYNCOSD_WR_MPEG_REG(OSDSR_UK_GRAD2DADJA_LIMIT, 0xffffff);
+			VSYNCOSD_WR_MPEG_REG(OSDSR_UK_BST_GAIN, 0x7a7a3a50);
+
+			/* config osd super scaler input size */
+			data32 = (src_h & 0x1fff) | (src_w & 0x1fff) << 16;
+			VSYNCOSD_WR_MPEG_REG(OSDSR_HV_SIZEIN, data32);
+			/* config osd super scaler output size */
+			data32 = ((osd_hw.free_dst_data[OSD2].x_end & 0xfff) |
+				  (osd_hw.free_dst_data[OSD2].x_start & 0xfff) << 16);
+			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_H_START_END, data32);
+
+			data32 = ((osd_hw.free_dst_data[OSD2].y_end & 0xfff) |
+				  (osd_hw.free_dst_data[OSD2].y_start & 0xfff) << 16);
+			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_V_START_END, data32);
+		} else {
+			/* disable osd scaler path */
+			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, 0);
+			/* disable osd super scaler */
+			VSYNCOSD_WR_MPEG_REG(OSDSR_HV_SIZEIN, 0);
+			VSYNCOSD_WR_MPEG_REG(OSDSR_CTRL_MODE, 0);
+			OSD_SUPER_SCALER_MEM_POWER_OFF();
+		}
+		remove_from_update_list(OSD2, DISP_FREESCALE_ENABLE);
+		return;
+	}
+#endif
 
-	dst_w = osd_hw.free_dst_data[OSD2].x_end -osd_hw.free_dst_data[OSD2].x_start+1;
-	hf_phase_step = ((osd_hw.free_scale_width[OSD2]+1)<< 18) / dst_w;
-	hf_phase_step = (hf_phase_step << 6);
+	/* config osd sc control reg */
+	data32 = 0x0;
+	if (osd_hw.free_scale_enable[OSD2]) {
+		/* enable osd scaler */
+		if (osd_hw.free_scale_mode[OSD2] & 0x1) {
+			data32 |= 1;      //select osd2 input
+			data32 |= 1 << 2; //enable osd scaler
+			data32 |= 1 << 3; //enable osd scaler path
+			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, data32);
+		}
 
-	dst_h = osd_hw.free_dst_data[OSD2].y_end - osd_hw.free_dst_data[OSD2].y_start+1;
-	vf_phase_step = ((osd_hw.free_scale_height[OSD2]+1) << 20) / dst_h;
-	if (osd_hw.field_out_en){  //interface output
-		bot_ini_phase = ((vf_phase_step/2) >> 4);
-	}else{
-		bot_ini_phase = 0;
+	} else {
+		/* disable osd scaler path */
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SC_CTRL0, 0);
 	}
-	vf_phase_step = (vf_phase_step << 4);
 
-	VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SC_DUMMY_DATA, 0x00808000, 0, 32);
+	hf_phase_step = (src_w << 18) / dst_w;
+	hf_phase_step = (hf_phase_step << 6);
+	vf_phase_step = (src_h << 20) / dst_h;
 
-	if (osd_hw.free_scale_enable[OSD2]){
-		VSYNCOSD_WR_MPEG_REG_BITS (VPP_OSD_SC_CTRL0, 1, 3, 1);
-		VSYNCOSD_WR_MPEG_REG_BITS (VPP_OSD_SC_CTRL0, OSD2, 0, 2);
-		VSYNCOSD_WR_MPEG_REG_BITS (VPP_OSD_SC_CTRL0, 0, 4, 8);
-	}else{
-		if (!osd_hw.free_scale_enable[OSD1]){
-		    VSYNCOSD_CLR_MPEG_REG_MASK (VPP_OSD_SC_CTRL0, 1<<3);
-		}
-	}
+	if (osd_hw.field_out_en)   //interface output
+		bot_ini_phase = ((vf_phase_step / 2) >> 4);
+	else
+		bot_ini_phase = 0;
+	vf_phase_step = (vf_phase_step << 4);
 
-	if (osd_hw.free_scale_enable[OSD2]){
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SCI_WH_M1, osd_hw.free_scale_width[OSD2], 16, 13);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SCI_WH_M1, osd_hw.free_scale_height[OSD2], 0, 13);
+	/* config osd scaler in/out hv size */
+	data32 = 0x0;
+	if (osd_hw.free_scale_enable[OSD2]) {
+		data32 = (((src_h - 1) & 0x1fff) | ((src_w - 1) & 0x1fff) << 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCI_WH_M1, data32);
 
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SCO_H_START_END, osd_hw.free_dst_data[OSD2].x_start, 16, 12);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SCO_H_START_END, osd_hw.free_dst_data[OSD2].x_end, 0, 12);
+		data32 = ((osd_hw.free_dst_data[OSD2].x_end & 0xfff) |
+			  (osd_hw.free_dst_data[OSD2].x_start & 0xfff) << 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_H_START_END, data32);
 
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SCO_V_START_END, osd_hw.free_dst_data[OSD2].y_start, 16, 12);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_SCO_V_START_END, osd_hw.free_dst_data[OSD2].y_end, 0, 12);
+		data32 = ((osd_hw.free_dst_data[OSD2].y_end & 0xfff) |
+			  (osd_hw.free_dst_data[OSD2].y_start & 0xfff) << 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCO_V_START_END, data32);
 	}
 
-	if (osd_hw.free_scale[OSD2].hfs_enable){
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_CTRL0, hf_bank_len, 0, 3);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_CTRL0, hsc_ini_rcv_num, 3, 3);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_CTRL0, hsc_ini_rpt_p0_num, 8, 2);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_CTRL0, 1, 22, 1);
-	}else{
-		if (!osd_hw.free_scale[OSD1].hfs_enable){
-		    VSYNCOSD_CLR_MPEG_REG_MASK(VPP_OSD_HSC_CTRL0, 1<<22);
-		}
+	data32 = 0x0;
+	if (osd_hw.free_scale[OSD2].hfs_enable) {
+		data32 |= (hf_bank_len & 0x7) | ((hsc_ini_rcv_num & 0xf) << 3) | ((
+					hsc_ini_rpt_p0_num & 0x3) << 8);
+		data32 |= 1 << 22;
 	}
+	VSYNCOSD_WR_MPEG_REG(VPP_OSD_HSC_CTRL0, data32);
 
-	if (osd_hw.free_scale[OSD2].vfs_enable){
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, vf_bank_len, 0, 3);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, vsc_ini_rcv_num, 3, 3);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, vsc_ini_rpt_p0_num, 8, 2);
-		if (osd_hw.field_out_en){  //interface output
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, vsc_bot_rcv_num, 11, 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, vsc_bot_rpt_p0_num, 16, 2);
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, 1, 23, 1);
-		}else{
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, 0, 11, 4);
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, 0, 16, 2);
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, 0, 23, 1);
-		}
+	data32 = 0x0;
+	if (osd_hw.free_scale[OSD2].vfs_enable) {
+		data32 |= (vf_bank_len & 0x7) | ((vsc_ini_rcv_num & 0xf) << 3) | ((
+					vsc_ini_rpt_p0_num & 0x3) << 8);
+		if (osd_hw.field_out_en)   //interface output
+			data32 |= ((vsc_bot_rcv_num & 0xf) << 11) | ((vsc_bot_rpt_p0_num & 0x3) << 16)
+				  | (1 << 23);
 
-		if(osd_hw.scale_workaround){
-			VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, 0x1, 21, 1);
-		} else {
-			VSYNCOSD_CLR_MPEG_REG_MASK(VPP_OSD_VSC_CTRL0, 1<<21);
-		}
-        
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_CTRL0, 1, 24, 1);
-	}else{
-		if (!osd_hw.free_scale[OSD1].vfs_enable){
-		    VSYNCOSD_CLR_MPEG_REG_MASK(VPP_OSD_VSC_CTRL0, 1<<24);
-		}
+		if (osd_hw.scale_workaround)
+			data32 |= 1 << 21;
+		data32 |= 1 << 24;
 	}
+	VSYNCOSD_WR_MPEG_REG(VPP_OSD_VSC_CTRL0, data32);
 
-	if (osd_hw.free_scale_enable[OSD2]){
+	data32 = 0x0;
+	if (osd_hw.free_scale_enable[OSD2]) {
+		data32 |= (bot_ini_phase & 0xffff) << 16;
 		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_PHASE_STEP, hf_phase_step, 0, 28);
 		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_HSC_INI_PHASE, 0, 0, 16);
 
 		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_PHASE_STEP, vf_phase_step, 0, 28);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_INI_PHASE, 0, 0, 16);
-		VSYNCOSD_WR_MPEG_REG_BITS(VPP_OSD_VSC_INI_PHASE, bot_ini_phase, 16, 16);
+		VSYNCOSD_WR_MPEG_REG(VPP_OSD_VSC_INI_PHASE, data32);
 	}
-	remove_from_update_list(OSD2,DISP_FREESCALE_ENABLE);
+	remove_from_update_list(OSD2, DISP_FREESCALE_ENABLE);
 }
 
 static void osd2_update_coef(void)
 {
 	int i;
+	bool need_update_coef = false;
 	int hf_coef_wren = 1;
 
 	int vf_coef_wren = 1;
 	int *hf_coef, *vf_coef;
 
-	if(osd_hw.scale_workaround){
-		osd_v_filter_mode = 3;
+	if (osd_hw.scale_workaround) {
+		if (use_v_filter_mode != 3) {
+			use_v_filter_mode = 3;
+			need_update_coef = true;
+		} else
+			need_update_coef = false;
+	} else {
+		if (use_v_filter_mode != osd_v_filter_mode) {
+			use_v_filter_mode = osd_v_filter_mode;
+			need_update_coef = true;
+		} else
+			need_update_coef = false;
 	}
 
-	vf_coef = filter_table[osd_v_filter_mode];
+	vf_coef = filter_table[use_v_filter_mode];
 
-	if (vf_coef_wren) {
-		VSYNCOSD_WR_MPEG_REG_BITS (VPP_OSD_SCALE_COEF_IDX, 0x0000, 0, 9);
-		for (i = 0; i < 33; i++)
-		{
-			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCALE_COEF, vf_coef[i]);
+	if (need_update_coef) {
+		if (vf_coef_wren) {
+			aml_set_reg32_bits(P_VPP_OSD_SCALE_COEF_IDX, 0x0000, 0, 9);
+			for (i = 0; i < 33; i++)
+				aml_write_reg32(P_VPP_OSD_SCALE_COEF, vf_coef[i]);
 		}
 	}
 
-	hf_coef = filter_table[osd_h_filter_mode];
+	need_update_coef = false;
+	if (use_h_filter_mode != osd_h_filter_mode) {
+		use_h_filter_mode = osd_h_filter_mode;
+		need_update_coef = true;
+	}
+	hf_coef = filter_table[use_h_filter_mode];
 
-	if (hf_coef_wren) {
-		VSYNCOSD_WR_MPEG_REG_BITS (VPP_OSD_SCALE_COEF_IDX, 0x0100, 0, 9);
-		for (i = 0; i < 33; i++)
-		{
-			VSYNCOSD_WR_MPEG_REG(VPP_OSD_SCALE_COEF, hf_coef[i]);
+	if (need_update_coef) {
+		if (hf_coef_wren) {
+			aml_set_reg32_bits(P_VPP_OSD_SCALE_COEF_IDX, 0x0100, 0, 9);
+			for (i = 0; i < 33; i++)
+				aml_write_reg32(P_VPP_OSD_SCALE_COEF, hf_coef[i]);
 		}
 	}
-	remove_from_update_list(OSD2,OSD_FREESCALE_COEF);
+	remove_from_update_list(OSD2, OSD_FREESCALE_COEF);
 }
 
 static   void  osd1_update_color_mode(void)
 {
-	u32  data32=0;
+	u32  data32 = 0;
 
 	if (osd_hw.color_info[OSD1] != NULL) {
-		data32= (osd_hw.scan_mode== SCAN_MODE_INTERLACE) ? 2 : 0;
-		data32 |= VSYNCOSD_RD_MPEG_REG(VIU_OSD1_BLK0_CFG_W0)&0x30007040;
-		data32 |= osd_hw.fb_gem[OSD1].canvas_idx << 16 ;
-		if(!osd_hw.rotate[OSD1].on_off)
-		data32 |= OSD_DATA_LITTLE_ENDIAN	 <<15 ;
-
-		data32 |= osd_hw.color_info[OSD1]->hw_colormat<< 2;
-		if(osd_hw.color_info[OSD1]->color_index < COLOR_INDEX_YUV_422)
-			data32 |= 1                      << 7; /* rgb enable */
-		data32 |=  osd_hw.color_info[OSD1]->hw_blkmode<< 8; /* osd_blk_mode */
+		data32 = (osd_hw.scan_mode == SCAN_MODE_INTERLACE) ? 2 : 0;
+		data32 |= VSYNCOSD_RD_MPEG_REG(VIU_OSD1_BLK0_CFG_W0) & 0x30007040;
+		data32 |= osd_hw.fb_gem[OSD1].canvas_idx << 16;
+
+		if (!osd_hw.rotate[OSD1].on_off)
+			data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
+
+		data32 |= osd_hw.color_info[OSD1]->hw_colormat << 2;
+		if (osd_hw.color_info[OSD1]->color_index < COLOR_INDEX_YUV_422) {
+			data32 |= 1 << 7; /* rgb enable */
+		}
+		data32 |=  osd_hw.color_info[OSD1]->hw_blkmode << 8; /* osd_blk_mode */
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W0, data32);
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK1_CFG_W0, data32);
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK2_CFG_W0, data32);
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK3_CFG_W0, data32);
 	}
-	remove_from_update_list(OSD1,OSD_COLOR_MODE);
+	remove_from_update_list(OSD1, OSD_COLOR_MODE);
 }
 static   void  osd2_update_color_mode(void)
 {
-	u32  data32=0;
+	u32  data32 = 0;
 	if (osd_hw.color_info[OSD2] != NULL) {
-		data32= (osd_hw.scan_mode== SCAN_MODE_INTERLACE)? 2 : 0;
-		data32 |=VSYNCOSD_RD_MPEG_REG(VIU_OSD2_BLK0_CFG_W0)&0x30007040;
-		data32 |= osd_hw.fb_gem[OSD2].canvas_idx << 16 ;
-		if(!osd_hw.rotate[OSD1].on_off)
-		data32 |= OSD_DATA_LITTLE_ENDIAN	 <<15 ;
-
-		data32 |= osd_hw.color_info[OSD2]->hw_colormat<< 2;
-		if(osd_hw.color_info[OSD2]->color_index < COLOR_INDEX_YUV_422)
-			data32 |= 1                      << 7; /* rgb enable */
-		data32 |=  osd_hw.color_info[OSD2]->hw_blkmode<< 8; /* osd_blk_mode */
+		data32 = (osd_hw.scan_mode == SCAN_MODE_INTERLACE) ? 2 : 0;
+		data32 |= VSYNCOSD_RD_MPEG_REG(VIU_OSD2_BLK0_CFG_W0) & 0x30007040;
+		data32 |= osd_hw.fb_gem[OSD2].canvas_idx << 16;
+
+		if (!osd_hw.rotate[OSD2].on_off)
+			data32 |= OSD_DATA_LITTLE_ENDIAN << 15;
+
+		data32 |= osd_hw.color_info[OSD2]->hw_colormat << 2;
+		if (osd_hw.color_info[OSD2]->color_index < COLOR_INDEX_YUV_422) {
+			data32 |= 1 << 7; /* rgb enable */
+		}
+		data32 |=  osd_hw.color_info[OSD2]->hw_blkmode << 8; /* osd_blk_mode */
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W0, data32);
 	}
-	remove_from_update_list(OSD2,OSD_COLOR_MODE);
-}
-
-static   void  osd1_update_enable(void)
-{
-    unsigned long flags;
-    if (osd_hw.free_scale_mode[OSD1]){
-        spin_lock_irqsave(&osd_onoff_lock, flags);
-        if (osd_hw.enable[OSD1] == ENABLE){
-            aml_set_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
-            aml_set_reg32_mask(P_VPP_MISC,VPP_POSTBLEND_EN);
-        }else{
-            aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
-        }
-        spin_unlock_irqrestore(&osd_onoff_lock, flags);
-    }else{
-        u32  video_enable=0;
-        spin_lock_irqsave(&osd_onoff_lock, flags);
-        video_enable |=aml_read_reg32(P_VPP_MISC)&VPP_VD1_PREBLEND;
-
-        if(osd_hw.enable[OSD1]==ENABLE)
-        {
-            if(osd_hw.free_scale_enable[OSD1])
-            {
-                aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
-                aml_set_reg32_mask(P_VPP_MISC,VPP_OSD1_PREBLEND);
-                aml_set_reg32_mask(P_VPP_MISC,VPP_VD1_POSTBLEND);
-                aml_set_reg32_mask(P_VPP_MISC,VPP_PREBLEND_EN);
-            }
-            else
-            {
-                aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD1_PREBLEND);
-                if(!video_enable)
-                {
-                    aml_clr_reg32_mask(P_VPP_MISC,VPP_VD1_POSTBLEND);
-                }
-                aml_set_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
-            }
-
-        }
-        else
-        {
-            if(osd_hw.free_scale_enable[OSD1])
-            {
-                aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD1_PREBLEND);
-            }
-            else
-            {
-                aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
-            }
-        }
-        spin_unlock_irqrestore(&osd_onoff_lock, flags);
-    }
-    remove_from_update_list(OSD1,OSD_ENABLE);
-}
-static   void  osd2_update_enable(void)
-{
-    unsigned long flags;
-    if (osd_hw.free_scale_mode[OSD2]){
-        spin_lock_irqsave(&osd_onoff_lock, flags);
-        if (osd_hw.enable[OSD2] == ENABLE){
-            // osd1 and osd2 share the only one freescale, so set  VPP_OSD1_POSTBLEND here.
-            if(osd_hw.free_scale_enable[OSD2]){
-                aml_set_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
-                aml_set_reg32_mask(P_VPP_MISC,VPP_POSTBLEND_EN);
-            }else{
-				#ifndef CONFIG_FB_OSD2_CURSOR
-                aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND);
-				#endif
-                aml_set_reg32_mask(P_VPP_MISC,VPP_OSD2_POSTBLEND);
-                aml_set_reg32_mask(P_VPP_MISC,VPP_POSTBLEND_EN);
-            }
-        }else{
-            if (osd_hw.enable[OSD1] == ENABLE){
-                aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD2_POSTBLEND);
-            } else {
-                aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND|VPP_OSD2_POSTBLEND);
-            }
-        }
-        spin_unlock_irqrestore(&osd_onoff_lock, flags);
-    }else{
-        u32  video_enable=0;
-        video_enable |=VSYNCOSD_RD_MPEG_REG(VPP_MISC)&VPP_VD1_PREBLEND;
-        spin_lock_irqsave(&osd_onoff_lock, flags);
-        if(osd_hw.enable[OSD2]==ENABLE)
-        {
-            if(osd_hw.free_scale_enable[OSD2])
-            {
-                aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD2_POSTBLEND);
-                aml_set_reg32_mask(P_VPP_MISC,VPP_OSD2_PREBLEND);
-                aml_set_reg32_mask(P_VPP_MISC,VPP_VD1_POSTBLEND);
-            }
-            else
-            {
-                aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD2_PREBLEND);
-                if(!video_enable)
-                {
-                    aml_clr_reg32_mask(P_VPP_MISC,VPP_VD1_POSTBLEND);
-                }
-                aml_set_reg32_mask(P_VPP_MISC,VPP_OSD2_POSTBLEND);
-            }
-
-        }
-        else
-        {
-            if(osd_hw.free_scale_enable[OSD2])
-            {
-                aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD2_PREBLEND);
-            }
-            else
-            {
-                aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD2_POSTBLEND);
-            }
-        }
-         spin_unlock_irqrestore(&osd_onoff_lock, flags);
-    }
-    remove_from_update_list(OSD2,OSD_ENABLE);
+	remove_from_update_list(OSD2, OSD_COLOR_MODE);
 }
 
-static void osd1_update_disp_osd_reverse(void)
+static void osd1_update_enable(void)
+{
+	u32 video_enable = 0;
+
+	if (osd_hw.free_scale_mode[OSD1]) {
+		if (osd_hw.enable[OSD1] == ENABLE) {
+			VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC, VPP_OSD1_POSTBLEND | VPP_POSTBLEND_EN);
+			VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD1_CTRL_STAT, 1 << 21);
+		} else {
+			VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_CTRL_STAT, 1 << 21);
+			VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_OSD1_POSTBLEND);
+		}
+	} else {
+		video_enable |= VSYNCOSD_RD_MPEG_REG(VPP_MISC)&VPP_VD1_PREBLEND;
+		if (osd_hw.enable[OSD1] == ENABLE) {
+			if (osd_hw.free_scale_enable[OSD1]) {
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_OSD1_POSTBLEND);
+				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC,
+							   VPP_OSD1_PREBLEND | VPP_VD1_POSTBLEND | VPP_PREBLEND_EN);
+			} else {
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_OSD1_PREBLEND);
+				if (!video_enable)
+					VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_VD1_POSTBLEND);
+				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC, VPP_OSD1_POSTBLEND);
+			}
+		} else {
+			if (osd_hw.free_scale_enable[OSD1])
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_OSD1_PREBLEND);
+			else
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_OSD1_POSTBLEND);
+		}
+	}
+	remove_from_update_list(OSD1, OSD_ENABLE);
+}
+
+static void osd2_update_enable(void)
 {
-	if (osd_hw.osd_reverse[OSD1]){
-		VSYNCOSD_WR_MPEG_REG_BITS (VIU_OSD1_BLK0_CFG_W0, 3, 28, 2);
-	}else{
-		VSYNCOSD_CLR_MPEG_REG_MASK (VIU_OSD1_BLK0_CFG_W0, 3<<28);
+	u32 video_enable = 0;
+
+	if (osd_hw.free_scale_mode[OSD2]) {
+		if (osd_hw.enable[OSD2] == ENABLE) {
+			if (osd_hw.free_scale_enable[OSD2]) {
+				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC, VPP_OSD1_POSTBLEND | VPP_POSTBLEND_EN);
+				VSYNCOSD_SET_MPEG_REG_MASK(VIU_OSD2_CTRL_STAT, 1 << 21);
+			} else {
+				VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_CTRL_STAT, 1 << 21);
+#ifndef CONFIG_FB_OSD2_CURSOR
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_OSD1_POSTBLEND);
+#endif
+				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC, VPP_OSD2_POSTBLEND | VPP_POSTBLEND_EN);
+			}
+		} else {
+			if (osd_hw.enable[OSD1] == ENABLE)
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_OSD2_POSTBLEND);
+			else
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_OSD1_POSTBLEND | VPP_OSD2_POSTBLEND);
+		}
+	} else {
+		video_enable |= VSYNCOSD_RD_MPEG_REG(VPP_MISC)&VPP_VD1_PREBLEND;
+		if (osd_hw.enable[OSD2] == ENABLE) {
+			if (osd_hw.free_scale_enable[OSD2]) {
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_OSD2_POSTBLEND);
+				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC, VPP_OSD2_PREBLEND | VPP_VD1_POSTBLEND);
+			} else {
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_OSD2_PREBLEND);
+				if (!video_enable)
+					VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_VD1_POSTBLEND);
+				VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC, VPP_OSD2_POSTBLEND);
+			}
+		} else {
+			if (osd_hw.free_scale_enable[OSD2])
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_OSD2_PREBLEND);
+			else
+				VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, VPP_OSD2_POSTBLEND);
+		}
 	}
+	remove_from_update_list(OSD2, OSD_ENABLE);
+}
+
+static void osd1_update_disp_osd_reverse(void)
+{
+	if (osd_hw.osd_reverse[OSD1])
+		VSYNCOSD_WR_MPEG_REG_BITS(VIU_OSD1_BLK0_CFG_W0, 3, 28, 2);
+	else
+		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD1_BLK0_CFG_W0, 3 << 28);
 	remove_from_update_list(OSD1, DISP_OSD_REVERSE);
 }
 
 static void osd2_update_disp_osd_reverse(void)
 {
-	if (osd_hw.osd_reverse[OSD2]){
-		VSYNCOSD_WR_MPEG_REG_BITS (VIU_OSD2_BLK0_CFG_W0, 3, 28, 2);
-	}else{
-		VSYNCOSD_CLR_MPEG_REG_MASK (VIU_OSD2_BLK0_CFG_W0, 3<<28);
-	}
+	if (osd_hw.osd_reverse[OSD2])
+		VSYNCOSD_WR_MPEG_REG_BITS(VIU_OSD2_BLK0_CFG_W0, 3, 28, 2);
+	else
+		VSYNCOSD_CLR_MPEG_REG_MASK(VIU_OSD2_BLK0_CFG_W0, 3 << 28);
 	remove_from_update_list(OSD2, DISP_OSD_REVERSE);
 }
 static void osd1_update_disp_osd_rotate(void)
 {
-	unsigned char 	x_rev=0,y_rev=0;
-	unsigned char 	bpp=32;
+	unsigned char 	x_rev = 0, y_rev = 0;
+	unsigned char 	bpp = 32;
 	unsigned int	x_start;
 	unsigned int	x_end;
 	unsigned int	y_start;
 	unsigned int	y_end;
 	unsigned int	y_len_m1;
 
-	if( osd_hw.color_info[OSD1]->color_index <=COLOR_INDEX_08_PAL256){
-		bpp=8;
-	}else if( osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_16_565){
-		bpp=16;
-	}else if( osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_24_RGB){
-		bpp=24;
-	}else if( osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_32_ARGB){
-		bpp=32;
-	}
-
-	switch(osd_hw.rotate[OSD1].angle)
-	{
-	  case 0://clockwise H flip (dst )
-	  x_rev=0;
-	  y_rev=0;
-	  break;//clockwise
-	  case 1:
-	  y_rev=1;
-	  break;
-	  case 2://anti-clockwise
-	  x_rev=1;
-	  break;
-	  case 3://anti-clockwise H flip(dst)
-	  x_rev=1;
-	  y_rev=1;
-	  break;
+	if (osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_08_PAL256)
+		bpp = 8;
+	else if (osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_16_565)
+		bpp = 16;
+	else if (osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_24_RGB)
+		bpp = 24;
+	else if (osd_hw.color_info[OSD1]->color_index <= COLOR_INDEX_32_ARGB)
+		bpp = 32;
+
+	switch (osd_hw.rotate[OSD1].angle) {
+	case 0://clockwise H flip (dst )
+		x_rev = 0;
+		y_rev = 0;
+		break;//clockwise
+	case 1:
+		y_rev = 1;
+		break;
+	case 2://anti-clockwise
+		x_rev = 1;
+		break;
+	case 3://anti-clockwise H flip(dst)
+		x_rev = 1;
+		y_rev = 1;
+		break;
 	}
 
 	x_start = osd_hw.rotation_pandata[OSD1].x_start;
 	x_end = osd_hw.rotation_pandata[OSD1].x_end;
 	y_start = osd_hw.rotation_pandata[OSD1].y_start;
 	y_end = osd_hw.rotation_pandata[OSD1].y_end;
-	y_len_m1 = y_end-y_start;
+	y_len_m1 = y_end - y_start;
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 	{
-		if(IS_MESON_M8_CPU){
+		if (IS_MESON_M8_CPU) {
 			osd_set_prot(
 				x_rev,
 				y_rev,
-				(bpp>>3)-1,				//unsigned char   bytes_per_pixel,
+				(bpp >> 3) - 1,				//unsigned char   bytes_per_pixel,
 				0,				//unsigned char   conv_422to444,
 				OSD_DATA_LITTLE_ENDIAN,		//unsigned char   little_endian,
 				HOLD_LINES,			//unsigned int    hold_lines,
@@ -2097,54 +2438,52 @@ static void osd1_update_disp_osd_rotate(void)
 }
 static void osd2_update_disp_osd_rotate(void)
 {
-	unsigned char 	x_rev=0,y_rev=0;
-	unsigned char 	bpp=32;
+	unsigned char 	x_rev = 0, y_rev = 0;
+	unsigned char 	bpp = 32;
 	unsigned int	x_start;
 	unsigned int	x_end;
 	unsigned int	y_start;
 	unsigned int	y_end;
 	unsigned int	y_len_m1;
 
-	if( osd_hw.color_info[OSD2]->color_index <=COLOR_INDEX_08_PAL256){
-		bpp=8;
-	}else if( osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_16_565){
-		bpp=16;
-	}else if( osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_24_RGB){
-		bpp=24;
-	}else if( osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_32_ARGB){
-		bpp=32;
-	}
-	switch(osd_hw.rotate[OSD2].angle)
-	{
-	  case 0://clockwise H flip (dst )
-	  x_rev=0;
-	  y_rev=0;
-	  break;//clockwise
-	  case 1:
-	  y_rev=1;
-	  break;
-	  case 2://anti-clockwise
-	  x_rev=1;
-          break;
-	  case 3://anti-clockwise H flip(dst)
-	  x_rev=1;
-	  y_rev=1;
-	  break;
+	if (osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_08_PAL256)
+		bpp = 8;
+	else if (osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_16_565)
+		bpp = 16;
+	else if (osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_24_RGB)
+		bpp = 24;
+	else if (osd_hw.color_info[OSD2]->color_index <= COLOR_INDEX_32_ARGB)
+		bpp = 32;
+	switch (osd_hw.rotate[OSD2].angle) {
+	case 0://clockwise H flip (dst )
+		x_rev = 0;
+		y_rev = 0;
+		break;//clockwise
+	case 1:
+		y_rev = 1;
+		break;
+	case 2://anti-clockwise
+		x_rev = 1;
+		break;
+	case 3://anti-clockwise H flip(dst)
+		x_rev = 1;
+		y_rev = 1;
+		break;
 	}
 
 	x_start = osd_hw.rotation_pandata[OSD2].x_start;
 	x_end = osd_hw.rotation_pandata[OSD2].x_end;
 	y_start = osd_hw.rotation_pandata[OSD2].y_start;
 	y_end = osd_hw.rotation_pandata[OSD2].y_end;
-	y_len_m1 = y_end-y_start;
+	y_len_m1 = y_end - y_start;
 
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 	{
-		if(IS_MESON_M8_CPU){
+		if (IS_MESON_M8_CPU) {
 			osd_set_prot(
 				x_rev,
 				y_rev,
-				(bpp>>3)-1,				//unsigned char   bytes_per_pixel,
+				(bpp >> 3) - 1,				//unsigned char   bytes_per_pixel,
 				0,				//unsigned char   conv_422to444,
 				OSD_DATA_LITTLE_ENDIAN,		//unsigned char   little_endian,
 				HOLD_LINES,			//unsigned int    hold_lines,
@@ -2169,96 +2508,94 @@ static void osd2_update_disp_osd_rotate(void)
 		}
 	}
 #endif
-    remove_from_update_list(OSD2, DISP_OSD_ROTATE);
+	remove_from_update_list(OSD2, DISP_OSD_ROTATE);
 }
 
 
 static  void  osd1_update_color_key(void)
 {
-	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_TCOLOR_AG0,osd_hw.color_key[OSD1]);
-	remove_from_update_list(OSD1,OSD_COLOR_KEY);
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_TCOLOR_AG0, osd_hw.color_key[OSD1]);
+	remove_from_update_list(OSD1, OSD_COLOR_KEY);
 }
 static   void  osd2_update_color_key(void)
 {
-	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_TCOLOR_AG0,osd_hw.color_key[OSD2]);
-	remove_from_update_list(OSD2,OSD_COLOR_KEY);
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_TCOLOR_AG0, osd_hw.color_key[OSD2]);
+	remove_from_update_list(OSD2, OSD_COLOR_KEY);
 }
 static  void  osd1_update_color_key_enable(void)
 {
 	u32  data32;
-	data32=VSYNCOSD_RD_MPEG_REG(VIU_OSD1_BLK0_CFG_W0);
-	data32&=~(1<<6);
-	data32|=(osd_hw.color_key_enable[OSD1]<<6);
-	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W0,data32);
-	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK1_CFG_W0,data32);
-	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK2_CFG_W0,data32);
-	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK3_CFG_W0,data32);
-	remove_from_update_list(OSD1,OSD_COLOR_KEY_ENABLE);
+	data32 = VSYNCOSD_RD_MPEG_REG(VIU_OSD1_BLK0_CFG_W0);
+	data32 &= ~(1 << 6);
+	data32 |= (osd_hw.color_key_enable[OSD1] << 6);
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W0, data32);
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK1_CFG_W0, data32);
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK2_CFG_W0, data32);
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK3_CFG_W0, data32);
+	remove_from_update_list(OSD1, OSD_COLOR_KEY_ENABLE);
 }
 static  void  osd2_update_color_key_enable(void)
 {
 	u32  data32;
-	data32=VSYNCOSD_RD_MPEG_REG(VIU_OSD2_BLK0_CFG_W0);
-	data32&=~(1<<6);
-	data32|=(osd_hw.color_key_enable[OSD2]<<6);
-	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W0,data32);
-	remove_from_update_list(OSD2,OSD_COLOR_KEY_ENABLE);
+	data32 = VSYNCOSD_RD_MPEG_REG(VIU_OSD2_BLK0_CFG_W0);
+	data32 &= ~(1 << 6);
+	data32 |= (osd_hw.color_key_enable[OSD2] << 6);
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W0, data32);
+	remove_from_update_list(OSD2, OSD_COLOR_KEY_ENABLE);
 }
 static   void  osd1_update_gbl_alpha(void)
 {
 	u32  data32;
 
-	data32=VSYNCOSD_RD_MPEG_REG(VIU_OSD1_CTRL_STAT);
-	data32&=~(0x1ff<<12);
-	data32|=osd_hw.gbl_alpha[OSD1] <<12;
-	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_CTRL_STAT,data32);
-	remove_from_update_list(OSD1,OSD_GBL_ALPHA);
+	data32 = VSYNCOSD_RD_MPEG_REG(VIU_OSD1_CTRL_STAT);
+	data32 &= ~(0x1ff << 12);
+	data32 |= osd_hw.gbl_alpha[OSD1] << 12;
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD1_CTRL_STAT, data32);
+	remove_from_update_list(OSD1, OSD_GBL_ALPHA);
 }
 static   void  osd2_update_gbl_alpha(void)
 {
 	u32  data32;
 
-	data32=VSYNCOSD_RD_MPEG_REG(VIU_OSD2_CTRL_STAT);
-	data32&=~(0x1ff<<12);
-	data32|=osd_hw.gbl_alpha[OSD2] <<12;
-	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_CTRL_STAT,data32);
-	remove_from_update_list(OSD2,OSD_GBL_ALPHA);
+	data32 = VSYNCOSD_RD_MPEG_REG(VIU_OSD2_CTRL_STAT);
+	data32 &= ~(0x1ff << 12);
+	data32 |= osd_hw.gbl_alpha[OSD2] << 12;
+	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_CTRL_STAT, data32);
+	remove_from_update_list(OSD2, OSD_GBL_ALPHA);
 }
 static   void  osd2_update_order(void)
 {
-    unsigned long flags;
-    spin_lock_irqsave(&osd_onoff_lock, flags);
-    switch(osd_hw.osd_order)
-    {
-        case  OSD_ORDER_01:
-        aml_clr_reg32_mask(P_VPP_MISC,VPP_POST_FG_OSD2|VPP_PRE_FG_OSD2);
-        break;
-        case  OSD_ORDER_10:
-        aml_clr_reg32_mask(P_VPP_MISC,VPP_POST_FG_OSD2|VPP_PRE_FG_OSD2);
-        break;
-        default:
-        break;
-    }
-    spin_unlock_irqrestore(&osd_onoff_lock, flags);
-    remove_from_update_list(OSD2,OSD_CHANGE_ORDER);
+	unsigned long flags;
+	spin_lock_irqsave(&osd_onoff_lock, flags);
+	switch (osd_hw.osd_order) {
+	case  OSD_ORDER_01:
+		aml_clr_reg32_mask(P_VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+		break;
+	case  OSD_ORDER_10:
+		aml_clr_reg32_mask(P_VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&osd_onoff_lock, flags);
+	remove_from_update_list(OSD2, OSD_CHANGE_ORDER);
 }
 static   void  osd1_update_order(void)
 {
-    unsigned long flags;
-    spin_lock_irqsave(&osd_onoff_lock, flags);
-    switch(osd_hw.osd_order)
-    {
-        case  OSD_ORDER_01:
-        aml_clr_reg32_mask(P_VPP_MISC,VPP_POST_FG_OSD2|VPP_PRE_FG_OSD2);
-        break;
-        case  OSD_ORDER_10:
-        aml_clr_reg32_mask(P_VPP_MISC,VPP_POST_FG_OSD2|VPP_PRE_FG_OSD2);
-        break;
-        default:
-        break;
-    }
-    spin_unlock_irqrestore(&osd_onoff_lock, flags);
-    remove_from_update_list(OSD1,OSD_CHANGE_ORDER);
+	unsigned long flags;
+	spin_lock_irqsave(&osd_onoff_lock, flags);
+	switch (osd_hw.osd_order) {
+	case  OSD_ORDER_01:
+		aml_clr_reg32_mask(P_VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+		break;
+	case  OSD_ORDER_10:
+		aml_clr_reg32_mask(P_VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+		break;
+	default:
+		break;
+	}
+	spin_unlock_irqrestore(&osd_onoff_lock, flags);
+	remove_from_update_list(OSD1, OSD_CHANGE_ORDER);
 }
 
 static void osd_block_update_disp_geometry(u32 index)
@@ -2270,112 +2607,135 @@ static void osd_block_update_disp_geometry(u32 index)
 	u32 i;
 
 	switch (osd_hw.block_mode[index] & HW_OSD_BLOCK_LAYOUT_MASK) {
-		case HW_OSD_BLOCK_LAYOUT_HORIZONTAL:
-			yoff = ((osd_hw.pandata[index].y_end & 0x1fff) - (osd_hw.pandata[index].y_start & 0x1fff) + 1) >> 2;
-			data_w1 = (osd_hw.pandata[index].x_start & 0x1fff) | (osd_hw.pandata[index].x_end & 0x1fff) << 16 ;
-			data_w3 = (osd_hw.dispdata[index].x_start & 0xfff) | (osd_hw.dispdata[index].x_end & 0xfff) << 16;
-			for (i = 0; i < 4; i++) {
-				if (i == 3) {
-					data_w2 = ((osd_hw.pandata[index].y_start + yoff * i) & 0x1fff)
-						| (osd_hw.pandata[index].y_end & 0x1fff) << 16;
-					data_w4 = ((osd_hw.dispdata[index].y_start + yoff * i) & 0xfff)
-						| (osd_hw.dispdata[index].y_end & 0xfff) << 16;
-				} else {
-					data_w2 = ((osd_hw.pandata[index].y_start + yoff * i) & 0x1fff)
-						| ((osd_hw.pandata[index].y_start + yoff * (i + 1) - 1) & 0x1fff) << 16;
-					data_w4 = ((osd_hw.dispdata[index].y_start + yoff * i) & 0xfff)
-						| ((osd_hw.dispdata[index].y_start + yoff * (i + 1) - 1) & 0xfff) << 16;
-				}
-				if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
-					data32 = data_w4;
-					data_w4 = ((data32 & 0xfff) >> 1) | ((((((data32 >> 16) & 0xfff) + 1) >> 1) - 1) << 16);
-				}
-
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1 + (i << 4), data_w1);
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2 + (i << 4), data_w2);
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 + (i << 4), data_w3);
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4 + (i<<2), data_w4);
-
-				osd_hw.block_windows[index][i << 1] = data_w1;
-				osd_hw.block_windows[index][(i << 1) + 1] = data_w2;
+	case HW_OSD_BLOCK_LAYOUT_HORIZONTAL:
+		yoff = ((osd_hw.pandata[index].y_end & 0x1fff) - (osd_hw.pandata[index].y_start
+				& 0x1fff) + 1) >> 2;
+		data_w1 = (osd_hw.pandata[index].x_start & 0x1fff) |
+			  (osd_hw.pandata[index].x_end & 0x1fff) << 16 ;
+		data_w3 = (osd_hw.dispdata[index].x_start & 0xfff) |
+			  (osd_hw.dispdata[index].x_end & 0xfff) << 16;
+		for (i = 0; i < 4; i++) {
+			if (i == 3) {
+				data_w2 = ((osd_hw.pandata[index].y_start + yoff * i) & 0x1fff)
+					  | (osd_hw.pandata[index].y_end & 0x1fff) << 16;
+				data_w4 = ((osd_hw.dispdata[index].y_start + yoff * i) & 0xfff)
+					  | (osd_hw.dispdata[index].y_end & 0xfff) << 16;
+			} else {
+				data_w2 = ((osd_hw.pandata[index].y_start + yoff * i) & 0x1fff)
+					  | ((osd_hw.pandata[index].y_start + yoff * (i + 1) - 1) & 0x1fff) << 16;
+				data_w4 = ((osd_hw.dispdata[index].y_start + yoff * i) & 0xfff)
+					  | ((osd_hw.dispdata[index].y_start + yoff * (i + 1) - 1) & 0xfff) << 16;
 			}
-			break;
-		case HW_OSD_BLOCK_LAYOUT_VERTICAL:
-			xoff = ((osd_hw.pandata[index].x_end & 0x1fff) - (osd_hw.pandata[index].x_start & 0x1fff) + 1) >> 2;
-			data_w2 = (osd_hw.pandata[index].y_start & 0x1fff) | (osd_hw.pandata[index].y_end & 0x1fff) << 16 ;
-			data_w4 = (osd_hw.dispdata[index].y_start & 0xfff) | (osd_hw.dispdata[index].y_end & 0xfff) << 16;
 			if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
 				data32 = data_w4;
-				data_w4 = ((data32 & 0xfff) >> 1) | ((((((data32 >> 16) & 0xfff) + 1) >> 1) - 1) << 16);
-			}
-			for (i = 0; i < 4; i++) {
-				data_w1 = ((osd_hw.pandata[index].x_start  + xoff * i) & 0x1fff)
-					| ((osd_hw.pandata[index].x_start + xoff * (i + 1) - 1) & 0x1fff) << 16;
-				data_w3 = ((osd_hw.dispdata[index].x_start + xoff * i) & 0xfff)
-					| ((osd_hw.dispdata[index].x_start + xoff * (i + 1) - 1) & 0xfff) << 16;
-
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1 + (i << 4), data_w1);
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2 + (i << 4), data_w2);
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 + (i << 4), data_w3);
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4 + (i<<2), data_w4);
-
-				osd_hw.block_windows[index][i << 1] = data_w1;
-				osd_hw.block_windows[index][(i << 1) + 1] = data_w2;
+				data_w4 = ((data32 & 0xfff) >> 1) | ((((((data32 >> 16) & 0xfff) + 1) >> 1) - 1)
+								     << 16);
 			}
-			break;
-		case HW_OSD_BLOCK_LAYOUT_GRID:
-			xoff = ((osd_hw.pandata[index].x_end & 0x1fff) - (osd_hw.pandata[index].x_start & 0x1fff) + 1) >> 1;
-			yoff = ((osd_hw.pandata[index].y_end & 0x1fff) - (osd_hw.pandata[index].y_start & 0x1fff) + 1) >> 1;
-			for (i = 0; i < 4; i++) {
-				data_w1 = ((osd_hw.pandata[index].x_start + xoff * coef[i][0]) & 0x1fff)
-					| ((osd_hw.pandata[index].x_start + xoff * (coef[i][0] + 1) - 1) & 0x1fff) << 16;
-				data_w2 = ((osd_hw.pandata[index].y_start + yoff * coef[i][1]) & 0x1fff)
-					| ((osd_hw.pandata[index].y_start + yoff * (coef[i][1] + 1) - 1) & 0x1fff) << 16;
-				data_w3 = ((osd_hw.dispdata[index].x_start + xoff * coef[i][0]) & 0xfff)
-					| ((osd_hw.dispdata[index].x_start + xoff * (coef[i][0] + 1) - 1) & 0xfff) << 16;
-				data_w4 = ((osd_hw.dispdata[index].y_start + yoff * coef[i][1]) & 0xfff)
-					| ((osd_hw.dispdata[index].y_start + yoff * (coef[i][1] + 1) - 1) & 0xfff) << 16;
 
-				if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
-					data32 = data_w4;
-					data_w4 = ((data32 & 0xfff) >> 1) | ((((((data32 >> 16) & 0xfff) + 1) >> 1) - 1) << 16);
-				}
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1 + (i << 4), data_w1);
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2 + (i << 4), data_w2);
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 + (i << 4), data_w3);
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4 + (i<<2), data_w4);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1 + (i << 4), data_w1);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2 + (i << 4), data_w2);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 + (i << 4), data_w3);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4 + (i << 2), data_w4);
+
+			osd_hw.block_windows[index][i << 1] = data_w1;
+			osd_hw.block_windows[index][(i << 1) + 1] = data_w2;
+		}
+		break;
+	case HW_OSD_BLOCK_LAYOUT_VERTICAL:
+		xoff = ((osd_hw.pandata[index].x_end & 0x1fff) - (osd_hw.pandata[index].x_start
+				& 0x1fff) + 1) >> 2;
+		data_w2 = (osd_hw.pandata[index].y_start & 0x1fff) |
+			  (osd_hw.pandata[index].y_end & 0x1fff) << 16 ;
+		data_w4 = (osd_hw.dispdata[index].y_start & 0xfff) |
+			  (osd_hw.dispdata[index].y_end & 0xfff) << 16;
+		if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
+			data32 = data_w4;
+			data_w4 = ((data32 & 0xfff) >> 1) | ((((((data32 >> 16) & 0xfff) + 1) >> 1) - 1)
+							     << 16);
+		}
+		for (i = 0; i < 4; i++) {
+			data_w1 = ((osd_hw.pandata[index].x_start  + xoff * i) & 0x1fff)
+				  | ((osd_hw.pandata[index].x_start + xoff * (i + 1) - 1) & 0x1fff) << 16;
+			data_w3 = ((osd_hw.dispdata[index].x_start + xoff * i) & 0xfff)
+				  | ((osd_hw.dispdata[index].x_start + xoff * (i + 1) - 1) & 0xfff) << 16;
+
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1 + (i << 4), data_w1);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2 + (i << 4), data_w2);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 + (i << 4), data_w3);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4 + (i << 2), data_w4);
+
+			osd_hw.block_windows[index][i << 1] = data_w1;
+			osd_hw.block_windows[index][(i << 1) + 1] = data_w2;
+		}
+		break;
+	case HW_OSD_BLOCK_LAYOUT_GRID:
+		xoff = ((osd_hw.pandata[index].x_end & 0x1fff) - (osd_hw.pandata[index].x_start
+				& 0x1fff) + 1) >> 1;
+		yoff = ((osd_hw.pandata[index].y_end & 0x1fff) - (osd_hw.pandata[index].y_start
+				& 0x1fff) + 1) >> 1;
+		for (i = 0; i < 4; i++) {
+			data_w1 = ((osd_hw.pandata[index].x_start + xoff * coef[i][0]) & 0x1fff)
+				  | ((osd_hw.pandata[index].x_start + xoff * (coef[i][0] + 1) - 1) & 0x1fff) <<
+				  16;
+			data_w2 = ((osd_hw.pandata[index].y_start + yoff * coef[i][1]) & 0x1fff)
+				  | ((osd_hw.pandata[index].y_start + yoff * (coef[i][1] + 1) - 1) & 0x1fff) <<
+				  16;
+			data_w3 = ((osd_hw.dispdata[index].x_start + xoff * coef[i][0]) & 0xfff)
+				  | ((osd_hw.dispdata[index].x_start + xoff * (coef[i][0] + 1) - 1) & 0xfff) <<
+				  16;
+			data_w4 = ((osd_hw.dispdata[index].y_start + yoff * coef[i][1]) & 0xfff)
+				  | ((osd_hw.dispdata[index].y_start + yoff * (coef[i][1] + 1) - 1) & 0xfff) <<
+				  16;
 
-				osd_hw.block_windows[index][i << 1] = data_w1;
-				osd_hw.block_windows[index][(i << 1) + 1] = data_w2;
+			if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
+				data32 = data_w4;
+				data_w4 = ((data32 & 0xfff) >> 1) | ((((((data32 >> 16) & 0xfff) + 1) >> 1) - 1)
+								     << 16);
 			}
-			break;
-		case HW_OSD_BLOCK_LAYOUT_CUSTOMER:
-			for (i = 0; i < 4; i++) {
-				if (((osd_hw.block_windows[index][i << 1] >> 16) & 0x1fff) > osd_hw.pandata[index].x_end) {
-					osd_hw.block_windows[index][i << 1] = (osd_hw.block_windows[index][i << 1] & 0x1fff)
-						| ((osd_hw.pandata[index].x_end & 0x1fff) << 16);
-				}
-				data_w1 = osd_hw.block_windows[index][i << 1] & 0x1fff1fff;
-				data_w2 = ((osd_hw.pandata[index].y_start & 0x1fff) + (osd_hw.block_windows[index][(i << 1) + 1] & 0x1fff))
-					| (((osd_hw.pandata[index].y_start & 0x1fff) << 16) + (osd_hw.block_windows[index][(i << 1) + 1] & 0x1fff0000));
-				data_w3 = (osd_hw.dispdata[index].x_start + (data_w1 & 0xfff))
-					| (((osd_hw.dispdata[index].x_start & 0xfff) << 16) + (data_w1 & 0xfff0000));
-				data_w4 = (osd_hw.dispdata[index].y_start + (osd_hw.block_windows[index][(i << 1) + 1] & 0xfff))
-					| (((osd_hw.dispdata[index].y_start & 0xfff) << 16) + (osd_hw.block_windows[index][(i << 1) + 1] & 0xfff0000));
-				if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
-					data32 = data_w4;
-					data_w4 = ((data32 & 0xfff) >> 1) | ((((((data32 >> 16) & 0xfff) + 1) >> 1) - 1) << 16);
-				}
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1 + (i << 4), data_w1);
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2 + (i << 4), data_w2);
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 + (i << 4), data_w3);
-				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4 + (i<<2), data_w4);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1 + (i << 4), data_w1);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2 + (i << 4), data_w2);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 + (i << 4), data_w3);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4 + (i << 2), data_w4);
+
+			osd_hw.block_windows[index][i << 1] = data_w1;
+			osd_hw.block_windows[index][(i << 1) + 1] = data_w2;
+		}
+		break;
+	case HW_OSD_BLOCK_LAYOUT_CUSTOMER:
+		for (i = 0; i < 4; i++) {
+			if (((osd_hw.block_windows[index][i << 1] >> 16) & 0x1fff) >
+			    osd_hw.pandata[index].x_end) {
+				osd_hw.block_windows[index][i << 1] = (osd_hw.block_windows[index][i << 1] &
+								       0x1fff)
+								      | ((osd_hw.pandata[index].x_end & 0x1fff) << 16);
 			}
-			break;
+			data_w1 = osd_hw.block_windows[index][i << 1] & 0x1fff1fff;
+			data_w2 = ((osd_hw.pandata[index].y_start & 0x1fff) +
+				   (osd_hw.block_windows[index][(i << 1) + 1] & 0x1fff))
+				  | (((osd_hw.pandata[index].y_start & 0x1fff) << 16) +
+				     (osd_hw.block_windows[index][(i << 1) + 1] & 0x1fff0000));
+			data_w3 = (osd_hw.dispdata[index].x_start + (data_w1 & 0xfff))
+				  | (((osd_hw.dispdata[index].x_start & 0xfff) << 16) + (data_w1 & 0xfff0000));
+			data_w4 = (osd_hw.dispdata[index].y_start + (osd_hw.block_windows[index][(i <<
+					1) + 1] & 0xfff))
+				  | (((osd_hw.dispdata[index].y_start & 0xfff) << 16) +
+				     (osd_hw.block_windows[index][(i << 1) + 1] & 0xfff0000));
+			if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
+				data32 = data_w4;
+				data_w4 = ((data32 & 0xfff) >> 1) | ((((((data32 >> 16) & 0xfff) + 1) >> 1) - 1)
+								     << 16);
+			}
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1 + (i << 4), data_w1);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2 + (i << 4), data_w2);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 + (i << 4), data_w3);
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4 + (i << 2), data_w4);
+		}
+		break;
 
-		default:
-			amlog_level(LOG_LEVEL_HIGH, "ERROR block_mode: 0x%x\n", osd_hw.block_mode[index]);
-			break;
+	default:
+		amlog_level(LOG_LEVEL_HIGH, "ERROR block_mode: 0x%x\n",
+			    osd_hw.block_mode[index]);
+		break;
 	}
 }
 
@@ -2385,181 +2745,253 @@ static void osd1_update_disp_geometry(void)
 	/* enable osd multi block */
 	if (osd_hw.block_mode[OSD1]) {
 		osd_block_update_disp_geometry(OSD1);
-		data32=VSYNCOSD_RD_MPEG_REG(VIU_OSD1_CTRL_STAT);
+		data32 = VSYNCOSD_RD_MPEG_REG(VIU_OSD1_CTRL_STAT);
 		data32 &= 0xfffffff0;
 		data32 |= (osd_hw.block_mode[OSD1] & HW_OSD_BLOCK_ENABLE_MASK);
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_CTRL_STAT, data32);
 	} else {
-		data32 = (osd_hw.dispdata[OSD1].x_start& 0xfff) | (osd_hw.dispdata[OSD1].x_end & 0xfff) <<16 ;
+#if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
+		data32 = (osd_hw.dispdata[OSD1].x_start & 0xfff) | (osd_hw.dispdata[OSD1].x_end
+				& 0xfff) << 16 ;
 		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
-		if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
-			data32 = ((osd_hw.dispdata[OSD1].y_start >> 1) & 0xfff) | ((((osd_hw.dispdata[OSD1].y_end+1) >> 1) - 1) & 0xfff) << 16 ;
+		if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
+			data32 = ((osd_hw.dispdata[OSD1].y_start >> 1) & 0xfff) | ((((
+						osd_hw.dispdata[OSD1].y_end + 1) >> 1) - 1) & 0xfff) << 16 ;
+		else
+			data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff) | (osd_hw.dispdata[OSD1].y_end
+					& 0xfff) << 16 ;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
+#else
+		if (osd_hw.free_scale_mode[OSD1] == 0) {
+			if (osd_hw.free_scale_enable[OSD1] == 1) {
+				data32 = (osd_hw.free_scale_data[OSD1].x_start & 0xfff) |
+					 (osd_hw.free_scale_data[OSD1].x_end & 0xfff) << 16 ;
+				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
+				data32 = (osd_hw.free_scale_data[OSD1].y_start & 0xfff) |
+					 (osd_hw.free_scale_data[OSD1].y_end & 0xfff) << 16 ;
+				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
+			} else {
+				data32 = (osd_hw.dispdata[OSD1].x_start & 0xfff) | (osd_hw.dispdata[OSD1].x_end
+						& 0xfff) << 16 ;
+				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
+				if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
+					data32 = ((osd_hw.dispdata[OSD1].y_start >> 1) & 0xfff) | ((((
+								osd_hw.dispdata[OSD1].y_end + 1) >> 1) - 1) & 0xfff) << 16 ;
+				else
+					data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff) | (osd_hw.dispdata[OSD1].y_end
+							& 0xfff) << 16 ;
+				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
+			}
 		} else {
-			data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff) | (osd_hw.dispdata[OSD1].y_end & 0xfff) <<16 ;
+			data32 = (osd_hw.dispdata[OSD1].x_start & 0xfff) | (osd_hw.dispdata[OSD1].x_end
+					& 0xfff) << 16 ;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
+			if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
+				data32 = ((osd_hw.dispdata[OSD1].y_start >> 1) & 0xfff) | ((((
+							osd_hw.dispdata[OSD1].y_end + 1) >> 1) - 1) & 0xfff) << 16 ;
+			else
+				data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff) | (osd_hw.dispdata[OSD1].y_end
+						& 0xfff) << 16 ;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
 		}
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
-
+#endif
 		/* enable osd 2x scale */
 		if (osd_hw.scale[OSD1].h_enable || osd_hw.scale[OSD1].v_enable) {
-			data32 = (osd_hw.scaledata[OSD1].x_start & 0x1fff) | (osd_hw.scaledata[OSD1].x_end & 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1,data32);
-			data32 = ((osd_hw.scaledata[OSD1].y_start + osd_hw.pandata[OSD1].y_start) & 0x1fff)
-					| ((osd_hw.scaledata[OSD1].y_end  + osd_hw.pandata[OSD1].y_start) & 0x1fff) << 16 ;
+			data32 = (osd_hw.scaledata[OSD1].x_start & 0x1fff) |
+				 (osd_hw.scaledata[OSD1].x_end & 0x1fff) << 16;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+			data32 = ((osd_hw.scaledata[OSD1].y_start + osd_hw.pandata[OSD1].y_start) &
+				  0x1fff)
+				 | ((osd_hw.scaledata[OSD1].y_end  + osd_hw.pandata[OSD1].y_start) & 0x1fff) <<
+				 16 ;
 			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
 			/* adjust display x-axis */
 			if (osd_hw.scale[OSD1].h_enable) {
 				data32 = (osd_hw.dispdata[OSD1].x_start & 0xfff)
-					| ((osd_hw.dispdata[OSD1].x_start + (osd_hw.scaledata[OSD1].x_end - osd_hw.scaledata[OSD1].x_start) * 2 + 1 ) & 0xfff) << 16 ;
+					 | ((osd_hw.dispdata[OSD1].x_start + (osd_hw.scaledata[OSD1].x_end -
+							 osd_hw.scaledata[OSD1].x_start) * 2 + 1) & 0xfff) << 16 ;
 				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
+				if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
+					data32 = ((osd_hw.dispdata[OSD1].y_start >> 1) & 0xfff)
+						 | (((((osd_hw.dispdata[OSD1].y_start + (osd_hw.scaledata[OSD1].y_end -
+								 osd_hw.scaledata[OSD1].y_start) * 2) + 1) >> 1) - 1) & 0xfff) << 16 ;
+				} else {
+					data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff)
+						 | (((osd_hw.dispdata[OSD1].y_start  + (osd_hw.scaledata[OSD1].y_end -
+								 osd_hw.scaledata[OSD1].y_start) * 2)) & 0xfff) << 16 ;
+				}
+				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
 			}
 
 			/* adjust display y-axis */
 			if (osd_hw.scale[OSD1].v_enable) {
+				data32 = (osd_hw.dispdata[OSD1].x_start & 0xfff)
+					 | ((osd_hw.dispdata[OSD1].x_start + (osd_hw.scaledata[OSD1].x_end -
+							 osd_hw.scaledata[OSD1].x_start) * 2 + 1) & 0xfff) << 16 ;
+				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W3 , data32);
 				if (osd_hw.scan_mode == SCAN_MODE_INTERLACE) {
 					data32 = ((osd_hw.dispdata[OSD1].y_start >> 1) & 0xfff)
-						| (((((osd_hw.dispdata[OSD1].y_start + (osd_hw.scaledata[OSD1].y_end - osd_hw.scaledata[OSD1].y_start) * 2) + 1) >> 1) - 1) & 0xfff) << 16 ;
+						 | (((((osd_hw.dispdata[OSD1].y_start + (osd_hw.scaledata[OSD1].y_end -
+								 osd_hw.scaledata[OSD1].y_start) * 2) + 1) >> 1) - 1) & 0xfff) << 16 ;
 				} else {
 					data32 = (osd_hw.dispdata[OSD1].y_start & 0xfff)
-						| (((osd_hw.dispdata[OSD1].y_start  + (osd_hw.scaledata[OSD1].y_end - osd_hw.scaledata[OSD1].y_start) * 2)) & 0xfff) << 16 ;
+						 | (((osd_hw.dispdata[OSD1].y_start  + (osd_hw.scaledata[OSD1].y_end -
+								 osd_hw.scaledata[OSD1].y_start) * 2)) & 0xfff) << 16 ;
 				}
 				VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W4, data32);
 			}
 		} else if (osd_hw.free_scale_enable[OSD1]
-				&& (osd_hw.free_scale_data[OSD1].x_end > 0)
-				&& (osd_hw.free_scale_data[OSD1].y_end > 0)
-				&& (!osd_hw.rotate[OSD1].on_off)) {
+			   && (osd_hw.free_scale_data[OSD1].x_end > 0)
+			   && (osd_hw.free_scale_data[OSD1].y_end > 0)
+			   && (!osd_hw.rotate[OSD1].on_off)) {
 			/* enable osd free scale */
-			data32 = (osd_hw.free_scale_data[OSD1].x_start & 0x1fff) | (osd_hw.free_scale_data[OSD1].x_end & 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1,data32);
-			data32 = ((osd_hw.free_scale_data[OSD1].y_start + osd_hw.pandata[OSD1].y_start) & 0x1fff)
-					| ((osd_hw.free_scale_data[OSD1].y_end  + osd_hw.pandata[OSD1].y_start) & 0x1fff) << 16 ;
+			data32 = (osd_hw.free_scale_data[OSD1].x_start & 0x1fff) |
+				 (osd_hw.free_scale_data[OSD1].x_end & 0x1fff) << 16;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+			data32 = ((osd_hw.free_scale_data[OSD1].y_start + osd_hw.pandata[OSD1].y_start)
+				  & 0x1fff)
+				 | ((osd_hw.free_scale_data[OSD1].y_end  + osd_hw.pandata[OSD1].y_start) &
+				    0x1fff) << 16;
 			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
 		} else if (osd_hw.free_scale_enable[OSD1]
-				&& (osd_hw.free_scale_data[OSD1].x_end > 0)
-				&& (osd_hw.free_scale_data[OSD1].y_end > 0)
-				&& (osd_hw.rotate[OSD1].on_off
-				&& osd_hw.rotate[OSD1].angle > 0)){
-			data32 = (osd_hw.rotation_pandata[OSD1].x_start & 0x1fff) | (osd_hw.rotation_pandata[OSD1].x_end & 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1,data32);
-			data32 = ((osd_hw.rotation_pandata[OSD1].y_start + osd_hw.pandata[OSD1].y_start) & 0x1fff)
-					| ((osd_hw.rotation_pandata[OSD1].y_end  + osd_hw.pandata[OSD1].y_start) & 0x1fff) << 16 ;
-			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2,data32);
+			   && (osd_hw.free_scale_data[OSD1].x_end > 0)
+			   && (osd_hw.free_scale_data[OSD1].y_end > 0)
+			   && (osd_hw.rotate[OSD1].on_off
+			       && osd_hw.rotate[OSD1].angle > 0)) {
+			data32 = (osd_hw.rotation_pandata[OSD1].x_start & 0x1fff) |
+				 (osd_hw.rotation_pandata[OSD1].x_end & 0x1fff) << 16;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+			data32 = ((osd_hw.rotation_pandata[OSD1].y_start + osd_hw.pandata[OSD1].y_start)
+				  & 0x1fff)
+				 | ((osd_hw.rotation_pandata[OSD1].y_end  + osd_hw.pandata[OSD1].y_start) &
+				    0x1fff) << 16 ;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 			{
-				if(IS_MESON_M8_CPU){
-					VSYNCOSD_WR_MPEG_REG(VPU_PROT1_Y_START_END,data32);
-				}
+				if (IS_MESON_M8_CPU)
+					VSYNCOSD_WR_MPEG_REG(VPU_PROT1_Y_START_END, data32);
 			}
 #endif
-		}else if (osd_hw.rotate[OSD1].on_off
-				&& osd_hw.rotate[OSD1].angle > 0){
+		} else if (osd_hw.rotate[OSD1].on_off
+			   && osd_hw.rotate[OSD1].angle > 0) {
 			/* enable osd rotation */
-			data32 = (osd_hw.rotation_pandata[OSD1].x_start & 0x1fff) | (osd_hw.rotation_pandata[OSD1].x_end & 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1,data32);
-			data32 = ((osd_hw.rotation_pandata[OSD1].y_start + osd_hw.pandata[OSD1].y_start) & 0x1fff)
-					| ((osd_hw.rotation_pandata[OSD1].y_end  + osd_hw.pandata[OSD1].y_start) & 0x1fff) << 16 ;
-			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2,data32);
+			data32 = (osd_hw.rotation_pandata[OSD1].x_start & 0x1fff) |
+				 (osd_hw.rotation_pandata[OSD1].x_end & 0x1fff) << 16;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+			data32 = ((osd_hw.rotation_pandata[OSD1].y_start + osd_hw.pandata[OSD1].y_start)
+				  & 0x1fff)
+				 | ((osd_hw.rotation_pandata[OSD1].y_end  + osd_hw.pandata[OSD1].y_start) &
+				    0x1fff) << 16 ;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
 #if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8)
 			{
-				if(IS_MESON_M8_CPU){
-					VSYNCOSD_WR_MPEG_REG(VPU_PROT1_Y_START_END,data32);
-				}
+				if (IS_MESON_M8_CPU)
+					VSYNCOSD_WR_MPEG_REG(VPU_PROT1_Y_START_END, data32);
 			}
 #endif
-		}else {
-			/* norma/l mode */
-			data32 = (osd_hw.pandata[OSD1].x_start & 0x1fff) | (osd_hw.pandata[OSD1].x_end & 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1,data32);
-			data32 = (osd_hw.pandata[OSD1].y_start & 0x1fff) | (osd_hw.pandata[OSD1].y_end & 0x1fff) << 16 ;
-			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2,data32);
+		} else {
+			/* normal mode */
+			data32 = (osd_hw.pandata[OSD1].x_start & 0x1fff) | (osd_hw.pandata[OSD1].x_end &
+					0x1fff) << 16;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+			data32 = (osd_hw.pandata[OSD1].y_start & 0x1fff) | (osd_hw.pandata[OSD1].y_end &
+					0x1fff) << 16 ;
+			VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W2, data32);
 		}
 
-		data32=VSYNCOSD_RD_MPEG_REG(VIU_OSD1_CTRL_STAT);
+		data32 = aml_read_reg32(P_VIU_OSD1_CTRL_STAT);
 		data32 &= 0xfffffff0;
 		data32 |= HW_OSD_BLOCK_ENABLE_0;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_CTRL_STAT, data32);
+		aml_write_reg32(P_VIU_OSD1_CTRL_STAT, data32);
 	}
 
-	remove_from_update_list(OSD1,DISP_GEOMETRY);
+	remove_from_update_list(OSD1, DISP_GEOMETRY);
 }
 
 static   void  osd2_update_disp_geometry(void)
 {
 	u32 data32;
-   	data32 = (osd_hw.dispdata[OSD2].x_start& 0xfff) | (osd_hw.dispdata[OSD2].x_end & 0xfff) <<16 ;
+	data32 = (osd_hw.dispdata[OSD2].x_start & 0xfff) | (osd_hw.dispdata[OSD2].x_end
+			& 0xfff) << 16 ;
 	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W3 , data32);
-	if(osd_hw.scan_mode== SCAN_MODE_INTERLACE)
-	{
-		data32=((osd_hw.dispdata[OSD2].y_start >>1) & 0xfff) | ((((osd_hw.dispdata[OSD2].y_end+1)>>1)-1) & 0xfff) <<16 ;
-	}
+	if (osd_hw.scan_mode == SCAN_MODE_INTERLACE)
+		data32 = ((osd_hw.dispdata[OSD2].y_start >> 1) & 0xfff) | ((((
+					osd_hw.dispdata[OSD2].y_end + 1) >> 1) - 1) & 0xfff) << 16 ;
 	else
-	{
-   		data32 = (osd_hw.dispdata[OSD2].y_start & 0xfff) | (osd_hw.dispdata[OSD2].y_end & 0xfff) <<16 ;
-	}
+		data32 = (osd_hw.dispdata[OSD2].y_start & 0xfff) | (osd_hw.dispdata[OSD2].y_end
+				& 0xfff) << 16 ;
 	VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W4, data32);
 
 	if (osd_hw.scale[OSD2].h_enable || osd_hw.scale[OSD2].v_enable) {
 #if defined(CONFIG_FB_OSD2_CURSOR)
-		data32=(osd_hw.pandata[OSD2].x_start & 0x1fff) | (osd_hw.pandata[OSD2].x_end & 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1,data32);
-		data32=(osd_hw.pandata[OSD2].y_start & 0x1fff) | (osd_hw.pandata[OSD2].y_end & 0x1fff) << 16 ;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2,data32);
+		data32 = (osd_hw.pandata[OSD2].x_start & 0x1fff) | (osd_hw.pandata[OSD2].x_end &
+				0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+		data32 = (osd_hw.pandata[OSD2].y_start & 0x1fff) | (osd_hw.pandata[OSD2].y_end &
+				0x1fff) << 16 ;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
 #else
-		data32 = (osd_hw.scaledata[OSD2].x_start & 0x1fff) | (osd_hw.scaledata[OSD2].x_end & 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1,data32);
-		data32 = ((osd_hw.scaledata[OSD2].y_start + osd_hw.pandata[OSD2].y_start) & 0x1fff)
-				| ((osd_hw.scaledata[OSD2].y_end  + osd_hw.pandata[OSD2].y_start) & 0x1fff) << 16 ;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2,data32);
+		data32 = (osd_hw.scaledata[OSD2].x_start & 0x1fff) |
+			 (osd_hw.scaledata[OSD2].x_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+		data32 = ((osd_hw.scaledata[OSD2].y_start + osd_hw.pandata[OSD2].y_start) &
+			  0x1fff)
+			 | ((osd_hw.scaledata[OSD2].y_end  + osd_hw.pandata[OSD2].y_start) & 0x1fff) <<
+			 16 ;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
 #endif
 	} else if (osd_hw.free_scale_enable[OSD2]
-				&& (osd_hw.free_scale_data[OSD2].x_end > 0)
-				&& (osd_hw.free_scale_data[OSD2].y_end > 0)) {
-			/* enable osd free scale */
-			data32 = (osd_hw.free_scale_data[OSD2].x_start & 0x1fff) | (osd_hw.free_scale_data[OSD2].x_end & 0x1fff) << 16;
-			VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
-			data32 = ((osd_hw.free_scale_data[OSD2].y_start + osd_hw.pandata[OSD2].y_start) & 0x1fff)
-					| ((osd_hw.free_scale_data[OSD2].y_end  + osd_hw.pandata[OSD2].y_start) & 0x1fff) << 16 ;
-			VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
+		   && (osd_hw.free_scale_data[OSD2].x_end > 0)
+		   && (osd_hw.free_scale_data[OSD2].y_end > 0)) {
+		/* enable osd free scale */
+		data32 = (osd_hw.free_scale_data[OSD2].x_start & 0x1fff) |
+			 (osd_hw.free_scale_data[OSD2].x_end & 0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+		data32 = ((osd_hw.free_scale_data[OSD2].y_start + osd_hw.pandata[OSD2].y_start)
+			  & 0x1fff)
+			 | ((osd_hw.free_scale_data[OSD2].y_end  + osd_hw.pandata[OSD2].y_start) &
+			    0x1fff) << 16 ;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
 	} else {
-		data32=(osd_hw.pandata[OSD2].x_start & 0x1fff) | (osd_hw.pandata[OSD2].x_end & 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1,data32);
-		data32=(osd_hw.pandata[OSD2].y_start & 0x1fff) | (osd_hw.pandata[OSD2].y_end & 0x1fff) << 16 ;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2,data32);
+		data32 = (osd_hw.pandata[OSD2].x_start & 0x1fff) | (osd_hw.pandata[OSD2].x_end &
+				0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+		data32 = (osd_hw.pandata[OSD2].y_start & 0x1fff) | (osd_hw.pandata[OSD2].y_end &
+				0x1fff) << 16 ;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W2, data32);
 	}
-	remove_from_update_list(OSD2,DISP_GEOMETRY);
+	remove_from_update_list(OSD2, DISP_GEOMETRY);
 }
 static  void  osd1_update_disp_3d_mode(void)
 {
 	/*step 1 . set pan data */
 	u32  data32;
 
-	if(osd_hw.mode_3d[OSD1].left_right==LEFT)
-	{
-		data32=(osd_hw.mode_3d[OSD1].l_start& 0x1fff) | (osd_hw.mode_3d[OSD1].l_end& 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1,data32);
-	}
-	else
-	{
-		data32=(osd_hw.mode_3d[OSD1].r_start& 0x1fff) | (osd_hw.mode_3d[OSD1].r_end& 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1,data32);
+	if (osd_hw.mode_3d[OSD1].left_right == LEFT) {
+		data32 = (osd_hw.mode_3d[OSD1].l_start & 0x1fff) | (osd_hw.mode_3d[OSD1].l_end &
+				0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
+	} else {
+		data32 = (osd_hw.mode_3d[OSD1].r_start & 0x1fff) | (osd_hw.mode_3d[OSD1].r_end &
+				0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD1_BLK0_CFG_W1, data32);
 	}
-	osd_hw.mode_3d[OSD1].left_right^=1;
+	osd_hw.mode_3d[OSD1].left_right ^= 1;
 }
 static  void  osd2_update_disp_3d_mode(void)
 {
 	u32  data32;
 
-	if(osd_hw.mode_3d[OSD2].left_right==LEFT)
-	{
-		data32=(osd_hw.mode_3d[OSD2].l_start& 0x1fff) | (osd_hw.mode_3d[OSD2].l_end& 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1,data32);
-	}
-	else
-	{
-		data32=(osd_hw.mode_3d[OSD2].r_start& 0x1fff) | (osd_hw.mode_3d[OSD2].r_end& 0x1fff) << 16;
-		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1,data32);
+	if (osd_hw.mode_3d[OSD2].left_right == LEFT) {
+		data32 = (osd_hw.mode_3d[OSD2].l_start & 0x1fff) | (osd_hw.mode_3d[OSD2].l_end &
+				0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
+	} else {
+		data32 = (osd_hw.mode_3d[OSD2].r_start & 0x1fff) | (osd_hw.mode_3d[OSD2].r_end &
+				0x1fff) << 16;
+		VSYNCOSD_WR_MPEG_REG(VIU_OSD2_BLK0_CFG_W1, data32);
 	}
-	osd_hw.mode_3d[OSD2].left_right^=1;
+	osd_hw.mode_3d[OSD2].left_right ^= 1;
 }
 
 #if MESON_CPU_TYPE < MESON_CPU_TYPE_MESON8
@@ -2568,125 +3000,128 @@ void osd_init_scan_mode(void)
 #define  	VOUT_ENCI	1
 #define   	VOUT_ENCP	2
 #define	VOUT_ENCT	3
-	unsigned  char output_type=0;
-	output_type=aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)&0x3;
-	osd_hw.scan_mode= SCAN_MODE_PROGRESSIVE;
-	switch(output_type)
-	{
-		case VOUT_ENCP:
-			if (aml_read_reg32(P_ENCP_VIDEO_MODE) & (1 << 12)) //1080i
-				osd_hw.scan_mode= SCAN_MODE_INTERLACE;
-			break;
-		case VOUT_ENCI:
-			if (aml_read_reg32(P_ENCI_VIDEO_EN) & 1)
-				osd_hw.scan_mode= SCAN_MODE_INTERLACE;
-			break;
+	unsigned  char output_type = 0;
+	output_type = aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL) & 0x3;
+	osd_hw.scan_mode = SCAN_MODE_PROGRESSIVE;
+	switch (output_type) {
+	case VOUT_ENCP:
+		if (aml_read_reg32(P_ENCP_VIDEO_MODE) & (1 << 12)) //1080i
+			osd_hw.scan_mode = SCAN_MODE_INTERLACE;
+		break;
+	case VOUT_ENCI:
+		if (aml_read_reg32(P_ENCI_VIDEO_EN) & 1)
+			osd_hw.scan_mode = SCAN_MODE_INTERLACE;
+		break;
 	}
 }
 #endif
 
 void osd_init_hw(u32  logo_loaded)
 {
-	u32 group,idx,data32;
+	u32 group, idx, data32;
 
-	for(group=0;group<HW_OSD_COUNT;group++)
-	for(idx=0;idx<HW_REG_INDEX_MAX;idx++)
-	{
-		osd_hw.reg[group][idx].update_func=hw_func_array[group][idx];
-	}
-	osd_hw.updated[OSD1]=0;
-	osd_hw.updated[OSD2]=0;
+	for (group = 0; group < HW_OSD_COUNT; group++)
+		for (idx = 0; idx < HW_REG_INDEX_MAX; idx++)
+			osd_hw.reg[group][idx].update_func = hw_func_array[group][idx];
+	osd_hw.updated[OSD1] = 0;
+	osd_hw.updated[OSD2] = 0;
 	//here we will init default value ,these value only set once .
 #if defined(CONFIG_ARCH_MESON6TVD)||(defined(CONFIG_ARCH_MESON6TV))
-	aml_set_reg32_mask(P_VPU_OSD1_MMC_CTRL, 1<<12); // set OSD to vdisp2
+	aml_set_reg32_mask(P_VPU_OSD1_MMC_CTRL, 1 << 12); // set OSD to vdisp2
 #endif
-	if(!logo_loaded)
-	{
+	if (!logo_loaded) {
 		data32 = 1;          // Set DDR request priority to be urgent
 #if defined(CONFIG_ARCH_MESON6TVD)||(defined(CONFIG_ARCH_MESON6TV))
 		data32 |= 18  << 5;  // hold_fifo_lines
-		#else
+#else
 		data32 |= 4   << 5;  // hold_fifo_lines
-		#endif
+#endif
 		data32 |= 3   << 10; // burst_len_sel: 3=64
 		data32 |= 32  << 12; // fifo_depth_val: 32*8=256
 
 		aml_write_reg32(P_VIU_OSD1_FIFO_CTRL_STAT, data32);
 		aml_write_reg32(P_VIU_OSD2_FIFO_CTRL_STAT, data32);
 
-		aml_set_reg32_mask(P_VPP_MISC,VPP_POSTBLEND_EN);
+		aml_set_reg32_mask(P_VPP_MISC, VPP_POSTBLEND_EN);
 		aml_clr_reg32_mask(P_VPP_MISC, VPP_PREBLEND_EN);
-		aml_clr_reg32_mask(P_VPP_MISC,VPP_OSD1_POSTBLEND|VPP_OSD2_POSTBLEND );
+		aml_clr_reg32_mask(P_VPP_MISC, VPP_OSD1_POSTBLEND | VPP_OSD2_POSTBLEND);
 		// just disable osd to avoid booting hang up
-		#if defined(CONFIG_ARCH_MESON6TVD)||(defined(CONFIG_ARCH_MESON6TV))
+#if defined(CONFIG_ARCH_MESON6TVD)||(defined(CONFIG_ARCH_MESON6TV))
 		data32 = 0x0 << 0; // osd_blk_enable
-		#else
+#else
 		data32 = 0x1 << 0;
-		#endif
-	    	data32 |= OSD_GLOBAL_ALPHA_DEF<< 12;
-		data32 |= (1<<21);
-	    	aml_write_reg32(P_VIU_OSD1_CTRL_STAT , data32);
+#endif
+		data32 |= OSD_GLOBAL_ALPHA_DEF << 12;
+		data32 |= (1 << 21);
+		aml_write_reg32(P_VIU_OSD1_CTRL_STAT , data32);
 		aml_write_reg32(P_VIU_OSD2_CTRL_STAT , data32);
 	}
 
 #if defined(CONFIG_FB_OSD2_CURSOR)
-	aml_set_reg32_mask(P_VPP_MISC, VPP_POST_FG_OSD2|VPP_PRE_FG_OSD2);
-	osd_hw.osd_order=OSD_ORDER_10;
+	aml_set_reg32_mask(P_VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+	osd_hw.osd_order = OSD_ORDER_10;
 #else
-	aml_clr_reg32_mask(P_VPP_MISC,VPP_POST_FG_OSD2|VPP_PRE_FG_OSD2);
-	osd_hw.osd_order=OSD_ORDER_01;
+	aml_clr_reg32_mask(P_VPP_MISC, VPP_POST_FG_OSD2 | VPP_PRE_FG_OSD2);
+	osd_hw.osd_order = OSD_ORDER_01;
 #endif
 
-	osd_hw.enable[OSD2]=osd_hw.enable[OSD1]=DISABLE;
-	osd_hw.fb_gem[OSD1].canvas_idx=OSD1_CANVAS_INDEX;
-	osd_hw.fb_gem[OSD2].canvas_idx=OSD2_CANVAS_INDEX;
-	osd_hw.gbl_alpha[OSD1]=OSD_GLOBAL_ALPHA_DEF;
-	osd_hw.gbl_alpha[OSD2]=OSD_GLOBAL_ALPHA_DEF;
-	osd_hw.color_info[OSD1]=NULL;
-	osd_hw.color_info[OSD2]=NULL;
-	vf.width =vf.height=0;
-	osd_hw.color_key[OSD1]=osd_hw.color_key[OSD2]=0xffffffff;
-	osd_hw.scale[OSD1].h_enable=osd_hw.scale[OSD1].v_enable=0;
-	osd_hw.scale[OSD2].h_enable=osd_hw.scale[OSD2].v_enable=0;
-	osd_hw.mode_3d[OSD2].enable=osd_hw.mode_3d[OSD1].enable=0;
+	osd_hw.enable[OSD2] = osd_hw.enable[OSD1] = DISABLE;
+	osd_hw.fb_gem[OSD1].canvas_idx = OSD1_CANVAS_INDEX;
+	osd_hw.fb_gem[OSD2].canvas_idx = OSD2_CANVAS_INDEX;
+	osd_hw.gbl_alpha[OSD1] = OSD_GLOBAL_ALPHA_DEF;
+	osd_hw.gbl_alpha[OSD2] = OSD_GLOBAL_ALPHA_DEF;
+	osd_hw.color_info[OSD1] = NULL;
+	osd_hw.color_info[OSD2] = NULL;
+	vf.width = vf.height = 0;
+	osd_hw.color_key[OSD1] = osd_hw.color_key[OSD2] = 0xffffffff;
+	osd_hw.free_scale_enable[OSD1] = osd_hw.free_scale_enable[OSD2] = 0;
+	osd_hw.scale[OSD1].h_enable = osd_hw.scale[OSD1].v_enable = 0;
+	osd_hw.scale[OSD2].h_enable = osd_hw.scale[OSD2].v_enable = 0;
+	osd_hw.mode_3d[OSD2].enable = osd_hw.mode_3d[OSD1].enable = 0;
 	osd_hw.block_mode[OSD1] = osd_hw.block_mode[OSD2] = 0;
-	osd_hw.free_scale[OSD1].hfs_enable=0;
-	osd_hw.free_scale[OSD1].hfs_enable=0;
-	osd_hw.free_scale[OSD2].vfs_enable=0;
-	osd_hw.free_scale[OSD2].vfs_enable=0;
+	osd_hw.free_scale[OSD1].hfs_enable = 0;
+	osd_hw.free_scale[OSD1].hfs_enable = 0;
+	osd_hw.free_scale[OSD2].vfs_enable = 0;
+	osd_hw.free_scale[OSD2].vfs_enable = 0;
 	osd_hw.osd_reverse[OSD1] = osd_hw.osd_reverse[OSD2] = 0;
-	osd_hw.rotation_pandata[OSD1].x_start = osd_hw.rotation_pandata[OSD1].y_start = 0;
-	osd_hw.rotation_pandata[OSD2].x_start = osd_hw.rotation_pandata[OSD2].y_start = 0;
+	osd_hw.rotation_pandata[OSD1].x_start = osd_hw.rotation_pandata[OSD1].y_start =
+			0;
+	osd_hw.rotation_pandata[OSD2].x_start = osd_hw.rotation_pandata[OSD2].y_start =
+			0;
 	osd_hw.antiflicker_mode = 0;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	osd_hw.free_scale_data[OSD1].x_start = osd_hw.free_scale_data[OSD1].x_end = 0;
+	osd_hw.free_scale_data[OSD1].y_start = osd_hw.free_scale_data[OSD1].y_end = 0;
+	osd_hw.free_scale_data[OSD2].x_start = osd_hw.free_scale_data[OSD2].x_end = 0;
+	osd_hw.free_scale_data[OSD2].y_start = osd_hw.free_scale_data[OSD2].y_end = 0;
 	osd_hw.free_scale_mode[OSD1] = osd_hw.free_scale_mode[OSD2] = 1;
+	aml_write_reg32(P_VPP_OSD_SC_DUMMY_DATA, 0x00808000);
 #else
 	osd_hw.free_scale_mode[OSD1] = osd_hw.free_scale_mode[OSD2] = 0;
 #endif
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-    osd_hw.free_scale_mode[OSD1] = osd_hw.free_scale_mode[OSD2] = 1;
-#else
-    osd_hw.free_scale_mode[OSD1] = osd_hw.free_scale_mode[OSD2] = 0;
-#endif
+	memset(osd_hw.rotate, 0, sizeof(osd_rotate_t));
 
-	memset(osd_hw.rotate,0,sizeof(osd_rotate_t));
+#ifdef  CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
+	INIT_LIST_HEAD(&post_fence_list);
+	mutex_init(&post_fence_list_lock);
+#endif
 
 #ifdef FIQ_VSYNC
-	osd_hw.fiq_handle_item.handle=vsync_isr;
-	osd_hw.fiq_handle_item.key=(u32)vsync_isr;
-	osd_hw.fiq_handle_item.name="osd_vsync";
-	if(register_fiq_bridge_handle(&osd_hw.fiq_handle_item))
+	osd_hw.fiq_handle_item.handle = vsync_isr;
+	osd_hw.fiq_handle_item.key = (u32)vsync_isr;
+	osd_hw.fiq_handle_item.name = "osd_vsync";
+	if (register_fiq_bridge_handle(&osd_hw.fiq_handle_item))
 #else
-	if ( request_irq(INT_VIU_VSYNC, &vsync_isr,
-		IRQF_SHARED , "am_osd_vsync", osd_setup))
+	if (request_irq(INT_VIU_VSYNC, &vsync_isr,
+			IRQF_SHARED , "am_osd_vsync", osd_setup))
 #endif
 	{
-		amlog_level(LOG_LEVEL_HIGH,"can't request irq for vsync\r\n");
+		amlog_level(LOG_LEVEL_HIGH, "can't request irq for vsync\n");
 	}
 
 #ifdef FIQ_VSYNC
-    request_fiq(INT_VIU_VSYNC, &osd_fiq_isr);
+	request_fiq(INT_VIU_VSYNC, &osd_fiq_isr);
 #endif
 
 #ifdef CONFIG_VSYNC_RDMA
@@ -2694,50 +3129,50 @@ void osd_init_hw(u32  logo_loaded)
 #endif
 
 #ifdef CONFIG_VSYNC_RDMA
-
 	if (request_irq(INT_RDMA, &osd_rdma_isr,
-                    IRQF_SHARED, "osd_rdma", (void *)"osd_rdma"))
-	{
-		amlog_level(LOG_LEVEL_HIGH,"can't request irq for rdma\r\n");
-	}
+			IRQF_SHARED, "osd_rdma", (void *)"osd_rdma"))
+		amlog_level(LOG_LEVEL_HIGH, "can't request irq for rdma\n");
 #endif
 	return ;
 }
 
 
 #if defined(CONFIG_FB_OSD2_CURSOR)
-void osd_cursor_hw(s16 x, s16 y, s16 xstart, s16 ystart, u32 osd_w, u32 osd_h, int index)
+void osd_cursor_hw(s16 x, s16 y, s16 xstart, s16 ystart, u32 osd_w, u32 osd_h,
+		   int index)
 {
 	dispdata_t disp_tmp;
 
 	if (index != 1)
 		return;
 
-	if(osd_hw.free_scale_mode[OSD1]){
-		if(osd_hw.free_scale_enable[OSD1]){
+	if (osd_hw.free_scale_mode[OSD1]) {
+		if (osd_hw.free_scale_enable[OSD1])
 			memcpy(&disp_tmp, &osd_hw.cursor_dispdata[OSD1], sizeof(dispdata_t));
-		}else{
+		else
 			memcpy(&disp_tmp, &osd_hw.dispdata[OSD1], sizeof(dispdata_t));
-		}
-	}else{
+	} else
 		memcpy(&disp_tmp, &osd_hw.dispdata[OSD1], sizeof(dispdata_t));
-	}
-	
+
 	if (osd_hw.scale[OSD2].h_enable && (osd_hw.scaledata[OSD2].x_start > 0)
-			&& (osd_hw.scaledata[OSD2].x_end > 0)) {
+	    && (osd_hw.scaledata[OSD2].x_end > 0)) {
 		x = x * osd_hw.scaledata[OSD2].x_end / osd_hw.scaledata[OSD2].x_start;
 		if (osd_hw.scaledata[OSD2].x_end > osd_hw.scaledata[OSD2].x_start) {
-			disp_tmp.x_start=osd_hw.dispdata[OSD1].x_start * osd_hw.scaledata[OSD2].x_end / osd_hw.scaledata[OSD2].x_start;
-			disp_tmp.x_end=osd_hw.dispdata[OSD1].x_end * osd_hw.scaledata[OSD2].x_end / osd_hw.scaledata[OSD2].x_start;
+			disp_tmp.x_start = osd_hw.dispdata[OSD1].x_start *
+					   osd_hw.scaledata[OSD2].x_end / osd_hw.scaledata[OSD2].x_start;
+			disp_tmp.x_end = osd_hw.dispdata[OSD1].x_end * osd_hw.scaledata[OSD2].x_end /
+					 osd_hw.scaledata[OSD2].x_start;
 		}
 	}
 
 	if (osd_hw.scale[OSD2].v_enable && (osd_hw.scaledata[OSD2].y_start > 0)
-			&& (osd_hw.scaledata[OSD2].y_end > 0)) {
+	    && (osd_hw.scaledata[OSD2].y_end > 0)) {
 		y = y * osd_hw.scaledata[OSD2].y_end / osd_hw.scaledata[OSD2].y_start;
 		if (osd_hw.scaledata[OSD2].y_end > osd_hw.scaledata[OSD2].y_start) {
-			disp_tmp.y_start = osd_hw.dispdata[OSD1].y_start * osd_hw.scaledata[OSD2].y_end / osd_hw.scaledata[OSD2].y_start;
-			disp_tmp.y_end = osd_hw.dispdata[OSD1].y_end * osd_hw.scaledata[OSD2].y_end / osd_hw.scaledata[OSD2].y_start;
+			disp_tmp.y_start = osd_hw.dispdata[OSD1].y_start *
+					   osd_hw.scaledata[OSD2].y_end / osd_hw.scaledata[OSD2].y_start;
+			disp_tmp.y_end = osd_hw.dispdata[OSD1].y_end * osd_hw.scaledata[OSD2].y_end /
+					 osd_hw.scaledata[OSD2].y_start;
 		}
 	}
 
@@ -2753,7 +3188,7 @@ void osd_cursor_hw(s16 x, s16 y, s16 xstart, s16 ystart, u32 osd_w, u32 osd_h, i
 	osd_hw.dispdata[OSD2].y_start = y;
 	if (x <  disp_tmp.x_start) {
 		// if negative position, set osd to 0,y and pan.
-		if (( disp_tmp.x_start - x) < osd_w) {
+		if ((disp_tmp.x_start - x) < osd_w) {
 			osd_hw.pandata[OSD2].x_start = disp_tmp.x_start - x;
 			osd_hw.pandata[OSD2].x_end = osd_w - 1;
 		}
@@ -2764,13 +3199,12 @@ void osd_cursor_hw(s16 x, s16 y, s16 xstart, s16 ystart, u32 osd_w, u32 osd_h, i
 			// if past positive edge, set osd to inside of the edge and pan.
 			if (x < disp_tmp.x_end)
 				osd_hw.pandata[OSD2].x_end = disp_tmp.x_end - x;
-		} else {
+		} else
 			osd_hw.pandata[OSD2].x_end = osd_w - 1;
-		}
 	}
 	if (y < disp_tmp.y_start) {
-		if ((disp_tmp.y_start- y) < osd_h) {
-			osd_hw.pandata[OSD2].y_start =disp_tmp.y_start - y;
+		if ((disp_tmp.y_start - y) < osd_h) {
+			osd_hw.pandata[OSD2].y_start = disp_tmp.y_start - y;
 			osd_hw.pandata[OSD2].y_end = osd_h - 1;
 		}
 		osd_hw.dispdata[OSD2].y_start = 0;
@@ -2779,62 +3213,64 @@ void osd_cursor_hw(s16 x, s16 y, s16 xstart, s16 ystart, u32 osd_w, u32 osd_h, i
 		if (y + osd_h > disp_tmp.y_end) {
 			if (y < disp_tmp.y_end)
 				osd_hw.pandata[OSD2].y_end = disp_tmp.y_end - y;
-		} else {
+		} else
 			osd_hw.pandata[OSD2].y_end = osd_h - 1;
-		}
 	}
-	osd_hw.dispdata[OSD2].x_end = osd_hw.dispdata[OSD2].x_start + osd_hw.pandata[OSD2].x_end - osd_hw.pandata[OSD2].x_start;
-	osd_hw.dispdata[OSD2].y_end = osd_hw.dispdata[OSD2].y_start + osd_hw.pandata[OSD2].y_end - osd_hw.pandata[OSD2].y_start;
-	add_to_update_list(OSD2,DISP_GEOMETRY);
+	osd_hw.dispdata[OSD2].x_end = osd_hw.dispdata[OSD2].x_start +
+				      osd_hw.pandata[OSD2].x_end - osd_hw.pandata[OSD2].x_start;
+	osd_hw.dispdata[OSD2].y_end = osd_hw.dispdata[OSD2].y_start +
+				      osd_hw.pandata[OSD2].y_end - osd_hw.pandata[OSD2].y_start;
+	add_to_update_list(OSD2, DISP_GEOMETRY);
 }
 #endif //CONFIG_FB_OSD2_CURSOR
 
-void osddev_copy_data_tocursor_hw(u32 cursor_mem_vaddr, aml_hwc_addr_t *hwc_mem)
-{
-	u32 tmp;
-	u32 i;
-	u32 value_pixel = 0;
-	u32 size = 32*32*4;
-
-	if (hwc_mem->addr & 0x3) { /* Address not 32bit aligned */
-		for (i = 0; i < size; i += 4) {
-			tmp = readb(hwc_mem->addr + i);
-			value_pixel = tmp;
-			tmp = readb(hwc_mem->addr + i + 1);
-			value_pixel |= (tmp << 8);
-			tmp = readb(hwc_mem->addr + i + 2);
-			value_pixel |= (tmp << 16);
-			tmp = readb(hwc_mem->addr + i + 3);
-			value_pixel |= (tmp << 24);
-			writel(value_pixel, cursor_mem_vaddr+ i);
-		}
-	} else {
-		for (i = 0; i < size; i += 4) {
-			tmp = readl(hwc_mem->addr + i);
-			writel(tmp, cursor_mem_vaddr+ i);
-		}
-	}
-}
-
 void  osd_suspend_hw(void)
 {
-	osd_hw.reg_status_save = aml_read_reg32(P_VPP_MISC) & OSD_RELATIVE_BITS;
+	osd_rdma_enable(0);
+	osd_hw.reg_status_save[0] =
+		aml_read_reg32(P_VPP_MISC) & OSD_RELATIVE_BITS;
 
-	aml_clr_reg32_mask(P_VPP_MISC, OSD_RELATIVE_BITS);
+	//aml_clr_reg32_mask(P_VPP_MISC, OSD_RELATIVE_BITS);
+	VSYNCOSD_CLR_MPEG_REG_MASK(VPP_MISC, OSD_RELATIVE_BITS);
 
-    printk("osd_suspended\n");
+	printk("osd_suspended\n");
 
 	return ;
 
 }
 void osd_resume_hw(void)
 {
-    aml_set_reg32_mask(P_VPP_MISC, osd_hw.reg_status_save);
+	//aml_set_reg32_mask(P_VPP_MISC, osd_hw.reg_status_save);
+	VSYNCOSD_SET_MPEG_REG_MASK(VPP_MISC, osd_hw.reg_status_save[0]);
+	osd_rdma_enable(1);
 
-    printk("osd_resumed\n");
+	printk("osd_resumed\n");
+
+	return ;
+}
+
+#ifdef CONFIG_HIBERNATION
+void  osd_freeze_hw(void)
+{
+	osd_rdma_enable(0);
+	printk("osd_freezed\n");
 
 	return ;
 }
+void osd_thaw_hw(void)
+{
+	printk("osd_thawed\n");
+	osd_rdma_enable(1);
+	return;
+}
+void osd_restore_hw(void)
+{
+	osd_rdma_enable(1);
+	printk("osd_restored\n");
+
+	return;
+}
+#endif
 
 MODULE_PARM_DESC(osd_h_filter_mode, "\n osd_h_filter_mode \n");
 module_param(osd_h_filter_mode, int, 0664);
diff --git a/drivers/amlogic/display/osd/osd_hw_def.h b/drivers/amlogic/display/osd/osd_hw_def.h
old mode 100644
new mode 100755
index 89a02d78..cc0abc0a
--- a/drivers/amlogic/display/osd/osd_hw_def.h
+++ b/drivers/amlogic/display/osd/osd_hw_def.h
@@ -2,27 +2,25 @@
 #define	_OSD_HW_DEF_H
 #include <linux/amlogic/osd/osd_hw.h>
 #include <linux/amlogic/amports/vframe_provider.h>
-#include <plat/fiq_bridge.h>
+#include <linux/list.h>
 
 /************************************************************************
 **
 **	macro  define  part
 **
 **************************************************************************/
-#define	LEFT		0
-#define	RIGHT		1
-#define	OSD_RELATIVE_BITS				0x33370
-#define HW_OSD_COUNT					2
-#define HW_OSD_BLOCK_COUNT				4
-#define HW_OSD_BLOCK_REG_COUNT			(HW_OSD_BLOCK_COUNT*2)
+#define MAX_BUF_NUM						3  /*fence relative*/
+#define LEFT								0
+#define RIGHT								1
+#define OSD_RELATIVE_BITS				0x33370
 #define HW_OSD_BLOCK_ENABLE_MASK		0x000F
 #define HW_OSD_BLOCK_ENABLE_0			0x0001 /* osd blk0 enable */
 #define HW_OSD_BLOCK_ENABLE_1			0x0002 /* osd blk1 enable */
 #define HW_OSD_BLOCK_ENABLE_2			0x0004 /* osd blk2 enable */
 #define HW_OSD_BLOCK_ENABLE_3			0x0008 /* osd blk3 enable */
 #define HW_OSD_BLOCK_LAYOUT_MASK		0xFFFF0000
-/* 
- * osd block layout horizontal: 
+/*
+ * osd block layout horizontal:
  * -------------
  * |     0     |
  * |-----------|
@@ -34,8 +32,8 @@
  * -------------
  */
 #define HW_OSD_BLOCK_LAYOUT_HORIZONTAL 0x10000
-/* 
- * osd block layout vertical: 
+/*
+ * osd block layout vertical:
  * -------------
  * |  |  |  |  |
  * |  |  |  |  |
@@ -44,14 +42,14 @@
  * |  |  |  |  |
  * -------------
  *
- * NOTE: 
+ * NOTE:
  *     In this mode, just one of the OSD blocks can be enabled at the same time.
  *     Because the blocks must be sequenced in vertical display order if they
  *     want to be both enabled at the same time.
  */
 #define HW_OSD_BLOCK_LAYOUT_VERTICAL 0x20000
-/* 
- * osd block layout grid: 
+/*
+ * osd block layout grid:
  * -------------
  * |     |     |
  * |  0  |  1  |
@@ -60,7 +58,7 @@
  * |  2  |  3  |
  * -------------
  *
- * NOTE: 
+ * NOTE:
  *     In this mode, Block0 and Block1 cannot be enabled at the same time.
  *     Neither can Block2 and Block3.
  */
@@ -70,89 +68,6 @@
  */
 #define HW_OSD_BLOCK_LAYOUT_CUSTOMER 0xFFFF0000
 
-
-/************************************************************************
-**
-**	typedef  define  part
-**
-**************************************************************************/
-typedef  void (*update_func_t)(void) ;   
-
-typedef  struct{
-	struct list_head  	list ;
-	update_func_t    	update_func;  //each reg group has it's own update function.
-}hw_list_t;
-
-typedef  struct{
-	u32  width;  //in byte unit
-	u32	height; 
-	u32  canvas_idx;
-	u32	addr;
-}fb_geometry_t;
-typedef  struct{
-	u16	h_enable;
-	u16	v_enable;
-}osd_scale_t;
-typedef  struct{
-	u16	hfs_enable;
-	u16	vfs_enable;
-}osd_freescale_t;
-typedef  struct{
-	osd_scale_t  origin_scale;
-	u16  enable;
-	u16  left_right;
-	u16  l_start;
-	u16  l_end;
-	u16  r_start;
-	u16  r_end;
-}osd_3d_mode_t;
-typedef struct{
-	u32  on_off;
-	u32  angle;
-}osd_rotate_t;
-
-typedef  pandata_t  dispdata_t;
-
-typedef  struct {
-	pandata_t 		pandata[HW_OSD_COUNT];
-	dispdata_t		dispdata[HW_OSD_COUNT];
-	pandata_t 		scaledata[HW_OSD_COUNT];
-	pandata_t 		free_scale_data[HW_OSD_COUNT];
-	pandata_t		free_dst_data[HW_OSD_COUNT];
-	u32  			gbl_alpha[HW_OSD_COUNT];
-	u32  			color_key[HW_OSD_COUNT];
-	u32				color_key_enable[HW_OSD_COUNT];
-	u32				enable[HW_OSD_COUNT];
-	u32				reg_status_save;
-	bridge_item_t 		fiq_handle_item;
-	osd_scale_t		scale[HW_OSD_COUNT];
-	osd_freescale_t	free_scale[HW_OSD_COUNT];
-	u32				free_scale_enable[HW_OSD_COUNT];
-	u32				free_scale_width[HW_OSD_COUNT];
-	u32				free_scale_height[HW_OSD_COUNT];
-	fb_geometry_t		fb_gem[HW_OSD_COUNT];
-	const color_bit_define_t *color_info[HW_OSD_COUNT];
-	u32				scan_mode;
-	u32				osd_order;
-	osd_3d_mode_t	mode_3d[HW_OSD_COUNT];
-	u32			updated[HW_OSD_COUNT];
-	u32 			block_windows[HW_OSD_COUNT][HW_OSD_BLOCK_REG_COUNT];
-	u32 			block_mode[HW_OSD_COUNT];
-	u32			free_scale_mode[HW_OSD_COUNT];
-	u32			osd_reverse[HW_OSD_COUNT];
-	osd_rotate_t		rotate[HW_OSD_COUNT];
-	pandata_t	rotation_pandata[HW_OSD_COUNT];
-	hw_list_t	 	reg[HW_OSD_COUNT][HW_REG_INDEX_MAX];
-	u32			field_out_en;
-	u32			scale_workaround;
-	u32			fb_for_4k2k;
-	u32         		antiflicker_mode;
-	u32			angle[HW_OSD_COUNT];
-	u32			clone;
-	u32	       bot_type;
-	dispdata_t	cursor_dispdata[HW_OSD_COUNT];
-}hw_para_t;
-
 /************************************************************************
 **
 **	func declare  part
@@ -201,7 +116,7 @@ static unsigned long 	lock_flags;
 static unsigned long	fiq_flag;
 #endif
 static vframe_t vf;
-static update_func_t     hw_func_array[HW_OSD_COUNT][HW_REG_INDEX_MAX]={
+static update_func_t hw_func_array[HW_OSD_COUNT][HW_REG_INDEX_MAX]={
 	{
 		osd1_update_color_mode,
 		osd1_update_enable,
@@ -260,7 +175,7 @@ static update_func_t     hw_func_array[HW_OSD_COUNT][HW_REG_INDEX_MAX]={
 #define add_to_update_list(osd_idx,cmd_idx) \
 	spin_lock_irqsave(&osd_lock, lock_flags); \
 	osd_hw.updated[osd_idx]|=(1<<cmd_idx); \
-	spin_unlock_irqrestore(&osd_lock, lock_flags); 
+	spin_unlock_irqrestore(&osd_lock, lock_flags);
 #endif
 #endif
 
diff --git a/drivers/amlogic/display/osd/osd_log.h b/drivers/amlogic/display/osd/osd_log.h
old mode 100644
new mode 100755
index 6525a4c5..eb91dbed
--- a/drivers/amlogic/display/osd/osd_log.h
+++ b/drivers/amlogic/display/osd/osd_log.h
@@ -1,26 +1,26 @@
-#ifndef  OSD_LOG_H
-#define OSD_LOG_H
-
-#define DEBUG
-#ifdef  DEBUG
-#define  AMLOG   1
-#define LOG_LEVEL_VAR amlog_level_osd
-#define LOG_MASK_VAR amlog_mask_osd
-#endif
-
-
-#define  	LOG_LEVEL_HIGH    		0x00f
-#define	LOG_LEVEL_1			0x001
-#define 	LOG_LEVEL_LOW			0x000
-
-#define LOG_LEVEL_DESC \
-"[0x00]LOW[0X01]LEVEL1[0xf]HIGH"	
-
-#define  	LOG_MASK_INIT			0x001
-#define	LOG_MASK_IOCTL		0x002
-#define	LOG_MASK_HARDWARE	0x004
-#define	LOG_MASK_PARA			0x008
-#define 	LOG_MASK_DESC \
-"[0x01]:INIT,[0x02]:IOCTL,[0x04]:HARDWARE,[0x08]PARA"
-
-#endif
+#ifndef  OSD_LOG_H
+#define OSD_LOG_H
+
+#define DEBUG
+#ifdef  DEBUG
+#define  AMLOG   1
+#define LOG_LEVEL_VAR amlog_level_osd
+#define LOG_MASK_VAR amlog_mask_osd
+#endif
+
+
+#define  	LOG_LEVEL_HIGH    		0x00f
+#define	LOG_LEVEL_1			0x001
+#define 	LOG_LEVEL_LOW			0x000
+
+#define LOG_LEVEL_DESC \
+"[0x00]LOW[0X01]LEVEL1[0xf]HIGH"
+
+#define  	LOG_MASK_INIT			0x001
+#define	LOG_MASK_IOCTL		0x002
+#define	LOG_MASK_HARDWARE	0x004
+#define	LOG_MASK_PARA			0x008
+#define 	LOG_MASK_DESC \
+"[0x01]:INIT,[0x02]:IOCTL,[0x04]:HARDWARE,[0x08]PARA"
+
+#endif
diff --git a/drivers/amlogic/display/osd/osd_main.c b/drivers/amlogic/display/osd/osd_main.c
old mode 100644
new mode 100755
index a47835d1..02fca7f9
--- a/drivers/amlogic/display/osd/osd_main.c
+++ b/drivers/amlogic/display/osd/osd_main.c
@@ -48,19 +48,14 @@
 #include <linux/of.h>
 #include <linux/of_fdt.h>
 #include "osd_log.h"
+#include "osd_sync.h"
 #include <linux/amlogic/amlog.h>
 #include <linux/amlogic/logo/logo_dev.h>
 #include <linux/amlogic/logo/logo_dev_osd.h>
-#ifdef CONFIG_HAS_EARLYSUSPEND
-#include <linux/earlysuspend.h>
 
-// This is not in osd_hw.h private or public header
-void osd_wait_vsync_hw(void);
-
-#if defined(CONFIG_MACH_MESON8B_ODROIDC)
-static int monitor_onoff_flag;
-#endif
 
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
 static struct early_suspend early_suspend;
 static int early_suspend_flag = 0;
 #endif
@@ -75,7 +70,7 @@ osd_info_t  osd_info={
 
 MODULE_AMLOG(AMLOG_DEFAULT_LEVEL, 0x0, LOG_LEVEL_DESC, LOG_MASK_DESC);
 
-static myfb_dev_t  *gp_fbdev_list[OSD_COUNT]={NULL,NULL};
+myfb_dev_t  *gp_fbdev_list[OSD_COUNT]={NULL,NULL};
 
 static DEFINE_MUTEX(dbg_mutex);
 static char request2XScaleValue[32];
@@ -104,11 +99,7 @@ _find_color_format(struct fb_var_screeninfo * var)
 		lower_margin=COLOR_INDEX_24_6666_A;
 		break;		
 		case 3:
-#ifdef CONFIG_FB_AMLOGIC_UMP
-        upper_margin=COLOR_INDEX_32_ARGB;
-#else
-		upper_margin=COLOR_INDEX_32_ABGR;
-#endif
+		upper_margin=COLOR_INDEX_32_ARGB;
 		lower_margin=COLOR_INDEX_32_BGRA;
 		break;
 		case 4:
@@ -122,7 +113,7 @@ _find_color_format(struct fb_var_screeninfo * var)
 	if((var->red.length==0)||(var->green.length==0)||(var->blue.length==0)||
 		var->bits_per_pixel != (var->red.length+var->green.length+var->blue.length+var->transp.length))
 	{
-		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"not provide color component length,use default color \n");
+		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"not provide color component length,use default color\n");
 		ret =&default_color_format_array[upper_margin];
 	}
 	else
@@ -168,7 +159,7 @@ osd_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 	{
 		return -EFAULT ;
 	}
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"select color format :index%d,bpp %d\r\n",color_format_pt->color_index, \
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"select color format :index%d,bpp %d\n",color_format_pt->color_index, \
 												color_format_pt->bpp) ;
 	fbdev->color=color_format_pt;
 	var->red.offset = color_format_pt->red_offset;
@@ -192,10 +183,10 @@ osd_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 	fix->visual=color_format_pt->color_type ;
 	//adjust memory length.	
  	fix->line_length = var->xres_virtual*var->bits_per_pixel/8;
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"xvirtual=%d,bpp:%d,kernel_line_length=%d\r\n",var->xres_virtual,var->bits_per_pixel,fix->line_length);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"xvirtual=%d,bpp:%d,kernel_line_length=%d\n",var->xres_virtual,var->bits_per_pixel,fix->line_length);
 	if(var->xres_virtual*var->yres_virtual*var->bits_per_pixel/8> fbdev->fb_len )
 	{
-		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"no enough memory for %d*%d*%d\r\n",var->xres,var->yres,var->bits_per_pixel);
+		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"no enough memory for %d*%d*%d\n",var->xres,var->yres,var->bits_per_pixel);
 		return  -ENOMEM;
 	}
 	if (var->xres_virtual < var->xres)
@@ -279,12 +270,6 @@ osd_setcmap(struct fb_cmap *cmap, struct fb_info *info)
 	return 0;
 }
 
-#ifdef CONFIG_FB_AMLOGIC_UMP
-int (*disp_get_ump_secure_id) (struct fb_info *info, myfb_dev_t *g_fbi,
-					unsigned long arg, int buf);
-EXPORT_SYMBOL(disp_get_ump_secure_id);
-#endif
-
 static int
 osd_ioctl(struct fb_info *info, unsigned int cmd,
                unsigned long arg)
@@ -301,11 +286,8 @@ osd_ioctl(struct fb_info *info, unsigned int cmd,
 	 u32  block_mode;
         unsigned long  ret;
 	 u32  flush_rate;
+	fb_sync_request_t  sync_request;
 
-	unsigned int karg = 0;
-#ifdef CONFIG_FB_AMLOGIC_UMP
-	int secure_id_buf_num = 0;
-#endif
 
     	switch (cmd)
   	{
@@ -321,6 +303,11 @@ osd_ioctl(struct fb_info *info, unsigned int cmd,
 		case FBIOPUT_OSD_SCALE_AXIS:
 			ret=copy_from_user(&osd_axis, argp, 4 * sizeof(s32));
 			break;
+		case FBIOPUT_OSD_SYNC_ADD:
+			ret=copy_from_user(&sync_request,argp,sizeof(fb_sync_request_t));
+			//printk("osd_mai request offset:%d\n", sync_request.offset);
+			break;
+		case FBIO_WAITFORVSYNC:
 		case FBIOGET_OSD_SCALE_AXIS:
 		case FBIOPUT_OSD_ORDER:
 		case FBIOGET_OSD_ORDER:
@@ -351,54 +338,8 @@ osd_ioctl(struct fb_info *info, unsigned int cmd,
 		case FBIOPUT_OSD_WINDOW_AXIS:
 			ret=copy_from_user(&osd_dst_axis, argp, 4 * sizeof(s32));
 			break;
-#ifdef CONFIG_FB_AMLOGIC_UMP
-		case GET_UMP_SECURE_ID_BUF2:	/* flow trough */
-		{
-			secure_id_buf_num = 1;
-			if (!disp_get_ump_secure_id)
-				request_module("osd_ump");
-			if (disp_get_ump_secure_id)
-				return disp_get_ump_secure_id(info, fbdev, arg,
-							      secure_id_buf_num);
-			else
-				return -ENOTSUPP;
-		}
-		break;
-		case GET_UMP_SECURE_ID_BUF1:	/* flow trough */
-		{
-			secure_id_buf_num = 0;
-			if (!disp_get_ump_secure_id)
-				request_module("osd_ump");
-			if (disp_get_ump_secure_id)
-				return disp_get_ump_secure_id(info, fbdev, arg,
-							      secure_id_buf_num);
-			else
-				return -ENOTSUPP;
-		}
-		break;
-#endif
-		case FBIOPUT_OSD2_CURSOR_DATA:
-		{
-			if (copy_from_user(&karg, argp, sizeof(unsigned int))) {
-				return -EFAULT;
-			}
-			aml_hwc_addr_t para;
-			if (copy_from_user(&para, (void __user *)karg, sizeof(aml_hwc_addr_t))) {
-				return -EFAULT;
-			}
-			ret = osddev_copy_data_tocursor(fbdev, &para);
-		}
-		break;
-		
-		case FBIO_WAITFORVSYNC:
-		{
-        		osd_wait_vsync_hw();
-         		ret = 0;
-      		}
-      		break;
-
 		default :
-			amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_HIGH,"command not supported\r\n ");
+			amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_HIGH,"command not supported\n ");
 			return -1;
 	}
 	mutex_lock(&fbdev->lock);
@@ -453,7 +394,7 @@ osd_ioctl(struct fb_info *info, unsigned int cmd,
 			case COLOR_INDEX_24_888_B:
 			case COLOR_INDEX_24_RGB:
 			case COLOR_INDEX_YUV_422:
-	  	   	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"set osd color key 0x%x\r\n",src_colorkey);
+	  	   	amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"set osd color key 0x%x\n",src_colorkey);
             fbdev->color_key = src_colorkey;
 	  	 	osddev_set_colorkey(info->node,fbdev->color->color_index,src_colorkey);
 			break;
@@ -469,7 +410,7 @@ osd_ioctl(struct fb_info *info, unsigned int cmd,
 			case COLOR_INDEX_24_888_B:
 			case COLOR_INDEX_24_RGB:
 			case COLOR_INDEX_YUV_422:	
-			amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"set osd color key %s\r\n",srckey_enable?"enable":"disable");
+			amlog_mask_level(LOG_MASK_IOCTL,LOG_LEVEL_LOW,"set osd color key %s\n",srckey_enable?"enable":"disable");
 			if (srckey_enable != 0) {
 				fbdev->enable_key_flag |= KEYCOLOR_FLAG_TARGET;
 				if (!(fbdev->enable_key_flag & KEYCOLOR_FLAG_ONHOLD)) {
@@ -527,13 +468,24 @@ osd_ioctl(struct fb_info *info, unsigned int cmd,
 		case FBIOPUT_OSD_WINDOW_AXIS:
 			osddev_set_window_axis(info->node, osd_dst_axis[0], osd_dst_axis[1], osd_dst_axis[2], osd_dst_axis[3]);
 			break;
+		 case FBIOPUT_OSD_SYNC_ADD:
+		 	sync_request.out_fen_fd=osddev_sync_request(info, sync_request.xoffset,sync_request.yoffset,sync_request.in_fen_fd);
+			ret=copy_to_user(argp, &sync_request, sizeof(fb_sync_request_t));
+			if(sync_request.out_fen_fd  <0 ) // fence create fail.
+			ret=-1;
+			break;
+		case FBIO_WAITFORVSYNC:
+			osddev_wait_for_vsync();
+			ret=1;
+			ret=copy_to_user(argp,&ret,sizeof(u32));
+
 		default:
 			break;
     	}
 
    	mutex_unlock(&fbdev->lock);
 	
-	return  0;
+	return  ret;
 }
 static int osd_open(struct fb_info *info, int arg)
 {
@@ -541,31 +493,11 @@ static int osd_open(struct fb_info *info, int arg)
 	
 }
 
-/* Blank Mode */
-extern void control_hdmiphy(int on);
 
-static int
-osd_blank(int blank_mode, struct fb_info *info)
+int osd_blank(int blank_mode, struct fb_info *info)
 {
  	osddev_enable((blank_mode != 0) ? 0 : 1,info->node);
 
-#if defined(CONFIG_MACH_MESON8B_ODROIDC)
-	if (!monitor_onoff_flag)
-		return 0;
-
-	switch (blank_mode) {
-	case FB_BLANK_UNBLANK: /* Display: On; HSync: On, VSync: On */
-		control_hdmiphy(1); /* HDMI PHY ON */
-		break;
-	case FB_BLANK_NORMAL: /* Display: Off; HSync: On, VSync: On */
-	case FB_BLANK_HSYNC_SUSPEND: /* Display: Off; HSync: Off, VSync: On */
-	case FB_BLANK_VSYNC_SUSPEND: /* Display: Off; HSync: On, VSync: Off */
-		break;
-	case FB_BLANK_POWERDOWN: /* Display: Off; HSync: Off, VSync: Off */
-		control_hdmiphy(0); /* HDMI PHY OFF*/
-		break;
-	}
-#endif
     	return 0;
 }
 
@@ -573,7 +505,7 @@ static int osd_pan_display(struct fb_var_screeninfo *var,
                         struct fb_info *fbi)
 {
 	osddev_pan_display(var,fbi);
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"osd_pan_display:=>osd%d\r\n",fbi->node);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"osd_pan_display:=>osd%d\n",fbi->node);
 	return 0;
 }
 
@@ -654,12 +586,12 @@ int osd_notify_callback(struct notifier_block *block, unsigned long cmd , void *
 	disp_rect_t  *disp_rect;
 	
 	vinfo = get_current_vinfo();
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"tv_server:vmode=%s\r\n", vinfo->name);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"tv_server:vmode=%s\n", vinfo->name);
 	
 	switch(cmd)
 	{
 		case  VOUT_EVENT_MODE_CHANGE:
-		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"recevie change mode  message \r\n");
+		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"recevie change mode  message\n");
 		for(i=0;i<OSD_COUNT;i++)
 		{
 			if(NULL==(fb_dev=gp_fbdev_list[i])) continue;
@@ -691,7 +623,7 @@ int osd_notify_callback(struct notifier_block *block, unsigned long cmd , void *
 			if(fb_dev->preblend_enable) break;  //if osd layer preblend ,it's position is controled by vpp.
 			fb_dev->osd_ctl.disp_start_x=disp_rect->x  ;
 			fb_dev->osd_ctl.disp_start_y=disp_rect->y  ;
-			amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"set disp axis: x:%d y:%d w:%d h:%d\r\n"  , \
+			amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"set disp axis: x:%d y:%d w:%d h:%d\n"  , \
 					disp_rect->x, disp_rect->y,\
 					disp_rect->w, disp_rect->h );
 			if(disp_rect->x+disp_rect->w > vinfo->width)
@@ -711,7 +643,7 @@ int osd_notify_callback(struct notifier_block *block, unsigned long cmd , void *
 				fb_dev->osd_ctl.disp_end_y=fb_dev->osd_ctl.disp_start_y + disp_rect->h - 1 ;
 			}
 			disp_rect ++;
-			amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"new disp axis: startx:%d starty:%d endx:%d endy:%d\r\n"  , \
+			amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"new disp axis: startx:%d starty:%d endx:%d endy:%d\n"  , \
 					fb_dev->osd_ctl.disp_start_x, fb_dev->osd_ctl.disp_start_y,\
 					fb_dev->osd_ctl.disp_end_x,fb_dev->osd_ctl.disp_end_y);
 			console_lock();
@@ -727,6 +659,7 @@ int osd_notify_callback(struct notifier_block *block, unsigned long cmd , void *
 static struct notifier_block osd_notifier_nb = {
 	.notifier_call	= osd_notify_callback,
 };
+
 static ssize_t store_preblend_enable(struct device *device, struct device_attribute *attr,
 			 const char *buf, size_t count)
 {
@@ -1070,10 +1003,14 @@ static ssize_t show_freescale_mode(struct device *device, struct device_attribut
 {
 	struct fb_info *fb_info = dev_get_drvdata(device);
 	unsigned int free_scale_mode=0;
+	char *help_info = "free scale mode:\n"\
+						"    0: VPU free scaler\n" \
+						"    1: OSD free scaler\n" \
+						"    2: OSD super scaler\n";
 
 	osddev_get_free_scale_mode(fb_info->node, &free_scale_mode);
 
-	return snprintf(buf, PAGE_SIZE, "free_scale_mode:%s\n",free_scale_mode?"new":"default");
+	return snprintf(buf, PAGE_SIZE, "%scurrent free_scale_mode:%d\n", help_info, free_scale_mode);
 }
 
 static ssize_t store_scale(struct device *device, struct device_attribute *attr,
@@ -1397,6 +1334,25 @@ static ssize_t store_antiflicker(struct device *device, struct device_attribute
 	return count;
 }
 
+ static ssize_t show_update_freescale(struct device *device, struct device_attribute *attr,
+     char *buf)
+{
+  struct fb_info *fb_info = dev_get_drvdata(device);
+  unsigned int update_state = 0;
+  osddev_get_update_state(fb_info->node, &update_state);
+  return snprintf(buf, PAGE_SIZE, "update_state:[%s]\n", update_state?"TRUE":"FALSE");
+}
+
+static ssize_t store_update_freescale(struct device *device, struct device_attribute *attr,
+  const char *buf, size_t count)
+{
+  struct fb_info *fb_info = dev_get_drvdata(device);
+  unsigned int update_state = 0;
+  update_state = simple_strtoul(buf, NULL, 0);
+  osddev_set_update_state(fb_info->node, update_state);
+  return count;
+}
+
 static ssize_t show_ver_angle(struct device *device, struct device_attribute *attr,
                         char *buf)
 {
@@ -1509,19 +1465,6 @@ static inline int install_osd_reverse_info(osd_info_t *init_osd_info,char *para)
 	return 0;
 }
 
-#if defined(CONFIG_MACH_MESON8B_ODROIDC)
-static int __init osd_setup_monitor_onoff(char *str)
-{
-	if (!strcmp(str, "true") || !strcmp(str, "1"))
-		monitor_onoff_flag = 1;
-	else
-		monitor_onoff_flag = 0;
-
-	return 0;
-}
-__setup("monitor_onoff=", osd_setup_monitor_onoff);
-#endif
-
 /* --------------------------------------------------------------------------*/
 /**
  * @brief  set_osd_reverse
@@ -1600,6 +1543,7 @@ static struct device_attribute osd_attrs[] = {
 	__ATTR(osd_reverse, S_IRUGO|S_IWUSR, show_osd_reverse, store_osd_reverse),
 	__ATTR(prot_state, S_IRUGO|S_IWUSR, show_prot_state, NULL),
 	__ATTR(osd_antiflicker, S_IRUGO|S_IWUSR, show_antiflicker, store_antiflicker),
+	__ATTR(update_freescale, S_IRUGO|S_IWUSR, show_update_freescale, store_update_freescale),
 	__ATTR(ver_angle, S_IRUGO|S_IWUSR, show_ver_angle, store_ver_angle),
 	__ATTR(ver_clone, S_IRUGO|S_IWUSR, show_ver_clone, store_ver_clone),
 	__ATTR(ver_update_pan, S_IRUGO|S_IWUSR, NULL, store_ver_update_pan),
@@ -1624,7 +1568,6 @@ static int osd_resume(struct platform_device * dev)
 		return 0;
 	}
 #endif
-
 #ifdef CONFIG_HAS_EARLYSUSPEND
     if (early_suspend_flag)
         return 0;
@@ -1634,6 +1577,34 @@ static int osd_resume(struct platform_device * dev)
 }
 #endif 
 
+#ifdef CONFIG_HIBERNATION
+extern void osddev_freeze(void);
+extern void osddev_thaw(void);
+extern void osddev_restore(void);
+
+static int osd_freeze(struct device *dev)
+{
+    printk("**** %s ****\n", __FUNCTION__);
+    osddev_freeze();
+    return 0;
+}
+
+static int osd_thaw(struct device *dev)
+{
+    printk("**** %s ****\n", __FUNCTION__);
+    osddev_thaw();
+    return 0;
+}
+
+static int osd_restore(struct device *dev)
+{
+    printk("**** %s ****\n", __FUNCTION__);
+    osddev_restore();
+    return 0;
+}
+#endif
+
+
 #ifdef CONFIG_HAS_EARLYSUSPEND
 static void osd_early_suspend(struct early_suspend *h)
 {
@@ -1733,7 +1704,7 @@ osd_probe(struct platform_device *pdev)
 
 		if(prop_idx == 3){
 			if(get_current_mode_state() == VMODE_SETTED){
-				amlog_level(LOG_LEVEL_HIGH,"vmode has setted in aml logo module\r\n");
+				amlog_level(LOG_LEVEL_HIGH,"vmode has setted in aml logo module\n");
 			}else{
 				DisableVideoLayer();
 				#ifdef CONFIG_AM_HDMI_ONLY
@@ -1837,7 +1808,7 @@ osd_probe(struct platform_device *pdev)
 			mydef_var[index].yres_virtual=init_logo_obj->dev->vinfo->height<<1;//logo always use double buffer
 			mydef_var[index].bits_per_pixel=bpp;
 			
-			amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\r\n",mydef_var[index].bits_per_pixel);
+			amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\n",mydef_var[index].bits_per_pixel);
 			if(mydef_var[index].bits_per_pixel>32){
 				mydef_var[index].bits_per_pixel=32;
 			}
@@ -1855,15 +1826,15 @@ osd_probe(struct platform_device *pdev)
 					mydef_var[index].yres_virtual=var_screeninfo[3];//logo always use double buffer
 					mydef_var[index].bits_per_pixel=bpp;
 				
-					amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\r\n",mydef_var[index].bits_per_pixel);
+					amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\n",mydef_var[index].bits_per_pixel);
 					if(mydef_var[index].bits_per_pixel>32) 
 					{
 						mydef_var[index].bits_per_pixel=32;
 					}
 				}
 			}
-			amlog_level(LOG_LEVEL_HIGH,"---------------clear framebuffer%d memory  \r\n",index);
-			memset((char*)fbdev->fb_mem_vaddr, 0x80, fbdev->fb_len);
+			amlog_level(LOG_LEVEL_HIGH,"---------------clear framebuffer%d memory\n",index);
+			memset((char*)fbdev->fb_mem_vaddr, 0x00, fbdev->fb_len);
 		}
 
 		if (index == OSD0){
@@ -1903,7 +1874,11 @@ osd_probe(struct platform_device *pdev)
 		set_default_display_axis(&fbdev->fb_info->var,&fbdev->osd_ctl,vinfo);
 		osd_check_var(var, fbi);
     		register_framebuffer(fbi);
-		if(NULL==init_logo_obj )//if we have init a logo object ,then no need to setup hardware . 
+		if(index == OSD0 && init_logo_obj != NULL)
+		{
+			osddev_set(fbdev);
+		}
+		else if(NULL==init_logo_obj)//if we have init a logo object ,then no need to setup hardware .
 		{
 			osddev_set(fbdev);
 		}
@@ -1940,9 +1915,7 @@ osd_probe(struct platform_device *pdev)
 	}else{
 		osddev_set_osd_reverse(osd_info.index, osd_info.osd_reverse);
 	}
-	amlog_level(LOG_LEVEL_HIGH,"osd probe ok  \r\n");
-	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE, NULL);
-	osddev_free_scale_enable(osd_info.index, 0);
+	amlog_level(LOG_LEVEL_HIGH,"osd probe ok\n");
 	return 0;
 
 failed2:
@@ -2026,6 +1999,14 @@ static const struct of_device_id meson_fb_dt_match[]={
 	{},
 };
 
+#ifdef CONFIG_HIBERNATION
+struct dev_pm_ops osd_pm = {
+	.freeze		= osd_freeze,
+	.thaw		= osd_thaw,
+	.restore	= osd_restore,
+};
+#endif
+
 static struct platform_driver
 osd_driver = {
     .probe      = osd_probe,
@@ -2037,6 +2018,9 @@ osd_driver = {
     .driver     = {
         .name   = "mesonfb",
         .of_match_table=meson_fb_dt_match,
+#ifdef CONFIG_HIBERNATION
+        .pm     = &osd_pm,
+#endif
     }
 };
 
diff --git a/drivers/amlogic/display/osd/osd_progressbar.c b/drivers/amlogic/display/osd/osd_progressbar.c
new file mode 100644
index 00000000..7512d7a0
--- /dev/null
+++ b/drivers/amlogic/display/osd/osd_progressbar.c
@@ -0,0 +1,215 @@
+#include <linux/version.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/wait.h>
+#include <linux/of_fdt.h>
+#include <linux/console.h>
+#include <mach/am_regs.h>
+#include <linux/amlogic/osd/osd_dev.h>
+#include <linux/amlogic/amlog.h>
+#include <linux/amlogic/logo/logo_dev.h>
+#include <linux/amlogic/logo/logo_dev_osd.h>
+#include <linux/amlogic/logo/dev_ge2d.h>
+#include <mach/mod_gate.h>
+
+extern myfb_dev_t  *gp_fbdev_list[OSD_COUNT];
+extern int osd_blank(int blank_mode, struct fb_info *info);
+
+typedef struct{
+	ge2d_context_t  *ge2d_context;
+	const vinfo_t *vinfo;
+	src_dst_info_t  op_info;
+	u32 bar_border;
+	u32 bar_width;
+	u32 bar_height;
+} osd_progress_bar_t;
+
+static osd_progress_bar_t progress_bar;
+
+static int init_fb1_first (const vinfo_t *vinfo)
+{
+	struct osd_ctl_s  osd_ctl;
+	const color_bit_define_t  *color;
+	u32 reg = 0, data32 = 0;
+	int ret = 0;
+
+	ret = find_reserve_block("mesonfb", 1);
+	if (ret < 0) {
+		amlog_level(LOG_LEVEL_HIGH,
+			"can not find mesonfb1 reserve block\n");
+		return -EFAULT;
+	}
+
+	osd_ctl.addr = (phys_addr_t)get_reserve_block_addr(ret);
+
+	osd_ctl.index = 1; //fb1
+	color=&default_color_format_array[31];
+
+	osd_ctl.xres=vinfo->width;
+	osd_ctl.yres=vinfo->height;
+	osd_ctl.xres_virtual=osd_ctl.xres;
+	osd_ctl.yres_virtual=osd_ctl.yres;
+	osd_ctl.disp_start_x=0;
+	osd_ctl.disp_end_x=osd_ctl.xres -1;
+	osd_ctl.disp_start_y=0;
+	osd_ctl.disp_end_y=osd_ctl.yres-1;
+
+	reg = osd_ctl.index==0?P_VIU_OSD1_BLK0_CFG_W0:P_VIU_OSD2_BLK0_CFG_W0;
+	data32 = aml_read_reg32(reg)&(~(0xf<<8));
+	data32 |=  color->hw_blkmode<< 8; /* osd_blk_mode */
+	aml_write_reg32(reg, data32);
+
+	amlog_level(LOG_LEVEL_HIGH, "osd_ctl.addr is 0x%08x, osd_ctl.xres is %d,"
+		" osd_ctl.yres is %d\n", osd_ctl.addr,
+			osd_ctl.xres, osd_ctl.yres);
+	osd_setup(&osd_ctl, \
+		0, \
+		0, \
+		osd_ctl.xres, \
+		osd_ctl.yres, \
+		osd_ctl.xres_virtual, \
+		osd_ctl.yres_virtual, \
+		osd_ctl.disp_start_x, \
+		osd_ctl.disp_start_y, \
+		osd_ctl.disp_end_x, \
+		osd_ctl.disp_end_y, \
+		osd_ctl.addr, \
+		color, \
+		osd_ctl.index);
+
+	return SUCCESS;
+}
+
+int osd_show_progress_bar(u32 percent) {
+	static u32 progress= 0;
+	u32 step =1;
+	//wait_queue_head_t  wait_head;
+	myfb_dev_t *fb_dev;
+	ge2d_context_t  *context = progress_bar.ge2d_context;
+	src_dst_info_t  *op_info = &progress_bar.op_info;
+
+	if (NULL == context) {
+		//osd_init_progress_bar();
+		printk("context is NULL\n");
+		return -1;
+	}
+	if (NULL == (fb_dev = gp_fbdev_list[1])) {
+		amlog_level(LOG_LEVEL_HIGH, "fb1 should exit!!!");
+		return -EFAULT;
+	}
+	switch_mod_gate_by_name("ge2d", 1);
+	//init_waitqueue_head(&wait_head);
+
+	while (progress < percent) {
+		/*
+		printk("progress is %d, x: [%d], y: [%d], w: [%d], h: [%d]\n",
+			progress, op_info->dst_rect.x, op_info->dst_rect.y,
+			op_info->dst_rect.w, op_info->dst_rect.h);
+		*/
+
+		dev_ge2d_cmd(context,CMD_FILLRECT,op_info);
+		//wait_event_interruptible_timeout(wait_head,0,4);
+		progress+=step;
+		op_info->dst_rect.x+=op_info->dst_rect.w;
+		op_info->color-=(0xff*step/100)<<16; //color change smoothly.
+	}
+	switch_mod_gate_by_name("ge2d", 0);
+	if (100 == percent) {
+		progress = 0;
+		//console_lock();
+		//osd_blank(1,fb_dev->fb_info);
+		//console_unlock();
+	}
+	return SUCCESS;
+}
+EXPORT_SYMBOL(osd_show_progress_bar);
+
+int osd_init_progress_bar(void) {
+	src_dst_info_t  *op_info = &progress_bar.op_info;
+	const vinfo_t *vinfo = progress_bar.vinfo;
+	config_para_t	ge2d_config;
+	myfb_dev_t *fb_dev;
+	u32 step =1;
+
+	memset(&progress_bar, 0, sizeof(osd_progress_bar_t));
+
+	vinfo = get_current_vinfo();
+	/*
+	pr_info("vinfo->name is %s, vinfo->mode is %d, vinfo->width: [%d],"
+		" vinfo->height: [%d], vinfo->screen_real_width: [%d],"
+		" vinfo->screen_real_height: [%d]\n",
+		vinfo->name, vinfo->mode, vinfo->width, vinfo->height,
+		vinfo->screen_real_width, vinfo->screen_real_height);
+	*/
+	progress_bar.bar_border =
+		(((vinfo->field_height?vinfo->field_height:vinfo->height)*4/720)>>2)<<2;
+	progress_bar.bar_width =
+		(((vinfo->width*200/1280)>>2)<<2) + progress_bar.bar_border;
+	progress_bar.bar_height =
+		(((vinfo->field_height?vinfo->field_height:vinfo->height)*32/720)>>2)<<2;
+
+	if (SUCCESS == init_fb1_first(vinfo)) {
+		if (NULL == (fb_dev = gp_fbdev_list[1])) {
+			amlog_level(LOG_LEVEL_HIGH, "fb1 should exit!!!");
+			return -EFAULT;
+		}
+
+		switch_mod_gate_by_name("ge2d", 1);
+		ge2d_config.src_dst_type = OSD1_OSD1;
+		ge2d_config.alu_const_color = 0x000000ff;
+		progress_bar.ge2d_context = dev_ge2d_setup(&ge2d_config);
+		if (NULL == progress_bar.ge2d_context) {
+			pr_info("ge2d_context is NULL!!!!!!\n");
+			return -OUTPUT_DEV_SETUP_FAIL;
+		}
+		amlog_level(LOG_LEVEL_HIGH, "progress bar setup ge2d device OK\n");
+		//clear dst rect
+		op_info->color = 0x000000bf;
+		op_info->dst_rect.x = 0;
+		op_info->dst_rect.y = 0;
+		op_info->dst_rect.w = vinfo->width;
+		op_info->dst_rect.h =
+			vinfo->field_height?vinfo->field_height:vinfo->height;
+		dev_ge2d_cmd(progress_bar.ge2d_context,CMD_FILLRECT,op_info);
+		/*
+		pr_info("clear dst:%d-%d-%d-%d\n",
+			op_info->dst_rect.x,op_info->dst_rect.y,
+			op_info->dst_rect.w,op_info->dst_rect.h);
+		*/
+		// show fb1
+		console_lock();
+		osd_blank(0,fb_dev->fb_info);
+		console_unlock();
+		op_info->color=0x555555ff;
+		op_info->dst_rect.x =
+			(vinfo->width/2)-progress_bar.bar_width;
+		op_info->dst_rect.y =
+			((vinfo->field_height?vinfo->field_height:vinfo->height)*9)/10;
+		op_info->dst_rect.w = progress_bar.bar_width*2;
+		op_info->dst_rect.h = progress_bar.bar_height;
+		/*
+		pr_info("fill==dst:%d-%d-%d-%d\n",
+			op_info->dst_rect.x,op_info->dst_rect.y,
+			op_info->dst_rect.w,op_info->dst_rect.h);
+		*/
+		dev_ge2d_cmd(progress_bar.ge2d_context,CMD_FILLRECT,op_info);
+		switch_mod_gate_by_name("ge2d", 0);
+	} else {
+		amlog_level(LOG_LEVEL_HIGH, "fb1 init failed, exit!!!");
+		return -EFAULT;
+	}
+
+	// initial op info before draw actrualy
+	op_info->dst_rect.x += progress_bar.bar_border;
+	op_info->dst_rect.y += progress_bar.bar_border;
+	op_info->dst_rect.w =
+		(progress_bar.bar_width-progress_bar.bar_border)*2*step/100;
+	op_info->dst_rect.h =
+		progress_bar.bar_height-progress_bar.bar_border*2;
+	op_info->color = 0xffffff;
+
+	return SUCCESS;
+}
+EXPORT_SYMBOL(osd_init_progress_bar);
+
diff --git a/drivers/amlogic/display/osd/osd_prot.c b/drivers/amlogic/display/osd/osd_prot.c
old mode 100644
new mode 100755
index ea84bb3a..d923a512
--- a/drivers/amlogic/display/osd/osd_prot.c
+++ b/drivers/amlogic/display/osd/osd_prot.c
@@ -73,7 +73,7 @@ int osd_set_prot(unsigned char   x_rev,
 			VSYNCOSD_WR_MPEG_REG_BITS (VIU_OSD2_BLK0_CFG_W0, 1, 15, 1);//switch back to little endian
 			VSYNCOSD_WR_MPEG_REG(VIU_OSD2_PROT_CTRL,0);
 		}
-		
+
 		return 0;
 	}
 	if(osd_index==OSD1){
@@ -125,5 +125,4 @@ int osd_set_prot(unsigned char   x_rev,
     VSYNCOSD_WR_MPEG_REG(VPU_PROT1_REQ_ONOFF,    data32);
     VSYNCOSD_WR_MPEG_REG(VPU_PROT1_CLK_GATE, 1); // Enable clock
     return 0;
-}   
-
+}
diff --git a/drivers/amlogic/display/osd/osd_prot.h b/drivers/amlogic/display/osd/osd_prot.h
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/display/osd/osd_rdma.c b/drivers/amlogic/display/osd/osd_rdma.c
old mode 100644
new mode 100755
index e48b01d3..f0c9f44c
--- a/drivers/amlogic/display/osd/osd_rdma.c
+++ b/drivers/amlogic/display/osd/osd_rdma.c
@@ -23,41 +23,89 @@
  * description
  *     rdma table work as REGISTER Cache for read write.
  */
- #include "osd_rdma.h"
-static rdma_table_item_t* rdma_table=NULL;
-static u32		   table_paddr=0; 
-static u32		   rdma_enable=0;
-static u32		   item_count=0;
+#include "osd_rdma.h"
+#include <linux/amlogic/amlog.h>
+#include <linux/delay.h>
+#include <linux/spinlock.h>
+
+static DEFINE_MUTEX(rdma_mutex);
+static DEFINE_SPINLOCK(rdma_lock);
+
+static rdma_table_item_t *rdma_table = NULL;
+static u32		   table_paddr = 0;
+static u32		   rdma_enable = 0;
+static u32		   item_count = 0;
+static u32 		   rdma_debug = 0;
 
 static bool		osd_rdma_init_flat = false;
 static int ctrl_ahb_rd_burst_size = 3;
 static int ctrl_ahb_wr_burst_size = 3;
 
 static int  osd_rdma_init(void);
+void osd_rdma_start(void);
+
+#define OSD_RDMA_UPDATE_RETRY_COUNT 100
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 #define Wr(adr,val) WRITE_VCBUS_REG(adr, val)
 #define Rd(adr)    READ_VCBUS_REG(adr)
 #define Wr_reg_bits(adr, val, start, len)  WRITE_VCBUS_REG_BITS(adr, val, start, len)
-#define Wr_set_reg_bits_mask(adr, _mask)	 SET_VCBUS_REG_MASK(adr, _mask);
-#define Wr_clr_reg_bits_mask(adr, _mask)	 CLEAR_VCBUS_REG_MASK(adr, _mask);
+#define Wr_set_reg_bits_mask(adr, _mask)	 SET_VCBUS_REG_MASK(adr, _mask)
+#define Wr_clr_reg_bits_mask(adr, _mask)	 CLEAR_VCBUS_REG_MASK(adr, _mask)
 #else
 #define Wr(adr,val) WRITE_MPEG_REG(adr, val)
 #define Rd(adr)    READ_MPEG_REG(adr)
 #define Wr_reg_bits(adr, val, start, len)  WRITE_MPEG_REG_BITS(adr, val, start, len)
-#define Wr_set_reg_bits_mask(adr, _mask)	 SET_MPEG_REG_MASK(adr, _mask);
-#define Wr_clr_reg_bits_mask(adr, _mask)	 CLEAR_MPEG_REG_MASK(adr, _mask);
+#define Wr_set_reg_bits_mask(adr, _mask)	 SET_MPEG_REG_MASK(adr, _mask)
+#define Wr_clr_reg_bits_mask(adr, _mask)	 CLEAR_MPEG_REG_MASK(adr, _mask)
 #endif
 
-static int  update_table_item(u32 addr,u32 val)
+static void inline reset_rdma_table(void)
 {
-	if(item_count > (MAX_TABLE_ITEM-1)) return -1;
+	unsigned long flags;
+
+	spin_lock_irqsave(&rdma_lock, flags);
+	aml_write_reg32(END_ADDR, table_paddr - 1);
+	rdma_table[0].addr = OSD_RDMA_FLAG_REG;
+	rdma_table[0].val = OSD_RDMA_STATUS_MARK_TBL_RST;
+	item_count = 1;
+	spin_unlock_irqrestore(&rdma_lock, flags);
+}
 
-	//new comer,then add it .
-	rdma_table[item_count].addr=addr;
-	rdma_table[item_count].val=val;
+static int update_table_item(u32 addr, u32 val)
+{
+	unsigned long flags;
+	int retry_count = OSD_RDMA_UPDATE_RETRY_COUNT;
+retry:
+	//in reject region then we wait for hw rdma operation complete.
+	if (OSD_RDMA_STATUS_IS_REJECT && (retry_count > 0)) {
+		retry_count--;
+		goto retry;
+	}
+	if (!OSD_RDMA_STAUS_IS_DIRTY) { //since last HW op,no new wirte request. rdma HW op will clear DIRTY flag.
+		//reset all pointer. set table start margin.
+		reset_rdma_table();
+	}
+	//atom_lock_start:
+	//set write op aotmic lock flag.
+	OSD_RDMA_STAUS_MARK_DIRTY;
+	spin_lock_irqsave(&rdma_lock, flags);
 	item_count++;
-	aml_write_reg32(END_ADDR,(table_paddr + item_count*8-1));
+	rdma_table[item_count].addr = OSD_RDMA_FLAG_REG;
+	rdma_table[item_count].val = OSD_RDMA_STATUS_MARK_COMPLETE;
+	aml_write_reg32(END_ADDR, (table_paddr + item_count * 8 + 7));
+	rdma_table[item_count - 1].addr = addr;
+	rdma_table[item_count - 1].val = val;
+	spin_unlock_irqrestore(&rdma_lock, flags);
+	//if dirty flag is cleared, then RDMA hw write and cpu sw write is racing.
+	//if reject flag is true,then hw RDMA hw write start when cpu write.
+	//atom_lock_end:
+	if (!OSD_RDMA_STAUS_IS_DIRTY || OSD_RDMA_STATUS_IS_REJECT) {
+		spin_lock_irqsave(&rdma_lock, flags);
+		item_count--;
+		spin_unlock_irqrestore(&rdma_lock, flags);
+		goto retry ;
+	}
 	return 0;
 }
 
@@ -65,43 +113,40 @@ u32  VSYNCOSD_RD_MPEG_REG(unsigned long addr)
 {
 	int  i;
 
-	if(rdma_enable)
-	{
-		for(i=(item_count -1); i>=0; i--)
-		{
-			if(addr==rdma_table[i].addr)
-			return rdma_table[i].val;
+	if (rdma_enable) {
+		for (i = (item_count - 1); i >= 0; i--) {
+			if (addr == rdma_table[i].addr)
+				return rdma_table[i].val;
 		}
 	}
 	return Rd(addr);
-}    
+}
 EXPORT_SYMBOL(VSYNCOSD_RD_MPEG_REG);
 
 int VSYNCOSD_WR_MPEG_REG(unsigned long addr, unsigned long val)
 {
-	if(rdma_enable)
-	{
-		update_table_item(addr,val);
-	}else{
-		Wr(addr,val);
-	}
+	if (rdma_enable)
+		update_table_item(addr, val);
+	else
+		Wr(addr, val);
 	return 0;
 }
 EXPORT_SYMBOL(VSYNCOSD_WR_MPEG_REG);
 
-int VSYNCOSD_WR_MPEG_REG_BITS(unsigned long addr, unsigned long val, unsigned long start, unsigned long len)
+int VSYNCOSD_WR_MPEG_REG_BITS(unsigned long addr, unsigned long val,
+			      unsigned long start, unsigned long len)
 {
 	unsigned long read_val;
 	unsigned long write_val;
 
-	if(rdma_enable){
-		read_val=VSYNCOSD_RD_MPEG_REG(addr);
-		write_val = (read_val & ~(((1L<<(len))-1)<<(start)))|((unsigned int)(val) << (start));
-		update_table_item(addr,write_val);
-	}else{
-		Wr_reg_bits(addr,val,start,len);
-	}
-    
+	if (rdma_enable) {
+		read_val = VSYNCOSD_RD_MPEG_REG(addr);
+		write_val = (read_val & ~(((1L << (len)) - 1) << (start))) | ((unsigned int)(
+					val) << (start));
+		update_table_item(addr, write_val);
+	} else
+		Wr_reg_bits(addr, val, start, len);
+
 	return 0;
 }
 EXPORT_SYMBOL(VSYNCOSD_WR_MPEG_REG_BITS);
@@ -111,13 +156,12 @@ int VSYNCOSD_SET_MPEG_REG_MASK(unsigned long addr, unsigned long _mask)
 	unsigned long read_val;
 	unsigned long write_val;
 
-	if(rdma_enable){
-		read_val=VSYNCOSD_RD_MPEG_REG(addr);
-		write_val = read_val|_mask ;
-		update_table_item(addr,write_val);
-	}else{
-		Wr_set_reg_bits_mask(addr,_mask);
-	}	
+	if (rdma_enable) {
+		read_val = VSYNCOSD_RD_MPEG_REG(addr);
+		write_val = read_val | _mask ;
+		update_table_item(addr, write_val);
+	} else
+		Wr_set_reg_bits_mask(addr, _mask);
 
 	return 0;
 }
@@ -128,13 +172,12 @@ int VSYNCOSD_CLR_MPEG_REG_MASK(unsigned long addr, unsigned long _mask)
 	unsigned long read_val;
 	unsigned long write_val;
 
-	if(rdma_enable){
-		read_val=VSYNCOSD_RD_MPEG_REG(addr);
-		write_val = read_val&(~_mask) ;
-		update_table_item(addr,write_val);
-	}else{
-		Wr_clr_reg_bits_mask(addr,_mask);
-	}
+	if (rdma_enable) {
+		read_val = VSYNCOSD_RD_MPEG_REG(addr);
+		write_val = read_val & (~_mask) ;
+		update_table_item(addr, write_val);
+	} else
+		Wr_clr_reg_bits_mask(addr, _mask);
 
 	return 0;
 }
@@ -142,23 +185,28 @@ EXPORT_SYMBOL(VSYNCOSD_CLR_MPEG_REG_MASK);
 
 static int start_osd_rdma(char channel)
 {
-	char intr_bit=8*channel;
-	char rw_bit=4+channel;
-	char inc_bit=channel;
+	char intr_bit = 8 * channel;
+	char rw_bit = 4 + channel;
+	char inc_bit = channel;
 	u32 data32;
 
 	data32  = 0;
 	data32 |= 0                         << 6;   // [31: 6] Rsrv.
-	data32 |= ctrl_ahb_wr_burst_size    << 4;   // [ 5: 4] ctrl_ahb_wr_burst_size. 0=16; 1=24; 2=32; 3=48.
-	data32 |= ctrl_ahb_rd_burst_size    << 2;   // [ 3: 2] ctrl_ahb_rd_burst_size. 0=16; 1=24; 2=32; 3=48.
+	data32 |= ctrl_ahb_wr_burst_size    <<
+		  4;   // [ 5: 4] ctrl_ahb_wr_burst_size. 0=16; 1=24; 2=32; 3=48.
+	data32 |= ctrl_ahb_rd_burst_size    <<
+		  2;   // [ 3: 2] ctrl_ahb_rd_burst_size. 0=16; 1=24; 2=32; 3=48.
 	data32 |= 0                         << 1;   // [    1] ctrl_sw_reset.
 	data32 |= 0                         << 0;   // [    0] ctrl_free_clk_enable.
 	aml_write_reg32(P_RDMA_CTRL, data32);
 
 	data32  = aml_read_reg32(P_RDMA_ACCESS_AUTO);
-	data32 |= 0x1 << intr_bit;   // [23: 16] interrupt inputs enable mask for auto-start 1: vsync int bit 0
-	data32 |= 1 << rw_bit;   // [    6] ctrl_cbus_write_1. 1=Register write; 0=Register read.
-	data32 &= ~(1<<inc_bit);   // [    2] ctrl_cbus_addr_incr_1. 1=Incremental register access; 0=Non-incremental.
+	data32 |= 0x1 <<
+		  intr_bit;   // [23: 16] interrupt inputs enable mask for auto-start 1: vsync int bit 0
+	data32 |= 1 <<
+		  rw_bit;   // [    6] ctrl_cbus_write_1. 1=Register write; 0=Register read.
+	data32 &= ~(1 <<
+		    inc_bit); // [    2] ctrl_cbus_addr_incr_1. 1=Incremental register access; 0=Non-incremental.
 
 	aml_write_reg32(P_RDMA_ACCESS_AUTO, data32);
 	return 1;
@@ -166,50 +214,79 @@ static int start_osd_rdma(char channel)
 
 static int stop_rdma(char channel)
 {
-	char intr_bit=8*channel;
+	char intr_bit = 8 * channel;
 	u32 data32 = 0x0;
 
 	data32  = aml_read_reg32(P_RDMA_ACCESS_AUTO);
-	data32 &= ~(0x1 << intr_bit);   // [23: 16] interrupt inputs enable mask for auto-start 1: vsync int bit 0
+	data32 &= ~(0x1 <<
+		    intr_bit);   // [23: 16] interrupt inputs enable mask for auto-start 1: vsync int bit 0
 	aml_write_reg32(P_RDMA_ACCESS_AUTO, data32);
 	return 0;
 }
 
+int read_rdma_table(void)
+{
+	int rdma_count = 0;
+
+	if (rdma_debug) {
+		for (rdma_count = 0; rdma_count < item_count; rdma_count++)
+			printk("rdma_table addr is 0x%x, value is 0x%x\n", rdma_table[rdma_count].addr,
+			       rdma_table[rdma_count].val);
+	}
+	return 0;
+}
+EXPORT_SYMBOL(read_rdma_table);
+
 int reset_rdma(void)
 {
-	item_count=0;
-	aml_write_reg32(END_ADDR,(table_paddr + item_count*8-1));
-	//start_rdma(RDMA_CHANNEL_INDEX);
+	//reset mechanism , to clear rdma status.
+	if (OSD_RDMA_STAUS_IS_DONE) { //check if it is OSD rdma completed.
+		OSD_RDMA_STAUS_CLEAR_DONE;
+		//check if no cpu write request since the latest hw rdma op.
+		if (!OSD_RDMA_STAUS_IS_DIRTY) { //since last HW op,no new wirte request. rdma HW op will clear DIRTY flag.
+			//reset all pointer. set table start margin.
+			reset_rdma_table();
+		}
+	}
 	return 0;
 }
 EXPORT_SYMBOL(reset_rdma);
 
 int osd_rdma_enable(u32  enable)
 {
-	if (!osd_rdma_init_flat){
+	if (!osd_rdma_init_flat)
 		osd_rdma_init();
+	mutex_lock(&rdma_mutex);
+	if (enable == rdma_enable) {
+		mutex_unlock(&rdma_mutex);
+		return 0;
 	}
-
-	if(enable == rdma_enable) return 0;
 	rdma_enable = enable;
-	if(enable){
-		aml_write_reg32(START_ADDR,table_paddr);
+	while (aml_read_reg32(P_RDMA_STATUS) & 0x0fffff0f) {
+		printk("rdma still work RDMA_STATUS: 0x%x\n",
+				aml_read_reg32(P_RDMA_STATUS));
+		msleep(10);
+	}
+	if (enable) {
+		reset_rdma_table();
+		aml_write_reg32(START_ADDR, table_paddr);
 		//enable then start it.
-		reset_rdma();
+		OSD_RDMA_STATUS_CLEAR_ALL;
 		start_osd_rdma(RDMA_CHANNEL_INDEX);
-	}else{
+	} else
 		stop_rdma(RDMA_CHANNEL_INDEX);
-	}
+	mutex_unlock(&rdma_mutex);
 	return 1;
 }
 EXPORT_SYMBOL(osd_rdma_enable);
 
-static int  osd_rdma_init(void)
+static int osd_rdma_init(void)
 {
 	// alloc map table .
-	static ulong table_vaddr;
+	static ulong table_vaddr = 0;
 	osd_rdma_init_flat = true;
-	table_vaddr= __get_free_pages(GFP_KERNEL, get_order(PAGE_SIZE));
+
+	table_vaddr = __get_free_pages(GFP_KERNEL, get_order(PAGE_SIZE));
 	if (!table_vaddr) {
 		printk("%s: failed to alloc rmda_table\n", __func__);
 		return -1;
@@ -217,9 +294,8 @@ static int  osd_rdma_init(void)
 
 	table_paddr = virt_to_phys((u8 *)table_vaddr);
 	//remap addr nocache.
-	rdma_table=(rdma_table_item_t*) ioremap_nocache(table_paddr, PAGE_SIZE);
-
-	if (NULL==rdma_table) {
+	rdma_table = (rdma_table_item_t *) ioremap_nocache(table_paddr, PAGE_SIZE);
+	if (NULL == rdma_table) {
 		printk("%s: failed to remap rmda_table_addr\n", __func__);
 		return -1;
 	}
@@ -233,3 +309,5 @@ module_param(item_count, uint, 0664);
 MODULE_PARM_DESC(table_paddr, "\n table_paddr\n");
 module_param(table_paddr, uint, 0664);
 
+MODULE_PARM_DESC(rdma_debug, "\n rdma_debug\n");
+module_param(rdma_debug, uint, 0664);
diff --git a/drivers/amlogic/display/osd/osd_rdma.h b/drivers/amlogic/display/osd/osd_rdma.h
old mode 100644
new mode 100755
index 40919e7e..0dea0e77
--- a/drivers/amlogic/display/osd/osd_rdma.h
+++ b/drivers/amlogic/display/osd/osd_rdma.h
@@ -1,4 +1,4 @@
-#ifndef  _OSD_RDMA_H 
+#ifndef  _OSD_RDMA_H
 #define _OSD_RDMA_H
 
 #include <linux/version.h>
@@ -23,15 +23,49 @@
 #include <linux/clk.h>
 #include <linux/amlogic/logo/logo.h>
 
-typedef  struct{
+typedef  struct {
 	u32  addr;
 	u32  val;
-}rdma_table_item_t;
+} rdma_table_item_t;
 
+//static DEFINE_SPINLOCK(rdma_lock);
 #define TABLE_SIZE	 PAGE_SIZE
 #define MAX_TABLE_ITEM	 (TABLE_SIZE/sizeof(rdma_table_item_t))
 #define RDMA_CHANNEL_INDEX	3  //auto  1,2,3   manual is 0
 #define START_ADDR		(P_RDMA_AHB_START_ADDR_MAN+(RDMA_CHANNEL_INDEX<<3))
 #define END_ADDR		(P_RDMA_AHB_END_ADDR_MAN+(RDMA_CHANNEL_INDEX<<3))
 
+#define OSD_RDMA_FLAG_REG	VIU_OSD2_TCOLOR_AG3
+#define P_OSD_RDMA_FLAG_REG	P_VIU_OSD2_TCOLOR_AG3
+
+#define OSD_RDMA_FLAG_DONE	(1<<0) //hw rdma change it to 1 when rdma complete, rdma isr chagne it to 0 to reset it.
+#define OSD_RDMA_FLAG_REJECT	(1<<1) //hw rdma own this flag, change it to zero when start rdma,change it to 0 when complete
+#define	OSD_RDMA_FLAG_DIRTY	(1<<2) //hw rdma change it to 0 , cpu write change it to 1
+
+#define OSD_RDMA_FLAGS_ALL_ENABLE	(OSD_RDMA_FLAG_DONE|OSD_RDMA_FLAG_REJECT|OSD_RDMA_FLAG_DIRTY)
+
+#define  OSD_RDMA_STATUS		(aml_read_reg32(P_OSD_RDMA_FLAG_REG)&(OSD_RDMA_FLAG_REJECT|OSD_RDMA_FLAG_DONE|OSD_RDMA_FLAG_DIRTY))
+#define  OSD_RDMA_STATUS_IS_REJECT 	(aml_read_reg32(P_OSD_RDMA_FLAG_REG)&OSD_RDMA_FLAG_REJECT)
+#define  OSD_RDMA_STAUS_IS_DIRTY	(aml_read_reg32(P_OSD_RDMA_FLAG_REG)&OSD_RDMA_FLAG_DIRTY)
+#define  OSD_RDMA_STAUS_IS_DONE		(aml_read_reg32(P_OSD_RDMA_FLAG_REG)&OSD_RDMA_FLAG_DONE)
+
+//hw rdma op, set DONE && clear DIRTY && clear REJECT
+#define  OSD_RDMA_STATUS_MARK_COMPLETE	((aml_read_reg32(P_OSD_RDMA_FLAG_REG)&~OSD_RDMA_FLAGS_ALL_ENABLE)|(OSD_RDMA_FLAG_DONE))
+//hw rdma op,set REJECT && set DIRTY.
+#define  OSD_RDMA_STATUS_MARK_TBL_RST	((aml_read_reg32(P_OSD_RDMA_FLAG_REG)&~OSD_RDMA_FLAGS_ALL_ENABLE)|(OSD_RDMA_FLAG_REJECT|OSD_RDMA_FLAG_DIRTY))
+
+//cpu op
+#define  OSD_RDMA_STAUS_MARK_DIRTY	(aml_write_reg32(P_OSD_RDMA_FLAG_REG,aml_read_reg32(P_OSD_RDMA_FLAG_REG)|OSD_RDMA_FLAG_DIRTY))
+//isr op
+#define  OSD_RDMA_STAUS_CLEAR_DONE	(aml_write_reg32(P_OSD_RDMA_FLAG_REG,aml_read_reg32(P_OSD_RDMA_FLAG_REG)&~(OSD_RDMA_FLAG_DONE)))
+//cpu reset op.
+#define  OSD_RDMA_STATUS_CLEAR_ALL	(aml_write_reg32(P_OSD_RDMA_FLAG_REG,(aml_read_reg32(P_OSD_RDMA_FLAG_REG)&~OSD_RDMA_FLAGS_ALL_ENABLE)))
+
+//time diagram:
+/*
+** CLEAR: from rdma hw op complete  to the next cpu write .
+** REJECT: from rdma hw op start to rdma hw op complete.
+** DONE:  from rdma hw op complete to the next osd RDMA ISR
+*/
+
 #endif
diff --git a/drivers/amlogic/display/osd/osd_sync.h b/drivers/amlogic/display/osd/osd_sync.h
new file mode 100644
index 00000000..9a013be7
--- /dev/null
+++ b/drivers/amlogic/display/osd/osd_sync.h
@@ -0,0 +1,17 @@
+#ifndef   _OSD_SYNC_H
+#define _OSD_SYNC_H
+#include  <sw_sync.h>
+#include  <sync.h>
+
+typedef  struct{
+	unsigned int  xoffset;
+	unsigned int  yoffset;
+	int  in_fen_fd;
+	int  out_fen_fd;
+}fb_sync_request_t;
+
+typedef  struct{
+	struct sw_sync_timeline  *timeline;
+}osd_sync_obj;
+
+#endif
diff --git a/drivers/amlogic/display/osd_ext/Makefile b/drivers/amlogic/display/osd_ext/Makefile
index cf8a4c55..8936e3fc 100755
--- a/drivers/amlogic/display/osd_ext/Makefile
+++ b/drivers/amlogic/display/osd_ext/Makefile
@@ -12,3 +12,4 @@ endif
 
 EXTRA_CFLAGS += -Iinclude/linux/osd/
 EXTRA_CFLAGS += -Iinclude/linux/ge2d/
+EXTRA_CFLAGS += -Idrivers/staging/android/
diff --git a/drivers/amlogic/display/osd_ext/aml.dtd b/drivers/amlogic/display/osd_ext/aml.dtd
index 36066a3b..8dbd24d2 100755
--- a/drivers/amlogic/display/osd_ext/aml.dtd
+++ b/drivers/amlogic/display/osd_ext/aml.dtd
@@ -9,6 +9,6 @@
 		status = "ok";
 		reserve-memory = <0x01800000 0x00100000>;
 		display_size_default = <2048 1536 2048 3072 32>;
-	 
+
 	};
 #endif
\ No newline at end of file
diff --git a/drivers/amlogic/display/osd_ext/osd_clone.c b/drivers/amlogic/display/osd_ext/osd_clone.c
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/display/osd_ext/osd_clone.h b/drivers/amlogic/display/osd_ext/osd_clone.h
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/display/osd_ext/osd_dev.c b/drivers/amlogic/display/osd_ext/osd_dev.c
old mode 100644
new mode 100755
index 63443a5c..b0a0c145
--- a/drivers/amlogic/display/osd_ext/osd_dev.c
+++ b/drivers/amlogic/display/osd_ext/osd_dev.c
@@ -207,6 +207,16 @@ void osddev_ext_set_window_axis(u32 index, s32 x0, s32 y0, s32 x1, s32 y1)
 	osd_ext_set_window_axis_hw(index - 2, x0, y0, x1, y1);
 }
 
+int osddev_ext_sync_request(struct fb_info * info, u32 xoffset, u32 yoffset, s32 in_fence_fd)
+{
+	return osd_ext_sync_request(info->node-2, info->var.yres, xoffset , yoffset, in_fence_fd);
+}
+
+int osddev_ext_wait_for_vsync(void)
+{
+	return osd_ext_wait_vsync_event();
+}
+
 void osddev_ext_get_osd_ext_info(u32 index, s32(*posdval)[4], u32(*posdreg)[5], s32 info_flag)
 {
 	osd_ext_get_osd_ext_info_hw(index - 2, posdval, posdreg, info_flag);
diff --git a/drivers/amlogic/display/osd_ext/osd_dev.h b/drivers/amlogic/display/osd_ext/osd_dev.h
old mode 100644
new mode 100755
index 4a6d8c72..3e9a700d
--- a/drivers/amlogic/display/osd_ext/osd_dev.h
+++ b/drivers/amlogic/display/osd_ext/osd_dev.h
@@ -86,6 +86,8 @@ extern void osddev_ext_get_free_scale_mode(u32 index, u32 *freescale_mode);
 extern void osddev_ext_free_scale_mode(u32 index ,u32 freescale_mode);
 extern void osddev_ext_get_window_axis(u32 index, s32 *x0, s32 *y0, s32 *x1, s32 *y1);
 extern void osddev_ext_set_window_axis(u32 index, s32 x0, s32 y0, s32 x1, s32 y1);
+extern int    osddev_ext_sync_request(struct fb_info * info, u32 xoffset, u32 yoffset, s32 in_fence_fd);
+extern int    osddev_ext_wait_for_vsync(void);
 extern void osddev_ext_get_osd_ext_info(u32 index, s32(*posdval)[4], u32(*posdreq)[5], s32 info_flag);
 extern void osddev_ext_get_block_windows(u32 index, u32 *windows);
 extern void osddev_ext_set_block_windows(u32 index, u32 *windows);
@@ -124,4 +126,3 @@ extern void osddev_ext_set_angle(u32 index, u32 angle);
 extern void osddev_ext_get_clone(u32 index, u32 *clone);
 extern void osddev_ext_set_clone(u32 index, u32 clone);
 #endif /* OSDFBDEV_H */
-
diff --git a/drivers/amlogic/display/osd_ext/osd_hw.c b/drivers/amlogic/display/osd_ext/osd_hw.c
old mode 100644
new mode 100755
index 1ef5209a..358b460b
--- a/drivers/amlogic/display/osd_ext/osd_hw.c
+++ b/drivers/amlogic/display/osd_ext/osd_hw.c
@@ -29,12 +29,18 @@
 #include <linux/irqreturn.h>
 #include <linux/errno.h>
 #include <linux/irq.h>
+#include <linux/file.h>
+#include <linux/fdtable.h>
 #include <linux/slab.h>
 #include <linux/interrupt.h>
+#include <linux/kthread.h>
 #include <linux/amlogic/amports/canvas.h>
+#include <sw_sync.h>
+#include <sync.h>
 #include <linux/amlogic/amlog.h>
 #include <linux/amlogic/amports/vframe_receiver.h>
 #include <linux/amlogic/osd/osd.h>
+#include <linux/amlogic/osd/osd_hw.h>
 #include <linux/amlogic/vout/vout_notify.h>
 #ifdef CONFIG_AML_VSYNC_FIQ_ENABLE
 #define FIQ_VSYNC
@@ -43,11 +49,27 @@
 #include "osd_hw_def.h"
 #include "osd_clone.h"
 #include "osd_prot.h"
+#include "osd_hw.h"
 
 static DECLARE_WAIT_QUEUE_HEAD(osd_ext_vsync_wq);
 static bool vsync_hit = false;
 static bool osd_ext_vf_need_update = false;
 
+#ifdef  CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
+//add sync fence relative varible here.
+//we will limit all fence relative code in this driver file.
+static int ext_timeline_created=0;
+static struct  sw_sync_timeline *ext_timeline;
+static u32 ext_cur_streamline_val;
+//thread control part
+struct kthread_worker ext_buffer_toggle_worker;
+struct task_struct *ext_buffer_toggle_thread;
+struct kthread_work ext_buffer_toggle_work;
+struct list_head	ext_post_fence_list;
+struct mutex		ext_post_fence_list_lock;
+
+void osd_ext_pan_display_fence(osd_ext_fence_map_t *fence_map);
+#endif
 static struct vframe_provider_s osd_ext_vf_prov;
 static int  g_vf_visual_width;
 static int  g_vf_width;
@@ -167,6 +189,170 @@ static unsigned int filt_coef2[] =  //2 point bilinear, bank_length == 2
 	0x40400000
 };
 
+/********************************************************************/
+/***********		osd fence relative code 	 			*****************/
+/********************************************************************/
+
+#ifdef  CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
+static inline int find_ext_buf_num(u32 yres,u32 yoffset)
+{
+	int n=yres;
+	int i;
+	for(i=0;i<MAX_BUF_NUM;i++)  //find current addr position.
+	{
+		if(yoffset  < (n))
+		break;
+		n+=yres;
+	}
+	return i;
+}
+
+//next we will process two osd layer in toggle buffer.
+static void osd_ext_toggle_buffer(struct kthread_work *work)
+{
+	osd_ext_fence_map_t *data, *next;
+	struct list_head saved_list;
+
+	mutex_lock(&ext_post_fence_list_lock);
+	saved_list = ext_post_fence_list;
+	list_replace_init(&ext_post_fence_list, &saved_list);
+	mutex_unlock(&ext_post_fence_list_lock);
+
+	list_for_each_entry_safe(data, next, &saved_list, list){
+		osd_ext_pan_display_fence(data);
+		if((data->in_fence) && (data->in_fd > 0)){
+			__close_fd(data->files, data->in_fd);
+			sync_fence_put(data->in_fence);
+		}
+		list_del(&data->list);
+		kfree(data);
+	}
+}
+
+static int out_ext_fence_create(int *release_fence_fd, u32 *val, u32 buf_num)
+{
+	//the first time create out_fence_fd==0
+	//sw_sync_timeline_inc  will release fence and it's sync point
+	struct sync_pt * outer_sync_pt;
+	struct sync_fence * outer_fence;
+	int out_fence_fd = -1;
+
+	out_fence_fd = get_unused_fd();
+	if(out_fence_fd < 0) return -1;//no file descriptor could be used. Error.
+	if(!ext_timeline_created)//timeline has not been created
+	{
+		ext_timeline = sw_sync_timeline_create("osd_ext_timeline");
+		ext_cur_streamline_val=1;
+		if(NULL==ext_timeline)
+		{
+			return -1;
+		}
+		init_kthread_worker(&ext_buffer_toggle_worker);
+		ext_buffer_toggle_thread= kthread_run(kthread_worker_fn,
+						&ext_buffer_toggle_worker, "aml_buf_ext_toggle");
+		init_kthread_work(&ext_buffer_toggle_work,osd_ext_toggle_buffer);
+		ext_timeline_created=1;
+	}
+	//install fence map; first ,the simplest.
+	ext_cur_streamline_val++;
+	*val=ext_cur_streamline_val;
+
+	outer_sync_pt=sw_sync_pt_create(ext_timeline,*val);
+	if(NULL == outer_sync_pt)
+	{
+		goto error_ret;
+	}
+
+	outer_fence=sync_fence_create("osd_ext_fence_out", outer_sync_pt);//fence object will be released when no point
+	if(NULL == outer_fence)
+	{
+		sync_pt_free(outer_sync_pt); //free sync point.
+		goto error_ret;
+	}
+
+	sync_fence_install(outer_fence,out_fence_fd);
+	amlog_mask_level(LOG_MASK_HARDWARE,LOG_LEVEL_LOW,"---------------------------------------\n");
+	amlog_mask_level(LOG_MASK_HARDWARE,LOG_LEVEL_LOW,"return out fence fd:%d\n",out_fence_fd);
+	*release_fence_fd = out_fence_fd;
+	return out_fence_fd;
+
+error_ret:
+	ext_cur_streamline_val--; //pt or fence fail,restore timeline value.
+	amlog_level(LOG_LEVEL_HIGH,"fence obj create fail\n");
+	put_unused_fd(out_fence_fd);
+	return -1;
+
+}
+
+int osd_ext_sync_request(u32 index, u32 yres, u32 xoffset,u32 yoffset,s32 in_fence_fd)
+{
+	int out_fence_fd = -1;
+	int buf_num = 0;
+
+	osd_ext_fence_map_t *fence_map = kzalloc(sizeof(osd_ext_fence_map_t), GFP_KERNEL);
+	buf_num = find_ext_buf_num(yres, yoffset);
+
+	if (!fence_map) {
+		printk("could not allocate osd_ext_fence_map\n");
+		return -ENOMEM;
+	}
+
+	mutex_lock(&ext_post_fence_list_lock);
+	fence_map->fb_index = index;
+	fence_map->buf_num = buf_num;
+	fence_map->yoffset = yoffset;
+	fence_map->xoffset = xoffset;
+	fence_map->yres = yres;
+	fence_map->in_fd = in_fence_fd;
+	fence_map->in_fence = sync_fence_fdget(in_fence_fd);
+	fence_map->files = current->files;
+
+	fence_map->out_fd = out_ext_fence_create(&out_fence_fd, &fence_map->val, buf_num);
+	list_add_tail(&fence_map->list, &ext_post_fence_list);
+	mutex_unlock(&ext_post_fence_list_lock);
+
+	queue_kthread_work(&ext_buffer_toggle_worker, &ext_buffer_toggle_work);
+
+	return  out_fence_fd;
+}
+
+static int  osd_ext_wait_buf_ready(osd_ext_fence_map_t *fence_map)
+{
+	s32 ret=-1;
+	struct sync_fence *buf_ready_fence = NULL;
+
+	if(fence_map->in_fd <= 0)
+	{
+		ret =-1;
+		return ret;
+	}
+
+	buf_ready_fence = fence_map->in_fence;
+	if(NULL == buf_ready_fence)
+	{
+		ret = -1;//no fence ,output directly.
+		return ret;
+	}
+
+	ret=sync_fence_wait(buf_ready_fence, -1);
+	if(ret < 0){
+		amlog_level(LOG_LEVEL_HIGH,"Sync Fence wait error:%d\n",ret);
+		printk("-----wait buf idx:[%d] ERROR\n-----on screen buf idx:[%d]\n",fence_map->buf_num, find_ext_buf_num(fence_map->yres, osd_ext_hw.pandata[fence_map->fb_index].y_start));
+	}else{
+		ret=1;
+	}
+
+	return ret;
+}
+
+#else
+int osd_ext_sync_request(u32 index, u32 yres,u32 xoffset, u32 yoffset,s32 in_fence_fd)
+{
+	amlog_level(LOG_LEVEL_HIGH,"osd_ext_sync_request not supported\n");
+	return -5566;
+}
+#endif
+
 /********************************************************************/
 /***********		osd psedu frame provider 			*****************/
 /********************************************************************/
@@ -204,7 +390,7 @@ static inline void osd_ext_update_3d_mode(int enable_osd1, int enable_osd2)
 	}
 }
 
-static inline void wait_vsync_wakeup(void)
+static inline void wait_ext_vsync_wakeup(void)
 {
 	vsync_hit = true;
 	wake_up_interruptible(&osd_ext_vsync_wq);
@@ -231,7 +417,7 @@ static inline void walk_through_update_list(void)
 #ifdef FIQ_VSYNC
 static irqreturn_t vsync_isr(int irq, void *dev_id)
 {
-	wait_vsync_wakeup();
+	wait_ext_vsync_wakeup();
 
 	return IRQ_HANDLED;
 }
@@ -258,7 +444,7 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 		aml_write_reg32(P_VPU_PROT1_Y_START_END, data32);
 	}
 #endif
-	output_type=aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)&0x3;
+	output_type=aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)&0xc;
 	osd_ext_hw.scan_mode= SCAN_MODE_PROGRESSIVE;
 	switch(output_type)
 	{
@@ -330,7 +516,7 @@ static irqreturn_t vsync_isr(int irq, void *dev_id)
 #ifdef FIQ_VSYNC
 		fiq_bridge_pulse_trigger(&osd_ext_hw.fiq_handle_item);
 #else
-		wait_vsync_wakeup();
+		wait_ext_vsync_wakeup();
 #endif
 	}
 #ifndef FIQ_VSYNC
@@ -345,6 +531,13 @@ void osd_ext_wait_vsync_hw(void)
 	wait_event_interruptible_timeout(osd_ext_vsync_wq, vsync_hit, HZ);
 }
 
+s32 osd_ext_wait_vsync_event(void)
+{
+	vsync_hit = false;
+	wait_event_interruptible_timeout(osd_ext_vsync_wq, vsync_hit, 1); //waiting for 10ms.
+	return 0;
+}
+
 void osd_ext_set_gbl_alpha_hw(u32 index, u32 gbl_alpha)
 {
 	if (osd_ext_hw.gbl_alpha[index] != gbl_alpha) {
@@ -398,7 +591,7 @@ void osd_ext_set_colorkey_hw(u32 index, u32 color_index, u32 colorkey)
 	data32 = r << 24 | g << 16 | b << 8 | a;
 	if (osd_ext_hw.color_key[index] != data32) {
 		osd_ext_hw.color_key[index] = data32;
-		amlog_mask_level(LOG_MASK_HARDWARE, LOG_LEVEL_LOW, "bpp:%d--r:0x%x g:0x%x b:0x%x ,a:0x%x\r\n",
+		amlog_mask_level(LOG_MASK_HARDWARE, LOG_LEVEL_LOW, "bpp:%d--r:0x%x g:0x%x b:0x%x ,a:0x%x\n",
 				 color_index, r, g, b, a);
 		add_to_update_list(index, OSD_COLOR_KEY);
 
@@ -591,6 +784,14 @@ void osd_ext_change_osd_ext_order_hw(u32 index, u32 order)
 	osd_ext_wait_vsync_hw();
 }
 
+void osd_ext_enable_hw(int enable, int index)
+{
+	osd_ext_hw.enable[index] = enable;
+	add_to_update_list(index, OSD_ENABLE);
+
+	osd_ext_wait_vsync_hw();
+}
+
 void osd_ext_free_scale_enable_hw(u32 index, u32 enable)
 {
 	if (osd_ext_hw.free_scale_mode[index]){
@@ -647,7 +848,7 @@ void osd_ext_free_scale_enable_hw(u32 index, u32 enable)
 #endif
 #endif
 
-	amlog_level(LOG_LEVEL_HIGH, "osd%d free scale %s\r\n", index, enable ? "ENABLE" : "DISABLE");
+	amlog_level(LOG_LEVEL_HIGH, "osd%d free scale %s\n", index, enable ? "ENABLE" : "DISABLE");
 	osd_ext_hw.free_scale_enable[index] = enable;
 	if (index == OSD1) {
 		if (enable) {
@@ -866,40 +1067,9 @@ void osd_ext_set_block_mode_hw(u32 index, u32 mode)
 	osd_ext_wait_vsync_hw();
 }
 
-void osd_ext_enable_3d_mode_hw(int index, int enable)
-{
-	spin_lock_irqsave(&osd_ext_lock, lock_flags);
-	osd_ext_hw.mode_3d[index].enable = enable;
-	spin_unlock_irqrestore(&osd_ext_lock, lock_flags);
-	if (enable)		//when disable 3d mode ,we should return to stardard state.
-	{
-		osd_ext_hw.mode_3d[index].left_right = LEFT;
-		osd_ext_hw.mode_3d[index].l_start = osd_ext_hw.pandata[index].x_start;
-		osd_ext_hw.mode_3d[index].l_end =
-		    (osd_ext_hw.pandata[index].x_end + osd_ext_hw.pandata[index].x_start) >> 1;
-		osd_ext_hw.mode_3d[index].r_start = osd_ext_hw.mode_3d[index].l_end + 1;
-		osd_ext_hw.mode_3d[index].r_end = osd_ext_hw.pandata[index].x_end;
-		osd_ext_hw.mode_3d[index].origin_scale.h_enable = osd_ext_hw.scale[index].h_enable;
-		osd_ext_hw.mode_3d[index].origin_scale.v_enable = osd_ext_hw.scale[index].v_enable;
-		osd_ext_set_2x_scale_hw(index, 1, 0);
-	} else {
-
-		osd_ext_set_2x_scale_hw(index, osd_ext_hw.mode_3d[index].origin_scale.h_enable,
-					osd_ext_hw.mode_3d[index].origin_scale.v_enable);
-	}
-}
-
-void osd_ext_enable_hw(int enable, int index)
-{
-	osd_ext_hw.enable[index] = enable;
-	add_to_update_list(index, OSD_ENABLE);
-
-	osd_ext_wait_vsync_hw();
-}
-
 void osd_ext_set_2x_scale_hw(u32 index, u16 h_scale_enable, u16 v_scale_enable)
 {
-	amlog_level(LOG_LEVEL_HIGH, "osd[%d] set scale, h_scale: %s, v_scale: %s\r\n",
+	amlog_level(LOG_LEVEL_HIGH, "osd[%d] set scale, h_scale: %s, v_scale: %s\n",
 		    index, h_scale_enable ? "ENABLE" : "DISABLE", v_scale_enable ? "ENABLE" : "DISABLE");
 	amlog_level(LOG_LEVEL_HIGH, "osd[%d].scaledata: %d %d %d %d\n",
 		    index,
@@ -922,6 +1092,29 @@ void osd_ext_set_2x_scale_hw(u32 index, u16 h_scale_enable, u16 v_scale_enable)
 	osd_ext_wait_vsync_hw();
 }
 
+void osd_ext_enable_3d_mode_hw(int index, int enable)
+{
+	spin_lock_irqsave(&osd_ext_lock, lock_flags);
+	osd_ext_hw.mode_3d[index].enable = enable;
+	spin_unlock_irqrestore(&osd_ext_lock, lock_flags);
+	if (enable)		//when disable 3d mode ,we should return to stardard state.
+	{
+		osd_ext_hw.mode_3d[index].left_right = LEFT;
+		osd_ext_hw.mode_3d[index].l_start = osd_ext_hw.pandata[index].x_start;
+		osd_ext_hw.mode_3d[index].l_end =
+		    (osd_ext_hw.pandata[index].x_end + osd_ext_hw.pandata[index].x_start) >> 1;
+		osd_ext_hw.mode_3d[index].r_start = osd_ext_hw.mode_3d[index].l_end + 1;
+		osd_ext_hw.mode_3d[index].r_end = osd_ext_hw.pandata[index].x_end;
+		osd_ext_hw.mode_3d[index].origin_scale.h_enable = osd_ext_hw.scale[index].h_enable;
+		osd_ext_hw.mode_3d[index].origin_scale.v_enable = osd_ext_hw.scale[index].v_enable;
+		osd_ext_set_2x_scale_hw(index, 1, 0);
+	} else {
+
+		osd_ext_set_2x_scale_hw(index, osd_ext_hw.mode_3d[index].origin_scale.h_enable,
+					osd_ext_hw.mode_3d[index].origin_scale.v_enable);
+	}
+}
+
 void osd_ext_set_osd_ext_rotate_angle_hw(u32 index, u32 angle)
 {
 	osd_ext_hw.rotate[index].angle = angle;
@@ -1008,6 +1201,56 @@ void osd_ext_get_prot_canvas_hw(u32 index, s32 *x_start, s32 *y_start, s32 *x_en
 	*y_end = osd_ext_hw.rotation_pandata[index].y_end;
 }
 
+#ifdef  CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
+void osd_ext_pan_display_fence(osd_ext_fence_map_t *fence_map)
+{
+	s32 ret = 1;
+	long diff_x, diff_y;
+	u32 index = fence_map->fb_index;
+	u32 xoffset = fence_map->xoffset;
+	u32 yoffset = fence_map->yoffset;
+
+	if (index >= 2)
+		return;
+
+	if(ext_timeline_created) //out fence created success.
+	{
+		ret = osd_ext_wait_buf_ready(fence_map);
+		if(ret < 0)
+		{
+			amlog_mask_level(LOG_MASK_HARDWARE,LOG_LEVEL_LOW,"fence wait ret %d\n",ret);
+		}
+	}
+
+	if(ret){
+		if(xoffset!=osd_ext_hw.pandata[index].x_start || yoffset !=osd_ext_hw.pandata[index].y_start)
+		{
+			diff_x = xoffset - osd_ext_hw.pandata[index].x_start;
+			diff_y = yoffset - osd_ext_hw.pandata[index].y_start;
+
+			osd_ext_hw.pandata[index].x_start += diff_x;
+			osd_ext_hw.pandata[index].x_end   += diff_x;
+			osd_ext_hw.pandata[index].y_start += diff_y;
+			osd_ext_hw.pandata[index].y_end   += diff_y;
+			add_to_update_list(index, DISP_GEOMETRY);
+			osd_ext_wait_vsync_hw();
+		}
+	}
+
+	if(ext_timeline_created){
+		if(ret){
+			sw_sync_timeline_inc(ext_timeline, 1);
+		}else{
+			printk("------NOT signal out_fence ERROR\n");
+		}
+	}
+
+	amlog_mask_level(LOG_MASK_HARDWARE,LOG_LEVEL_LOW,"offset[%d-%d]x[%d-%d]y[%d-%d]\n", \
+			xoffset,yoffset,osd_ext_hw.pandata[index].x_start ,osd_ext_hw.pandata[index].x_end , \
+			osd_ext_hw.pandata[index].y_start ,osd_ext_hw.pandata[index].y_end);
+}
+#endif
+
 void osd_ext_pan_display_hw(unsigned int xoffset, unsigned int yoffset, int index)
 {
 	long diff_x, diff_y;
@@ -1154,15 +1397,16 @@ static  void  osd1_update_disp_freescale_enable(void)
 
 static void osd1_update_coef(void)
 {
+	int hf_coef_idx = 0;
 	int vf_coef_idx = 0;
-	int *vf_coef;
+	int *hf_coef, *vf_coef;
+
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	int i;
-	int hf_coef_idx = 0;
+	int i = 0;
 	int hf_coef_wren = 1;
 	int vf_coef_wren = 1;
-	int *hf_coef;
 #endif
+
 	if (vf_coef_idx == 0){
 		vf_coef = filt_coef0;
 	}else if (vf_coef_idx == 1){
@@ -1173,15 +1417,6 @@ static void osd1_update_coef(void)
 		vf_coef = filt_coef0;
 	}
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	if (vf_coef_wren) {
-		aml_set_reg32_bits(P_VPP2_OSD_SCALE_COEF_IDX, 0x0000, 0, 9);
-		for (i = 0; i < 33; i++)
-		{
-			aml_write_reg32(P_VPP2_OSD_SCALE_COEF, vf_coef[i]);
-		}
-	}
-
 	if (hf_coef_idx == 0){
 		hf_coef = filt_coef0;
 	}else if (hf_coef_idx == 1){
@@ -1192,6 +1427,15 @@ static void osd1_update_coef(void)
 		hf_coef = filt_coef0;
 	}
 
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	if (vf_coef_wren) {
+		aml_set_reg32_bits(P_VPP2_OSD_SCALE_COEF_IDX, 0x0000, 0, 9);
+		for (i = 0; i < 33; i++)
+		{
+			aml_write_reg32(P_VPP2_OSD_SCALE_COEF, vf_coef[i]);
+		}
+	}
+
 	if (hf_coef_wren) {
 		aml_set_reg32_bits(P_VPP2_OSD_SCALE_COEF_IDX, 0x0100, 0, 9);
 		for (i = 0; i < 33; i++)
@@ -1279,16 +1523,16 @@ static  void  osd2_update_disp_freescale_enable(void)
 
 static void osd2_update_coef(void)
 {
+	int hf_coef_idx = 0;
 	int vf_coef_idx = 0;
-	int  *vf_coef;
+	int *hf_coef, *vf_coef;
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	int i;
-	int hf_coef_idx = 0;
-	int vf_coef_wren = 1;
+	int i = 0;
 	int hf_coef_wren = 1;
-	int *hf_coef;
+	int vf_coef_wren = 1;
 #endif
+
 	if (vf_coef_idx == 0){
 		vf_coef = filt_coef0;
 	}else if (vf_coef_idx == 1){
@@ -1299,15 +1543,6 @@ static void osd2_update_coef(void)
 		vf_coef = filt_coef0;
 	}
 
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	if (vf_coef_wren) {
-		aml_set_reg32_bits (P_VPP2_OSD_SCALE_COEF_IDX, 0x0000, 0, 9);
-		for (i = 0; i < 33; i++)
-		{
-			aml_write_reg32(P_VPP2_OSD_SCALE_COEF, vf_coef[i]);
-		}
-	}
-
 	if (hf_coef_idx == 0){
 		hf_coef = filt_coef0;
 	}else if (hf_coef_idx == 1){
@@ -1318,6 +1553,15 @@ static void osd2_update_coef(void)
 		hf_coef = filt_coef0;
 	}
 
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+	if (vf_coef_wren) {
+		aml_set_reg32_bits (P_VPP2_OSD_SCALE_COEF_IDX, 0x0000, 0, 9);
+		for (i = 0; i < 33; i++)
+		{
+			aml_write_reg32(P_VPP2_OSD_SCALE_COEF, vf_coef[i]);
+		}
+	}
+
 	if (hf_coef_wren) {
 		aml_set_reg32_bits (P_VPP2_OSD_SCALE_COEF_IDX, 0x0100, 0, 9);
 		for (i = 0; i < 33; i++)
@@ -2024,7 +2268,12 @@ void osd_ext_init_hw(u32 logo_loaded)
 	osd_ext_hw.block_mode[OSD1] = osd_ext_hw.block_mode[OSD2] = 0;
 	osd_ext_hw.rotation_pandata[OSD1].x_start = osd_ext_hw.rotation_pandata[OSD1].y_start = 0;
 	osd_ext_hw.rotation_pandata[OSD2].x_start = osd_ext_hw.rotation_pandata[OSD2].y_start = 0;
-	memset(osd_ext_hw.rotate,0,sizeof(osd_rotate_t));
+	memset(osd_ext_hw.rotate,0,sizeof(osd_ext_rotate_t));
+
+#ifdef  CONFIG_FB_OSD_SUPPORT_SYNC_FENCE
+	INIT_LIST_HEAD(&ext_post_fence_list);
+	mutex_init(&ext_post_fence_list_lock);
+#endif
 
 #ifdef FIQ_VSYNC
 	osd_ext_hw.fiq_handle_item.handle = vsync_isr;
@@ -2035,7 +2284,7 @@ void osd_ext_init_hw(u32 logo_loaded)
 	if (request_irq(INT_VIU2_VSYNC, &vsync_isr, IRQF_SHARED, "am_osd_ext_vsync", osd_ext_setup))
 #endif
 	{
-		amlog_level(LOG_LEVEL_HIGH, "can't request irq for vsync\r\n");
+		amlog_level(LOG_LEVEL_HIGH, "can't request irq for vsync\n");
 	}
 #ifdef FIQ_VSYNC
 	request_fiq(INT_VIU2_VSYNC, &osd_ext_fiq_isr);
@@ -2227,7 +2476,7 @@ void osd_ext_set_angle_hw(u32 index, u32 angle)
 		osd_ext_clone_pan(index);
 	}
 }
-	
+
 void osd_ext_get_clone_hw(u32 index, u32 * clone)
 {
 	amlog_level(LOG_LEVEL_HIGH, "get osd_ext[%d]->clone: %d\n", index, osd_ext_hw.clone[index]);
diff --git a/drivers/amlogic/display/osd_ext/osd_hw.h b/drivers/amlogic/display/osd_ext/osd_hw.h
old mode 100644
new mode 100755
index 627248a9..16f7a47c
--- a/drivers/amlogic/display/osd_ext/osd_hw.h
+++ b/drivers/amlogic/display/osd_ext/osd_hw.h
@@ -105,6 +105,8 @@ extern void osd_ext_set_prot_canvas_hw(u32 index, s32 x_start, s32 y_start, s32
 extern void osd_ext_setpal_hw(unsigned regno, unsigned red, unsigned green, unsigned blue, unsigned transp, int index);
 extern void osd_ext_enable_hw(int enable, int index);
 extern void osd_ext_pan_display_hw(unsigned int xoffset, unsigned int yoffset, int index);
+extern int    osd_ext_sync_request(u32 index, u32 yres,u32 xoffset ,u32 yoffset,s32 in_fence_fd);
+extern s32  osd_ext_wait_vsync_event(void);
 #if defined(CONFIG_FB_OSD2_CURSOR)
 extern void osd_ext_cursor_hw(s16 x, s16 y, s16 xstart, s16 ystart, u32 osd_ext_w, u32 osd_ext_h, int index);
 #endif
diff --git a/drivers/amlogic/display/osd_ext/osd_hw_def.h b/drivers/amlogic/display/osd_ext/osd_hw_def.h
old mode 100644
new mode 100755
index 156d9c21..7abda53b
--- a/drivers/amlogic/display/osd_ext/osd_hw_def.h
+++ b/drivers/amlogic/display/osd_ext/osd_hw_def.h
@@ -9,6 +9,9 @@
 **	macro  define  part
 **
 **************************************************************************/
+
+#define MAX_BUF_NUM	 3  /*fence relative*/
+
 #define	LEFT		0
 #define	RIGHT		1
 #define	OSD_RELATIVE_BITS               0x333f0
@@ -81,14 +84,14 @@ typedef void (*update_func_t)(void);
 typedef struct {
 	struct list_head list;
 	update_func_t update_func;  //each reg group has it's own update function.
-} hw_list_t;
+} hw_ext_list_t;
 
 typedef struct {
 	u32 width;  //in byte unit
 	u32	height;
 	u32 canvas_idx;
 	u32	addr;
-} fb_geometry_t;
+} fb_ext_geometry_t;
 
 typedef struct {
 	u16	h_enable;
@@ -113,7 +116,22 @@ typedef struct {
 typedef struct{
 	u32  on_off;
 	u32  angle;
-}osd_rotate_t;
+}osd_ext_rotate_t;
+
+typedef struct {
+	struct list_head list;
+
+	u32  fb_index;
+	u32  buf_num;
+	u32  xoffset;
+	u32  yoffset;
+	u32  yres;
+	s32  in_fd;
+	s32  out_fd;
+	u32  val;
+	struct sync_fence *in_fence;
+	struct files_struct * files;
+}osd_ext_fence_map_t;
 
 typedef pandata_t dispdata_t;
 
@@ -134,7 +152,7 @@ typedef struct {
 	u32             free_scale_enable[HW_OSD_COUNT];
 	u32             free_scale_width[HW_OSD_COUNT];
 	u32             free_scale_height[HW_OSD_COUNT];
-	fb_geometry_t   fb_gem[HW_OSD_COUNT];
+	fb_ext_geometry_t   fb_gem[HW_OSD_COUNT];
 	const color_bit_define_t *color_info[HW_OSD_COUNT];
 	u32             scan_mode;
 	u32             osd_ext_order;
@@ -144,12 +162,12 @@ typedef struct {
 	u32             block_mode[HW_OSD_COUNT];
 	u32		free_scale_mode[HW_OSD_COUNT];
 	u32		osd_reverse[HW_OSD_COUNT];
-	osd_rotate_t	rotate[HW_OSD_COUNT];
+	osd_ext_rotate_t	rotate[HW_OSD_COUNT];
 	pandata_t		rotation_pandata[HW_OSD_COUNT];
-	hw_list_t       reg[HW_OSD_COUNT][HW_REG_INDEX_MAX];
+	hw_ext_list_t       reg[HW_OSD_COUNT][HW_REG_INDEX_MAX];
 	u32             clone[HW_OSD_COUNT];
 	u32             angle[HW_OSD_COUNT];
-} hw_para_t;
+} hw_para_ext_t;
 
 /************************************************************************
 **
@@ -188,7 +206,7 @@ static void osd2_update_disp_3d_mode(void);
 **
 **************************************************************************/
 static DEFINE_SPINLOCK(osd_ext_lock);
-static hw_para_t osd_ext_hw;
+static hw_para_ext_t osd_ext_hw;
 static unsigned long lock_flags;
 #ifdef FIQ_VSYNC
 static unsigned long fiq_flag;
diff --git a/drivers/amlogic/display/osd_ext/osd_log.h b/drivers/amlogic/display/osd_ext/osd_log.h
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/display/osd_ext/osd_main.c b/drivers/amlogic/display/osd_ext/osd_main.c
old mode 100644
new mode 100755
index c9b442e6..d7de555e
--- a/drivers/amlogic/display/osd_ext/osd_main.c
+++ b/drivers/amlogic/display/osd_ext/osd_main.c
@@ -46,6 +46,7 @@
 #include <asm/uaccess.h>
 #include "osd_log.h"
 #include "osd_main.h"
+#include "osd_sync.h"
 #include "osd_dev.h"
 #include <linux/amlogic/amlog.h>
 #ifdef CONFIG_HAS_EARLYSUSPEND
@@ -100,7 +101,7 @@ _find_color_format(struct fb_var_screeninfo * var)
 	//if not provide color component length then we find the first depth match.
 	if ((var->red.length == 0) || (var->green.length == 0) || (var->blue.length == 0) ||
 	    var->bits_per_pixel != (var->red.length + var->green.length + var->blue.length + var->transp.length)) {
-		amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "not provide color component length,use default color \n");
+		amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "not provide color component length,use default color\n");
 		ret = &default_color_format_array[upper_margin];
 	} else {
 		for (i = upper_margin; i >= lower_margin; i--) {
@@ -141,7 +142,7 @@ osd_ext_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 	if (color_format_pt == NULL || color_format_pt->color_index == 0) {
 		return -EFAULT ;
 	}
-	amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "select color format :index%d,bpp %d\r\n", color_format_pt->color_index, \
+	amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "select color format :index%d,bpp %d\n", color_format_pt->color_index, \
 	                 color_format_pt->bpp) ;
 	fbdev->color = color_format_pt ;
 	var->red.offset = color_format_pt->red_offset;
@@ -167,7 +168,7 @@ osd_ext_check_var(struct fb_var_screeninfo *var, struct fb_info *info)
 	//adjust memory length.
 	fix->line_length = var->xres_virtual * var->bits_per_pixel / 8;
 	if (var->xres_virtual * var->yres_virtual * var->bits_per_pixel / 8 > fbdev->fb_len) {
-		amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_HIGH, "no enough memory for %d*%d*%d\r\n", var->xres, var->yres, var->bits_per_pixel);
+		amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_HIGH, "no enough memory for %d*%d*%d\n", var->xres, var->yres, var->bits_per_pixel);
 		return  -ENOMEM;
 	}
 	if (var->xres_virtual < var->xres) {
@@ -267,6 +268,7 @@ osd_ext_ioctl(struct fb_info *info, unsigned int cmd,
 	u32 block_windows[8] = {0};
 	u32 block_mode;
 	unsigned long ret;
+	fb_ext_sync_request_t  sync_request;
 
 	switch (cmd) {
 	case  FBIOPUT_OSD_SRCKEY_ENABLE:
@@ -281,6 +283,11 @@ osd_ext_ioctl(struct fb_info *info, unsigned int cmd,
 	case FBIOPUT_OSD_SCALE_AXIS:
 		ret = copy_from_user(&osd_ext_axis, argp, 4 * sizeof(s32));
 		break;
+	case FBIOPUT_OSD_SYNC_ADD:
+		ret=copy_from_user(&sync_request,argp,sizeof(fb_ext_sync_request_t));
+		//printk("osd_mai request offset:%d\n", sync_request.offset);
+		break;
+	case FBIO_WAITFORVSYNC:
 	case FBIOGET_OSD_SCALE_AXIS:
 	case FBIOPUT_OSD_ORDER:
 	case FBIOGET_OSD_ORDER:
@@ -311,7 +318,7 @@ osd_ext_ioctl(struct fb_info *info, unsigned int cmd,
 		ret=copy_from_user(&osd_ext_dst_axis, argp, 4 * sizeof(s32));
 		break;
 	default :
-		amlog_mask_level(LOG_MASK_IOCTL, LOG_LEVEL_HIGH, "command not supported\r\n ");
+		amlog_mask_level(LOG_MASK_IOCTL, LOG_LEVEL_HIGH, "command not supported\n ");
 		return -1;
 	}
 	mutex_lock(&fbdev->lock);
@@ -356,7 +363,7 @@ osd_ext_ioctl(struct fb_info *info, unsigned int cmd,
 		case COLOR_INDEX_24_888_B:
 		case COLOR_INDEX_24_RGB:
 		case COLOR_INDEX_YUV_422:
-			amlog_mask_level(LOG_MASK_IOCTL, LOG_LEVEL_LOW, "set osd color key 0x%x\r\n", src_colorkey);
+			amlog_mask_level(LOG_MASK_IOCTL, LOG_LEVEL_LOW, "set osd color key 0x%x\n", src_colorkey);
 			fbdev->color_key = src_colorkey;
 			osddev_ext_set_colorkey(info->node, fbdev->color->color_index, src_colorkey);
 			break;
@@ -372,7 +379,7 @@ osd_ext_ioctl(struct fb_info *info, unsigned int cmd,
 		case COLOR_INDEX_24_888_B:
 		case COLOR_INDEX_24_RGB:
 		case COLOR_INDEX_YUV_422:
-			amlog_mask_level(LOG_MASK_IOCTL, LOG_LEVEL_LOW, "set osd color key %s\r\n", srckey_enable ? "enable" : "disable");
+			amlog_mask_level(LOG_MASK_IOCTL, LOG_LEVEL_LOW, "set osd color key %s\n", srckey_enable ? "enable" : "disable");
 			if (srckey_enable != 0) {
 				fbdev->enable_key_flag |= KEYCOLOR_FLAG_TARGET;
 				if (!(fbdev->enable_key_flag & KEYCOLOR_FLAG_ONHOLD)) {
@@ -431,6 +438,17 @@ osd_ext_ioctl(struct fb_info *info, unsigned int cmd,
 	case FBIOPUT_OSD_WINDOW_AXIS:
 		osddev_ext_set_window_axis(info->node, osd_ext_dst_axis[0], osd_ext_dst_axis[1], osd_ext_dst_axis[2], osd_ext_dst_axis[3]);
 		break;
+	case FBIOPUT_OSD_SYNC_ADD:
+		sync_request.out_fen_fd=osddev_ext_sync_request(info, sync_request.xoffset, sync_request.yoffset, sync_request.in_fen_fd);
+		ret=copy_to_user(argp, &sync_request, sizeof(fb_ext_sync_request_t));
+		if(sync_request.out_fen_fd < 0) // fence create fail.
+		ret=-1;
+		break;
+	case FBIO_WAITFORVSYNC:
+		osddev_ext_wait_for_vsync();
+		ret=1;
+		ret=copy_to_user(argp,&ret,sizeof(u32));
+		break;
 	default:
 		break;
 	}
@@ -458,7 +476,7 @@ static int osd_ext_pan_display(struct fb_var_screeninfo *var,
 {
 
 	osddev_ext_pan_display(var, fbi);
-	amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "osd_ext_pan_display:=>osd%d\r\n", fbi->node);
+	amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "osd_ext_pan_display:=>osd%d\n", fbi->node);
 	return 0;
 }
 
@@ -532,7 +550,7 @@ int osd_ext_notify_callback(struct notifier_block *block, unsigned long cmd , vo
 	disp_rect_t *disp_rect;
 
 	vinfo = get_current_vinfo2();
-	amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "tv_server:vmode=%s\r\n", vinfo->name);
+	amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "tv_server:vmode=%s\n", vinfo->name);
 
 	if(vinfo->mode == VMODE_INIT_NULL){
 		return 1;
@@ -540,7 +558,7 @@ int osd_ext_notify_callback(struct notifier_block *block, unsigned long cmd , vo
 
 	switch (cmd) {
 	case  VOUT_EVENT_MODE_CHANGE:
-		amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "recevie change mode  message \r\n");
+		amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "recevie change mode  message\n");
 		for (i = 0; i < OSD_COUNT; i++) {
 			if (NULL == (fb_dev = gp_fbdev_list[i])) {
 				continue;
@@ -576,7 +594,7 @@ int osd_ext_notify_callback(struct notifier_block *block, unsigned long cmd , vo
 			}
 			fb_dev->osd_ext_ctl.disp_start_x = disp_rect->x  ;
 			fb_dev->osd_ext_ctl.disp_start_y = disp_rect->y  ;
-			amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "set disp axis: x:%d y:%d w:%d h:%d\r\n"  , \
+			amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "set disp axis: x:%d y:%d w:%d h:%d\n"  , \
 			                 disp_rect->x, disp_rect->y, \
 			                 disp_rect->w, disp_rect->h);
 			if (disp_rect->x + disp_rect->w > vinfo->width) {
@@ -590,7 +608,7 @@ int osd_ext_notify_callback(struct notifier_block *block, unsigned long cmd , vo
 				fb_dev->osd_ext_ctl.disp_end_y = fb_dev->osd_ext_ctl.disp_start_y + disp_rect->h - 1 ;
 			}
 			disp_rect ++;
-			amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "new disp axis: startx:%d starty:%d endx:%d endy:%d\r\n"  , \
+			amlog_mask_level(LOG_MASK_PARA, LOG_LEVEL_LOW, "new disp axis: startx:%d starty:%d endx:%d endy:%d\n"  , \
 			                 fb_dev->osd_ext_ctl.disp_start_x, fb_dev->osd_ext_ctl.disp_start_y, \
 			                 fb_dev->osd_ext_ctl.disp_end_x, fb_dev->osd_ext_ctl.disp_end_y);
 			console_lock();
@@ -1354,7 +1372,7 @@ EXPORT_SYMBOL(osd_ext_resume_early);
 #endif
 
 static struct resource memobj;
-static int 
+static int
 osd_ext_probe(struct platform_device *pdev)
 {
 	int r,ret;
@@ -1373,7 +1391,6 @@ osd_ext_probe(struct platform_device *pdev)
 
 	if (NULL == init_logo_obj) {
 		set_current_vmode2(VMODE_INIT_NULL);
-		//set_current_vmode2(VMODE_LCD);
 		osddev_ext_init();
 	}
 	vinfo = get_current_vinfo2();
@@ -1383,21 +1400,8 @@ osd_ext_probe(struct platform_device *pdev)
 		printk("don't find need osd_ext memory from mesonfb_ext-dts\n");
 	}
 
-	for (index = 0; index < OSD_COUNT; index++) {
+	for (index = 0; index < OSD_COUNT; index++){
 		//platform resource
-#if 0
-		if (!(mem = platform_get_resource(pdev, IORESOURCE_MEM, index))) {
-			amlog_level(LOG_LEVEL_HIGH, "No frame buffer memory define.\n");
-			r = -EFAULT;
-			goto failed2;
-		}
-
-		//if we have no resource then no need to create this device.
-		amlog_level(LOG_LEVEL_HIGH, "[osd%d] 0x%x-0x%x\n", index+2, mem->start, mem->end);
-		if (!mem || mem->start == 0 || mem->end == 0 || mem->start == mem->end) {
-			continue ;
-		}
-#else
 		if(osd_ext_memory){
 			mem = &memobj;
 			ret = find_reserve_block(pdev->dev.of_node->name,index);
@@ -1409,7 +1413,7 @@ osd_ext_probe(struct platform_device *pdev)
 			mem->start = (phys_addr_t)get_reserve_block_addr(ret);
 			mem->end = mem->start+ (phys_addr_t)get_reserve_block_size(ret)-1;
 		}
-#endif
+
 		fbi = framebuffer_alloc(sizeof(struct myfb_dev), &pdev->dev);
 		if (!fbi) {
 			r = -ENOMEM;
@@ -1453,7 +1457,7 @@ osd_ext_probe(struct platform_device *pdev)
 			mydef_var[index].xres_virtual = init_logo_obj->dev->vinfo->width;
 			mydef_var[index].yres_virtual = init_logo_obj->dev->vinfo->height << 1; //logo always use double buffer
 			mydef_var[index].bits_per_pixel = bpp ;
-			amlog_level(LOG_LEVEL_HIGH, "init fbdev bpp is :%d\r\n", mydef_var[index].bits_per_pixel);
+			amlog_level(LOG_LEVEL_HIGH, "init fbdev bpp is :%d\n", mydef_var[index].bits_per_pixel);
 
 			if (mydef_var[index].bits_per_pixel > 32) {
 				mydef_var[index].bits_per_pixel = 32;
@@ -1472,7 +1476,7 @@ osd_ext_probe(struct platform_device *pdev)
 					mydef_var[index].yres_virtual=var_screeninfo[3];//logo always use double buffer
 					mydef_var[index].bits_per_pixel=bpp;
 
-					amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\r\n",mydef_var[index].bits_per_pixel);
+					amlog_level(LOG_LEVEL_HIGH,"init fbdev bpp is :%d\n",mydef_var[index].bits_per_pixel);
 					if(mydef_var[index].bits_per_pixel>32)
 					{
 						mydef_var[index].bits_per_pixel=32;
@@ -1480,7 +1484,7 @@ osd_ext_probe(struct platform_device *pdev)
 				}
 			}
 #if 0 //avoid clearing the mem of uboot osd1 logo
-			amlog_level(LOG_LEVEL_HIGH, "---------------clear framebuffer%d memory  \r\n", index + 2);
+			amlog_level(LOG_LEVEL_HIGH, "---------------clear framebuffer%d memory\n", index + 2);
 			memset((char*)fbdev->fb_mem_vaddr, 0x80, fbdev->fb_len);
 #endif
 		}
@@ -1539,7 +1543,7 @@ osd_ext_probe(struct platform_device *pdev)
 	register_early_suspend(&early_suspend);
 #endif
 
-	amlog_level(LOG_LEVEL_HIGH, "osd-ext probe ok  \r\n");
+	amlog_level(LOG_LEVEL_HIGH, "osd-ext probe ok\n");
 	return 0;
 
 failed2:
diff --git a/drivers/amlogic/display/osd_ext/osd_main.h b/drivers/amlogic/display/osd_ext/osd_main.h
old mode 100644
new mode 100755
index 6743348c..2fc2f55f
--- a/drivers/amlogic/display/osd_ext/osd_main.h
+++ b/drivers/amlogic/display/osd_ext/osd_main.h
@@ -158,5 +158,6 @@ typedef struct {
 #define  FBIOPUT_OSD_WINDOW_AXIS  	0x4513
 #define FBIOPUT_OSD_ROTATE_ON   	0x4516
 #define FBIOPUT_OSD_ROTATE_ANGLE	0x4517
+#define  FBIOPUT_OSD_SYNC_ADD	0x4518
 
 #endif /* OSD_MAIN_H */
diff --git a/drivers/amlogic/display/osd_ext/osd_prot.c b/drivers/amlogic/display/osd_ext/osd_prot.c
old mode 100644
new mode 100755
index 6fec9474..011df6eb
--- a/drivers/amlogic/display/osd_ext/osd_prot.c
+++ b/drivers/amlogic/display/osd_ext/osd_prot.c
@@ -76,7 +76,7 @@ int osd_ext_set_prot(unsigned char   x_rev,
 			aml_set_reg32_bits(P_VIU2_OSD2_BLK0_CFG_W0, 1, 15, 1);//switch back to little endian
 			aml_write_reg32(P_VIU2_OSD2_PROT_CTRL,0);
 		}
-		
+
 		return 0;
 	}
 	if(osd_index==OSD1){
@@ -128,5 +128,4 @@ int osd_ext_set_prot(unsigned char   x_rev,
     aml_write_reg32(P_VPU_PROT1_REQ_ONOFF,    data32);
     aml_write_reg32(P_VPU_PROT1_CLK_GATE, 1); // Enable clock
     return 0;
-}   
-
+}
diff --git a/drivers/amlogic/display/osd_ext/osd_prot.h b/drivers/amlogic/display/osd_ext/osd_prot.h
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/display/osd_ext/osd_sync.h b/drivers/amlogic/display/osd_ext/osd_sync.h
new file mode 100644
index 00000000..0641cf8d
--- /dev/null
+++ b/drivers/amlogic/display/osd_ext/osd_sync.h
@@ -0,0 +1,17 @@
+#ifndef   _OSD_SYNC_H
+#define _OSD_SYNC_H
+#include  <sw_sync.h>
+#include  <sync.h>
+
+typedef  struct{
+	unsigned int  xoffset;
+	unsigned int  yoffset;
+	int  in_fen_fd;
+	int  out_fen_fd;
+}fb_ext_sync_request_t;
+
+typedef  struct{
+	struct sw_sync_timeline  *timeline;
+}osd_ext_sync_obj;
+
+#endif
diff --git a/drivers/amlogic/display/sys_led/Kconfig b/drivers/amlogic/display/sys_led/Kconfig
new file mode 100644
index 00000000..8e57f1c2
--- /dev/null
+++ b/drivers/amlogic/display/sys_led/Kconfig
@@ -0,0 +1,11 @@
+
+menu "Amlogic Sys led Support"
+
+config AMLOGIC_SYS_LED
+	bool "Amlogic Sys led support"
+	select SETIO_CLASS_DEVICE
+	default y
+	help
+	  Say Y here if you want to use the amlogic system led management.
+
+endmenu
diff --git a/drivers/amlogic/display/sys_led/Makefile b/drivers/amlogic/display/sys_led/Makefile
new file mode 100644
index 00000000..526dd9eb
--- /dev/null
+++ b/drivers/amlogic/display/sys_led/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_AMLOGIC_SYS_LED) 				+= aml_sysled.o
diff --git a/drivers/amlogic/display/sys_led/aml_sysled.c b/drivers/amlogic/display/sys_led/aml_sysled.c
new file mode 100644
index 00000000..02c09726
--- /dev/null
+++ b/drivers/amlogic/display/sys_led/aml_sysled.c
@@ -0,0 +1,345 @@
+/*
+ * AMLOGIC sysled driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  wind <wind.zhang@amlogic.com>
+ *
+ */
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/fb.h>
+#include <linux/clk.h>
+#include <linux/gpio.h>
+#include <linux/slab.h>
+#include <mach/power_gate.h>
+#include <linux/of.h>
+#include <mach/gpio.h>
+#include <plat/io.h>
+#include <linux/amlogic/aml_gpio_consumer.h>
+#include <linux/of_gpio.h>
+#include <mach/pinmux.h>
+
+#ifdef CONFIG_HAS_EARLYSUSPEND
+#include <linux/earlysuspend.h>
+static struct early_suspend early_suspend;
+#endif
+
+#define SYSLED_MODULE_NAME   "aml-sysled"
+
+struct aml_sysled_platform_data {
+	const char *name;
+	unsigned int  red_led_mode;
+	unsigned int  blue_led_mode;
+	int red_led_gpio;
+	int blue_led_gpio;
+};
+
+//#define AML_sysled_DBG
+
+struct aml_sysled {
+	struct aml_sysled_platform_data	*pdata;
+	struct platform_device			*pdev;	
+};
+
+typedef enum led_mode_e {
+	LED_RED = 0,
+	LED_BLUE,
+	LED_OFF,
+}led_mode_t;
+
+static struct aml_sysled *Myamlsysled = NULL;
+static int sleep = 0;
+
+static int led_control(unsigned int led_mode )
+{
+	struct aml_sysled *amlsysled = Myamlsysled;	
+
+	switch(led_mode)
+	{
+		case LED_RED:
+			if(amlsysled->pdata[0].red_led_gpio){
+				amlogic_gpio_request(amlsysled->pdata[0].red_led_gpio, SYSLED_MODULE_NAME);
+				amlogic_gpio_direction_output(amlsysled->pdata[0].red_led_gpio, amlsysled->pdata[0].red_led_mode, SYSLED_MODULE_NAME);
+			}
+			if(amlsysled->pdata[0].blue_led_gpio){
+				amlogic_gpio_request(amlsysled->pdata[0].blue_led_gpio, SYSLED_MODULE_NAME);
+				amlogic_gpio_direction_output(amlsysled->pdata[0].blue_led_gpio, !amlsysled->pdata[0].blue_led_mode, SYSLED_MODULE_NAME);
+			}
+    		break;
+		case LED_BLUE:
+			if(amlsysled->pdata[0].red_led_gpio){
+				amlogic_gpio_request(amlsysled->pdata[0].red_led_gpio, SYSLED_MODULE_NAME);
+				amlogic_gpio_direction_output(amlsysled->pdata[0].red_led_gpio, !amlsysled->pdata[0].red_led_mode, SYSLED_MODULE_NAME);
+			}
+			if(amlsysled->pdata[0].blue_led_gpio){
+				amlogic_gpio_request(amlsysled->pdata[0].blue_led_gpio, SYSLED_MODULE_NAME);
+				amlogic_gpio_direction_output(amlsysled->pdata[0].blue_led_gpio, amlsysled->pdata[0].blue_led_mode, SYSLED_MODULE_NAME);
+			}
+  			break;
+  			break;
+		case LED_OFF:
+			if(amlsysled->pdata[0].red_led_gpio){
+				amlogic_gpio_request(amlsysled->pdata[0].red_led_gpio, SYSLED_MODULE_NAME);
+				amlogic_gpio_direction_output(amlsysled->pdata[0].red_led_gpio, !amlsysled->pdata[0].red_led_mode, SYSLED_MODULE_NAME);
+			}
+			if(amlsysled->pdata[0].blue_led_gpio){
+				amlogic_gpio_request(amlsysled->pdata[0].blue_led_gpio, SYSLED_MODULE_NAME);
+				amlogic_gpio_direction_output(amlsysled->pdata[0].blue_led_gpio, !amlsysled->pdata[0].blue_led_mode, SYSLED_MODULE_NAME);
+			}
+    		break;
+  }
+  return 0;
+}
+////////////////////////////////////for sysfs///////////////////////////////////////////////////////////////
+static ssize_t sysled_val(struct device *dev, struct device_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int led_mode=0;
+
+	if (!strcmp(attr->attr.name, "io_val")) {        
+		printk(KERN_INFO"----%s\n", buf);
+		sscanf(buf, "%d", &led_mode);       
+	}
+	led_control(led_mode);
+	return count;
+}
+static ssize_t getio_val(struct device *dev, struct device_attribute *attr, char *buf)
+{
+	printk(KERN_INFO"read failed\n");
+	return 0;
+}
+
+static DEVICE_ATTR(io_val, S_IRWXUGO, getio_val, sysled_val);
+///////////////////////////////////////////////////////////////////////////////////////////////////////
+static const struct of_device_id amlogic_led_match[] =
+{
+	{
+		.compatible = "amlogic-led",
+	},
+};
+///////////////////////////////////////////early suspend////////////////////////////////////////////
+#ifdef CONFIG_HAS_EARLYSUSPEND
+static void aml_sysled_early_suspend(struct early_suspend *dev)
+{
+	printk(KERN_INFO "enter aml_sysled_early_suspend\n");
+	led_control(LED_RED);
+	sleep = 1;
+}
+static void aml_sysled_late_resume(struct early_suspend *dev)
+{
+	printk(KERN_INFO "enter aml_sysled_late_resume\n");
+	if(sleep == 1){
+		printk("dgt, aml_sysled_late_resume blue led\n");
+		led_control(LED_BLUE);
+	}
+	
+	sleep = 0;
+}
+#endif
+///////////////////////////////////////////////////////////////////////////////////////////////////////
+static int aml_sysled_suspend(struct platform_device *pdev,pm_message_t state)
+{
+	printk(KERN_INFO "enter aml_sysled_suspend\n");
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	sleep = 2;
+#else
+	led_control(LED_RED);
+#endif
+	return 0;
+}
+
+static int aml_sysled_resume(struct platform_device *pdev)
+{
+	printk(KERN_INFO "enter aml_sysled_resume\n");
+	if (READ_AOBUS_REG(AO_RTI_STATUS_REG2) == 0x1234abcd) {
+		led_control(LED_BLUE);
+	}
+	sleep = 0;
+	return 0;
+}
+
+static void aml_sysled_shutdown(struct platform_device *pdev,pm_message_t state)
+{
+	printk(KERN_INFO "enter aml_sysled_shutdown\n");
+	led_control(LED_RED);
+}
+
+static int aml_sysled_probe(struct platform_device *pdev)
+{
+	struct aml_sysled_platform_data *pdata;
+	struct aml_sysled *amlsysled;
+	int retval,ret;
+	int ret_dts = -1;
+	struct device_node *np = pdev->dev.of_node;
+	int value = -1;
+	const char *str;
+
+	printk(KERN_INFO "enter aml_sysled_probe\n");
+	amlsysled = kzalloc(sizeof(struct aml_sysled), GFP_KERNEL);
+	if (!amlsysled)
+	{   
+		printk(KERN_ERR "kzalloc error\n");
+		return -ENOMEM;
+	}
+	pdata=kzalloc(sizeof(struct aml_sysled_platform_data),GFP_KERNEL);
+	if(!pdata){
+		goto err;
+	}
+	memset((void* )pdata,0,sizeof(*pdata));
+	amlsysled->pdev = pdev;
+    
+	//dts init
+	if(np == NULL ){
+		printk(KERN_ERR "np == null \n");
+		goto err;
+	}
+	printk("start read sedio dts \n");
+	
+	//read dev_name
+	ret_dts=of_property_read_string(pdev->dev.of_node,"dev_name",&pdata->name);
+	if (ret_dts){
+		dev_err(&pdev->dev, "read %s  error\n","dev_name");
+		goto err;
+	}
+	printk("sysled pdata->name:%s\n",pdata->name);
+	
+	//read red_led_mode
+	value=-1;
+	ret_dts=of_property_read_u32(pdev->dev.of_node,"red_led_mode",&value);
+	if (ret_dts){
+		dev_err(&pdev->dev, "read %s  error\n","red_led_mode");
+		goto err;
+	}
+	pdata->red_led_mode=value;
+	printk("sysled pdata->red_led_mode:%d\n",pdata->red_led_mode);
+	
+	//read blue_led_mode
+	value=-1;
+	ret_dts=of_property_read_u32(pdev->dev.of_node,"blue_led_mode",&value);
+	if (ret_dts){
+		dev_err(&pdev->dev, "read %s  error\n","blue_led_mode");
+		goto err;
+	}
+	pdata->blue_led_mode=value;
+	printk("sysled pdata->blue_led_mode:%d\n",pdata->blue_led_mode);
+	
+	//read red_led_gpio
+	ret_dts = of_property_read_string(pdev->dev.of_node, "red_led_gpio", &str);
+	if(ret_dts)
+	{
+	    printk("Error: can not get red_led_gpio name------%s %d\n",__func__,__LINE__);
+		pdata->red_led_gpio = 0;
+	}else{
+	    pdata->red_led_gpio = amlogic_gpio_name_map_num(str);
+	    printk("red_led_gpio is %d\n",pdata->red_led_gpio);
+	}
+
+	//read blue_led_gpio
+	ret_dts = of_property_read_string(pdev->dev.of_node, "blue_led_gpio", &str);
+	if(ret_dts)
+	{
+	    printk("Error: can not get blue_led_gpio name------%s %d\n",__func__,__LINE__);
+		pdata->blue_led_gpio = 0;
+	}else{
+	    pdata->blue_led_gpio = amlogic_gpio_name_map_num(str);
+	    printk("blue_led_gpio is %d\n",pdata->blue_led_gpio);
+		if(pdata->blue_led_gpio == pdata->red_led_gpio){
+			pdata->blue_led_gpio = 0;
+		}
+	}
+	//end dts init
+	
+	if (!pdata) {
+		printk(KERN_ERR "missing platform data\n");
+		retval = -ENODEV;
+		goto err;
+	}	
+	amlsysled->pdata = pdata;
+	platform_set_drvdata(pdev, amlsysled);
+	
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN - 9;
+	early_suspend.suspend = aml_sysled_early_suspend;
+	early_suspend.resume = aml_sysled_late_resume;
+	register_early_suspend(&early_suspend);
+#endif
+	Myamlsysled = amlsysled;
+	ret = device_create_file(&pdev->dev, &dev_attr_io_val);
+	if (ret < 0)
+		printk(KERN_WARNING "asoc: failed to add io_val sysfs files\n");
+	
+	return 0;
+
+err:
+	kfree(amlsysled);
+	kfree(pdata);
+	return retval;
+}
+
+static int __exit aml_sysled_remove(struct platform_device *pdev)
+{
+	struct aml_sysled *amlsysled = platform_get_drvdata(pdev);
+
+	printk(KERN_INFO "enter aml_sysled_remove\n");
+#ifdef CONFIG_HAS_EARLYSUSPEND
+	unregister_early_suspend(&early_suspend);
+#endif
+	platform_set_drvdata(pdev, NULL);
+	kfree(amlsysled);
+
+	return 0;
+}
+
+static struct platform_driver aml_sysled_driver = {
+	.driver = {
+		.name = "aml-sysled",
+	.owner = THIS_MODULE,
+	.of_match_table = of_match_ptr(amlogic_led_match),
+	},
+	.probe = aml_sysled_probe,
+	.remove = __exit_p(aml_sysled_remove),
+	.suspend = aml_sysled_suspend,
+	.resume  = aml_sysled_resume,
+	.shutdown = aml_sysled_shutdown,
+};
+
+static int __init aml_sysled_init(void)
+{
+	int ret = -1;
+  
+	printk(KERN_INFO "enter aml_sysled_init\n");
+	ret = platform_driver_register(&aml_sysled_driver);
+  
+	if (ret != 0) {
+		printk(KERN_ERR "failed to register sysled driver, error %d\n", ret);
+		return -ENODEV;
+	}
+	return ret;    
+}
+module_init(aml_sysled_init);
+
+static void __exit aml_sysled_exit(void)
+{
+	//printk(KERN_INFO "enter aml_sysled_exit\n");
+	platform_driver_unregister(&aml_sysled_driver);
+}
+module_exit(aml_sysled_exit);
+
+MODULE_DESCRIPTION("Amlogic sysled driver");
+MODULE_AUTHOR("dianzhong.huo <dianzhong.huo@amlogic.com>");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/display/vout/Kconfig b/drivers/amlogic/display/vout/Kconfig
index d2b78031..a771a5e5 100755
--- a/drivers/amlogic/display/vout/Kconfig
+++ b/drivers/amlogic/display/vout/Kconfig
@@ -6,7 +6,7 @@ menu "Amlogic video output module"
 config AM_TV_OUTPUT
 	tristate "TV output"
 	default y
-	help  
+	help
 		tv output module
 
 config AML_VOUT_FRAMERATE_AUTOMATION
@@ -16,10 +16,17 @@ config AML_VOUT_FRAMERATE_AUTOMATION
 	help
 		framerate adjustment automatically from video source
 
+config AML_VDAC_HW_SWITCH
+	bool "vdac hardware switch"
+	default n
+	depends on AM_TV_OUTPUT
+	help
+		vdac hardware switch of cvbs/ypbpr for mx.
+
 config AM_LCD_OUTPUT
-	tristate "LCD output" 
+	tristate "LCD output"
 	default y
-	help  
+	help
 		LCD output module
 
 config AML_GAMMA_DEBUG
diff --git a/drivers/amlogic/display/vout/Makefile b/drivers/amlogic/display/vout/Makefile
index d661f10c..403cd263 100755
--- a/drivers/amlogic/display/vout/Makefile
+++ b/drivers/amlogic/display/vout/Makefile
@@ -1,11 +1,18 @@
 obj-y 	+=display.o
 display-objs=vout_notify.o  vout_serve.o
-display-objs-$(CONFIG_AM_LCD_OUTPUT)  += vdac_switch.o
 
+obj-$(CONFIG_AML_VDAC_HW_SWITCH)  += vdac_switch.o
 
-obj-$(CONFIG_AM_TV_OUTPUT)  += am_tvout.o
-am_tvout-objs :=   tvoutc.o  tvconf.o enc_clk_config.o
 
+obj-$(CONFIG_AM_TV_OUTPUT)  += am_tvout.o
+am_tvout-objs :=   tvoutc.o  tvconf.o
+ifeq ($(CONFIG_ARCH_MESONG9TV),y)
+else
+ifeq ($(CONFIG_ARCH_MESONG9BB),y)
+else
+am_tvout-objs += enc_clk_config.o
+endif
+endif
 obj-$(CONFIG_AM_LCD_OUTPUT)  += lcdoutc.o
 obj-$(CONFIG_AM_LCD_OUTPUT)  += lcd_extern/
 
diff --git a/drivers/amlogic/display/vout/aml_lcd.dtd b/drivers/amlogic/display/vout/aml_lcd.dtd
index bacc0929..1cace622 100755
--- a/drivers/amlogic/display/vout/aml_lcd.dtd
+++ b/drivers/amlogic/display/vout/aml_lcd.dtd
@@ -27,6 +27,7 @@
 //$$ L4 PROP_U32 3 = "edp_user_link_rate_lane_count"
 //$$ L4 PROP_U32 2 = "edp_link_adaptive_vswing"
 //$$ L4 PROP_U32 = "edp_sync_clock_mode"
+//$$ L4 PROP_U32 = "edp_edid_timing_used"
 //$$ L4 PROP_U32 2 = "rgb_base_coeff"
 
 //$$ L2 PROP_STR 3 = "power_on_uboot"
@@ -96,13 +97,13 @@
         gamma_en_reverse=<1 0>;	/** gamma_en(0=disable gamma table, 1=enable gamma table), gamma_table_reverse(0=normal, 1=reverse) */
         gamma_multi_rgb_coeff=<0 100 100 100>;	/** gamma_multi(0=single gamma, RGB are same, 1=multi gamma, RGB are different), gamma_r_coeff(%), gamma_g_coeff(%), gamma_b_coeff(%) */
         /** if gamma_multi=1, there must be 3 gamma tables, named as gamma_table_r, gamma_table_g, gamma_table_b */
-        gamma_table=<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 
-                    32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 
-                    64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 
-                    96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 
-                    128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159  
-                    160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 
-                    192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 
+        gamma_table=<0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31
+                    32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63
+                    64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95
+                    96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127
+                    128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159
+                    160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191
+                    192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223
                     224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255>;
 
         /* default settings, don't modify them unless there is display problem */
@@ -114,6 +115,7 @@
         edp_user_link_rate_lane_count=<1 1 2>;	/** edp_user(0=auto setting, 1=user define), link_rate(0=1.62G, 1=2.7G, only valid when edp_user=1), lane_count(support 1,2,4, only valid when edp_user=1) */
         edp_link_adaptive_vswing=<0 0>;	/** adaptive(0=fixed user defined vswing, 1=auto setting vswing by training), vswing(support level 0,1,2,3, user defined vswing, only valid when adaptive=0) */
         edp_sync_clock_mode=<1>; /** clocking mode for the user data: (0=asyncronous clock, 1=synchronous clock. default 1) */
+        edp_edid_timing_used=<0>; /** edp use edid timing: (0=no use, 1=use) */
         rgb_base_coeff=<0xf0 0x74a>;	/** rgb_base, rgb_coeff */
 
         //lcd power ctrl	//support up to 15 steps for each sequence
@@ -154,7 +156,11 @@
     };
 
 //******************************************************************************
-//mipi
+//Interface: mipi
+
+//mipi command
+//format:  data_type, num, data....
+//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
 //******************************************************************************
 //$$ MATCH "lcd_model_config_match" = <&lcd_B080XAN01>
 //$$ L2 PROP_STR = "model_name"
@@ -185,8 +191,8 @@
         period=<948 1140>;      /** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<64843200 0>; /** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<64 120>; /** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<50 80>;  /** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<64 56>; /** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<50 30>;  /** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;          /** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         dsi_lane_num=<4>; /** mipi dsi data lane number */
@@ -194,14 +200,14 @@
         dsi_bit_rate_max=<550>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-        dsi_init_on=<0x05 0x11 0 //sleep out
+        dsi_init_on=<0x05 1 0x11 //sleep out
                     0xff 20      //delay 20ms
-                    0x05 0x29 0  //display on
+                    0x05 1 0x29  //display on
                     0xff 20      //delay 20ms
                     0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        dsi_init_off=<0x05 0x28 0 //display off
+        dsi_init_off=<0x05 1 0x28 //display off
                     0xff 10       //delay 10ms
-                    0x05 0x10 0   //sleep in
+                    0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
@@ -236,8 +242,8 @@
         period=<948 1140>;     /** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<64843200 0>; /** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<64 120>; /** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<50 80>;  /** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<64 56>; /** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<50 30>;  /** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;          /** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
@@ -245,14 +251,14 @@
         dsi_bit_rate_min_max=<550>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-        dsi_init_on=<0x05 0x11 0 //sleep out
+        dsi_init_on=<0x05 1 0x11 //sleep out
                     0xff 100     //delay 100ms
-                    0x05 0x29 0  //display on
+                    0x05 1 0x29  //display on
                     0xff 100     //delay 100ms
                     0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        dsi_init_off=<0x05 0x28 0 //display off
+        dsi_init_off=<0x05 1 0x28 //display off
                     0xff 10       //delay 10ms
-                    0x05 0x10 0   //sleep in
+                    0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
@@ -287,8 +293,8 @@
         period=<2080 1235>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<154128000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<32 112>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<6 26>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<32 80>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<6 20>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
@@ -296,14 +302,14 @@
         dsi_bit_rate_min_max=<1000>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<15>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<1 0>; /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-        dsi_init_on=<0x05 0x11 0 //sleep out
+        dsi_init_on=<0x05 1 0x11 //sleep out
                     0xff 100     //delay 100ms
-                    0x05 0x29 0  //display on
+                    0x05 1 0x29  //display on
                     0xff 100     //delay 100ms
                     0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        dsi_init_off=<0x05 0x28 0 //display off
+        dsi_init_off=<0x05 1 0x28 //display off
                     0xff 10       //delay 10ms
-                    0x05 0x10 0   //sleep in
+                    0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
@@ -339,8 +345,8 @@
         period=<864 1315>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<56800000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<4 48>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<4 44>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 21>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
         vsync_horizontal_phase=<1 4>; /** adj_sign(0=positive, 1=negative), adj_value. default is <0 0> */
 
@@ -349,23 +355,23 @@
         dsi_bit_rate_min_max=<500>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-        dsi_init_on=<0x15 0x01 1 0x0 
+        dsi_init_on=<0x15 2 0x01 0x0 
                     0xff 20     //delay 20ms
-                    0x15 0xAE 1 0x0B 
-                    0x15 0xEE 1 0xEA 
-                    0x15 0xEF 1 0x5F 
-                    0x15 0xF2 1 0x68 
-                    0x15 0xEE 1 0x0 
-                    0x15 0xEF 1 0x0 
-
-                    0x05 0x11 0  //sleep out
+                    0x15 2 0xAE 0x0B 
+                    0x15 2 0xEE 0xEA 
+                    0x15 2 0xEF 0x5F 
+                    0x15 2 0xF2 0x68 
+                    0x15 2 0xEE 0x0 
+                    0x15 2 0xEF 0x0 
+
+                    0x05 1 0x11  //sleep out
                     0xff 200     //delay 200ms
-                    0x05 0x29 0  //display on
+                    0x05 1 0x29  //display on
                     0xff 100     //delay 100ms
                     0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        dsi_init_off=<0x05 0x28 0 //display off
+        dsi_init_off=<0x05 1 0x28 //display off
                     0xff 10       //delay 10ms
-                    0x05 0x10 0   //sleep in
+                    0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         lcd_extern_init=<0>;  /** lcd extern init command control(0=disable, 1=enable) */
@@ -401,8 +407,8 @@
         period=<864 1315>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<56800000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<4 48>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<3 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<4 44>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<3 20>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
         vsync_horizontal_phase=<1 4>; /** adj_sign(0=positive, 1=negative), adj_value. default is <0 0> */
 
@@ -445,8 +451,8 @@
         period=<1984 1235>;      /** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<147010000 0>; /** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<16 48>; /** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 20>;  /** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<16 32>; /** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 18>;  /** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;         /** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
@@ -454,7 +460,7 @@
         dsi_bit_rate_min_max=<900>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 2>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-        dsi_init_on=<0x32 0x0 0  //turn on peripheral
+        dsi_init_on=<0x32 0  //turn on peripheral
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         dsi_init_off=<0xff 0xff>; /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
@@ -489,8 +495,8 @@
         period=<1392 1956>;     /** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<136138000 0>; /** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<12 72>; /** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 8>;   /** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<12 60>; /** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 6>;   /** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;         /** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         dsi_lane_num=<4>;/** mipi dsi data lane number */
@@ -498,32 +504,77 @@
         dsi_bit_rate_max=<900>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
         pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
         dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
-        dsi_init_on=<0x05 0x01 0  //soft reset
+        dsi_init_on=<0x05 1 0x01  //soft reset
                     0xff 5        //delay 5ms
-                    0x23 0xb0 1 0x00  //MCAP
-                    0x29 0xb4 1 0x0c  //interface ID setting
-                    0x29 0xb6 2 0x3a 0xd3 //DSI control
+                    0x23 2 0xb0 0x00  //MCAP
+                    0x29 2 0xb4 0x0c  //interface ID setting
+                    0x29 3 0xb6 0x3a 0xd3 //DSI control
 
-                    0x15 0x51 1 0xe6 //write display brightness
-                    0x15 0x53 1 0x2c //write control display
+                    0x15 2 0x51 0xe6 //write display brightness
+                    0x15 2 0x53 0x2c //write control display
 
-                    0x15 0x3a 1 0x77 //set pixel format
-                    0x05 0x11 0 //sleep out
+                    0x15 2 0x3a 0x77 //set pixel format
+                    0x05 1 0x11 //sleep out
                     0xff 120    //delay 120ms
-                    0x29 0xb3 5 0x14 0x08 0x00 0x22 0x00 //Interface setting
-                    0x05 0x29 0 //display on
+                    0x29 6 0xb3 0x14 0x08 0x00 0x22 0x00 //Interface setting
+                    0x05 1 0x29 //display on
                     0xff 30     //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
-        dsi_init_off=<0x05 0x28 0 //display off
+        dsi_init_off=<0x05 1 0x28 //display off
                     0xff 10       //delay 10ms
-                    0x05 0x10 0   //sleep in
+                    0x05 1 0x10   //sleep in
                     0xff 10       //delay 10ms
                     0xff 0xff>;   /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
         lcd_extern_init=<0>;    /** lcd extern init command control(0=disable, 1=enable) */
     };
 
+//$$ MATCH "lcd_model_config_match" = <&lcd_KD080D13>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "vsync_horizontal_phase"
+//$$ L2 PROP_U32 = "dsi_lane_num"
+//$$ L2 PROP_U32 2 = "dsi_operation_mode"
+//$$ L2 PROP_U32 = "dsi_bit_rate_max"
+//$$ L2 PROP_U32 = "pclk_lanebyteclk_factor"
+//$$ L2 PROP_U32 2 = "dsi_transfer_ctrl"
+//$$ L2 PROP_U32 2 = "dsi_init_on"
+//$$ L2 PROP_U32 2 = "dsi_init_off"
+//$$ L2 PROP_U32 = "lcd_extern_init"
+    lcd_KD080D13:lcd_KD080D13{
+        model_name="KD080D13";	/** lcd model name */
+        interface="mipi";		/** lcd_interface(mipi, lvds, edp, ttl) */
+        active_area=<108 172>;		/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+        lcd_bits_option=<8 0>;		/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+
+        resolution=<800 1280>;	/** horizontal resolution, vertical resolution */
+        period=<880 1380>;		/** horizontal period(htotal), vertical period(vtotal) */
+
+        clock_hz_pol=<72864000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+        hsync_width_backporch=<16 48>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<4 4>;	/** vsync_width, vsync_backporch(without vsync_width) */
+        pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+        vsync_horizontal_phase=<1 4>; /** adj_sign(0=positive, 1=negative), adj_value. default is <0 0> */
+
+        dsi_lane_num=<4>;/** mipi dsi data lane number */
+        dsi_operation_mode=<1 0>; /** operation mode when init and display: (0=video mode, 1=command mode). default is <1 0> */
+        dsi_bit_rate_min_max=<500>; /** mipi-dsi data lane bit rate limit(unit: MHz) */
+        pclk_lanebyteclk_factor =<0>;   /** special adjust, default is 0 */
+        dsi_transfer_ctrl=<0 0>;  /** clk_lane auto stop in LP mode: (0=disable, 1=enable), transfer switch between LP and HS: (0=auto, 1=standard, 2=slow). default is <0 0> */
+        dsi_init_on=<0xff 0xff>;  /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
+        dsi_init_off=<0xff 0xff>; /** mipi command(data_type, command, para_num, parameters). 0xff,0xff is ending flag. 0xff,n(n<0xff) means delay n(unit: ms) */
+        lcd_extern_init=<1>;    /** lcd extern init command control(0=disable, 1=enable) */
+    };
+
 //******************************************************************************
-//edp
+//Interface: edp
 //******************************************************************************
 //$$ MATCH "lcd_model_config_match" = <&lcd_LP097QX1>
 //$$ L2 PROP_STR = "model_name"
@@ -547,8 +598,8 @@
         period=<2219 1560>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<207700000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<1 22>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<5 115>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<1 21>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         max_lane_count=<4>; /** max lane count supported */
@@ -576,8 +627,8 @@
         period=<2720 1481>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<245500000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<32 112>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<5 38>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<32 80>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<5 33>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         max_lane_count=<4>; /** max lane count supported */
@@ -605,15 +656,73 @@
         period=<1598 798>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<76300000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<1 22>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<5 115>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<1 21>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         max_lane_count=<1>; /** max lane count supported */
     };
+	
+//$$ MATCH "lcd_model_config_match" = <&lcd_B140RTN02>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "max_lane_count"
+    lcd_B140RTN02:lcd_B140RTN02{
+        model_name="B140RTN02"; /** lcd model name */
+        interface="edp";		/** lcd_interface(mipi, lvds, edp, ttl) */
+        active_area=<309 174>;	/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+        lcd_bits_option=<6 0>;	/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+
+        resolution=<1600 900>;	/** horizontal resolution, vertical resolution */
+        period=<2032 930>;		/** horizontal period(htotal), vertical period(vtotal) */
+
+        clock_hz_pol=<113385600 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+        hsync_width_backporch=<32 168>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 21>;	/** vsync_width, vsync_backporch(without vsync_width) */
+        pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+
+        max_lane_count=<1>; /** max lane count supported */
+    };
+	
+//$$ MATCH "lcd_model_config_match" = <&lcd_LP097QX2>
+//$$ L2 PROP_STR = "model_name"
+//$$ L2 PROP_STR = "interface"
+//$$ L2 PROP_U32 2 = "active_area"
+//$$ L2 PROP_U32 2 = "lcd_bits_option"
+//$$ L2 PROP_U32 2 = "resolution"
+//$$ L2 PROP_U32 2 = "period"
+//$$ L2 PROP_U32 2 = "clock_hz_pol"
+//$$ L2 PROP_U32 2 = "hsync_width_backporch"
+//$$ L2 PROP_U32 2 = "vsync_width_backporch"
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
+//$$ L2 PROP_U32 = "max_lane_count"
+	lcd_LP097QX2:lcd_LP097QX2{
+		model_name="LP097QX2";	/** lcd model name */
+		interface="edp";	 /** lcd_interface(mipi, lvds, edp, ttl) */
+		active_area=<163 208>;	/** lcd active_area or display_area horizontal size, vertical size : (unit in mm, you can find them on the home page of lcd spec) */
+		lcd_bits_option=<8 0>;	/** lcd_bits(6,8), bits_option(0=only support one mode as lcd_bits define, 1=both support 6/8bit) */
+
+		resolution=<1536 2048>;	/** horizontal resolution, vertical resolution */
+		period=<1759 2081>;	 /** horizontal period(htotal), vertical period(vtotal) */
+
+		clock_hz_pol=<200000000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
+		hsync_width_backporch=<15 52>;	/** hsync_width, hsync_backporch(without hsync_width) */
+		vsync_width_backporch=<1 3>;	/** vsync_width, vsync_backporch(without vsync_width) */
+		pol_hsync_vsync=<1 1>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
+ 
+		max_lane_count=<4>; /** max lane count supported */
+	};
 
 //******************************************************************************
-//lvds
+//Interface: lvds
 //******************************************************************************
 //$$ MATCH "lcd_model_config_match" = <&lcd_LP097X02>
 //$$ L2 PROP_STR = "model_name"
@@ -636,8 +745,8 @@
         period=<2084 810>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<85700000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<3 30>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<3 27>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -662,8 +771,8 @@
         period=<1000 1320>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<79200000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 20>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -688,8 +797,8 @@
         period=<960 1320>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<76000000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 20>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -714,8 +823,8 @@
         period=<1344 635>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<51200000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 20>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -740,8 +849,8 @@
         period=<1344 806>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<65000000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 20>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -766,8 +875,8 @@
         period=<1440 838>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<72400000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 20>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -792,8 +901,8 @@
         period=<960 1320>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<63400000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 20>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -818,8 +927,8 @@
         period=<1440 835>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<71100000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<5 120>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 32>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<5 115>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 30>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -833,7 +942,7 @@
 //$$ L2 PROP_U32 2 = "clock_hz_pol"
 //$$ L2 PROP_U32 2 = "hsync_width_backporch"
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
-//$$ L2 PROP_U32 2 = "pol_hsync_vsync"	
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
     lcd_KD101N4:lcd_KD101N4{
         model_name="KD101N4";	/** lcd model name */
         interface="lvds";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -844,8 +953,8 @@
         period=<1440 838>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<72400000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 20>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -859,7 +968,7 @@
 //$$ L2 PROP_U32 2 = "clock_hz_pol"
 //$$ L2 PROP_U32 2 = "hsync_width_backporch"
 //$$ L2 PROP_U32 2 = "vsync_width_backporch"
-//$$ L2 PROP_U32 2 = "pol_hsync_vsync"	
+//$$ L2 PROP_U32 2 = "pol_hsync_vsync"
     lcd_HM185WX3:lcd_HM185WX3{
         model_name="HM185WX3";	/** lcd model name */
         interface="lvds";		/** lcd_interface(mipi, lvds, edp, ttl) */
@@ -870,8 +979,8 @@
         period=<1560 806>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<78000000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 20>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -897,8 +1006,8 @@
         period=<1344 635>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<51200000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 170>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 25>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 160>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 23>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
 
         lcd_extern_init=<1>;/** lcd extern init command control(0=disable, 1=enable) */
@@ -925,12 +1034,12 @@
         period=<928 1065>;        /** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<59300000 0>;    /** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 80>; /** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 23>;  /** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 70>; /** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 21>;  /** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;    /** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 //******************************************************************************
-//ttl
+//Interface: ttl
 //******************************************************************************
 //$$ MATCH "lcd_model_config_match" = <&lcd_CLAP070NJ02>
 //$$ L2 PROP_STR = "model_name"
@@ -953,8 +1062,8 @@
         period=<1344 635>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<42700000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 170>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<5 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 160>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<5 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -979,8 +1088,8 @@
         period=<1056 525>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<33300000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 46>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<5 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 36>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<5 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -1005,8 +1114,8 @@
         period=<1056 525>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<30000000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<20 46>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<5 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<20 26>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<5 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -1031,8 +1140,8 @@
         period=<1056 525>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<33300000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 46>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<5 23>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 36>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<5 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
@@ -1057,13 +1166,13 @@
         period=<620 310>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<11500000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<5 40>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 8>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<5 35>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 6>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
 //******************************************************************************
-//bridge
+//Interface: bridge
 //******************************************************************************
 //$$ MATCH "lcd_model_config_match" = <&lcd_TM080XSZ00>
 //$$ L2 PROP_STR = "model_name"
@@ -1086,8 +1195,8 @@
         period=<1440 810>;		/** horizontal period(htotal), vertical period(vtotal) */
 
         clock_hz_pol=<70000000 0>;	/** clock_hz(unit in Hz, both support clk and frame_rate, >200 regard as clk, <200 regard as frame_rate), clk_pol(only valid for TTL) */
-        hsync_width_backporch=<10 70>;	/** hsync_width, hsync_backporch(include hsync_width) */
-        vsync_width_backporch=<2 20>;	/** vsync_width, vsync_backporch(include vsync_width) */
+        hsync_width_backporch=<10 60>;	/** hsync_width, hsync_backporch(without hsync_width) */
+        vsync_width_backporch=<2 18>;	/** vsync_width, vsync_backporch(without vsync_width) */
         pol_hsync_vsync=<0 0>;	/** hsync_polarity, vsync_polarity : (0=negative, 1=positive) */
     };
 
diff --git a/drivers/amlogic/display/vout/enc_clk_config.c b/drivers/amlogic/display/vout/enc_clk_config.c
old mode 100644
new mode 100755
index d56b62f4..cc81d6df
--- a/drivers/amlogic/display/vout/enc_clk_config.c
+++ b/drivers/amlogic/display/vout/enc_clk_config.c
@@ -1,13 +1,15 @@
 #include <linux/delay.h>
 #include <linux/kernel.h>
+#include <linux/mutex.h>
 #include <linux/amlogic/vout/vinfo.h>
 #include <mach/register.h>
 #include <mach/am_regs.h>
 #include <mach/clock.h>
 #include <linux/amlogic/vout/enc_clk_config.h>
-#include <linux/amlogic/hdmi_tx/hdmi_tx_module.h>
-#include <linux/mutex.h>
 
+#define check_clk_config(para)\
+    if (para == -1)\
+        return;
 
 #define check_div() \
     if(div == -1)\
@@ -51,10 +53,30 @@
             printk(KERN_CRIT "pll[0x%x] reset %d times\n", reg, 9 - cnt);\
     }while(0);
 
+static int (*hdmi_is_special_tv_func)(void)= NULL;
+void register_hdmi_is_special_tv_func( int (*pfunc)(void) )
+{
+    hdmi_is_special_tv_func = pfunc;
+}
+int hdmitx_is_special_tv_process(void)
+{
+    if (hdmi_is_special_tv_func)
+        return hdmi_is_special_tv_func();
+    else
+        return 0;
+}
+
 static void set_hpll_clk_out(unsigned clk)
 {
+    check_clk_config(clk);
     printk("config HPLL\n");
 
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV
+    printk("%s[%d]\n", __FILE__, __LINE__);
+    printk("TODO\n");
+    return;
+#endif
+
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
     printk("%s[%d] clk = %d\n", __func__, __LINE__, clk);
     aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c88000);
@@ -62,33 +84,54 @@ static void set_hpll_clk_out(unsigned clk)
     aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x40238100);
     aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00012286);
     aml_write_reg32(P_HHI_VID2_PLL_CNTL2, 0x430a800);       // internal LDO share with HPLL & VIID PLL
+    aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0x21ef, 0, 15);
     switch(clk){
         case 2971:      // only for 4k mode
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	case 2976:	// only for 4k mode with clock*0.999
+        case 2976:		// only for 4k mode with clock*0.999
 #endif
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84000);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0xce49c022);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4123b100);
-            aml_set_reg32_bits(P_HHI_VID2_PLL_CNTL2, 1, 16, 1);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00012385);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000043d);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4000043d);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-            h_delay();
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00016385);   // optimise HPLL VCO 2.97GHz performance
+            //aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x0000043d);
+            if (IS_MESON_M8_CPU && hdmitx_is_special_tv_process()) {//SAMSUNG future TV, M8, in 4K2K mode
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	    if (clk == 2976)
-	            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84d04);	// lower div_frac to get clk*0.999
-	    else
-	            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84e00);
+                if ( clk == 2976 )
+                    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c84d04); // lower div_frac to get clk*0.999
+                else
+                    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c84e00);
 #else
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84e00);
-#endif
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c84e00);
+#endif
+                aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0xce49c822);
+                aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4123b100);
+                aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00012385);
+                aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000043d);
+                aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4000043d);
+                WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
+                h_delay();
+                aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00016385);   // optimise HPLL VCO 2.97GHz performance
+            }
+            else {
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+                if ( clk == 2976 )
+                    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69d84d04); // lower div_frac to get clk*0.999
+                else
+                    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69d84e00);
+#else
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69d84e00);
+#endif
+                aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0xca46c023);
+                aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4123b100);
+                aml_set_reg32_bits(P_HHI_VID2_PLL_CNTL2, 1, 16, 1);
+                aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00012385);
+                aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000043d);
+                aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4000043d);
+                WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
+                h_delay();
+                aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00016385);   // optimise HPLL VCO 2.97GHz performance
+            }
             break;
         case 2970:      // for 1080p/i 720p mode
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	case 2975:	// For 1080P/i 720p mode with clock*0.999
+		case 2975:		// FOR 1080P/i 720p mode with clock*0.999
 #endif
             aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84000);
             aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a46c023);
@@ -100,14 +143,14 @@ static void set_hpll_clk_out(unsigned clk)
             h_delay();
             aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00016385);   // optimise HPLL VCO 2.97GHz performance
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	    if (clk == 2975)
-	            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84d04);	// lower div_frac to get clk*0.999
-	    else
-	            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84e00);
+			if( clk == 2975 )
+				aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84d04); // lower div_frac to get clk*0.999
+			else
+				aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84e00);
 #else
             aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84e00);
 #endif
-            break;
+            break;
         case 2160:
             aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84000);
             aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a46c023);
@@ -117,126 +160,8 @@ static void set_hpll_clk_out(unsigned clk)
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4001042d);
             WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
             break;
-        case 2058:
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6001042a);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4001042a);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8cdf4);
-            break;
-        case 1600:
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c000);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60000442);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40000442);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c506);
-            break;
-        case 1710:
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c000);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60000447);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40000447);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c3ac);
-            break;
-        case 2130:
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6001042c);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4001042c);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c74f);
-            break;
-        case 2560:
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60010435);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40010435);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c294);
-            break;
-        case 2600:
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60010436);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40010436);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c294);
-            break;
-        case 2925:
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6001043c);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4001043c);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8cfb4);
-            break;
-        case 2380:
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60010431);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40010431);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c994);
-            break;
-        case 1716:
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c000);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60000447);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40000447);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c7f8);
-            break;
-        case 2014:
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c8cf55);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60010429);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40010429);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-            break;
-        case 1422:
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c000);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000043b);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4000043b);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c40f);
-            break;
-		case 1540:
-			aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c2ab);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60000440);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40000440);
-			WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-			break;
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-        case 2161:
+		case 2161:/*for N200/M200 480p59hz*/
             aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84f48);
             aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a46c023);
             aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
@@ -244,21 +169,17 @@ static void set_hpll_clk_out(unsigned clk)
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6001042c);
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4001042c);
             WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-            break;
-#endif                 
+			break;
+#endif			
         case 1080:
-			aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c000);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
-			aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000042d);
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4000042d);
             WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
             break;
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION            
-        case 1081:
-            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8cf48);
-            aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000042c);
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION		
+		case 1081:/*for N200/M200 480p59hz*/
+			aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8cf48);
+			aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000042c);
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4000042c);
             WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
             break;
@@ -271,7 +192,7 @@ static void set_hpll_clk_out(unsigned clk)
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x600c0436);
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x400c0436);
             aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00016385);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
+			WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
             break;
         default:
             printk("error hpll clk: %d\n", clk);
@@ -282,6 +203,7 @@ static void set_hpll_clk_out(unsigned clk)
 #endif
 
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+    printk("%s[%d] clk = %d\n", __func__, __LINE__, clk);
     aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c88000);
     aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0xca563823);
     aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x40238100);
@@ -290,29 +212,28 @@ static void set_hpll_clk_out(unsigned clk)
     switch(clk){
         case 2970:
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-        case 2975:              // FOR 1080P/i 720p mode with clock*0.999
+		case 2975:		// FOR 1080P/i 720p mode with clock*0.999
 #endif
             aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84000);
             aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a46c023);
             aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4123b100);
             aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00012385);
-
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000043d);
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4000043d);
             WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
             h_delay();
             aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00016385);   // optimise HPLL VCO 2.97GHz performance
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-            if( clk == 2975 )
-                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84d04); // lower div_frac to get clk*0.999
-            else
-                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84e00);
+			if( clk == 2975 )
+				aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84cf8); // lower div_frac to get clk*0.999
+			else
+				aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84e00);
 #else
             aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84e00);
 #endif
             break;
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-        case 2161:
+		case 2161:/*for N200/M200 480p59hz*/
             aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84f48);
             aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a46c023);
             aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
@@ -321,8 +242,8 @@ static void set_hpll_clk_out(unsigned clk)
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4001042c);
             WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
             break;
-#endif                     
-    case 2160:
+#endif			
+        case 2160:
             aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84000);
             aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a46c023);
             aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
@@ -331,7 +252,7 @@ static void set_hpll_clk_out(unsigned clk)
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4001042d);
             WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
             break;
-	case 1296:
+        case 1296:
             aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c88000);
             aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0xca49b022);
             aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0023b100);
@@ -339,147 +260,14 @@ static void set_hpll_clk_out(unsigned clk)
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x600c0436);
             aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x400c0436);
             aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x00016385);
-            WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
+			WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
+            break;
+        default:
+            printk("error hpll clk: %d\n", clk);
             break;
-    case 1422:	/* VMODE_800P */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c000);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000043b);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4000043b);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c40f);
-	    break;
-    case 2380:	/* VMODE_800X480P_60HZ */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60010431);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40010431);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c994);
-	    break;
-    case 1716:	/* VMODE_1366X768P_60HZ */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c000);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60000447);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40000447);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c7f8);
-	    break;
-    case 1600:	/* VMODE_800X600P_60HZ */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c000);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60000442);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40000442);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c506);
-	    break;
-    case 2058:	/* VMODE_1024X600P_60HZ */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6001042a);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4001042a);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8cdf4);
-	    break;
-    case 2560:	/* VMODE_480X800P_60HZ */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60010435);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40010435);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c294);
-	    break;
-    case 2600:	/* VMODE_1024X768P_60HZ */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60010436);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40010436);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c294);
-	    break;
-    case 1710:	/* VMODE_1360X768P_60HZ */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c000);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60000447);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40000447);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c3ac);
-	    break;
-    case 2130:	/* VMODE_1440X900P_60HZ */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6001042c);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4001042c);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c74f);
-	    break;
-    case 2925:	/* VMODE_1680X1050P_60HZ */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c80000);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6001043c);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4001043c);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8cfb4);
-	    break;
-    case 1540:	/* VMODE_1920x1200 */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c2ab);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60000440);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40000440);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    break;
-    case 2014:	/* VMODE_VGA */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c8cf55);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x0a563823);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x0123b100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12385);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x60010429);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x40010429);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    break;
-    case 1058:	/* VMODE_SVGA */
-	    WRITE_CBUS_REG(HHI_VID_PLL_CNTL, 0x422);
-	    break;
-    case 1086:	/* VMODE_XGA */
-	    WRITE_CBUS_REG(HHI_VID_PLL_CNTL, 0x43e);
-	    break;
-    case 1080:	/* VMODE_SXGA */
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8c000);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL4, 0x4023d100);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a7ad023);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, 0x12286);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x6000042d);
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4000042d);
-	    WAIT_FOR_PLL_LOCKED(P_HHI_VID_PLL_CNTL);
-	    break;
-    default:
-	    printk("error hpll clk: %d\n", clk);
-	    break;
     }
     if(clk < 2970)
-	    aml_write_reg32(P_HHI_VID_PLL_CNTL5, (aml_read_reg32(P_HHI_VID_PLL_CNTL5) & (~(0xf << 12))) | (0x6 << 12));
+        aml_write_reg32(P_HHI_VID_PLL_CNTL5, (aml_read_reg32(P_HHI_VID_PLL_CNTL5) & (~(0xf << 12))) | (0x6 << 12));
 #endif
 
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
@@ -507,22 +295,12 @@ static void set_hpll_clk_out(unsigned clk)
             break;
     }
 #endif
-
-#if defined(CONFIG_MACH_MESON8B_ODROIDC)
-	/* Improve HDMI HPLL Long TIE
-	 * 1296MHz is only for 480cvbs/576cvbs on m8 serials
-	 * and is not suitable with 0x8a56d023
-	 *
-	 * http://forum.odroid.com/viewtopic.php?f=117&t=15860&p=104507#p104507
-	 */
-	if (voutmode_vga() && clk != 1296)
-		aml_write_reg32(P_HHI_VID_PLL_CNTL3, 0x8a56d023);
-#endif
     printk("config HPLL done\n");
 }
 
 static void set_hpll_hdmi_od(unsigned div)
 {
+    check_clk_config(div);
     switch(div){
         case 1:
             WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 0, 18, 2);
@@ -531,7 +309,11 @@ static void set_hpll_hdmi_od(unsigned div)
             WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 1, 18, 2);
             break;
         case 4:
-            WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 2, 18, 2);
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6           
+			WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 3, 18, 2);
+#else                                                 
+			WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 2, 18, 2);
+#endif  
             break;
         case 8:
             WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 1, 16, 2);
@@ -545,6 +327,7 @@ static void set_hpll_hdmi_od(unsigned div)
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 static void set_hpll_lvds_od(unsigned div)
 {
+    check_clk_config(div);
     switch(div) {
         case 1:
             aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0, 16, 2);
@@ -588,6 +371,7 @@ int set_viu_path(unsigned viu_channel_sel, viu_type_e viu_type_sel)
 
 static void set_vid_pll_div(unsigned div)
 {
+    check_clk_config(div);
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON6
     // Gate disable
     WRITE_CBUS_REG_BITS(HHI_VID_DIVIDER_CNTL, 0, 16, 1);
@@ -651,6 +435,7 @@ static void set_vid_pll_div(unsigned div)
 
 static void set_clk_final_div(unsigned div)
 {
+    check_clk_config(div);
     if(div == 0)
         div = 1;
     WRITE_CBUS_REG_BITS(HHI_VID_CLK_CNTL, 1, 19, 1);
@@ -663,17 +448,26 @@ static void set_hdmi_tx_pixel_div(unsigned div)
 {
     check_div();
     WRITE_CBUS_REG_BITS(HHI_HDMI_CLK_CNTL, div, 16, 4);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    WRITE_CBUS_REG_BITS(HHI_VID_CLK_CNTL2, 1, 5, 1);
+#endif
 }
 static void set_encp_div(unsigned div)
 {
     check_div();
     WRITE_CBUS_REG_BITS(HHI_VID_CLK_DIV, div, 24, 4);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    WRITE_CBUS_REG_BITS(HHI_VID_CLK_CNTL2, 1, 2, 1);
+#endif
 }
 
 static void set_enci_div(unsigned div)
 {
     check_div();
     WRITE_CBUS_REG_BITS(HHI_VID_CLK_DIV, div, 28, 4);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    WRITE_CBUS_REG_BITS(HHI_VID_CLK_CNTL2, 1, 0, 1);
+#endif
 }
 
 static void set_enct_div(unsigned div)
@@ -686,12 +480,18 @@ static void set_encl_div(unsigned div)
 {
     check_div();
     WRITE_CBUS_REG_BITS(HHI_VIID_CLK_DIV, div, 12, 4);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    WRITE_CBUS_REG_BITS(HHI_VID_CLK_CNTL2, 1, 3, 1);
+#endif
 }
 
 static void set_vdac0_div(unsigned div)
 {
     check_div();
     WRITE_CBUS_REG_BITS(HHI_VIID_CLK_DIV, div, 28, 4);
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    WRITE_CBUS_REG_BITS(HHI_VID_CLK_CNTL2, 1, 4, 1);
+#endif
 }
 
 static void set_vdac1_div(unsigned div)
@@ -709,8 +509,8 @@ static enc_clk_val_t setting_enc_clk_val_m8m2[] = {
 		{VMODE_480CVBS,    1296, 4, 1, 1, VIU_ENCI,  6, 4, 2,-1,  2, -1, -1,  2,  -1},
 		{VMODE_480P,       2160, 8, 1, 1, VIU_ENCP,  5, 4, 2, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-                {VMODE_480P_59HZ,  2161, 8, 1, 1, VIU_ENCP,  5, 4, 2, 1, -1, -1, -1,  1,  -1},
-#endif         
+		{VMODE_480P_59HZ,  2161, 8, 1, 1, VIU_ENCP,  5, 4, 2, 1, -1, -1, -1,  1,  -1},
+#endif		
 		{VMODE_480P_RPT,   2160, 2, 1, 1, VIU_ENCP,  5, 4, 1, 2, -1, -1, -1,  1,  -1},
 		{VMODE_576I,       2160, 8, 1, 1, VIU_ENCI,  5, 4, 2,-1,  2, -1, -1,  2,  -1},
 		{VMODE_576I_RPT,   2160, 4, 1, 1, VIU_ENCI,  5, 4, 2,-1,  4, -1, -1,  2,  -1},
@@ -719,36 +519,37 @@ static enc_clk_val_t setting_enc_clk_val_m8m2[] = {
 		{VMODE_576P_RPT,   2160, 2, 1, 1, VIU_ENCP,  5, 4, 1, 2, -1, -1, -1,  1,  -1},
 		{VMODE_720P,       2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-               // 2975 for hpll: vco2970 * 0.999
-                {VMODE_720P,       2975, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
+		// 2975 for hpll: vco2970 * 0.999
+		{VMODE_720P_59HZ,  2975, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 #endif
 		{VMODE_1080I,      2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-                {VMODE_1080I_59HZ, 2975, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
+		{VMODE_1080I_59HZ, 2975, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 #endif
 		{VMODE_1080P,      2970, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
+		{VMODE_1080P,      2970, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-                // 2975 for hpll: vco2970 * 0.999
-                {VMODE_1080P,      2975, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
+		// 2975 for hpll: vco2970 * 0.999
+		{VMODE_1080P_59HZ, 2975, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
 #endif
 		{VMODE_720P_50HZ,  2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 		{VMODE_1080I_50HZ, 2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 		{VMODE_1080P_50HZ, 2970, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
 		{VMODE_1080P_24HZ, 2970, 4, 2, 1, VIU_ENCP, 10, 2, 1, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-               // 2975 for hpll: vco2970 * 0.999
-                {VMODE_1080P_24HZ, 2975, 4, 2, 1, VIU_ENCP, 10, 2, 1, 1, -1, -1, -1,  1,  -1},
+		// 2975 for hpll: vco2970 * 0.999
+		{VMODE_1080P_23HZ, 2975, 4, 2, 1, VIU_ENCP, 10, 2, 1, 1, -1, -1, -1,  1,  -1},
 #endif
 		{VMODE_4K2K_30HZ,  2971, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-               // 2976 for hpll: vco2970(4k) * 0.999
-                {VMODE_4K2K_30HZ,  2976, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
+		// 2976 for hpll: vco2970(4k) * 0.999
+		{VMODE_4K2K_29HZ,  2976, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
 #endif
 		{VMODE_4K2K_25HZ,  2971, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
 		{VMODE_4K2K_24HZ,  2971, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-               // 2976 for hpll: vco2970(4k) * 0.999
-                {VMODE_4K2K_24HZ,  2976, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
+		// 2976 for hpll: vco2970(4k) * 0.999
+		{VMODE_4K2K_23HZ,  2976, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
 #endif
 		{VMODE_4K2K_SMPTE, 2971, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
 		{VMODE_VGA,  1066, 3, 1, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  1},
@@ -756,56 +557,43 @@ static enc_clk_val_t setting_enc_clk_val_m8m2[] = {
 		{VMODE_XGA, 1085, 1, 1, 1, VIU_ENCP, 5, 1, 1, 1, -1, -1, -1,  1,  1},
 };
 static enc_clk_val_t setting_enc_clk_val[] = {
+
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-    {VMODE_480X320P_60HZ, 2014, 8, 1, 1, VIU_ENCP, 10, 4, 1, 1, -1, -1, -1, 1, -1},
-    {VMODE_480X272P_60HZ, 2014, 8, 1, 1, VIU_ENCP, 10, 4, 1, 1, -1, -1, -1, 1, -1},
     {VMODE_480I,       2160, 8, 1, 1, VIU_ENCI,  5, 4, 2,-1,  2, -1, -1,  2,  -1},
     {VMODE_480CVBS,    1296, 4, 1, 1, VIU_ENCI,  6, 4, 2,-1,  2, -1, -1,  2,  -1},
     {VMODE_480P,       2160, 8, 1, 1, VIU_ENCP,  5, 4, 2, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    {VMODE_480P_59HZ,  2161, 8, 1, 1, VIU_ENCP,  5, 4, 2, 1, -1, -1, -1,  1,  -1},
-#endif
+	{VMODE_480P_59HZ,  2161, 8, 1, 1, VIU_ENCP,  5, 4, 2, 1, -1, -1, -1,  1,  -1},
+#endif	
     {VMODE_576I,       2160, 8, 1, 1, VIU_ENCI,  5, 4, 2,-1,  2, -1, -1,  2,  -1},
     {VMODE_576CVBS,    1296, 4, 1, 1, VIU_ENCI,  6, 4, 2,-1,  2, -1, -1,  2,  -1},
     {VMODE_576P,       2160, 8, 1, 1, VIU_ENCP,  5, 4, 2, 1, -1, -1, -1,  1,  -1},
     {VMODE_720P,       2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-       // 2975 for hpll: vco2970 * 0.999
-    {VMODE_720P,       2975, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
-#endif
-    {VMODE_800P,       1422, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1}, // MDRJR Verify
-    {VMODE_800X480P_60HZ, 2380, 8, 4, 1, VIU_ENCP,  10, 4, 1, 1, -1, -1, -1,  1,  -1},
-    {VMODE_480X800P_60HZ, 2560, 8, 4, 1, VIU_ENCP,  10, 4, 1, 1, -1, -1, -1,  1,  -1},
-    {VMODE_1366X768P_60HZ, 1716, 2, 2, 1, VIU_ENCP,  10, 1, 1, 1, -1, -1, -1,  1,  -1},
-    {VMODE_1600X900P_60HZ, 2160, 2, 2, 1, VIU_ENCP,  10, 1, 1, 1, -1, -1, -1,  1,  -1},
-    {VMODE_800X600P_60HZ, 1600, 4, 4, 1, VIU_ENCP,  10, 1, 1, 1, -1, -1, -1,  1,  -1},
-    {VMODE_1024X600P_60HZ, 2058, 4, 4, 1, VIU_ENCP,  10, 1, 1, 1, -1, -1, -1,  1,  -1},
-    {VMODE_1024X768P_60HZ, 2600, 4, 4, 1, VIU_ENCP,  10, 1, 1, 1, -1, -1, -1,  1,  -1},
-    {VMODE_1360X768P_60HZ, 1710, 2, 2, 1, VIU_ENCP,  10, 1, 1, 1, -1, -1, -1,  1,  -1},
-    {VMODE_1440X900P_60HZ, 2130, 2, 2, 1, VIU_ENCP,  10, 1, 1, 1, -1, -1, -1,  1,  -1},
-    {VMODE_1680X1050P_60HZ, 2925, 2, 2, 1, VIU_ENCP,  10, 1, 1, 1, -1, -1, -1,  1,  -1},
+	// 2975 for hpll: vco2970 * 0.999
+	{VMODE_720P_59HZ,  2975, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
+#endif
     {VMODE_1080I,      2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    {VMODE_1080I_59HZ, 2975, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
+	{VMODE_1080I_59HZ, 2975, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 #endif
     {VMODE_1080P,      2970, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
+    {VMODE_1080P,      2970, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-       // 2975 for hpll: vco2970 * 0.999
-    {VMODE_1080P,      2975, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
+	// 2975 for hpll: vco2970 * 0.999
+	{VMODE_1080P_59HZ, 2975, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
 #endif
     {VMODE_720P_50HZ,  2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
     {VMODE_1080I_50HZ, 2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
     {VMODE_1080P_50HZ, 2970, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
     {VMODE_1080P_24HZ, 2970, 4, 2, 1, VIU_ENCP, 10, 2, 1, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    // 2975 for hpll: vco2970 * 0.999
-    {VMODE_1080P_24HZ, 2975, 4, 2, 1, VIU_ENCP, 10, 2, 1, 1, -1, -1, -1,  1,  -1},
+	// 2975 for hpll: vco2970 * 0.999
+	{VMODE_1080P_23HZ, 2975, 4, 2, 1, VIU_ENCP, 10, 2, 1, 1, -1, -1, -1,  1,  -1},
 #endif
-    {VMODE_VGA,        2014, 8, 1, 1, VIU_ENCP, 10, 4, 1, 1, -1, -1, -1,  1,  -1},
-    {VMODE_SVGA,       1058, 2, 1, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,   1},
-    {VMODE_XGA,        1085, 1, 1, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,   1},
-    {VMODE_SXGA,       2160, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
-    {VMODE_1920x1200,  1540, 1, 1, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
+    {VMODE_VGA,  1066, 3, 1, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  1},
+    {VMODE_SVGA, 1058, 2, 1, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  1},
+    {VMODE_XGA, 1085, 1, 1, 1, VIU_ENCP, 5, 1, 1, 1, -1, -1, -1,  1,  1},
 #endif
 
 #if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
@@ -814,7 +602,7 @@ static enc_clk_val_t setting_enc_clk_val[] = {
     {VMODE_480CVBS,    1296, 4, 1, 1, VIU_ENCI,  6, 4, 2,-1,  2, -1, -1,  2,  -1},
     {VMODE_480P,       1080, 4, 1, 1, VIU_ENCP,  5, 4, 2, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    {VMODE_480P_59HZ,  1081, 4, 1, 1, VIU_ENCP,  5, 4, 2, 1, -1, -1, -1,  1,  -1},
+	{VMODE_480P_59HZ,  1081, 4, 1, 1, VIU_ENCP,  5, 4, 2, 1, -1, -1, -1,  1,  -1},
 #endif
     {VMODE_480P_RPT,   2160, 2, 1, 1, VIU_ENCP,  5, 4, 1, 2, -1, -1, -1,  1,  -1},
     {VMODE_576I,       1080, 4, 1, 1, VIU_ENCI,  5, 4, 2,-1,  2, -1, -1,  2,  -1},
@@ -824,32 +612,37 @@ static enc_clk_val_t setting_enc_clk_val[] = {
     {VMODE_576P_RPT,   2160, 2, 1, 1, VIU_ENCP,  5, 4, 1, 2, -1, -1, -1,  1,  -1},
     {VMODE_720P,       2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    // 2975 for hpll: vco2970 * 0.999
-    {VMODE_720P_59HZ,  2975, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
+	// 2975 for hpll: vco2970 * 0.999
+	{VMODE_720P_59HZ,  2975, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 #endif
-    {VMODE_1080I,      2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
+	{VMODE_1080I,      2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    {VMODE_1080I_59HZ, 2975, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
+	{VMODE_1080I_59HZ, 2975, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
 #endif
     {VMODE_1080P,      2970, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
+    {VMODE_1080P,      2970, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+	// 2975 for hpll: vco2970 * 0.999
+	{VMODE_1080P_59HZ, 2975, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
+#endif
     {VMODE_720P_50HZ,  2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
     {VMODE_1080I_50HZ, 2970, 4, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
     {VMODE_1080P_50HZ, 2970, 2, 2, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
     {VMODE_1080P_24HZ, 2970, 4, 2, 1, VIU_ENCP, 10, 2, 1, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    // 2975 for hpll: vco2970 * 0.999
-    {VMODE_1080P_23HZ, 2975, 4, 2, 1, VIU_ENCP, 10, 2, 1, 1, -1, -1, -1,  1,  -1},
+	// 2975 for hpll: vco2970 * 0.999
+	{VMODE_1080P_23HZ, 2975, 4, 2, 1, VIU_ENCP, 10, 2, 1, 1, -1, -1, -1,  1,  -1},
 #endif
     {VMODE_4K2K_30HZ,  2971, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    // 2976 for hpll: vco2970(4k) * 0.999
-    {VMODE_4K2K_29HZ,  2976, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
+	// 2976 for hpll: vco2970(4k) * 0.999
+	{VMODE_4K2K_29HZ,  2976, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
 #endif
     {VMODE_4K2K_25HZ,  2971, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
     {VMODE_4K2K_24HZ,  2971, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    // 2976 for hpll: vco2970(4k) * 0.999
-    {VMODE_4K2K_23HZ,  2976, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
+	// 2976 for hpll: vco2970(4k) * 0.999
+	{VMODE_4K2K_23HZ,  2976, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
 #endif
     {VMODE_4K2K_SMPTE, 2971, 1, 2, 1, VIU_ENCP,  5, 1, 1, 1, -1, -1, -1,  1,  -1},
     {VMODE_VGA,  1066, 3, 1, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  1},
@@ -867,15 +660,24 @@ static enc_clk_val_t setting_enc_clk_val[] = {
     {VMODE_720P,       1488, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
     {VMODE_1080I,      1488, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
     {VMODE_1080P,      1488, 1, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
+    {VMODE_1080P,      1488, 1, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
     {VMODE_720P_50HZ,  1488, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
     {VMODE_1080I_50HZ, 1488, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  -1},
     {VMODE_1080P_50HZ, 1488, 1, 1, VIU_ENCP, 10, 1, 1, 1, -1, -1, -1,  1,  -1},
     {VMODE_1080P_24HZ, 1488, 2, 1, VIU_ENCP, 10, 2, 1, 1, -1, -1, -1,  1,  -1},
-    {VMODE_VGA,  1066, 3, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  1},
-    {VMODE_SVGA, 1058, 2, 1, VIU_ENCP, 10, 1, 2, 1, -1, -1, -1,  1,  1},
-    {VMODE_XGA, 1085, 1, 1, VIU_ENCP, 5, 1, 1, 1, -1, -1, -1,  1,  1},
+    {VMODE_4K2K_30HZ,  2970, 1, 2, VIU_ENCP, 5, 1, 1, 1, -1, -1, -1,  1,  -1},
+    {VMODE_4K2K_25HZ,  2970, 1, 2, VIU_ENCP, 5, 1, 1, 1, -1, -1, -1,  1,  -1},
+    {VMODE_4K2K_24HZ,  2970, 1, 2, VIU_ENCP, 5, 1, 1, 1, -1, -1, -1,  1,  -1},
+    {VMODE_4K2K_SMPTE, 2970, 1, 2, VIU_ENCP, 5, 1, 1, 1, -1, -1, -1,  1,  -1},
+    {VMODE_VGA,        -1, -1, 1, VIU_ENCP, -1, -1, -1, 1, -1, -1, -1,  1,  1},
+    {VMODE_SVGA,       -1, -1, 1, VIU_ENCP, -1, -1, -1, 1, -1, -1, -1,  1,  1},
+    {VMODE_XGA,        -1, -1, 1, VIU_ENCP, -1, -1, -1, 1, -1, -1, -1,  1,  1},
+    {VMODE_SXGA,       -1, -1, 1, VIU_ENCP, -1, -1, -1, 1, -1, -1, -1,  1,  1},
+    {VMODE_WSXGA,      -1, -1, 1, VIU_ENCP, -1, -1, -1, 1, -1, -1, -1,  1,  1},
+    {VMODE_FHDVGA,     -1, -1, 1, VIU_ENCP, -1, -1, -1, 1, -1, -1, -1,  1,  1},
 #endif
 };
+
 static DEFINE_MUTEX(setclk_mutex);
 
 void set_vmode_clk(vmode_t mode)
@@ -883,7 +685,8 @@ void set_vmode_clk(vmode_t mode)
     enc_clk_val_t *p_enc =NULL;
 
     int i = 0;
-    int j = 0; 
+    int j = 0;
+
     mutex_lock(&setclk_mutex);
 	if(IS_MESON_M8M2_CPU){
 		p_enc=&setting_enc_clk_val_m8m2[0];
@@ -902,13 +705,7 @@ void set_vmode_clk(vmode_t mode)
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
     set_hpll_lvds_od(p_enc[j].hpll_lvds_od);
 #endif
-    mutex_unlock(&setclk_mutex);
-    
     set_hpll_hdmi_od(p_enc[j].hpll_hdmi_od);
-#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
-    if((mode == VMODE_800X600P_60HZ) || (mode == VMODE_1024X600P_60HZ) || (mode == VMODE_1024X768P_60HZ))
-        aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 2, 18, 2);
-#endif
     set_vid_pll_div(p_enc[j].vid_pll_div);
     set_clk_final_div(p_enc[j].clk_final_div);
     set_hdmi_tx_pixel_div(p_enc[j].hdmi_tx_pixel_div);
@@ -927,7 +724,7 @@ void set_vmode_clk(vmode_t mode)
         WRITE_CBUS_REG(HHI_VID_PLL_CNTL4, 0x42000101);
     }
 #endif
-    
+    mutex_unlock(&setclk_mutex);
 // For debug only
 #if 0
     printk("hdmi debug tag\n%s\n%s[%d]\n", __FILE__, __FUNCTION__, __LINE__);
@@ -988,3 +785,14 @@ void set_vmode_clk(vmode_t mode)
 #endif
 }
  
+unsigned int reset_hpll(void)
+{
+    aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0x0, 29, 2);
+    msleep(1);
+    aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0x3, 29, 2);
+    msleep(1);
+    aml_set_reg32_bits(P_HHI_VID_PLL_CNTL, 0x2, 29, 2);
+    msleep(20);
+    printk("%s[%d]\n", __func__, __LINE__);
+    return !!(aml_read_reg32(P_HHI_VID_PLL_CNTL) & (1 << 31));
+}
diff --git a/drivers/amlogic/display/vout/lcd_extern/Makefile b/drivers/amlogic/display/vout/lcd_extern/Makefile
index 3a5b2b01..9ffac066 100755
--- a/drivers/amlogic/display/vout/lcd_extern/Makefile
+++ b/drivers/amlogic/display/vout/lcd_extern/Makefile
@@ -2,5 +2,5 @@
 obj-y	+= lcd_extern.o
 obj-y	+= i2c_tc101.o
 obj-y	+= mipi_N070ICN.o
+obj-y	+= mipi_KD080D13.o
 obj-y	+= spi_LD070WS2.o
-
diff --git a/drivers/amlogic/display/vout/lcd_extern/aml.dtd b/drivers/amlogic/display/vout/lcd_extern/aml.dtd
index ca49f7b1..b8d6f09a 100755
--- a/drivers/amlogic/display/vout/lcd_extern/aml.dtd
+++ b/drivers/amlogic/display/vout/lcd_extern/aml.dtd
@@ -1,6 +1,6 @@
 #ifdef CONFIG_AM_LCD_OUTPUT
 //******************************************************************************
-//lcd extern 
+//lcd extern
 //Notice: only one dev support
 //******************************************************************************
 //$$ DEVICE = "lcd_extern_i2c_tc101"
@@ -44,5 +44,32 @@
 
 		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
 	};
+	
+//$$ DEVICE = "lcd_extern_mipi_KD080D13"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "type"
+	lcd_extern_mipi_KD080D13{
+		compatible = "amlogic,lcd_mipi_KD080D13";
+		dev_name ="lcd_mipi_KD080D13";
+		status = "disabled";
+
+		type = <2>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+	};
+	
+//$$ DEVICE = "lcd_extern_edp_ANX6345"
+//$$ L2 PROP_STR = "status"
+//$$ L2 PROP_U32 = "type"
+	lcd_extern_edp_ANX6345{
+		compatible = "amlogic,lcd_anx6345";
+		dev_name ="lcd_anx6345";
+		status = "disabled";
 
+		type = <0>;	/** lcd_extern_driver type: 0=i2c, 1=spi, 2=mipi */
+		i2c_address = <0x38>; /** i2c address */
+		i2c_bus = "i2c_bus_b";
+		lane_num = <1>; /** edp lane_num:1/2/4 */
+		bits = <0>;  /** bits of lcd(0: 6bit, 1: 8bit) */
+		link_rate = <1>; /** edp link rate (0: 1.62G, 1: 27G, 2: 5.4G) */
+	};	
+	
 #endif
diff --git a/drivers/amlogic/display/vout/lcd_extern/edp_anx6345.c b/drivers/amlogic/display/vout/lcd_extern/edp_anx6345.c
new file mode 100644
index 00000000..df5d433f
--- /dev/null
+++ b/drivers/amlogic/display/vout/lcd_extern/edp_anx6345.c
@@ -0,0 +1,587 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * I2C 
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h> 
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#include "edp_anx6345.h"
+
+static struct lcd_extern_config_t *lcd_extern_config = NULL;
+                          
+static struct i2c_client *aml_anx6345_70_client;
+static struct i2c_client *aml_anx6345_72_client;
+
+const char *anx_addr_name[2] = {"anx6345_70","anx6345_72"};
+static unsigned edp_tx_lane = 1;
+
+//#define LCD_EXT_DEBUG_INFO
+#ifdef LCD_EXT_DEBUG_INFO
+#define DBG_PRINT(...)		printk(__VA_ARGS__)
+#else
+#define DBG_PRINT(...)
+#endif
+
+#define LCD_EXTERN_NAME			"lcd_anx6345"
+
+
+static int aml_i2c_write(struct i2c_client *i2client,unsigned char *buff, unsigned len)
+{
+    int res = 0;
+    struct i2c_msg msg[] = {
+        {
+        .addr = i2client->addr,
+        .flags = 0,
+        .len = len,
+        .buf = buff,
+        }
+    };
+    
+    res = i2c_transfer(i2client->adapter, msg, 1);
+    if (res < 0) {
+        printk("%s: i2c transfer failed [addr 0x%02x]\n", __FUNCTION__, i2client->addr);
+    }
+    
+    return res;
+}
+
+static int aml_i2c_read(struct i2c_client *i2client,unsigned char *buff, unsigned len)
+{
+    int res = 0;
+    struct i2c_msg msgs[] = {
+        {
+            .addr = i2client->addr,
+            .flags = 0,
+            .len = 1,
+            .buf = buff,
+        },
+        {
+            .addr = i2client->addr,
+            .flags = I2C_M_RD,
+            .len = len,
+            .buf = buff,
+        }
+    };
+    res = i2c_transfer(i2client->adapter, msgs, 2);
+    if (res < 0) {
+        printk("%s: i2c transfer failed [addr 0x%02x]\n", __FUNCTION__, i2client->addr);
+    }
+
+    return res;
+}
+
+static int i2c_reg_read(unsigned char reg, unsigned char *buf)
+{
+    int ret = 0;
+
+    return ret;
+}
+
+static int i2c_reg_write(unsigned char reg, unsigned char value)
+{
+    int ret=0;
+
+    return ret;
+}
+static int SP_TX_Write_Reg(unsigned char addr,unsigned char reg ,unsigned char data)
+{
+	struct i2c_client *client =aml_anx6345_70_client;
+	unsigned char buff[2];
+	int ret;
+	buff[0] = reg;
+	buff[1] = data;
+	if (addr == 0x70){
+		client=aml_anx6345_70_client;
+	}	
+	else if (addr == 0x72){
+		client=aml_anx6345_72_client;
+	}
+
+	ret =aml_i2c_write(client,	buff, 1);
+	if (ret < 0)
+		return -1;
+	else
+		return 0;
+}
+
+static int SP_TX_Read_Reg(unsigned char addr,unsigned char reg ,unsigned char* data)
+{
+		struct i2c_client *client =aml_anx6345_70_client;
+		int ret;
+		*data = reg;
+
+		if (addr == 0x70){
+			client = aml_anx6345_70_client;
+		}	
+		else if (addr == 0x72){
+			client = aml_anx6345_72_client;
+		}
+					
+		ret = aml_i2c_read(client, data, 1);
+		if (ret < 0)
+			return -1;
+		else
+			return 0;
+}
+
+static int SP_TX_Wait_AUX_Finished(void)
+{
+	unsigned char c;
+	unsigned char cCnt;
+	cCnt = 0;
+
+	SP_TX_Read_Reg(0x70, SP_TX_AUX_STATUS, &c);
+	while(c & 0x10){//aux busy
+		cCnt++;
+		SP_TX_Read_Reg(0x70, SP_TX_AUX_STATUS, &c);
+
+		if(cCnt>100){
+			return 0; //aux fail
+		}
+	}
+
+	return 1;//aux ok
+}
+
+static int SP_TX_AUX_DPCDRead_Bytes(unsigned char addrh, unsigned char addrm, unsigned char addrl,unsigned char cCount,unsigned char *pBuf)
+{
+	unsigned char c,i;
+
+	//clr buffer
+	SP_TX_Write_Reg(0x70, SP_TX_BUF_DATA_COUNT_REG, 0x80);
+
+	//set read cmd and count
+	SP_TX_Write_Reg(0x70, SP_TX_AUX_CTRL_REG, ((cCount-1) <<4)|0x09);
+
+	//set aux address15:0
+	SP_TX_Write_Reg(0x70, SP_TX_AUX_ADDR_7_0_REG, addrl);
+	SP_TX_Write_Reg(0x70, SP_TX_AUX_ADDR_15_8_REG, addrm);
+
+	//set address19:16 and enable aux
+	SP_TX_Read_Reg(0x70, SP_TX_AUX_ADDR_19_16_REG, &c);
+	SP_TX_Write_Reg(0x70, SP_TX_AUX_ADDR_19_16_REG, (c & 0xf0) | addrh);
+
+	//Enable Aux
+	SP_TX_Read_Reg(0x70, SP_TX_AUX_CTRL_REG2, &c);
+	SP_TX_Write_Reg(0x70, SP_TX_AUX_CTRL_REG2, c|0x01);
+
+	mdelay(5);
+	if(!SP_TX_Wait_AUX_Finished())
+	return 0;
+
+	for(i =0;i<cCount;i++) {
+		SP_TX_Read_Reg(0x70, SP_TX_BUF_DATA_0_REG+i, &c);
+
+		*(pBuf+i) = c;
+
+		if(i >= MAX_BUF_CNT)
+		break;
+	}
+
+	return 1;//aux ok
+}
+
+static int lcd_extern_i2c_init(void)
+{
+		unsigned lane_num;
+		unsigned link_rate;
+		unsigned char bits;
+		unsigned char device_id;
+		unsigned char temp;
+		unsigned char temp1;
+		unsigned count =0;
+		unsigned count1 =0;
+		lane_num = edp_tx_lane; //1 lane
+		link_rate = VAL_EDP_TX_LINK_BW_SET_270; //2.7G
+		bits =0; //0x00: 6bit;  0x10:8bit
+		SP_TX_Write_Reg (0x72, 0x05, 0x00);
+		
+		SP_TX_Read_Reg(0x72, 0x01, &device_id);
+		
+		if(device_id==0xaa) {
+			printk("ANX6345 Chip found\n\n\n");
+		}	else {
+			printk("ANX6345 Chip not found\n\n\n");
+			return 1;
+		}
+		temp = device_id;
+		//if aux read fail, do h/w reset,
+		while((!SP_TX_AUX_DPCDRead_Bytes(0x00,0x00,0x00,1,&temp1))&&(count<200)) {
+			//read fail, h/w reset
+			SP_TX_Write_Reg (0x72, 0x06, 0x01);
+			SP_TX_Write_Reg (0x72, 0x06, 0x00);
+			SP_TX_Write_Reg (0x72, 0x05, 0x00);
+			mdelay(10);
+			count++;
+		}
+		
+		//software reset
+		SP_TX_Read_Reg(0x72, SP_TX_RST_CTRL_REG, &temp);
+		SP_TX_Write_Reg(0x72, SP_TX_RST_CTRL_REG, temp | SP_TX_RST_SW_RST);
+		SP_TX_Write_Reg(0x72, SP_TX_RST_CTRL_REG, temp & ~SP_TX_RST_SW_RST);
+		
+		SP_TX_Write_Reg(0x70, SP_TX_EXTRA_ADDR_REG, 0x50);//EDID address for AUX access
+		SP_TX_Write_Reg(0x70, SP_TX_HDCP_CTRL, 0x00);	//disable HDCP polling mode.
+		//SP_TX_Write_Reg(0x70, SP_TX_HDCP_CTRL, 0x02);	//Enable HDCP polling mode.
+		SP_TX_Write_Reg(0x70, SP_TX_LINK_DEBUG_REG, 0x30);//enable M value read out
+		
+		//SP_TX_Read_Reg(0x70, SP_TX_DEBUG_REG1, &temp);
+		SP_TX_Write_Reg(0x70, SP_TX_DEBUG_REG1, 0x00);//disable polling HPD
+		
+		SP_TX_Read_Reg(0x70, SP_TX_HDCP_CONTROL_0_REG, &temp);
+		SP_TX_Write_Reg(0x70, SP_TX_HDCP_CONTROL_0_REG, temp | 0x03);//set KSV valid
+		
+		SP_TX_Read_Reg(0x70, SP_TX_AUX_CTRL_REG2, &temp);
+		SP_TX_Write_Reg(0x70, SP_TX_AUX_CTRL_REG2, temp|0x08);//set double AUX output
+		
+		SP_TX_Write_Reg(0x72, SP_COMMON_INT_MASK1, 0xbf);//unmask pll change int
+		SP_TX_Write_Reg(0x72, SP_COMMON_INT_MASK2, 0xff);//mask all int
+		SP_TX_Write_Reg(0x72, SP_COMMON_INT_MASK3, 0xff);//mask all int
+		SP_TX_Write_Reg(0x72, SP_COMMON_INT_MASK4, 0xff);//mask all int
+		
+		//reset AUX
+		SP_TX_Read_Reg(0x72, SP_TX_RST_CTRL2_REG, &temp);
+		SP_TX_Write_Reg(0x72, SP_TX_RST_CTRL2_REG, temp |SP_TX_AUX_RST);
+		SP_TX_Write_Reg(0x72, SP_TX_RST_CTRL2_REG, temp & (~SP_TX_AUX_RST));
+		
+		//Chip initialization
+		
+		SP_TX_Write_Reg(0x70, SP_TX_SYS_CTRL1_REG, 0x00);
+		mdelay(10);
+		
+			SP_TX_Write_Reg(0x72, SP_TX_VID_CTRL2_REG, bits);
+		
+		//ANX6345 chip analog setting
+		SP_TX_Write_Reg(0x70, SP_TX_PLL_CTRL_REG, 0x00);				  //UPDATE: FROM 0X07 TO 0X00
+		
+		//ANX chip analog setting
+		//	SP_TX_Write_Reg(0x72, ANALOG_DEBUG_REG1, 0x70); 			  //UPDATE: FROM 0XF0 TO 0X70
+		SP_TX_Write_Reg(0x70, SP_TX_LINK_DEBUG_REG, 0x30);
+		
+		//force HPD
+		SP_TX_Write_Reg(0x70, SP_TX_SYS_CTRL3_REG, 0x30);
+		
+		/* enable ssc function */
+		SP_TX_Write_Reg(0x70, 0xA7, 0x00); 		          // disable SSC first
+		SP_TX_Write_Reg(0x70, 0xD0, 0x5f);              // ssc d  0.4%, f0/4 mode
+		SP_TX_Write_Reg(0x70, 0xD1, 0x00);
+		SP_TX_Write_Reg(0x70, 0xD2, 0x75);              // ctrl_th
+		SP_TX_Read_Reg(0x70, 0xA7, &temp);
+		SP_TX_Write_Reg(0x70, 0xA7, temp | 0x10);          // enable SSC
+		SP_TX_Read_Reg(0x72, 0x07, &temp);                 //reset SSC
+		SP_TX_Write_Reg(0x72, 0x07, temp | 0x80);
+		SP_TX_Write_Reg(0x72, 0x07, temp & (~0x80));
+		
+		//Select 2.7G
+		SP_TX_Write_Reg(0x70, SP_TX_LINK_BW_SET_REG, link_rate);		//2.7g:0x0a;1.62g:0x06
+		//Select 2 lanes
+		SP_TX_Write_Reg(0x70, 0xa1, lane_num);
+		
+		SP_TX_Write_Reg(0x70, SP_TX_LINK_TRAINING_CTRL_REG, SP_TX_LINK_TRAINING_CTRL_EN);
+		mdelay(5);
+		SP_TX_Read_Reg(0x70, SP_TX_LINK_TRAINING_CTRL_REG, &temp);
+		/* UPDATE: FROM 0X01 TO 0X80 */
+		while((temp&0x80)!=0) {
+			//debug_puts("Waiting...\n");
+			mdelay(5);
+			count1 ++;
+			if(count1 > 100) {
+				printk("ANX6345 Link training fail\n");
+				break;
+			}
+			SP_TX_Read_Reg(0x70, SP_TX_LINK_TRAINING_CTRL_REG, &temp);
+		}
+		
+
+		SP_TX_Write_Reg(0x72, 0x12, 0x2c);
+		SP_TX_Write_Reg(0x72, 0x13, 0x06);
+		SP_TX_Write_Reg(0x72, 0x14, 0x00);
+		SP_TX_Write_Reg(0x72, 0x15, 0x06);
+		SP_TX_Write_Reg(0x72, 0x16, 0x02);
+		SP_TX_Write_Reg(0x72, 0x17, 0x04);
+		SP_TX_Write_Reg(0x72, 0x18, 0x26);
+		SP_TX_Write_Reg(0x72, 0x19, 0x50);
+		SP_TX_Write_Reg(0x72, 0x1a, 0x04);
+		SP_TX_Write_Reg(0x72, 0x1b, 0x00);
+		SP_TX_Write_Reg(0x72, 0x1c, 0x04);
+		SP_TX_Write_Reg(0x72, 0x1d, 0x18);
+		SP_TX_Write_Reg(0x72, 0x1e, 0x00);
+		SP_TX_Write_Reg(0x72, 0x1f, 0x10);
+		SP_TX_Write_Reg(0x72, 0x20, 0x00);
+		SP_TX_Write_Reg(0x72, 0x21, 0x28);
+		
+		SP_TX_Write_Reg(0x72, 0x11, 0x03);
+	//enable BIST. In normal mode, don't need to config this reg
+	//if want to open BIST,must setting right dat 0x11-0x21 base lcd timing.	
+	//	SP_TX_Write_Reg(0x72, 0x0b, 0x09);//colorbar:08,graystep:09
+		SP_TX_Write_Reg(0x72, 0x08, 0x81);		//SDR:0x81;DDR:0x8f
+		
+		//force HPD and stream valid
+		SP_TX_Write_Reg(0x70, 0x82, 0x33);
+    printk("%s\n", __FUNCTION__);
+    return 0;
+}
+
+static int lcd_extern_i2c_remove(void)
+{
+    int ret=0;
+
+    return ret;
+}
+
+static int get_lcd_extern_config(struct device_node* of_node, struct lcd_extern_config_t *lcd_ext_cfg)
+{
+    int ret = 0;
+    struct aml_lcd_extern_driver_t* lcd_ext;
+
+    ret = get_lcd_extern_dt_data(of_node, lcd_ext_cfg);
+    if (ret) {
+        printk("[error] %s: failed to get dt data\n", LCD_EXTERN_NAME);
+        return ret;
+    }
+
+    //lcd extern driver update
+    lcd_ext = aml_lcd_extern_get_driver();
+    if (lcd_ext) {
+        lcd_ext->type      = lcd_ext_cfg->type;
+        lcd_ext->name      = lcd_ext_cfg->name;
+        lcd_ext->reg_read  = i2c_reg_read;
+        lcd_ext->reg_write = i2c_reg_write;
+        lcd_ext->power_on  = lcd_extern_i2c_init;
+        lcd_ext->power_off = lcd_extern_i2c_remove;
+    }
+    else {
+        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_cfg->name);
+        ret = -1;
+    }
+
+    return ret;
+}
+
+static int aml_anx6345_70_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        printk("[error] %s: functionality check failed\n", __FUNCTION__);
+        return -ENODEV;
+    }
+    else {
+        aml_anx6345_70_client = client;
+    }
+
+    printk("%s OK\n", __FUNCTION__);
+    return 0;
+}
+
+static int aml_anx6345_72_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+    if (!i2c_check_functionality(client->adapter, I2C_FUNC_I2C)) {
+        printk("[error] %s: functionality check failed\n", __FUNCTION__);
+        return -ENODEV;
+    }
+    else {
+        aml_anx6345_72_client = client;
+    }
+
+    printk("%s OK\n", __FUNCTION__);
+    return 0;
+}
+
+
+static int aml_anx6345_70_remove(struct i2c_client *client)
+{
+    return 0;
+}
+static int aml_anx6345_72_remove(struct i2c_client *client)
+{
+    return 0;
+}
+
+
+static const struct i2c_device_id aml_anx6345_70_id[]= {
+    {"anx6345_70", 0},
+    { }
+};
+static const struct i2c_device_id aml_anx6345_72_id[]= {
+    {"anx6345_72", 0},
+    { }
+};
+
+// MODULE_DEVICE_TABLE(i2c, aml_tc101_id);
+
+static struct i2c_driver aml_anx6345_70_driver= {
+    .probe    = aml_anx6345_70_probe,
+    .remove   = aml_anx6345_70_remove,
+    .id_table = aml_anx6345_70_id,
+    .driver = {
+        .name = "anx6345_70",
+        .owner =THIS_MODULE,
+    },
+};
+static struct i2c_driver aml_anx6345_72_driver= {
+    .probe    = aml_anx6345_72_probe,
+    .remove   = aml_anx6345_72_remove,
+    .id_table = aml_anx6345_72_id,
+    .driver = {
+        .name = "anx6345_72",
+        .owner =THIS_MODULE,
+    },
+};
+
+
+static int aml_anx6345_probe(struct platform_device *pdev)
+{
+    struct i2c_board_info i2c_info[2];
+    struct i2c_adapter *adapter;
+    struct i2c_client *i2c_client;
+    // struct lcd_extern_config_t extern_config[3];
+    int i = 0;
+    int ret = 0;
+
+    if (lcd_extern_driver_check()) {
+        return -1;
+    }
+    if (lcd_extern_config == NULL)
+        lcd_extern_config = kzalloc(sizeof(*lcd_extern_config), GFP_KERNEL);
+    if (lcd_extern_config == NULL) {
+        printk("[error] %s probe: failed to alloc data\n", LCD_EXTERN_NAME);
+        return -1;
+    }
+
+    pdev->dev.platform_data = lcd_extern_config;
+
+    ret = get_lcd_extern_config(pdev->dev.of_node, lcd_extern_config);
+    if (ret) {
+        goto lcd_extern_probe_failed;
+    }
+
+    for (i=0;i<2;i++) {
+        memset(&i2c_info[i], 0, sizeof(i2c_info[i]));
+    }
+
+    adapter = i2c_get_adapter(lcd_extern_config->i2c_bus);
+    if (!adapter) {
+        printk("[error] %sfailed to get i2c adapter\n", LCD_EXTERN_NAME);
+        goto lcd_extern_probe_failed;
+    }
+    for(i=0; i<2; i++){
+        strncpy(i2c_info[i].type, anx_addr_name[i], I2C_NAME_SIZE);
+    }
+    i2c_info[0].addr = 0x38;//0x70 >> 1;
+    i2c_info[1].addr = 0x39;//0x72 >>1;
+    for(i=0; i<2; i++){
+        //i2c_info[i].platform_data = extern_config[i];
+        i2c_info[i].flags = 0;
+        if (i2c_info[i].addr>0x7f)
+            i2c_info[i].flags = 0x10;
+        i2c_client = i2c_new_device(adapter, &i2c_info[i]);
+        if (!i2c_client) {
+            printk("[error] %x :failed to new i2c device\n", i2c_info[i].addr);
+            goto lcd_extern_probe_failed;
+        }
+        else{
+            DBG_PRINT("[error] %x: new i2c device succeed\n",i2c_info[i].addr);
+        }
+   }
+
+    if (!aml_anx6345_70_client) {
+        ret = i2c_add_driver(&aml_anx6345_70_driver);
+        if (ret) {
+            printk("[error] lcd_extern probe: add i2c_driver failed\n");
+            goto lcd_extern_probe_failed;
+        }
+    }
+
+    if (!aml_anx6345_72_client) {
+        ret = i2c_add_driver(&aml_anx6345_72_driver);
+        if (ret) {
+            printk("[error] lcd_extern probe: add i2c_driver failed\n");
+            goto lcd_extern_probe_failed;
+        }
+    }
+
+    printk("%s ok\n", __FUNCTION__);
+    return ret;
+
+lcd_extern_probe_failed:
+    if (lcd_extern_config) {
+        kfree(lcd_extern_config);
+        lcd_extern_config = NULL;
+    }
+    return -1;
+}
+
+static int aml_anx6345_remove(struct platform_device *pdev)
+{
+    if (pdev->dev.platform_data)
+        kfree (pdev->dev.platform_data);
+    return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id aml_anx6345_dt_match[]={
+    {
+        .compatible = "amlogic,lcd_anx6345",
+    },
+    {},
+};
+#else
+#define aml_tc101_dt_match NULL
+#endif
+
+static struct platform_driver aml_anx6345_driver = {
+    .probe  = aml_anx6345_probe,
+    .remove = aml_anx6345_remove,
+    .driver = {
+        .name  = LCD_EXTERN_NAME,
+        .owner = THIS_MODULE,
+#ifdef CONFIG_USE_OF
+        .of_match_table = aml_anx6345_dt_match,
+#endif
+    },
+};
+
+static int __init aml_anx6345_init(void)
+{
+    int ret;
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    ret = platform_driver_register(&aml_anx6345_driver);
+    if (ret) {
+        printk("[error] %s failed to register lcd extern driver module\n", __FUNCTION__);
+        return -ENODEV;
+    }
+    return ret;
+}
+
+static void __exit aml_anx6345_exit(void)
+{
+    platform_driver_unregister(&aml_anx6345_driver);
+}
+
+//late_initcall(aml_tc101_init);
+module_init(aml_anx6345_init);
+module_exit(aml_anx6345_exit);
+
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("LCD Extern driver for TC101");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/display/vout/lcd_extern/edp_anx6345.h b/drivers/amlogic/display/vout/lcd_extern/edp_anx6345.h
new file mode 100644
index 00000000..d8cb084b
--- /dev/null
+++ b/drivers/amlogic/display/vout/lcd_extern/edp_anx6345.h
@@ -0,0 +1,673 @@
+#ifndef EDP_ANX6345_H
+#define EDP_ANX6345_H
+
+
+#define SP_TX_PORT0_ADDR 0x70
+#define SP_TX_PORT1_ADDR 0x74
+#define SP_TX_PORT2_ADDR 0x72
+#define MIPI_RX_PORT1_ADDR 0x7A
+
+#define MAX_BUF_CNT 6
+
+#define CR_LOOP_TIME 5
+#define EQ_LOOP_TIME 5
+
+#define SP_TX_AVI_SEL 0x01
+#define SP_TX_SPD_SEL 0x02
+#define SP_TX_MPEG_SEL 0x04
+
+#define VAL_EDP_TX_LINK_BW_SET_162						0x06
+#define VAL_EDP_TX_LINK_BW_SET_270						0x0a
+#define VAL_EDP_TX_LINK_BW_SET_540						0x14
+
+//End for DEV_addr 0x7A/0x7E
+
+/***************************************************************/
+//  DEV_ADDR = 0x70 or 0x78 , Displayport mode and HDCP registers
+#define SP_TX_HDCP_STATUS							  				0x00
+#define SP_TX_HDCP_AUTH_PASS						  			0x02//bit position
+
+#define SP_TX_HDCP_CONTROL_0_REG                  		0x01
+#define SP_TX_HDCP_CONTROL_0_STORE_AN            0x80//bit position
+#define SP_TX_HDCP_CONTROL_0_RX_REPEATER   	0x40//bit position
+#define SP_TX_HDCP_CONTROL_0_RE_AUTH              0x20//bit position
+#define SP_TX_HDCP_CONTROL_0_SW_AUTH_OK       0x10//bit position
+#define SP_TX_HDCP_CONTROL_0_HARD_AUTH_EN   0x08//bit position
+#define SP_TX_HDCP_CONTROL_0_HDCP_ENC_EN      0x04//bit position
+#define SP_TX_HDCP_CONTROL_0_BKSV_SRM_PASS  0x02//bit position
+#define SP_TX_HDCP_CONTROL_0_KSVLIST_VLD        0x01//bit position
+
+
+#define SP_TX_HDCP_CONTROL_1_REG                  		0x02
+#define SP_TX_HDCP_CONTROL_1_DDC_NO_STOP      			0x20//bit position
+#define SP_TX_HDCP_CONTROL_1_DDC_NO_ACK        			0x10//bit position
+#define SP_TX_HDCP_CONTROL_1_EDDC_NO_ACK          		0x08//bit position
+//#define SP_TX_HDCP_CONTROL_1_HDCP_EMB_SCREEN_EN   		0x04//bit position
+#define SP_TX_HDCP_CONTROL_1_RCV_11_EN                  0x02//bit position
+#define SP_TX_HDCP_CONTROL_1_HDCP_11_EN           		0x01//bit position
+
+#define SP_TX_HDCP_LINK_CHK_FRAME_NUM				 	0x03
+#define SP_TX_HDCP_CONTROL_2_REG						0x04
+
+#define SP_TX_HDCP_AKSV0								0x05
+#define SP_TX_HDCP_AKSV1								0x06
+#define SP_TX_HDCP_AKSV2								0x07
+#define SP_TX_HDCP_AKSV3								0x08
+#define SP_TX_HDCP_AKSV4								0x09
+
+//AKSV
+#define SP_TX_HDCP_AN0									0x0A
+#define SP_TX_HDCP_AN1									0x0B
+#define SP_TX_HDCP_AN2									0x0C
+#define SP_TX_HDCP_AN3									0x0D
+#define SP_TX_HDCP_AN4									0x0E
+#define SP_TX_HDCP_AN5									0x0F
+#define SP_TX_HDCP_AN6									0x10
+#define SP_TX_HDCP_AN7									0x11
+
+//BKSV
+#define SP_TX_HDCP_BKSV0								0x12
+#define SP_TX_HDCP_BKSV1								0x13
+#define SP_TX_HDCP_BKSV2								0x14
+#define SP_TX_HDCP_BKSV3								0x15
+#define SP_TX_HDCP_BKSV4								0x16
+
+#define SP_TX_HDCP_R0_L									0x17
+#define SP_TX_HDCP_R0_H									0x18
+
+#ifndef M_VID_0
+#define M_VID_0 0xC0
+#define M_VID_1 0xC1
+#define M_VID_2 0xC2
+#define N_VID_0 0xC3
+#define N_VID_1 0xC4
+#define N_VID_2 0xC5
+#endif
+
+#define SP_TX_HDCP_R0_WAIT_Timer					 0x40
+
+
+
+#define SP_TX_SYS_CTRL1_REG           					0x80
+//#define SP_TX_SYS_CTRL1_PD_IO         					0x80    // bit position
+//#define SP_TX_SYS_CTRL1_PD_VID        					0x40    // bit position
+//#define SP_TX_SYS_CTRL1_PD_LINK       					0x20    // bit position
+//#define SP_TX_SYS_CTRL1_PD_TOTAL      					0x10    // bit position
+//#define SP_TX_SYS_CTRL1_MODE_SEL      					0x08    // bit position
+#define SP_TX_SYS_CTRL1_DET_STA       					0x04    // bit position
+#define SP_TX_SYS_CTRL1_FORCE_DET     					0x02    // bit position
+#define SP_TX_SYS_CTRL1_DET_CTRL      					0x01    // bit position
+
+#define SP_TX_SYS_CTRL2_REG           					0x81
+// #define SP_TX_SYS_CTRL2_ENHANCED 	  					0x08	  //bit position
+#define SP_TX_SYS_CTRL2_CHA_STA       					0x04    // bit position
+#define SP_TX_SYS_CTRL2_FORCE_CHA     					0x02    // bit position
+#define SP_TX_SYS_CTRL2_CHA_CTRL      					0x01    // bit position
+
+#define SP_TX_SYS_CTRL3_REG           					0x82
+#define SP_TX_SYS_CTRL3_HPD_STATUS    					0x40    // bit position
+#define SP_TX_SYS_CTRL3_F_HPD         					0x20    // bit position
+#define SP_TX_SYS_CTRL3_HPD_CTRL      					0x10    // bit position
+#define SP_TX_SYS_CTRL3_STRM_VALID    					0x04    // bit position
+#define SP_TX_SYS_CTRL3_F_VALID       					0x02    // bit position
+#define SP_TX_SYS_CTRL3_VALID_CTRL    					0x01    // bit position
+
+#define SP_TX_SYS_CTRL4_REG			  					0x83
+#define SP_TX_SYS_CTRL4_ENHANCED 	  					0x08//bit position
+
+#define SP_TX_VID_CTRL				  					0x84
+
+#define SP_TX_AUD_CTRL									0x87
+#define SP_TX_AUD_CTRL_AUD_EN							0x01
+
+
+#define SP_TX_PKT_EN_REG              					0x90
+#define SP_TX_PKT_AUD_UP								0x80  // bit position
+#define SP_TX_PKT_AVI_UD              					0x40  // bit position
+#define SP_TX_PKT_MPEG_UD             					0x20  // bit position    
+#define SP_TX_PKT_SPD_UD              					0x10  // bit position   
+#define SP_TX_PKT_AUD_EN								0x08  // bit position=
+#define SP_TX_PKT_AVI_EN              					0x04  // bit position          
+#define SP_TX_PKT_MPEG_EN             					0x02  // bit position     
+#define SP_TX_PKT_SPD_EN              					0x01  // bit position       
+
+
+#define SP_TX_HDCP_CTRL 												0x92
+
+#define SP_TX_LINK_BW_SET_REG         				 0xA0
+#define SP_TX_LANE_COUNT_SET_REG      				 0xA1
+
+#define SP_TX_TRAINING_PTN_SET_REG                   0xA2
+#define SP_TX_SCRAMBLE_DISABLE						 0x20//bit 5
+
+#define SP_TX_TRAINING_LANE0_SET_REG                 				0xA3
+#define SP_TX_TRAINING_LANE0_SET_MAX_PRE_REACH        0x20        // bit position
+#define SP_TX_TRAINING_LANE0_SET_MAX_DRIVE_REACH     0x04        // bit position
+
+#define SP_TX_TRAINING_LANE1_SET_REG                0xA4
+
+
+#define SSC_CTRL_REG1					 0xA7
+#define SPREAD_AMP						 0x10//bit 4
+#define MODULATION_FREQ					 0x01//bit 0
+
+
+#define SP_TX_LINK_TRAINING_CTRL_REG                0xA8
+#define SP_TX_LINK_TRAINING_CTRL_EN                 0x01        // bit position
+
+
+#define SP_TX_DEBUG_REG1							0xB0
+#define SP_TX_DEBUG_HPD_POLLING_DET						0x40//bit position
+#define SP_TX_DEBUG_HPD_POLLING_EN						0x20//bit position
+#define SP_TX_DEBUG_PLL_LOCK						0x10//bit position
+
+
+#define SP_TX_LINK_DEBUG_REG                        0xB8
+#define SP_TX_LINK_DEBUG_INSERT_ER                  0x02        // bit position
+#define SP_TX_LINK_DEBUG_PRBS31_EN                  0x01        // bit position
+
+#define SP_TX_SINK_COUNT_REG                0xB9
+
+#define SP_TX_LINK_STATUS_REG1                               0xBB
+
+#define SP_TX_SINK_STATUS_REG                                   0xBE
+#define SP_TX_SINK_STATUS_SINK_STATUS_1          	0x02        // bit position
+#define SP_TX_SINK_STATUS_SINK_STATUS_0          	0x01        // bit position
+
+
+//#define SP_TX_LINK_TEST_COUNT                     0xC0
+
+
+#define SP_TX_PLL_CTRL_REG											0xC7	
+#define SP_TX_PLL_CTRL_PLL_PD           						0x80        // bit position
+#define SP_TX_PLL_CTRL_PLL_RESET        					0x40        // bit position 
+//#define SP_TX_PLL_CTRL_CPREG_BLEED      					0x08        // bit position 
+
+#define SP_TX_ANALOG_POWER_DOWN_REG                   			0xC8
+#define SP_TX_ANALOG_POWER_DOWN_MACRO_PD              	0x20        // bit position 
+#define SP_TX_ANALOG_POWER_DOWN_AUX_PD                		0x10        // bit position 
+//#define SP_TX_ANALOG_POWER_DOWN_CH3_PD                		0x08        // bit position 
+//#define SP_TX_ANALOG_POWER_DOWN_CH2_PD                		0x04        // bit position 
+#define SP_TX_ANALOG_POWER_DOWN_CH1_PD                		0x02        // bit position 
+#define SP_TX_ANALOG_POWER_DOWN_CH0_PD                		0x01        // bit position 
+
+
+#define SP_TX_ANALOG_TEST_REG                         					0xC9
+#define SP_TX_ANALOG_TEST_MACRO_RST                   				0x20       // bit position 
+#define SP_TX_ANALOG_TEST_PLL_TEST                    				0x10       // bit position 
+#define SP_TX_ANALOG_TEST_CH3_TEST                    				0x08       // bit position 
+#define SP_TX_ANALOG_TEST_CH2_TEST                    				0x04       // bit position 
+#define SP_TX_ANALOG_TEST_CH1_TEST                    				0x02       // bit position 
+#define SP_TX_ANALOG_TEST_CH0_TEST                    				0x01       // bit position 
+
+#define SP_TX_GNS_CTRL_REG                            							0xCD
+#define SP_EQ_LOOP_CNT											0x40//bit position
+#define SP_TX_VIDEO_MAP_CTRL                 			                            0x02       // bit position 
+#define SP_TX_RS_CTRL                        					              	0x01       // bit position 
+
+#define SP_TX_DOWN_SPREADING_CTRL1                                               0xD0   //guochuncheng
+#define SP_TX_DOWN_SPREADING_CTRL2                                               0xD1
+#define SP_TX_DOWN_SPREADING_CTRL3                                               0xD2
+#define SP_TX_SSC_D_CTRL                                                             0x40       //bit position
+#define SP_TX_FS_CTRL_TH_CTRL                                                   0x20       //bit position
+
+#define SP_TX_M_CALCU_CTRL												0xD9
+#define M_GEN_CLK_SEL													0x01//bit 0
+
+
+#define SP_TX_EXTRA_ADDR_REG											0xCE
+#define SP_TX_I2C_STRETCH_CTRL_REG                                                              0xDB
+#define SP_TX_AUX_STATUS            										0xE0
+#define SP_TX_DEFER_CTRL_REG            									0xE2
+#define SP_TXL_DEFER_CTRL_EN  					                     		       0x80       // bit position 
+
+#define SP_TX_BUF_DATA_COUNT_REG											0xE4
+#define SP_TX_AUX_CTRL_REG              										0xE5
+#define SP_TX_MOT_BIT													0x04//bit 2
+
+#define SP_TX_AUX_ADDR_7_0_REG          									0xE6
+#define SP_TX_AUX_ADDR_15_8_REG         									0xE7
+#define SP_TX_AUX_ADDR_19_16_REG        									0xE8
+
+#define SP_TX_AUX_CTRL_REG2                                                 0xE9
+#define SP_TX_ADDR_ONLY_BIT													0x02//bit 1
+
+#define SP_TX_BUF_DATA_0_REG                          0xf0
+#define SP_TX_BUF_DATA_1_REG                          0xf1
+#define SP_TX_BUF_DATA_2_REG                          0xf2
+#define SP_TX_BUF_DATA_3_REG                          0xf3
+#define SP_TX_BUF_DATA_4_REG                          0xf4
+#define SP_TX_BUF_DATA_5_REG                          0xf5
+#define SP_TX_BUF_DATA_6_REG                          0xf6
+#define SP_TX_BUF_DATA_7_REG                          0xf7
+#define SP_TX_BUF_DATA_8_REG                          0xf8
+#define SP_TX_BUF_DATA_9_REG                          0xf9
+#define SP_TX_BUF_DATA_10_REG                         0xfa
+#define SP_TX_BUF_DATA_11_REG                         0xfb
+#define SP_TX_BUF_DATA_12_REG                         0xfc
+#define SP_TX_BUF_DATA_13_REG                         0xfd
+#define SP_TX_BUF_DATA_14_REG                         0xfe
+#define SP_TX_BUF_DATA_15_REG                         0xff
+
+//End for Address 0x70 or 0x78
+
+/***************************************************************/
+//  DEV_ADDR = 0x72 or 0x76, System control registers
+#define SP_TX_VND_IDL_REG             	0x00
+#define SP_TX_VND_IDH_REG             	0x01
+#define SP_TX_DEV_IDL_REG             	0x02
+#define SP_TX_DEV_IDH_REG             	0x03
+#define SP_TX_DEV_REV_REG             	0x04
+
+#define SP_POWERD_CTRL_REG			  	0x05
+#define SP_POWERD_REGISTER_REG			0x80// bit position
+//#define SP_POWERD_MISC_REG			  	0x40// bit position
+#define SP_POWERD_IO_REG			  	0x20// bit position
+#define SP_POWERD_AUDIO_REG				0x10// bit position
+#define SP_POWERD_VIDEO_REG			  	0x08// bit position
+#define SP_POWERD_LINK_REG			  	0x04// bit position
+#define SP_POWERD_TOTAL_REG			  	0x02// bit position
+#define SP_MODE_SEL_REG				  	0x01// bit position
+
+#define SP_TX_RST_CTRL_REG            	0x06
+#define SP_TX_RST_MISC_REG 			  	0x80	// bit position
+#define SP_TX_RST_VIDCAP_REG		  	0x40	// bit position
+#define SP_TX_RST_VIDFIF_REG          	0x20    // bit position
+#define SP_TX_RST_AUDFIF_REG          	0x10    // bit position
+#define SP_TX_RST_AUDCAP_REG         	0x08    // bit position
+#define SP_TX_RST_HDCP_REG            	0x04    // bit position
+#define SP_TX_RST_SW_RST             	0x02    // bit position
+#define SP_TX_RST_HW_RST             	0x01    // bit position
+
+#define SP_TX_RST_CTRL2_REG				0x07
+#define SP_TX_RST_SSC					0x80//bit position
+#define SP_TX_AC_MODE					0x40//bit position
+//#define SP_TX_DDC_RST					0x10//bit position
+//#define SP_TX_TMDS_BIST_RST				0x08//bit position
+#define SP_TX_AUX_RST					0x04//bit position
+#define SP_TX_SERDES_FIFO_RST			0x02//bit position
+#define SP_TX_I2C_REG_RST				0x01//bit position
+
+
+#define SP_TX_VID_CTRL1_REG           	0x08
+#define SP_TX_VID_CTRL1_VID_EN       0x80    // bit position
+#define SP_TX_VID_CTRL1_VID_MUTE   0x40    // bit position
+#define SP_TX_VID_CTRL1_DE_GEN      0x20    // bit position
+#define SP_TX_VID_CTRL1_DEMUX        0x10    // bit position
+#define SP_TX_VID_CTRL1_IN_BIT		  	0x04    // bit position
+#define SP_TX_VID_CTRL1_DDRCTRL		0x02    // bit position
+#define SP_TX_VID_CTRL1_EDGE		  		0x01    // bit position
+
+#define SP_TX_VID_CTRL2_REG           	0x09
+#define SP_TX_VID_CTRL1_YCBIT_SEL  		0x04    // bit position
+
+#define SP_TX_VID_CTRL3_REG           	0x0A
+
+#define SP_TX_VID_CTRL4_REG           	0x0B
+#define SP_TX_VID_CTRL4_E_SYNC_EN	  	0x80	  //bit position
+#define SP_TX_VID_CTRL4_EX_E_SYNC    0x40    // bit position
+#define SP_TX_VID_CTRL4_BIST          		0x08    // bit position
+#define SP_TX_VID_CTRL4_BIST_WIDTH   0x04        // bit position
+
+#define SP_TX_VID_CTRL5_REG           		0x0C
+
+#define SP_TX_VID_CTRL6_REG           		0x0D
+#define SP_TX_VID_UPSAMPLE					0x02//bit position
+
+#define SP_TX_VID_CTRL7_REG           		0x0E
+#define SP_TX_VID_CTRL8_REG           		0x0F
+#define SP_TX_VID_CTRL9_REG           		0x10
+
+#define SP_TX_VID_CTRL10_REG           	0x11
+#define SP_TX_VID_CTRL10_INV_F         	0x08    // bit position
+#define SP_TX_VID_CTRL10_I_SCAN        	0x04    // bit position
+#define SP_TX_VID_CTRL10_VSYNC_POL   0x02    // bit position
+#define SP_TX_VID_CTRL10_HSYNC_POL   0x01    // bit position
+
+#define SP_TX_TOTAL_LINEL_REG         0x12
+#define SP_TX_TOTAL_LINEH_REG         0x13
+#define SP_TX_ACT_LINEL_REG           0x14
+#define SP_TX_ACT_LINEH_REG           0x15
+#define SP_TX_VF_PORCH_REG            0x16
+#define SP_TX_VSYNC_CFG_REG           0x17
+#define SP_TX_VB_PORCH_REG            0x18
+#define SP_TX_TOTAL_PIXELL_REG        0x19
+#define SP_TX_TOTAL_PIXELH_REG        0x1A
+#define SP_TX_ACT_PIXELL_REG          0x1B
+#define SP_TX_ACT_PIXELH_REG          0x1C
+#define SP_TX_HF_PORCHL_REG           0x1D
+#define SP_TX_HF_PORCHH_REG           0x1E
+#define SP_TX_HSYNC_CFGL_REG          0x1F
+#define SP_TX_HSYNC_CFGH_REG          0x20
+#define SP_TX_HB_PORCHL_REG           0x21
+#define SP_TX_HB_PORCHH_REG           0x22
+
+#define SP_TX_VID_STATUS						0x23
+
+#define SP_TX_TOTAL_LINE_STA_L        0x24
+#define SP_TX_TOTAL_LINE_STA_H        0x25
+#define SP_TX_ACT_LINE_STA_L          0x26
+#define SP_TX_ACT_LINE_STA_H          0x27
+#define SP_TX_V_F_PORCH_STA           0x28
+#define SP_TX_V_SYNC_STA              0x29
+#define SP_TX_V_B_PORCH_STA           0x2A
+#define SP_TX_TOTAL_PIXEL_STA_L       0x2B
+#define SP_TX_TOTAL_PIXEL_STA_H       0x2C
+#define SP_TX_ACT_PIXEL_STA_L         0x2D
+#define SP_TX_ACT_PIXEL_STA_H         0x2E
+#define SP_TX_H_F_PORCH_STA_L         0x2F
+#define SP_TX_H_F_PORCH_STA_H         0x30
+#define SP_TX_H_SYNC_STA_L            0x31
+#define SP_TX_H_SYNC_STA_H            0x32
+#define SP_TX_H_B_PORCH_STA_L         0x33
+#define SP_TX_H_B_PORCH_STA_H         0x34
+
+#define SP_TX_Video_Interface_BIST    0x35
+
+#define SPDIF_AUDIO_CTRL0			0x36
+#define SPDIF_AUDIO_CTRL0_SPDIF_IN  0x80 // bit position
+
+#define SPDIF_AUDIO_STATUS0			0x38
+#define SPDIF_AUDIO_STATUS0_CLK_DET 0x80
+#define SPDIF_AUDIO_STATUS0_AUD_DET 0x01
+
+#define SPDIF_AUDIO_STATUS1 0x39
+
+#define AUDIO_BIST_CTRL 0x3c
+#define AUDIO_BIST_EN 0x01
+
+//#define AUDIO_BIST_CHANNEL_STATUS1 0xd0
+//#define AUDIO_BIST_CHANNEL_STATUS2 0xd1
+//#define AUDIO_BIST_CHANNEL_STATUS3 0xd2
+//#define AUDIO_BIST_CHANNEL_STATUS4 0xd3
+//#define AUDIO_BIST_CHANNEL_STATUS5 0xd4
+
+#define SP_TX_VIDEO_BIT_CTRL_0_REG                    0x40
+#define SP_TX_VIDEO_BIT_CTRL_1_REG                    0x41
+#define SP_TX_VIDEO_BIT_CTRL_2_REG                    0x42
+#define SP_TX_VIDEO_BIT_CTRL_3_REG                    0x43
+#define SP_TX_VIDEO_BIT_CTRL_4_REG                    0x44
+#define SP_TX_VIDEO_BIT_CTRL_5_REG                    0x45
+#define SP_TX_VIDEO_BIT_CTRL_6_REG                    0x46
+#define SP_TX_VIDEO_BIT_CTRL_7_REG                    0x47
+#define SP_TX_VIDEO_BIT_CTRL_8_REG                    0x48
+#define SP_TX_VIDEO_BIT_CTRL_9_REG                    0x49
+#define SP_TX_VIDEO_BIT_CTRL_10_REG                   0x4a
+#define SP_TX_VIDEO_BIT_CTRL_11_REG                   0x4b
+#define SP_TX_VIDEO_BIT_CTRL_12_REG                   0x4c
+#define SP_TX_VIDEO_BIT_CTRL_13_REG                   0x4d
+#define SP_TX_VIDEO_BIT_CTRL_14_REG                   0x4e
+#define SP_TX_VIDEO_BIT_CTRL_15_REG                   0x4f
+#define SP_TX_VIDEO_BIT_CTRL_16_REG                   0x50
+#define SP_TX_VIDEO_BIT_CTRL_17_REG                   0x51
+#define SP_TX_VIDEO_BIT_CTRL_18_REG                   0x52
+#define SP_TX_VIDEO_BIT_CTRL_19_REG                   0x53
+#define SP_TX_VIDEO_BIT_CTRL_20_REG                   0x54
+#define SP_TX_VIDEO_BIT_CTRL_21_REG                   0x55
+#define SP_TX_VIDEO_BIT_CTRL_22_REG                   0x56
+#define SP_TX_VIDEO_BIT_CTRL_23_REG                   0x57
+#define SP_TX_VIDEO_BIT_CTRL_24_REG                   0x58
+#define SP_TX_VIDEO_BIT_CTRL_25_REG                   0x59
+#define SP_TX_VIDEO_BIT_CTRL_26_REG                   0x5a
+#define SP_TX_VIDEO_BIT_CTRL_27_REG                   0x5b
+#define SP_TX_VIDEO_BIT_CTRL_28_REG                   0x5c
+#define SP_TX_VIDEO_BIT_CTRL_29_REG                   0x5d
+#define SP_TX_VIDEO_BIT_CTRL_30_REG                   0x5e
+#define SP_TX_VIDEO_BIT_CTRL_31_REG                   0x5f
+#define SP_TX_VIDEO_BIT_CTRL_32_REG                   0x60
+#define SP_TX_VIDEO_BIT_CTRL_33_REG                   0x61
+#define SP_TX_VIDEO_BIT_CTRL_34_REG                   0x62
+#define SP_TX_VIDEO_BIT_CTRL_35_REG                   0x63
+#define SP_TX_VIDEO_BIT_CTRL_36_REG                   0x64
+#define SP_TX_VIDEO_BIT_CTRL_37_REG                   0x65
+#define SP_TX_VIDEO_BIT_CTRL_38_REG                   0x66
+#define SP_TX_VIDEO_BIT_CTRL_39_REG                   0x67
+#define SP_TX_VIDEO_BIT_CTRL_40_REG                   0x68
+#define SP_TX_VIDEO_BIT_CTRL_41_REG                   0x69
+#define SP_TX_VIDEO_BIT_CTRL_42_REG                   0x6a
+#define SP_TX_VIDEO_BIT_CTRL_43_REG                   0x6b
+#define SP_TX_VIDEO_BIT_CTRL_44_REG                   0x6c
+#define SP_TX_VIDEO_BIT_CTRL_45_REG                   0x6d
+#define SP_TX_VIDEO_BIT_CTRL_46_REG                   0x6e
+#define SP_TX_VIDEO_BIT_CTRL_47_REG                   0x6f
+
+//AVI info frame
+#define SP_TX_AVI_TYPE              0x70
+#define SP_TX_AVI_VER               0x71
+#define SP_TX_AVI_LEN               0x72
+#define SP_TX_AVI_DB0		     0x73
+#define SP_TX_AVI_DB1               0x74
+#define SP_TX_AVI_DB2               0x75
+#define SP_TX_AVI_DB3               0x76
+#define SP_TX_AVI_DB4               0x77
+#define SP_TX_AVI_DB5               0x78
+#define SP_TX_AVI_DB6               0x79
+#define SP_TX_AVI_DB7               0x7A
+#define SP_TX_AVI_DB8               0x7B
+#define SP_TX_AVI_DB9               0x7C
+#define SP_TX_AVI_DB10              0x7D
+#define SP_TX_AVI_DB11              0x7E
+#define SP_TX_AVI_DB12              0x7F
+#define SP_TX_AVI_DB13              0x80
+#define SP_TX_AVI_DB14              0x81
+#define SP_TX_AVI_DB15              0x82
+
+//Audio info frame
+#define SP_TX_AUD_TYPE			 0x83
+#define SP_TX_AUD_VER			 0x84
+#define SP_TX_AUD_LEN			 0x85
+#define SP_TX_AUD_DB0			 0x86
+#define SP_TX_AUD_DB1			 0x87
+#define SP_TX_AUD_DB2			 0x88
+#define SP_TX_AUD_DB3			 0x89
+#define SP_TX_AUD_DB4			 0x8A
+#define SP_TX_AUD_DB5			 0x8B
+#define SP_TX_AUD_DB6			 0x8C
+#define SP_TX_AUD_DB7			 0x8D
+#define SP_TX_AUD_DB8			 0x8E
+#define SP_TX_AUD_DB9			 0x8F
+#define SP_TX_AUD_DB10			 0x90
+
+//SPD info frame
+#define SP_TX_SPD_TYPE                0x91
+#define SP_TX_SPD_VER                 0x92
+#define SP_TX_SPD_LEN                 0x93
+#define SP_TX_SPD_DATA0		0x94
+#define SP_TX_SPD_DATA1               0x95
+#define SP_TX_SPD_DATA2               0x96
+#define SP_TX_SPD_DATA3               0x97
+#define SP_TX_SPD_DATA4               0x98
+#define SP_TX_SPD_DATA5               0x99
+#define SP_TX_SPD_DATA6               0x9A
+#define SP_TX_SPD_DATA7               0x9B
+#define SP_TX_SPD_DATA8               0x9C
+#define SP_TX_SPD_DATA9               0x9D
+#define SP_TX_SPD_DATA10              0x9E
+#define SP_TX_SPD_DATA11              0x9F
+#define SP_TX_SPD_DATA12              0xA0
+#define SP_TX_SPD_DATA13              0xA1
+#define SP_TX_SPD_DATA14              0xA2
+#define SP_TX_SPD_DATA15              0xA3
+#define SP_TX_SPD_DATA16              0xA4
+#define SP_TX_SPD_DATA17              0xA5
+#define SP_TX_SPD_DATA18              0xA6
+#define SP_TX_SPD_DATA19              0xA7
+#define SP_TX_SPD_DATA20              0xA8
+#define SP_TX_SPD_DATA21              0xA9
+#define SP_TX_SPD_DATA22              0xAA
+#define SP_TX_SPD_DATA23              0xAB
+#define SP_TX_SPD_DATA24              0xAC
+#define SP_TX_SPD_DATA25              0xAD
+#define SP_TX_SPD_DATA26              0xAE
+#define SP_TX_SPD_DATA27              0xAF
+
+//Mpeg source info frame
+#define SP_TX_MPEG_TYPE               0xB0
+#define SP_TX_MPEG_VER                0xB1
+#define SP_TX_MPEG_LEN                0xB2
+#define SP_TX_MPEG_DATA0              0xB3
+#define SP_TX_MPEG_DATA1              0xB4
+#define SP_TX_MPEG_DATA2              0xB5
+#define SP_TX_MPEG_DATA3              0xB6
+#define SP_TX_MPEG_DATA4              0xB7
+#define SP_TX_MPEG_DATA5              0xB8
+#define SP_TX_MPEG_DATA6              0xB9
+#define SP_TX_MPEG_DATA7              0xBA
+#define SP_TX_MPEG_DATA8              0xBB
+#define SP_TX_MPEG_DATA9              0xBC
+#define SP_TX_MPEG_DATA10             0xBD
+#define SP_TX_MPEG_DATA11            0xBE
+#define SP_TX_MPEG_DATA12            0xBF
+#define SP_TX_MPEG_DATA13            0xC0
+#define SP_TX_MPEG_DATA14            0xC1
+#define SP_TX_MPEG_DATA15            0xC2
+#define SP_TX_MPEG_DATA16            0xC3
+#define SP_TX_MPEG_DATA17            0xC4
+#define SP_TX_MPEG_DATA18            0xC5
+#define SP_TX_MPEG_DATA19            0xC6
+#define SP_TX_MPEG_DATA20            0xC7
+#define SP_TX_MPEG_DATA21            0xC8
+#define SP_TX_MPEG_DATA22            0xC9
+#define SP_TX_MPEG_DATA23            0xCA
+#define SP_TX_MPEG_DATA24            0xCB
+#define SP_TX_MPEG_DATA25            0xCC
+#define SP_TX_MPEG_DATA26            0xCD
+#define SP_TX_MPEG_DATA27            0xCE
+
+//#define GNSS_CTRL_REG				0xCD
+//#define ENABLE_SSC_FILTER			0x80//bit 
+
+//#define SSC_D_VALUE					 0xD0
+//#define SSC_CTRL_REG2					 0xD1
+
+#define ANALOG_DEBUG_REG1			0xDC
+#define ANALOG_SEL_BG				0x40//bit 4
+#define ANALOG_SWING_A_30PER		0x08//bit 3
+
+#define ANALOG_DEBUG_REG2			0xDD
+#define ANALOG_24M_SEL				0x08//bit 3
+//#define ANALOG_FILTER_ENABLED		0x10//bit 4
+
+
+#define ANALOG_DEBUG_REG3			0xDE
+
+#define PLL_FILTER_CTRL1			0xDF
+#define PD_RING_OSC					0x40//bit 6
+
+#define PLL_FILTER_CTRL2			0xE0
+#define PLL_FILTER_CTRL3			0xE1
+#define PLL_FILTER_CTRL4			0xE2
+#define PLL_FILTER_CTRL5			0xE3
+#define PLL_FILTER_CTRL6			0xE4
+
+#define SP_TX_I2S_CTRL			0xE6
+#define SP_TX_I2S_FMT			0xE7
+#define SP_TX_I2S_CH_Status1			0xD0
+#define SP_TX_I2S_CH_Status2			0xD1
+#define SP_TX_I2S_CH_Status3			0xD2
+#define SP_TX_I2S_CH_Status4			0xD3
+#define SP_TX_I2S_CH_Status5			0xD4
+
+//interrupt
+#define SP_COMMON_INT_STATUS1     0xF1
+#define SP_COMMON_INT1_PLL_LOCK_CHG 	0x40//bit position
+#define SP_COMMON_INT1_VIDEO_FORMAT_CHG 0x08//bit position
+#define SP_COMMON_INT1_AUDIO_CLK_CHG	0x04//bit position
+#define SP_COMMON_INT1_VIDEO_CLOCK_CHG  0x02//bit position
+
+
+#define SP_COMMON_INT_STATUS2	  0xF2
+#define SP_COMMON_INT2_AUTHCHG	  0x02 //bit position
+#define SP_COMMON_INT2_AUTHDONE	  0x01 //bit position
+
+#define SP_COMMON_INT_STATUS3	  0xF3
+#define SP_COMMON_INT3_AFIFO_UNDER	0x80//bit position
+#define SP_COMMON_INT3_AFIFO_OVER	0x40//bit position
+
+#define SP_COMMON_INT_STATUS4	    0xF4
+#define SP_COMMON_INT4_PLUG                0x01   // bit position
+#define SP_COMMON_INT4_ESYNC_ERR          0x10   // bit position
+#define SP_COMMON_INT4_HPDLOST		0x02   //bit position
+#define SP_COMMON_INT4_HPD_CHANGE   0x04   //bit position
+
+
+#define SP_TX_INT_STATUS1		  0xF7
+#define SP_TX_INT_STATUS1_HPD	  0x40 //bit position
+#define SP_TX_INT_STATUS1_TRAINING_Finish       0x20   // bit position
+#define SP_TX_INT_STATUS1_POLLING_ERR        0x10   // bit position
+
+#define SP_TX_INT_SINK_CHG		  0x08//bit position
+
+//interrupt mask
+#define SP_COMMON_INT_MASK1			  0xF8
+#define SP_COMMON_INT_MASK2			  0xF9
+#define SP_COMMON_INT_MASK3			  0xFA
+#define SP_COMMON_INT_MASK4			  0xFB
+#define SP_INT_MASK					  					0xFE
+#define SP_TX_INT_CTRL_REG            		0xFF
+//End for dev_addr 0x72 or 0x76
+
+/***************************************************************/
+/***************************************************************/
+
+//DPCD regs
+#define DPCD_DPCD_REV                                                0x00
+#define DPCD_MAX_LINK_RATE                                      0x01
+#define DPCD_MAX_LANE_COUNT                                   0x02
+#define DPCD_MAX_DOWNSPREAD                                  0x03
+#define DPCD_NORP                                                        0x04
+#define DPCD_DOWNSTREAMPORT_PRESENT                  0x05
+
+#define DPCD_RECEIVE_PORT0_CAP_0                        0x08
+#define DPCD_RECEIVE_PORT0_CAP_1                        0x09
+#define DPCD_RECEIVE_PORT0_CAP_2                        0x0a
+#define DPCD_RECEIVE_PORT0_CAP_3                        0x0b
+
+#define DPCD_LINK_BW_SET                                      0x00
+#define DPCD_LANE_COUNT_SET                                0x01
+#define DPCD_TRAINING_PATTERN_SET                     0x02
+#define DPCD_TRAINNIG_LANE0_SET                         0x03
+#define DPCD_TRAINNIG_LANE1_SET                         0x04
+#define DPCD_TRAINNIG_LANE2_SET                         0x05
+#define DPCD_TRAINNIG_LANE3_SET                         0x06
+#define DPCD_DOWNSPREAD_CTRL                            0x07
+
+#define DPCD_SINK_COUNT                                          0x00
+#define DPCD_DEVICE_SERVICE_IRQ_VECTOR              0x01
+#define DPCD_LANE0_1_STATUS                                   0x02
+#define DPCD_LANE2_3_STATUS                                   0x03
+#define DPCD_LANE_ALIGN_STATUS_UPDATED            0x04
+#define DPCD_SINK_STATUS                                          0x05
+#define DPCD_ADJUST_REQUEST_LANE0_1                     0x06
+#define DPCD_ADJUST_REQUEST_LANE2_3                     0x07
+#define DPCD_TRAINING_SCORE_LANE0                       0x08
+#define DPCD_TRAINING_SCORE_LANE1                       0x09
+#define DPCD_TRAINING_SCORE_LANE2                       0x0a
+#define DPCD_TRAINING_SCORE_LANE3                       0x0b
+
+#define DPCD_TEST_REQUEST                               0x18
+#define DPCD_TEST_LINK_RATE                             0x19
+
+#define DPCD_TEST_LANE_COUNT                            0x20
+
+#define DPCD_TEST_Response                              0x60
+#define TEST_ACK                                                  0x01
+#define DPCD_TEST_EDID_Checksum_Write                   0x04//bit position
+
+#define DPCD_TEST_EDID_Checksum                         0x61
+
+
+#define DPCD_SPECIFIC_INTERRUPT                               0x10
+#define DPCD_USER_COMM1                                             0x22//define for downstream HDMI Rx sense detection
+
+
+
+
+
+
+
+
+
+
+
+#endif
\ No newline at end of file
diff --git a/drivers/amlogic/display/vout/lcd_extern/i2c_tc101.c b/drivers/amlogic/display/vout/lcd_extern/i2c_tc101.c
old mode 100644
new mode 100755
index fe39a4e1..a2c57770
--- a/drivers/amlogic/display/vout/lcd_extern/i2c_tc101.c
+++ b/drivers/amlogic/display/vout/lcd_extern/i2c_tc101.c
@@ -2,7 +2,7 @@
  * AMLOGIC lcd external driver.
  *
  * Communication protocol:
- * I2C 
+ * I2C
  *
  */
 
@@ -11,7 +11,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
-#include <linux/jiffies.h> 
+#include <linux/jiffies.h>
 #include <linux/i2c.h>
 #include <linux/i2c-aml.h>
 #include <linux/miscdevice.h>
@@ -26,7 +26,7 @@
 #include <mach/gpio.h>
 #include <linux/amlogic/vout/aml_lcd_extern.h>
 
-static struct lcd_extern_config_t *lcd_ext_config = NULL;
+static struct lcd_extern_config_t *lcd_extern_config = NULL;
 
 static struct i2c_client *aml_tc101_i2c_client;
 
@@ -60,12 +60,12 @@ static int aml_i2c_write(struct i2c_client *i2client,unsigned char *buff, unsign
         .buf = buff,
         }
     };
-    
+
     res = i2c_transfer(i2client->adapter, msg, 1);
     if (res < 0) {
         printk("%s: i2c transfer failed [addr 0x%02x]\n", __FUNCTION__, i2client->addr);
     }
-    
+
     return res;
 }
 #if 0
@@ -142,24 +142,33 @@ static int lcd_extern_i2c_remove(void)
     return ret;
 }
 
-static int lcd_extern_driver_update(void)
+static int get_lcd_extern_config(struct device_node* of_node, struct lcd_extern_config_t *lcd_ext_cfg)
 {
+    int ret = 0;
     struct aml_lcd_extern_driver_t* lcd_ext;
 
+    ret = get_lcd_extern_dt_data(of_node, lcd_ext_cfg);
+    if (ret) {
+        printk("[error] %s: failed to get dt data\n", LCD_EXTERN_NAME);
+        return ret;
+    }
+
+    //lcd extern driver update
     lcd_ext = aml_lcd_extern_get_driver();
     if (lcd_ext) {
-        lcd_ext->type      = lcd_ext_config->type;
-        lcd_ext->name      = lcd_ext_config->name;
+        lcd_ext->type      = lcd_ext_cfg->type;
+        lcd_ext->name      = lcd_ext_cfg->name;
         lcd_ext->reg_read  = i2c_reg_read;
         lcd_ext->reg_write = i2c_reg_write;
         lcd_ext->power_on  = lcd_extern_i2c_init;
         lcd_ext->power_off = lcd_extern_i2c_remove;
     }
     else {
-        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_config->name);
+        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_cfg->name);
+        ret = -1;
     }
 
-    return 0;
+    return ret;
 }
 
 static int aml_tc101_i2c_probe(struct i2c_client *client, const struct i2c_device_id *id)
@@ -171,7 +180,6 @@ static int aml_tc101_i2c_probe(struct i2c_client *client, const struct i2c_devic
     }
     else {
         aml_tc101_i2c_client = client;
-        lcd_extern_driver_update();
     }
 
     printk("%s OK\n", __FUNCTION__);
@@ -210,31 +218,31 @@ static int aml_tc101_probe(struct platform_device *pdev)
     if (lcd_extern_driver_check()) {
         return -1;
     }
-    if (lcd_ext_config == NULL)
-        lcd_ext_config = kzalloc(sizeof(*lcd_ext_config), GFP_KERNEL);
-    if (lcd_ext_config == NULL) {
+    if (lcd_extern_config == NULL)
+        lcd_extern_config = kzalloc(sizeof(*lcd_extern_config), GFP_KERNEL);
+    if (lcd_extern_config == NULL) {
         printk("[error] %s probe: failed to alloc data\n", LCD_EXTERN_NAME);
         return -1;
     }
 
-    pdev->dev.platform_data = lcd_ext_config;
+    pdev->dev.platform_data = lcd_extern_config;
 
-    if (get_lcd_extern_dt_data(pdev->dev.of_node, lcd_ext_config) != 0) {
-        printk("[error] %s probe: failed to get dt data\n", LCD_EXTERN_NAME);
+    ret = get_lcd_extern_config(pdev->dev.of_node, lcd_extern_config);
+    if (ret) {
         goto lcd_extern_probe_failed;
     }
 
     memset(&i2c_info, 0, sizeof(i2c_info));
 
-    adapter = i2c_get_adapter(lcd_ext_config->i2c_bus);
+    adapter = i2c_get_adapter(lcd_extern_config->i2c_bus);
     if (!adapter) {
         printk("[error] %sfailed to get i2c adapter\n", LCD_EXTERN_NAME);
         goto lcd_extern_probe_failed;
     }
 
-    strncpy(i2c_info.type, lcd_ext_config->name, I2C_NAME_SIZE);
-    i2c_info.addr = lcd_ext_config->i2c_addr;
-    i2c_info.platform_data = lcd_ext_config;
+    strncpy(i2c_info.type, lcd_extern_config->name, I2C_NAME_SIZE);
+    i2c_info.addr = lcd_extern_config->i2c_addr;
+    i2c_info.platform_data = lcd_extern_config;
     i2c_info.flags=0;
     if(i2c_info.addr>0x7f)
         i2c_info.flags=0x10;
@@ -259,14 +267,15 @@ static int aml_tc101_probe(struct platform_device *pdev)
     return ret;
 
 lcd_extern_probe_failed:
-    if (lcd_ext_config)
-        kfree(lcd_ext_config);
+    if (lcd_extern_config) {
+        kfree(lcd_extern_config);
+        lcd_extern_config = NULL;
+    }
     return -1;
 }
 
 static int aml_tc101_remove(struct platform_device *pdev)
 {
-    remove_lcd_extern(lcd_ext_config);
     if (pdev->dev.platform_data)
         kfree (pdev->dev.platform_data);
     return 0;
diff --git a/drivers/amlogic/display/vout/lcd_extern/lcd_extern.c b/drivers/amlogic/display/vout/lcd_extern/lcd_extern.c
old mode 100644
new mode 100755
index 9ddcf608..2a6fc72d
--- a/drivers/amlogic/display/vout/lcd_extern/lcd_extern.c
+++ b/drivers/amlogic/display/vout/lcd_extern/lcd_extern.c
@@ -1,188 +1,172 @@
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/interrupt.h>
-#include <linux/platform_device.h>
-#include <linux/i2c.h>
-#include <linux/i2c-aml.h>
-#include <linux/clk.h>
-#include <linux/delay.h>
-#include <linux/slab.h>
-#include <linux/of.h>
-#include <mach/am_regs.h>
-#include <mach/gpio.h>
-#include <linux/amlogic/vout/aml_lcd_extern.h>
-
-//#define LCD_EXT_DEBUG_INFO
-#ifdef LCD_EXT_DEBUG_INFO
-#define DBG_PRINT(...)		printk(__VA_ARGS__)
-#else
-#define DBG_PRINT(...)
-#endif
-
-static struct aml_lcd_extern_driver_t lcd_ext_driver = {
-	.type = LCD_EXTERN_MAX,
-	.name = NULL,
-	.reg_read = NULL,
-	.reg_write = NULL,
-	.power_on = NULL,
-	.power_off = NULL,
-	.init_on_cmd_8 = NULL,
-	.init_off_cmd_8 = NULL,
-};
-
-struct aml_lcd_extern_driver_t* aml_lcd_extern_get_driver(void)
-{
-    return &lcd_ext_driver;
-}
-
-int lcd_extern_driver_check(void)
-{
-	struct aml_lcd_extern_driver_t* lcd_ext;
-
-	lcd_ext = aml_lcd_extern_get_driver();
-	if (lcd_ext) {
-		if (lcd_ext->type < LCD_EXTERN_MAX) {
-			printk("[warning]: lcd_extern has already exist (%s)\n", lcd_ext->name);
-			return -1;
-		}
-	}
-	else {
-		printk("get lcd_extern_driver failed\n");
-	}
-	
-	return 0;
-}
-
-#define BL_EXT_NAME_LEN_MAX		50
-int get_lcd_extern_dt_data(struct device_node* of_node, struct lcd_extern_config_t *pdata)
-{
-	int err;
-	int val;
-	const char *str;
-	
-	err = of_property_read_string(of_node, "dev_name", &str);
-	if (err) {
-		str = "aml_lcd_extern";
-		printk("warning: get dev_name failed\n");
-	}
-	pdata->name = (char *)kmalloc(sizeof(char)*BL_EXT_NAME_LEN_MAX, GFP_KERNEL);
-	if (pdata->name == NULL) {
-		printk("[get_lcd_extern_dt_data]: Not enough memory\n");
-	}
-	else {
-		memset(pdata->name, 0, BL_EXT_NAME_LEN_MAX);
-		strcpy(pdata->name, str);
-		printk("load bl_extern in dtb: %s\n", pdata->name);
-	}
-	err = of_property_read_u32(of_node, "type", &pdata->type);
-	if (err) {
-		pdata->type = LCD_EXTERN_MAX;
-		printk("warning: get type failed, exit\n");
-		return -1;
-	}
-	switch (pdata->type) {
-		case LCD_EXTERN_I2C:
-			err = of_property_read_u32(of_node,"i2c_address",&pdata->i2c_addr);
-			if (err) {
-				printk("%s warning: get i2c_address failed\n", pdata->name);
-				pdata->i2c_addr = 0;
-			}
-			DBG_PRINT("%s: i2c_address=0x%02x\n", pdata->name, pdata->i2c_addr);
-		  
-			err = of_property_read_string(of_node, "i2c_bus", &str);
-			if (err) {
-				printk("%s warning: get i2c_bus failed, use default i2c bus\n", pdata->name);
-				pdata->i2c_bus = AML_I2C_MASTER_A;
-			}
-			else {
-				if (strncmp(str, "i2c_bus_a", 9) == 0)
-					pdata->i2c_bus = AML_I2C_MASTER_A;
-				else if (strncmp(str, "i2c_bus_b", 9) == 0)
-					pdata->i2c_bus = AML_I2C_MASTER_B;
-				else if (strncmp(str, "i2c_bus_c", 9) == 0)
-					pdata->i2c_bus = AML_I2C_MASTER_C;
-				else if (strncmp(str, "i2c_bus_d", 9) == 0)
-					pdata->i2c_bus = AML_I2C_MASTER_D;
-				else if (strncmp(str, "i2c_bus_ao", 10) == 0)
-					pdata->i2c_bus = AML_I2C_MASTER_AO;
-				else
-					pdata->i2c_bus = AML_I2C_MASTER_A; 
-			}
-			DBG_PRINT("%s: i2c_bus=%s[%d]\n", pdata->name, str, pdata->i2c_bus);
-			break;
-		case LCD_EXTERN_SPI:
-			err = of_property_read_string(of_node,"gpio_spi_cs", &str);
-			if (err) {
-				printk("%s warning: get spi gpio_spi_cs failed\n", pdata->name);
-				pdata->spi_cs = -1;
-			}
-			else {
-			    val = amlogic_gpio_name_map_num(str);
-				if (val > 0) {
-					err = lcd_extern_gpio_request(val);
-					if (err) {
-					  printk("faild to alloc spi_cs gpio (%s)!\n", str);
-					}
-					pdata->spi_cs = val;
-					DBG_PRINT("spi_cs gpio = %s(%d)\n", str, pdata->spi_cs);
-				}
-				else {
-					pdata->spi_cs = -1;
-				}
-			}
-			err = of_property_read_string(of_node,"gpio_spi_clk", &str);
-			if (err) {
-				printk("%s warning: get spi gpio_spi_clk failed\n", pdata->name);
-				pdata->spi_clk = -1;
-			}
-			else {
-			    val = amlogic_gpio_name_map_num(str);
-				if (val > 0) {
-					err = lcd_extern_gpio_request(val);
-					if (err) {
-					  printk("faild to alloc spi_clk gpio (%s)!\n", str);
-					}
-					pdata->spi_clk = val;
-					DBG_PRINT("spi_clk gpio = %s(%d)\n", str, pdata->spi_clk);
-				}
-				else {
-					pdata->spi_clk = -1;
-				}
-			}
-			err = of_property_read_string(of_node,"gpio_spi_data", &str);
-			if (err) {
-				printk("%s warning: get spi gpio_spi_data failed\n", pdata->name);
-				pdata->spi_data = -1;
-			}
-			else {
-			    val = amlogic_gpio_name_map_num(str);
-				if (val > 0) {
-					err = lcd_extern_gpio_request(val);
-					if (err) {
-					  printk("faild to alloc spi_data gpio (%s)!\n", str);
-					}
-					pdata->spi_data = val;
-					DBG_PRINT("spi_data gpio = %s(%d)\n", str, pdata->spi_data);
-				}
-				else {
-					pdata->spi_data = -1;
-				}
-			}
-			break;
-		case LCD_EXTERN_MIPI:
-			break;
-		default:
-			break;
-	}
-	
-	return 0;
-}
-
-int remove_lcd_extern(struct lcd_extern_config_t *pdata)
-{
-	if (pdata->name)
-		kfree(pdata->name);
-		
-	return 0;
-}
-
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/interrupt.h>
+#include <linux/platform_device.h>
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/clk.h>
+#include <linux/delay.h>
+#include <linux/slab.h>
+#include <linux/of.h>
+#include <mach/am_regs.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+
+//#define LCD_EXT_DEBUG_INFO
+#ifdef LCD_EXT_DEBUG_INFO
+#define DBG_PRINT(...)		printk(__VA_ARGS__)
+#else
+#define DBG_PRINT(...)
+#endif
+
+static struct aml_lcd_extern_driver_t lcd_ext_driver = {
+	.type = LCD_EXTERN_MAX,
+	.name = NULL,
+	.reg_read = NULL,
+	.reg_write = NULL,
+	.power_on = NULL,
+	.power_off = NULL,
+	.init_on_cmd_8 = NULL,
+	.init_off_cmd_8 = NULL,
+};
+
+struct aml_lcd_extern_driver_t* aml_lcd_extern_get_driver(void)
+{
+    return &lcd_ext_driver;
+}
+
+int lcd_extern_driver_check(void)
+{
+	struct aml_lcd_extern_driver_t* lcd_ext;
+
+	lcd_ext = aml_lcd_extern_get_driver();
+	if (lcd_ext) {
+		if (lcd_ext->type < LCD_EXTERN_MAX) {
+			printk("[warning]: lcd_extern has already exist (%s)\n", lcd_ext->name);
+			return -1;
+		}
+	}
+	else {
+		printk("get lcd_extern_driver failed\n");
+	}
+	
+	return 0;
+}
+
+int get_lcd_extern_dt_data(struct device_node* of_node, struct lcd_extern_config_t *pdata)
+{
+	int err;
+	int val;
+	const char *str;
+	
+	err = of_property_read_string(of_node, "dev_name", (const char **)&pdata->name);
+	if (err) {
+		pdata->name = "aml_lcd_extern";
+		printk("warning: get dev_name failed\n");
+	}
+	printk("load lcd_extern in dtb: %s\n", pdata->name);
+
+	err = of_property_read_u32(of_node, "type", &pdata->type);
+	if (err) {
+		pdata->type = LCD_EXTERN_MAX;
+		printk("warning: get type failed, exit\n");
+		return -1;
+	}
+	switch (pdata->type) {
+		case LCD_EXTERN_I2C:
+			err = of_property_read_u32(of_node,"i2c_address",&pdata->i2c_addr);
+			if (err) {
+				printk("%s warning: get i2c_address failed\n", pdata->name);
+				pdata->i2c_addr = 0;
+			}
+			DBG_PRINT("%s: i2c_address=0x%02x\n", pdata->name, pdata->i2c_addr);
+		  
+			err = of_property_read_string(of_node, "i2c_bus", &str);
+			if (err) {
+				printk("%s warning: get i2c_bus failed, use default i2c bus\n", pdata->name);
+				pdata->i2c_bus = AML_I2C_MASTER_A;
+			}
+			else {
+				if (strncmp(str, "i2c_bus_a", 9) == 0)
+					pdata->i2c_bus = AML_I2C_MASTER_A;
+				else if (strncmp(str, "i2c_bus_b", 9) == 0)
+					pdata->i2c_bus = AML_I2C_MASTER_B;
+				else if (strncmp(str, "i2c_bus_c", 9) == 0)
+					pdata->i2c_bus = AML_I2C_MASTER_C;
+				else if (strncmp(str, "i2c_bus_d", 9) == 0)
+					pdata->i2c_bus = AML_I2C_MASTER_D;
+				else if (strncmp(str, "i2c_bus_ao", 10) == 0)
+					pdata->i2c_bus = AML_I2C_MASTER_AO;
+				else
+					pdata->i2c_bus = AML_I2C_MASTER_A; 
+			}
+			DBG_PRINT("%s: i2c_bus=%s[%d]\n", pdata->name, str, pdata->i2c_bus);
+			break;
+		case LCD_EXTERN_SPI:
+			err = of_property_read_string(of_node,"gpio_spi_cs", &str);
+			if (err) {
+				printk("%s warning: get spi gpio_spi_cs failed\n", pdata->name);
+				pdata->spi_cs = -1;
+			}
+			else {
+				val = amlogic_gpio_name_map_num(str);
+				if (val > 0) {
+					err = lcd_extern_gpio_request(val);
+					if (err) {
+					  printk("faild to alloc spi_cs gpio (%s)!\n", str);
+					}
+					pdata->spi_cs = val;
+					DBG_PRINT("spi_cs gpio = %s(%d)\n", str, pdata->spi_cs);
+				}
+				else {
+					pdata->spi_cs = -1;
+				}
+			}
+			err = of_property_read_string(of_node,"gpio_spi_clk", &str);
+			if (err) {
+				printk("%s warning: get spi gpio_spi_clk failed\n", pdata->name);
+				pdata->spi_clk = -1;
+			}
+			else {
+				val = amlogic_gpio_name_map_num(str);
+				if (val > 0) {
+					err = lcd_extern_gpio_request(val);
+					if (err) {
+					  printk("faild to alloc spi_clk gpio (%s)!\n", str);
+					}
+					pdata->spi_clk = val;
+					DBG_PRINT("spi_clk gpio = %s(%d)\n", str, pdata->spi_clk);
+				}
+				else {
+					pdata->spi_clk = -1;
+				}
+			}
+			err = of_property_read_string(of_node,"gpio_spi_data", &str);
+			if (err) {
+				printk("%s warning: get spi gpio_spi_data failed\n", pdata->name);
+				pdata->spi_data = -1;
+			}
+			else {
+				val = amlogic_gpio_name_map_num(str);
+				if (val > 0) {
+					err = lcd_extern_gpio_request(val);
+					if (err) {
+					  printk("faild to alloc spi_data gpio (%s)!\n", str);
+					}
+					pdata->spi_data = val;
+					DBG_PRINT("spi_data gpio = %s(%d)\n", str, pdata->spi_data);
+				}
+				else {
+					pdata->spi_data = -1;
+				}
+			}
+			break;
+		case LCD_EXTERN_MIPI:
+			break;
+		default:
+			break;
+	}
+	
+	return 0;
+}
+
diff --git a/drivers/amlogic/display/vout/lcd_extern/mipi_KD080D13.c b/drivers/amlogic/display/vout/lcd_extern/mipi_KD080D13.c
new file mode 100644
index 00000000..cde6ae09
--- /dev/null
+++ b/drivers/amlogic/display/vout/lcd_extern/mipi_KD080D13.c
@@ -0,0 +1,209 @@
+/*
+ * AMLOGIC lcd external driver.
+ *
+ * Communication protocol:
+ * MIPI 
+ *
+ */
+
+#include <linux/kernel.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/slab.h>
+#include <linux/jiffies.h> 
+#include <linux/i2c.h>
+#include <linux/i2c-aml.h>
+#include <linux/miscdevice.h>
+#include <linux/mutex.h>
+#include <linux/mm.h>
+#include <linux/device.h>
+#include <linux/fs.h>
+#include <linux/delay.h>
+#include <linux/sysctl.h>
+#include <asm/uaccess.h>
+#include <mach/pinmux.h>
+#include <mach/gpio.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+
+static struct lcd_extern_config_t *lcd_extern_config = NULL;
+
+//#define LCD_EXT_DEBUG_INFO
+#ifdef LCD_EXT_DEBUG_INFO
+#define DBG_PRINT(...)		printk(__VA_ARGS__)
+#else
+#define DBG_PRINT(...)
+#endif
+
+#define LCD_EXTERN_NAME			"lcd_mipi_KD080D13"
+
+//******************** mipi command ********************//
+//format:  data_type, num, data....
+//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
+//******************************************************//
+static unsigned char mipi_init_on_table[] = {
+    0x39,3,0xf0,0x5a,0x5a,
+    0x39,3,0xf1,0x5a,0x5a,
+    0x39,3,0xfc,0xa5,0xa5,
+    0x39,3,0xd0,0x00,0x10,
+    0x15,2,0xb1,0x10,
+    0x39,5,0xb2,0x14,0x22,0x2f,0x04,
+    0x39,6,0xf2,0x02,0x08,0x08,0x40,0x10,
+    0x15,2,0xb0,0x03,
+    0x39,3,0xfd,0x23,0x09,
+    0x39,11,0xf3,0x01,0x93,0x20,0x22,0x80,0x05,0x25,0x3c,0x26,0x00,
+    0x39,46,0xf4,0x00,0x02,0x03,0x26,0x03,0x02,0x09,0x00,0x07,0x16,0x16,0x03,0x00,0x08,0x08,0x03,0x0E,0x0F,0x12,0x1C,0x1D,0x1E,0x0C,0x09,0x01,0x04,0x02,0x61,0x74,0x75,0x72,0x83,0x80,0x80,0xB0,0x00,0x01,0x01,0x28,0x04,0x03,0x28,0x01,0xD1,0x32,
+    0x39,27,0xf5,0x84,0x2F,0x2F,0x5F,0xAB,0x98,0x52,0x0F,0x33,0x43,0x04,0x59,0x54,0x52,0x05,0x40,0x60,0x4E,0x60,0x40,0x27,0x26,0x52,0x25,0x6D,0x18,
+    0x39,9,0xee,0x25,0x00,0x25,0x00,0x25,0x00,0x25,0x00,
+    0x39,9,0xef,0x34,0x12,0x98,0xBA,0x20,0x00,0x24,0x80,
+    0x39,33,0xf7,0x0E,0x0E,0x0A,0x0A,0x0F,0x0F,0x0B,0x0B,0x05,0x07,0x01,0x01,0x01,0x01,0x01,0x01,0x0C,0x0C,0x08,0x08,0x0D,0x0D,0x09,0x09,0x04,0x06,0x01,0x01,0x01,0x01,0x01,0x01,
+    0x39,4,0xbc,0x01,0x4e,0x0a,
+    0x39,6,0xe1,0x03,0x10,0x1c,0xa0,0x10,
+    0x39,7,0xf6,0x60,0x21,0xA6,0x00,0x00,0x00,
+    0x39,7,0xfe,0x00,0x0D,0x03,0x21,0x80,0x48,
+    0x15,2,0xb0,0x22,
+    0x39,18,0xfa,0x02,0x34,0x09,0x13,0x0B,0x0F,0x16,0x16,0x17,0x1E,0x1D,0x1C,0x1E,0x1D,0x1D,0x1F,0x24,
+    0x15,2,0xb0,0x22,
+    0x39,18,0xfb,0x00,0x34,0x07,0x11,0x09,0x0D,0x14,0x14,0x15,0x1C,0x1F,0x1C,0x1D,0x1D,0x1D,0x20,0x26,
+    0x15,2,0xb0,0x11,
+    0x39,18,0xfa,0x20,0x34,0x24,0x27,0x19,0x1B,0x1F,0x1E,0x1B,0x1F,0x21,0x1F,0x1E,0x20,0x1E,0x1E,0x21,
+    0x15,2,0xb0,0x11,
+    0x39,18,0xfb,0x1E,0x34,0x22,0x25,0x17,0x19,0x1D,0x1A,0x19,0x20,0x1F,0x1E,0x20,0x1E,0x1E,0x1F,0x22,
+    0x39,18,0xfa,0x1C,0x34,0x1C,0x1F,0x13,0x17,0x1A,0x18,0x18,0x1E,0x20,0x21,0x21,0x21,0x23,0x22,0x2A,
+    0x39,18,0xfb,0x1A,0x34,0x1A,0x1D,0x11,0x15,0x18,0x16,0x16,0x1C,0x20,0x20,0x20,0x1F,0x23,0x23,0x2B,
+
+    0x05,1,0x11,
+    0xff,20,
+    0x39,4,0xc3,0x40,0x00,0x28,
+    0xff,200,
+    0x15,2,0x35,0x00,
+    0x05,1,0x29,
+    0xff,30,     //delay 30ms
+    0xff,0xff,   //ending flag
+};
+
+static unsigned char mipi_init_off_table[] = {
+    0x05,1,0x28, //display off
+    0xff,30,     //delay 30ms
+    0x05,1,0x10, //sleep in
+    0xff,30,     //delay 30ms
+    0x39,4,0xc3,0x40,0x00,0x20,
+    0xff,10,
+    0xff,0xff,   //ending flag
+};
+
+static int get_lcd_extern_config(struct device_node* of_node, struct lcd_extern_config_t *lcd_ext_cfg)
+{
+    int ret = 0;
+    struct aml_lcd_extern_driver_t* lcd_ext;
+
+    ret = get_lcd_extern_dt_data(of_node, lcd_ext_cfg);
+    if (ret) {
+        printk("[error] %s: failed to get dt data\n", LCD_EXTERN_NAME);
+        return ret;
+    }
+
+    //lcd extern driver update
+    lcd_ext = aml_lcd_extern_get_driver();
+    if (lcd_ext) {
+        lcd_ext->type      = lcd_ext_cfg->type;
+        lcd_ext->name      = lcd_ext_cfg->name;
+        lcd_ext->init_on_cmd_8  = &mipi_init_on_table[0];
+        lcd_ext->init_off_cmd_8 = &mipi_init_off_table[0];
+    }
+    else {
+        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_cfg->name);
+        ret = -1;
+    }
+
+    return ret;
+}
+
+static int aml_KD080D13_probe(struct platform_device *pdev)
+{
+    int ret = 0;
+
+    if (lcd_extern_driver_check()) {
+        return -1;
+    }
+    if (lcd_extern_config == NULL)
+        lcd_extern_config = kzalloc(sizeof(*lcd_extern_config), GFP_KERNEL);
+    if (lcd_extern_config == NULL) {
+        printk("[error] %s probe: failed to alloc data\n", LCD_EXTERN_NAME);
+        return -1;
+    }
+
+    pdev->dev.platform_data = lcd_extern_config;
+
+    ret = get_lcd_extern_config(pdev->dev.of_node, lcd_extern_config);
+    if (ret) {
+        goto lcd_extern_probe_failed;
+    }
+
+    printk("%s probe ok\n", LCD_EXTERN_NAME);
+    return ret;
+
+lcd_extern_probe_failed:
+    if (lcd_extern_config) {
+        kfree(lcd_extern_config);
+        lcd_extern_config = NULL;
+    }
+    return -1;
+}
+
+static int aml_KD080D13_remove(struct platform_device *pdev)
+{
+    if (pdev->dev.platform_data)
+        kfree (pdev->dev.platform_data);
+    return 0;
+}
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id aml_KD080D13_dt_match[]={
+    {
+        .compatible = "amlogic,lcd_mipi_KD080D13",
+    },
+    {},
+};
+#else
+#define aml_KD080D13_dt_match NULL
+#endif
+
+static struct platform_driver aml_KD080D13_driver = {
+    .probe  = aml_KD080D13_probe,
+    .remove = aml_KD080D13_remove,
+    .driver = {
+        .name  = LCD_EXTERN_NAME,
+        .owner = THIS_MODULE,
+#ifdef CONFIG_USE_OF
+        .of_match_table = aml_KD080D13_dt_match,
+#endif
+    },
+};
+
+static int __init aml_KD080D13_init(void)
+{
+    int ret;
+    DBG_PRINT("%s\n", __FUNCTION__);
+
+    ret = platform_driver_register(&aml_KD080D13_driver);
+    if (ret) {
+        printk("[error] %s failed to register lcd extern driver module\n", __FUNCTION__);
+        return -ENODEV;
+    }
+
+    return ret;
+}
+
+static void __exit aml_KD080D13_exit(void)
+{
+    platform_driver_unregister(&aml_KD080D13_driver);
+}
+
+//late_initcall(aml_KD080D13_init);
+module_init(aml_KD080D13_init);
+module_exit(aml_KD080D13_exit);
+
+MODULE_AUTHOR("AMLOGIC");
+MODULE_DESCRIPTION("LCD Extern driver for KD080D13");
+MODULE_LICENSE("GPL");
diff --git a/drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c b/drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c
old mode 100644
new mode 100755
index a8ae633c..16f7db2a
--- a/drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c
+++ b/drivers/amlogic/display/vout/lcd_extern/mipi_N070ICN.c
@@ -2,7 +2,7 @@
  * AMLOGIC lcd external driver.
  *
  * Communication protocol:
- * MIPI 
+ * MIPI
  *
  */
 
@@ -11,7 +11,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
-#include <linux/jiffies.h> 
+#include <linux/jiffies.h>
 #include <linux/i2c.h>
 #include <linux/i2c-aml.h>
 #include <linux/miscdevice.h>
@@ -26,7 +26,7 @@
 #include <mach/gpio.h>
 #include <linux/amlogic/vout/aml_lcd_extern.h>
 
-static struct lcd_extern_config_t *lcd_ext_config = NULL;
+static struct lcd_extern_config_t *lcd_extern_config = NULL;
 
 //#define LCD_EXT_DEBUG_INFO
 #ifdef LCD_EXT_DEBUG_INFO
@@ -37,232 +37,245 @@ static struct lcd_extern_config_t *lcd_ext_config = NULL;
 
 #define LCD_EXTERN_NAME			"lcd_mipi_N070ICN"
 
+//******************** mipi command ********************//
+//format:  data_type, num, data....
+//special: data_type=0xff, num<0xff means delay ms, num=0xff means ending.
+//******************************************************//
 static unsigned char mipi_init_on_table[] = {
-    0x39,0xFF,4,0xAA,0x55,0xA5,0x80, //========== Internal setting ==========
-
-    0x39,0x6F,2,0x11,0x00, //MIPI related Timing Setting
-    0x39,0xF7,2,0x20,0x00,
-
-    0x15,0x6F,1,0x06,      //Improve ESD option
-    0x15,0xF7,1,0xA0,
-    0x15,0x6F,1,0x19,
-    0x15,0xF7,1,0x12,
-
-    0x15,0x6F,1,0x08,     //Vcom floating
-    0x15,0xFA,1,0x40,
-    0x15,0x6F,1,0x11,
-    0x15,0xF3,1,0x01,
-
-    0x39,0xF0,5,0x55,0xAA,0x52,0x08,0x00, //========== page0 relative ==========
-    0x15,0xC8,1,0x80,
-
-    0x39,0xB1,2,0x6C,0x01, //Set WXGA resolution
-
-    0x15,0xB6,1,0x08,      //Set source output hold time
-
-    0x15,0x6F,1,0x02,      //EQ control function
-    0x15,0xB8,1,0x08,
-
-    0x39,0xBB,2,0x54,0x54, //Set bias current for GOP and SOP
-
-    0x39,0xBC,2,0x05,0x05, //Inversion setting
-
-    0x15,0xC7,1,0x01,      //zigzag setting
-
-    0x39,0xBD,5,0x02,0xB0,0x0C,0x0A,0x00, //DSP Timing Settings update for BIST
-
-    0x39,0xF0,5,0x55,0xAA,0x52,0x08,0x01, //========== page1 relative ==========
-
-    0x39,0xB0,2,0x05,0x05,                // Setting AVDD, AVEE clamp
-    0x39,0xB1,2,0x05,0x05,
-
-    0x39,0xBC,2,0x3A,0x01,                // VGMP, VGMN, VGSP, VGSN setting
-    0x39,0xBD,2,0x3E,0x01,
-
-    0x15,0xCA,1,0x00,                    // gate signal control
-
-    0x15,0xC0,1,0x04,                    // power IC control
-    0x15,0xB2,1,0x00,
-    0x15,0xBE,1,0x80,      //vcom    -1.88V
-
-    0x39,0xB3,2,0x19,0x19, // Setting VGH=15V, VGL=-11V
-    0x39,0xB4,2,0x12,0x12,
-
-    0x39,0xB9,2,0x24,0x24, // power control for VGH, VGL
-    0x39,0xBA,2,0x14,0x14,
-
-    0x39,0xF0,5,0x55,0xAA,0x52,0x08,0x02, //========== page2 relative ==========
-
-    0x15,0xEE,1,0x01,                     //Gamma setting
-    0x39,0xEF,4,0x09,0x06,0x15,0x18,      //Gradient Control for Gamma Voltage
-
-    0x39,0xB0,6,0x00,0x00,0x00,0x08,0x00,0x17, //========== GOA relative ==========
-    0x15,0x6F,1,0x06,
-    0x39,0xB0,6,0x00,0x25,0x00,0x30,0x00,0x45,
-    0x15,0x6F,1,0x0C,
-    0x39,0xB0,4,0x00,0x56,0x00,0x7A,
-    0x39,0xB1,6,0x00,0xA3,0x00,0xE7,0x01,0x20, ////////////////////////////
-    0x15,0x6F,1,0x06,
-    0x39,0xB1,6,0x01,0x7A,0x01,0xC2,0x01,0xC5,
-    0x15,0x6F,1,0x0C,
-    0x39,0xB1,4,0x02,0x06,0x02,0x5F,
-    0x39,0xB2,6,0x02,0x92,0x02,0xD0,0x02,0xFC,
-    0x15,0x6F,1,0x06,
-    0x39,0xB2,6,0x03,0x35,0x03,0x5D,0x03,0x8B,
-    0x15,0x6F,1,0x0C,
-    0x39,0xB2,4,0x03,0xA2,0x03,0xBF,
-    0x39,0xB3,4,0x03,0xD2,0x03,0xFF,
-
-    0x39,0xF0,5,0x55,0xAA,0x52,0x08,0x06,      //PAGE6 : GOUT Mapping, VGLO select
-    0x39,0xB0,2,0x00,0x17,
-    0x39,0xB1,2,0x16,0x15,
-    0x39,0xB2,2,0x14,0x13,
-    0x39,0xB3,2,0x12,0x11,
-    0x39,0xB4,2,0x10,0x2D,
-    0x39,0xB5,2,0x01,0x08,
-    0x39,0xB6,2,0x09,0x31,
-    0x39,0xB7,2,0x31,0x31,
-    0x39,0xB8,2,0x31,0x31,
-    0x39,0xB9,2,0x31,0x31,
-    0x39,0xBA,2,0x31,0x31,
-    0x39,0xBB,2,0x31,0x31,
-    0x39,0xBC,2,0x31,0x31,
-    0x39,0xBD,2,0x31,0x09,
-    0x39,0xBE,2,0x08,0x01,
-    0x39,0xBF,2,0x2D,0x10,
-    0x39,0xC0,2,0x11,0x12,
-    0x39,0xC1,2,0x13,0x14,
-    0x39,0xC2,2,0x15,0x16,
-    0x39,0xC3,2,0x17,0x00,
-    0x39,0xE5,2,0x31,0x31,
-    0x39,0xC4,2,0x00,0x17,
-    0x39,0xC5,2,0x16,0x15,
-    0x39,0xC6,2,0x14,0x13,
-    0x39,0xC7,2,0x12,0x11,
-    0x39,0xC8,2,0x10,0x2D,
-    0x39,0xC9,2,0x01,0x08,
-    0x39,0xCA,2,0x09,0x31,
-    0x39,0xCB,2,0x31,0x31,
-    0x39,0xCC,2,0x31,0x31,
-    0x39,0xCD,2,0x31,0x31,
-    0x39,0xCE,2,0x31,0x31,
-    0x39,0xCF,2,0x31,0x31,
-    0x39,0xD0,2,0x31,0x31,
-    0x39,0xD1,2,0x31,0x09,
-    0x39,0xD2,2,0x08,0x01,
-    0x39,0xD3,2,0x2D,0x10,
-    0x39,0xD4,2,0x11,0x12,
-    0x39,0xD5,2,0x13,0x14,
-    0x39,0xD6,2,0x15,0x16,
-    0x39,0xD7,2,0x17,0x00,
-    0x39,0xE6,2,0x31,0x31,
-    0x39,0xD8,5,0x00,0x00,0x00,0x00,0x00, //VGL level select;
-    0x39,0xD9,5,0x00,0x00,0x00,0x00,0x00,
-    0x15,0xE7,1,0x00,
-
-    0x39,0xF0,5,0x55,0xAA,0x52,0x08,0x03, //===page 3====//gate timing control
-    0x39,0xB0,2,0x20,0x00,
-    0x39,0xB1,2,0x20,0x00,
-    0x39,0xB2,5,0x05,0x00,0x42,0x00,0x00,
-    0x39,0xB6,5,0x05,0x00,0x42,0x00,0x00,
-    0x39,0xBA,5,0x53,0x00,0x42,0x00,0x00,
-    0x39,0xBB,5,0x53,0x00,0x42,0x00,0x00,
-    0x15,0xC4,1,0x40,
-
-    0x39,0xF0,5,0x55,0xAA,0x52,0x08,0x05, //===page 5====//
-    0x39,0xB0,2,0x17,0x06,
-    0x15,0xB8,1,0x00,
-    0x39,0xBD,5,0x03,0x01,0x01,0x00,0x01,
-    0x39,0xB1,2,0x17,0x06,
-    0x39,0xB9,2,0x00,0x01,
-    0x39,0xB2,2,0x17,0x06,
-    0x39,0xBA,2,0x00,0x01,
-    0x39,0xB3,2,0x17,0x06,
-    0x39,0xBB,2,0x0A,0x00,
-    0x39,0xB4,2,0x17,0x06,
-    0x39,0xB5,2,0x17,0x06,
-    0x39,0xB6,2,0x14,0x03,
-    0x39,0xB7,2,0x00,0x00,
-    0x39,0xBC,2,0x02,0x01,
-    0x15,0xC0,1,0x05,
-    0x15,0xC4,1,0xA5,
-    0x39,0xC8,2,0x03,0x30,
-    0x39,0xC9,2,0x03,0x51,
-    0x39,0xD1,5,0x00,0x05,0x03,0x00,0x00,
-    0x39,0xD2,5,0x00,0x05,0x09,0x00,0x00,
-    0x15,0xE5,1,0x02,
-    0x15,0xE6,1,0x02,
-    0x15,0xE7,1,0x02,
-    0x15,0xE9,1,0x02,
-    0x15,0xED,1,0x33,
-
-    0x05,0x11,0, //sleep out
+    0x39,5,0xFF,0xAA,0x55,0xA5,0x80, //========== Internal setting ==========
+
+    0x39,3,0x6F,0x11,0x00, //MIPI related Timing Setting
+    0x39,3,0xF7,0x20,0x00,
+
+    0x15,2,0x6F,0x06,      //Improve ESD option
+    0x15,2,0xF7,0xA0,
+    0x15,2,0x6F,0x19,
+    0x15,2,0xF7,0x12,
+
+    0x15,2,0x6F,0x08,     //Vcom floating
+    0x15,2,0xFA,0x40,
+    0x15,2,0x6F,0x11,
+    0x15,2,0xF3,0x01,
+
+    0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x00, //========== page0 relative ==========
+    0x15,2,0xC8,0x80,
+
+    0x39,3,0xB1,0x6C,0x01, //Set WXGA resolution
+
+    0x15,2,0xB6,0x08,      //Set source output hold time
+
+    0x15,2,0x6F,0x02,      //EQ control function
+    0x15,2,0xB8,0x08,
+
+    0x39,3,0xBB,0x54,0x54, //Set bias current for GOP and SOP
+
+    0x39,3,0xBC,0x05,0x05, //Inversion setting
+
+    0x15,2,0xC7,0x01,      //zigzag setting
+
+    0x39,6,0xBD,0x02,0xB0,0x0C,0x0A,0x00, //DSP Timing Settings update for BIST
+
+    0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x01, //========== page1 relative ==========
+
+    0x39,3,0xB0,0x05,0x05,                // Setting AVDD, AVEE clamp
+    0x39,3,0xB1,0x05,0x05,
+
+    0x39,3,0xBC,0x3A,0x01,                // VGMP, VGMN, VGSP, VGSN setting
+    0x39,3,0xBD,0x3E,0x01,
+
+    0x15,2,0xCA,0x00,                    // gate signal control
+
+    0x15,2,0xC0,0x04,                    // power IC control
+    0x15,2,0xB2,0x00,
+    0x15,2,0xBE,0x80,      //vcom    -1.88V
+
+    0x39,3,0xB3,0x19,0x19, // Setting VGH=15V, VGL=-11V
+    0x39,3,0xB4,0x12,0x12,
+
+    0x39,3,0xB9,0x24,0x24, // power control for VGH, VGL
+    0x39,3,0xBA,0x14,0x14,
+
+    0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x02, //========== page2 relative ==========
+
+    0x15,2,0xEE,0x01,                     //Gamma setting
+    0x39,5,0xEF,0x09,0x06,0x15,0x18,      //Gradient Control for Gamma Voltage
+
+    0x39,7,0xB0,0x00,0x00,0x00,0x08,0x00,0x17, //========== GOA relative ==========
+    0x15,2,0x6F,0x06,
+    0x39,7,0xB0,0x00,0x25,0x00,0x30,0x00,0x45,
+    0x15,2,0x6F,0x0C,
+    0x39,5,0xB0,0x00,0x56,0x00,0x7A,
+    0x39,7,0xB1,0x00,0xA3,0x00,0xE7,0x01,0x20, ////////////////////////////
+    0x15,2,0x6F,0x06,
+    0x39,7,0xB1,0x01,0x7A,0x01,0xC2,0x01,0xC5,
+    0x15,2,0x6F,0x0C,
+    0x39,5,0xB1,0x02,0x06,0x02,0x5F,
+    0x39,7,0xB2,0x02,0x92,0x02,0xD0,0x02,0xFC,
+    0x15,2,0x6F,0x06,
+    0x39,7,0xB2,0x03,0x35,0x03,0x5D,0x03,0x8B,
+    0x15,2,0x6F,0x0C,
+    0x39,5,0xB2,0x03,0xA2,0x03,0xBF,
+    0x39,5,0xB3,0x03,0xD2,0x03,0xFF,
+
+    0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x06,      //PAGE6 : GOUT Mapping, VGLO select
+    0x39,3,0xB0,0x00,0x17,
+    0x39,3,0xB1,0x16,0x15,
+    0x39,3,0xB2,0x14,0x13,
+    0x39,3,0xB3,0x12,0x11,
+    0x39,3,0xB4,0x10,0x2D,
+    0x39,3,0xB5,0x01,0x08,
+    0x39,3,0xB6,0x09,0x31,
+    0x39,3,0xB7,0x31,0x31,
+    0x39,3,0xB8,0x31,0x31,
+    0x39,3,0xB9,0x31,0x31,
+    0x39,3,0xBA,0x31,0x31,
+    0x39,3,0xBB,0x31,0x31,
+    0x39,3,0xBC,0x31,0x31,
+    0x39,3,0xBD,0x31,0x09,
+    0x39,3,0xBE,0x08,0x01,
+    0x39,3,0xBF,0x2D,0x10,
+    0x39,3,0xC0,0x11,0x12,
+    0x39,3,0xC1,0x13,0x14,
+    0x39,3,0xC2,0x15,0x16,
+    0x39,3,0xC3,0x17,0x00,
+    0x39,3,0xE5,0x31,0x31,
+    0x39,3,0xC4,0x00,0x17,
+    0x39,3,0xC5,0x16,0x15,
+    0x39,3,0xC6,0x14,0x13,
+    0x39,3,0xC7,0x12,0x11,
+    0x39,3,0xC8,0x10,0x2D,
+    0x39,3,0xC9,0x01,0x08,
+    0x39,3,0xCA,0x09,0x31,
+    0x39,3,0xCB,0x31,0x31,
+    0x39,3,0xCC,0x31,0x31,
+    0x39,3,0xCD,0x31,0x31,
+    0x39,3,0xCE,0x31,0x31,
+    0x39,3,0xCF,0x31,0x31,
+    0x39,3,0xD0,0x31,0x31,
+    0x39,3,0xD1,0x31,0x09,
+    0x39,3,0xD2,0x08,0x01,
+    0x39,3,0xD3,0x2D,0x10,
+    0x39,3,0xD4,0x11,0x12,
+    0x39,3,0xD5,0x13,0x14,
+    0x39,3,0xD6,0x15,0x16,
+    0x39,3,0xD7,0x17,0x00,
+    0x39,3,0xE6,0x31,0x31,
+    0x39,6,0xD8,0x00,0x00,0x00,0x00,0x00, //VGL level select;
+    0x39,6,0xD9,0x00,0x00,0x00,0x00,0x00,
+    0x15,2,0xE7,0x00,
+
+    0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x03, //===page 3====//gate timing control
+    0x39,3,0xB0,0x20,0x00,
+    0x39,3,0xB1,0x20,0x00,
+    0x39,6,0xB2,0x05,0x00,0x42,0x00,0x00,
+    0x39,6,0xB6,0x05,0x00,0x42,0x00,0x00,
+    0x39,6,0xBA,0x53,0x00,0x42,0x00,0x00,
+    0x39,6,0xBB,0x53,0x00,0x42,0x00,0x00,
+    0x15,2,0xC4,0x40,
+
+    0x39,6,0xF0,0x55,0xAA,0x52,0x08,0x05, //===page 5====//
+    0x39,3,0xB0,0x17,0x06,
+    0x15,2,0xB8,0x00,
+    0x39,6,0xBD,0x03,0x01,0x01,0x00,0x01,
+    0x39,3,0xB1,0x17,0x06,
+    0x39,3,0xB9,0x00,0x01,
+    0x39,3,0xB2,0x17,0x06,
+    0x39,3,0xBA,0x00,0x01,
+    0x39,3,0xB3,0x17,0x06,
+    0x39,3,0xBB,0x0A,0x00,
+    0x39,3,0xB4,0x17,0x06,
+    0x39,3,0xB5,0x17,0x06,
+    0x39,3,0xB6,0x14,0x03,
+    0x39,3,0xB7,0x00,0x00,
+    0x39,3,0xBC,0x02,0x01,
+    0x15,2,0xC0,0x05,
+    0x15,2,0xC4,0xA5,
+    0x39,3,0xC8,0x03,0x30,
+    0x39,3,0xC9,0x03,0x51,
+    0x39,6,0xD1,0x00,0x05,0x03,0x00,0x00,
+    0x39,6,0xD2,0x00,0x05,0x09,0x00,0x00,
+    0x15,2,0xE5,0x02,
+    0x15,2,0xE6,0x02,
+    0x15,2,0xE7,0x02,
+    0x15,2,0xE9,0x02,
+    0x15,2,0xED,0x33,
+
+    0x05,1,0x11, //sleep out
     0xff,30,     //delay 30ms
-    0x05,0x29,0, //display on
+    0x05,1,0x29, //display on
     0xff,30,     //delay 30ms
     0xff,0xff,   //ending flag
 };
 
 static unsigned char mipi_init_off_table[] = {
-    0x05,0x28,0, //display off
+    0x05,1,0x28, //display off
     0xff,10,     //delay 10ms
-    0x05,0x10,0, //sleep in
+    0x05,1,0x10, //sleep in
     0xff,10,     //delay 10ms
     0xff,0xff,   //ending flag
 };
 
-static int lcd_extern_driver_update(void)
+static int get_lcd_extern_config(struct device_node* of_node, struct lcd_extern_config_t *lcd_ext_cfg)
 {
+    int ret = 0;
     struct aml_lcd_extern_driver_t* lcd_ext;
 
+    ret = get_lcd_extern_dt_data(of_node, lcd_ext_cfg);
+    if (ret) {
+        printk("[error] %s: failed to get dt data\n", LCD_EXTERN_NAME);
+        return ret;
+    }
+
+    //lcd extern driver update
     lcd_ext = aml_lcd_extern_get_driver();
     if (lcd_ext) {
-        lcd_ext->type       = lcd_ext_config->type;
-        lcd_ext->name       = lcd_ext_config->name;
+        lcd_ext->type      = lcd_ext_cfg->type;
+        lcd_ext->name      = lcd_ext_cfg->name;
         lcd_ext->init_on_cmd_8  = &mipi_init_on_table[0];
         lcd_ext->init_off_cmd_8 = &mipi_init_off_table[0];
     }
     else {
-        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_config->name);
+        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_cfg->name);
+        ret = -1;
     }
 
-    return 0;
+    return ret;
 }
 
 static int aml_N070ICN_probe(struct platform_device *pdev)
 {
-    //int i = 0;
+    int ret = 0;
 
     if (lcd_extern_driver_check()) {
         return -1;
     }
-    if (lcd_ext_config == NULL)
-        lcd_ext_config = kzalloc(sizeof(*lcd_ext_config), GFP_KERNEL);
-    if (lcd_ext_config == NULL) {
+    if (lcd_extern_config == NULL)
+        lcd_extern_config = kzalloc(sizeof(*lcd_extern_config), GFP_KERNEL);
+    if (lcd_extern_config == NULL) {
         printk("[error] %s probe: failed to alloc data\n", LCD_EXTERN_NAME);
         return -1;
     }
 
-    pdev->dev.platform_data = lcd_ext_config;
+    pdev->dev.platform_data = lcd_extern_config;
 
-    if (get_lcd_extern_dt_data(pdev->dev.of_node, lcd_ext_config) != 0) {
-        printk("[error] %s probe: failed to get dt data\n", LCD_EXTERN_NAME);
+    ret = get_lcd_extern_config(pdev->dev.of_node, lcd_extern_config);
+    if (ret) {
         goto lcd_extern_probe_failed;
     }
-    lcd_extern_driver_update();
 
     printk("%s probe ok\n", LCD_EXTERN_NAME);
-    return 0;
+    return ret;
 
 lcd_extern_probe_failed:
-    if (lcd_ext_config)
-        kfree(lcd_ext_config);
+    if (lcd_extern_config) {
+        kfree(lcd_extern_config);
+        lcd_extern_config = NULL;
+    }
     return -1;
 }
 
 static int aml_N070ICN_remove(struct platform_device *pdev)
 {
-    remove_lcd_extern(lcd_ext_config);
     if (pdev->dev.platform_data)
         kfree (pdev->dev.platform_data);
     return 0;
diff --git a/drivers/amlogic/display/vout/lcd_extern/spi_LD070WS2.c b/drivers/amlogic/display/vout/lcd_extern/spi_LD070WS2.c
old mode 100644
new mode 100755
index 00b5d732..e875bde3
--- a/drivers/amlogic/display/vout/lcd_extern/spi_LD070WS2.c
+++ b/drivers/amlogic/display/vout/lcd_extern/spi_LD070WS2.c
@@ -2,7 +2,7 @@
  * AMLOGIC lcd external driver.
  *
  * Communication protocol:
- * SPI 
+ * SPI
  *
  */
 
@@ -11,7 +11,7 @@
 #include <linux/module.h>
 #include <linux/platform_device.h>
 #include <linux/slab.h>
-#include <linux/jiffies.h> 
+#include <linux/jiffies.h>
 #include <linux/i2c.h>
 #include <linux/i2c-aml.h>
 #include <linux/miscdevice.h>
@@ -26,7 +26,7 @@
 #include <mach/gpio.h>
 #include <linux/amlogic/vout/aml_lcd_extern.h>
 
-static struct lcd_extern_config_t *lcd_ext_config = NULL;
+static struct lcd_extern_config_t *lcd_extern_config = NULL;
 
 //#define LCD_EXT_DEBUG_INFO
 #ifdef LCD_EXT_DEBUG_INFO
@@ -62,19 +62,19 @@ static unsigned char spi_off_table[][2] = {
 
 static void set_lcd_csb(unsigned v)
 {
-    lcd_extern_gpio_direction_output(lcd_ext_config->spi_cs, v);
+    lcd_extern_gpio_direction_output(lcd_extern_config->spi_cs, v);
     udelay(SPI_DELAY);
 }
 
 static void set_lcd_scl(unsigned v)
 {
-    lcd_extern_gpio_direction_output(lcd_ext_config->spi_clk, v);
+    lcd_extern_gpio_direction_output(lcd_extern_config->spi_clk, v);
     udelay(SPI_DELAY);
 }
-    
+
 static void set_lcd_sda(unsigned v)
 {
-    lcd_extern_gpio_direction_output(lcd_ext_config->spi_data, v);
+    lcd_extern_gpio_direction_output(lcd_extern_config->spi_data, v);
     udelay(SPI_DELAY);
 }
 
@@ -173,58 +173,67 @@ static int lcd_extern_spi_off(void)
     return 0;
 }
 
-static int lcd_extern_driver_update(void)
+static int get_lcd_extern_config(struct device_node* of_node, struct lcd_extern_config_t *lcd_ext_cfg)
 {
+    int ret = 0;
     struct aml_lcd_extern_driver_t* lcd_ext;
 
+    ret = get_lcd_extern_dt_data(of_node, lcd_ext_cfg);
+    if (ret) {
+        printk("[error] %s: failed to get dt data\n", LCD_EXTERN_NAME);
+        return ret;
+    }
+
+    //lcd extern driver update
     lcd_ext = aml_lcd_extern_get_driver();
     if (lcd_ext) {
-        lcd_ext->type       = lcd_ext_config->type;
-        lcd_ext->name       = lcd_ext_config->name;
+        lcd_ext->type      = lcd_ext_cfg->type;
+        lcd_ext->name      = lcd_ext_cfg->name;
         lcd_ext->power_on   = lcd_extern_spi_init;
         lcd_ext->power_off  = lcd_extern_spi_off;
     }
     else {
-        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_config->name);
+        printk("[error] %s get lcd_extern_driver failed\n", lcd_ext_cfg->name);
+        ret = -1;
     }
 
-    return 0;
+    return ret;
 }
 
 static int aml_LD070WS2_probe(struct platform_device *pdev)
 {
-    //int i = 0;
+    int ret = 0;
 
     if (lcd_extern_driver_check()) {
         return -1;
     }
-    if (lcd_ext_config == NULL)
-        lcd_ext_config = kzalloc(sizeof(*lcd_ext_config), GFP_KERNEL);
-    if (lcd_ext_config == NULL) {
+    if (lcd_extern_config == NULL)
+        lcd_extern_config = kzalloc(sizeof(*lcd_extern_config), GFP_KERNEL);
+    if (lcd_extern_config == NULL) {
         printk("[error] %s probe: failed to alloc data\n", LCD_EXTERN_NAME);
         return -1;
     }
 
-    pdev->dev.platform_data = lcd_ext_config;
+    pdev->dev.platform_data = lcd_extern_config;
 
-    if (get_lcd_extern_dt_data(pdev->dev.of_node, lcd_ext_config) != 0) {
-        printk("[error] %s probe: failed to get dt data\n", LCD_EXTERN_NAME);
+    ret = get_lcd_extern_config(pdev->dev.of_node, lcd_extern_config);
+    if (ret) {
         goto lcd_extern_probe_failed;
     }
-    lcd_extern_driver_update();
 
     printk("%s probe ok\n", LCD_EXTERN_NAME);
-    return 0;
+    return ret;
 
 lcd_extern_probe_failed:
-    if (lcd_ext_config)
-        kfree(lcd_ext_config);
+    if (lcd_extern_config) {
+        kfree(lcd_extern_config);
+        lcd_extern_config = NULL;
+    }
     return -1;
 }
 
 static int aml_LD070WS2_remove(struct platform_device *pdev)
 {
-    remove_lcd_extern(lcd_ext_config);
     if (pdev->dev.platform_data)
         kfree (pdev->dev.platform_data);
     return 0;
diff --git a/drivers/amlogic/display/vout/lcdoutc.c b/drivers/amlogic/display/vout/lcdoutc.c
old mode 100644
new mode 100755
index 11cd8b02..e35ac378
--- a/drivers/amlogic/display/vout/lcdoutc.c
+++ b/drivers/amlogic/display/vout/lcdoutc.c
@@ -1,2320 +1,2424 @@
-/*
- * AMLOGIC lcd controller driver.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
- *
- * Author:  Tim Yao <timyao@amlogic.com>
- *
- * Modify:  Evoke Zhang <evoke.zhang@amlogic.com>
- * compatible dts
- *
- */
-#include <linux/init.h>
-#include <linux/version.h>
-#include <linux/types.h>
-#include <linux/slab.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/string.h>
-#include <linux/amlogic/vout/vinfo.h>
-#include <linux/amlogic/vout/vout_notify.h>
-#include <linux/kernel.h>
-#include <linux/interrupt.h>
-#include <linux/amlogic/logo/logo.h>
-#include <plat/regops.h>
-#include <mach/am_regs.h>
-#include <mach/lcd_reg.h>
-#include <mach/lcdoutc.h>
-#include <linux/amlogic/vout/lcdoutc.h>
-#include <linux/amlogic/vout/aml_lcd_common.h>
-#include <linux/amlogic/vout/lcd_aml.h>
-#include <mach/clock.h>
-#include <asm/fiq.h>
-#include <linux/delay.h>
-#include <linux/notifier.h>
-#include <linux/reboot.h>
-#include <linux/of.h>
-#include <linux/amlogic/aml_lcd_bl.h>
-#include <linux/amlogic/vout/aml_lcd_extern.h>
-#ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
-#include <linux/amlogic/aml_pmu_common.h>
-#endif
-
-#define PANEL_NAME		"panel"
-
-#ifdef LCD_DEBUG_INFO
-unsigned int lcd_print_flag = 1;
-#else
-unsigned int lcd_print_flag = 0;
-#endif
-void lcd_print(const char *fmt, ...)
-{
-	va_list args;
-
-	if (lcd_print_flag == 0)
-		return;
-	va_start(args, fmt);
-	vprintk(fmt, args);
-	va_end(args);
-}
-
-static const char* lcd_power_type_table[]={
-	"cpu",
-	"pmu",
-	"signal",
-	"init",
-	"null",
-};
-
-static const char* lcd_power_pmu_gpio_table[]={
-	"GPIO0",
-	"GPIO1",
-	"GPIO2",
-	"GPIO3",
-	"GPIO4",
-	"null",
-}; 
-
-typedef struct {
-	Lcd_Config_t *pConf;
-	vinfo_t lcd_info;
-} lcd_dev_t;
-
-static lcd_dev_t *pDev = NULL;
-static struct class *gamma_debug_class = NULL;
-static Bool_t data_status = ON;
-static int bl_status = ON;
-
-static inline void lcd_mdelay(int n)
-{
-	mdelay(n);
-}
-
-#ifdef CONFIG_USE_OF
-static void lcd_setup_gamma_table(Lcd_Config_t *pConf, unsigned int rgb_flag)
-{
-	int i;
-	
-	const unsigned short gamma_adjust[256] = {
-		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
-		32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
-		64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
-		96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
-		128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
-		160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
-		192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
-		224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
-	};
-
-	if (rgb_flag == 0) {	//r
-		for (i=0; i<256; i++) {
-			pConf->lcd_effect.GammaTableR[i] = gamma_adjust[i] << 2;
-		}
-	}
-	else if (rgb_flag == 1) {	//g
-		for (i=0; i<256; i++) {
-			pConf->lcd_effect.GammaTableG[i] = gamma_adjust[i] << 2;
-		}
-	}
-	else if (rgb_flag == 2) {	//b
-		for (i=0; i<256; i++) {
-			pConf->lcd_effect.GammaTableB[i] = gamma_adjust[i] << 2;
-		}
-	}
-	else if (rgb_flag == 3) {	//rgb
-		for (i=0; i<256; i++) {
-			pConf->lcd_effect.GammaTableR[i] = gamma_adjust[i] << 2;
-			pConf->lcd_effect.GammaTableG[i] = gamma_adjust[i] << 2;
-			pConf->lcd_effect.GammaTableB[i] = gamma_adjust[i] << 2;
-		}
-	}
-}
-
-static void backlight_power_ctrl(Bool_t status)
-{
-	if( status == ON ){
-		if ((data_status == OFF) || (bl_status == ON))
-			return;
-		bl_power_on(LCD_BL_FLAG);
-	}
-	else{
-		if (bl_status == OFF)
-			return;
-		bl_power_off(LCD_BL_FLAG);
-	}
-	lcd_print("%s(%s): data_status=%s\n", __FUNCTION__, (status ? "ON" : "OFF"), (data_status ? "ON" : "OFF"));
-	bl_status = status;
-}
-
-static int lcd_power_ctrl(Bool_t status)
-{
-	int i;
-	int ret = 0;
-#ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
-	struct aml_pmu_driver *pmu_driver;
-#endif
-	struct aml_lcd_extern_driver_t *lcd_extern_driver;
-
-	lcd_print("%s(): %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
-	if (status) {
-		for (i=0; i<pDev->pConf->lcd_power_ctrl.power_on_step; i++) {
-			lcd_print("%s %s step %d\n", __FUNCTION__, (status ? "ON" : "OFF"), i+1);
-			switch (pDev->pConf->lcd_power_ctrl.power_on_config[i].type) {
-				case LCD_POWER_TYPE_CPU:
-					if (pDev->pConf->lcd_power_ctrl.power_on_config[i].value == LCD_POWER_GPIO_OUTPUT_LOW) {
-						lcd_gpio_direction_output(pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio, 0);
-					}
-					else if (pDev->pConf->lcd_power_ctrl.power_on_config[i].value == LCD_POWER_GPIO_OUTPUT_HIGH) {
-						lcd_gpio_direction_output(pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio, 1);
-					}
-					else if (pDev->pConf->lcd_power_ctrl.power_on_config[i].value == LCD_POWER_GPIO_INPUT) {
-						lcd_gpio_direction_input(pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio);
-					}
-					break;
-				case LCD_POWER_TYPE_PMU:
-#ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
-					pmu_driver = aml_pmu_get_driver();
-					if (pmu_driver == NULL) {
-						printk("no pmu driver\n");
-					}
-					else if (pmu_driver->pmu_set_gpio) {
-						if (pDev->pConf->lcd_power_ctrl.power_on_config[i].value == LCD_POWER_GPIO_OUTPUT_LOW) {
-							pmu_driver->pmu_set_gpio(pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio, 0);
-						}
-						else {
-							pmu_driver->pmu_set_gpio(pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio, 1);
-						}
-					}
-#endif
-					break;
-				case LCD_POWER_TYPE_SIGNAL:
-					if (pDev->pConf->lcd_power_ctrl.ports_ctrl == NULL)
-						printk("no lcd_ports_ctrl\n");
-					else
-						pDev->pConf->lcd_power_ctrl.ports_ctrl(ON);
-					break;
-				case LCD_POWER_TYPE_INITIAL:
-					lcd_extern_driver = aml_lcd_extern_get_driver();
-					if (lcd_extern_driver == NULL) {
-						printk("no lcd_extern driver\n");
-					}
-					else {
-						if (lcd_extern_driver->power_on) {
-							lcd_extern_driver->power_on();
-							printk("%s power on init\n", lcd_extern_driver->name);
-						}
-					}
-					break;
-				default:
-					printk("lcd power ctrl ON step %d is null.\n", i+1);
-					break;
-			}
-			if (pDev->pConf->lcd_power_ctrl.power_on_config[i].delay > 0)
-				lcd_mdelay(pDev->pConf->lcd_power_ctrl.power_on_config[i].delay);
-		}
-		if (pDev->pConf->lcd_power_ctrl.power_ctrl_video)
-			ret = pDev->pConf->lcd_power_ctrl.power_ctrl_video(ON);
-		data_status = status;
-	}
-	else {
-		data_status = status;
-		lcd_mdelay(30);
-		if (pDev->pConf->lcd_power_ctrl.power_ctrl_video)
-			ret = pDev->pConf->lcd_power_ctrl.power_ctrl_video(OFF);
-		for (i=0; i<pDev->pConf->lcd_power_ctrl.power_off_step; i++) {
-			lcd_print("%s %s step %d\n", __FUNCTION__, (status ? "ON" : "OFF"), i+1);
-			switch (pDev->pConf->lcd_power_ctrl.power_off_config[i].type) {
-				case LCD_POWER_TYPE_CPU:
-					if (pDev->pConf->lcd_power_ctrl.power_off_config[i].value == LCD_POWER_GPIO_OUTPUT_LOW) {
-						lcd_gpio_direction_output(pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio, 0);
-					}
-					else if (pDev->pConf->lcd_power_ctrl.power_off_config[i].value == LCD_POWER_GPIO_OUTPUT_HIGH) {
-						lcd_gpio_direction_output(pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio, 1);
-					}
-					else if (pDev->pConf->lcd_power_ctrl.power_off_config[i].value == LCD_POWER_GPIO_INPUT) {
-						lcd_gpio_direction_input(pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio);
-					}
-					break;
-				case LCD_POWER_TYPE_PMU:
-#ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
-					pmu_driver = aml_pmu_get_driver();
-					if (pmu_driver == NULL) {
-						printk("no pmu driver\n");
-					}
-					else if (pmu_driver->pmu_set_gpio) {
-						if (pDev->pConf->lcd_power_ctrl.power_off_config[i].value == LCD_POWER_GPIO_OUTPUT_LOW) {
-							pmu_driver->pmu_set_gpio(pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio, 0);
-						}
-						else {
-							pmu_driver->pmu_set_gpio(pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio, 1);
-						}
-					}
-#endif
-					break;
-				case LCD_POWER_TYPE_SIGNAL:
-					if (pDev->pConf->lcd_power_ctrl.ports_ctrl == NULL)
-						printk("no lcd_ports_ctrl\n");
-					else
-						pDev->pConf->lcd_power_ctrl.ports_ctrl(OFF);
-					break;
-				case LCD_POWER_TYPE_INITIAL:
-					lcd_extern_driver = aml_lcd_extern_get_driver();
-					if (lcd_extern_driver == NULL) {
-						printk("no lcd_extern driver\n");
-					}
-					else {
-						if (lcd_extern_driver->power_off) {
-							lcd_extern_driver->power_off();
-							printk("%s power off init\n", lcd_extern_driver->name);
-						}
-					}
-					break;
-				default:
-					printk("lcd power ctrl OFF step %d is null.\n", i+1);
-					break;
-			}
-			if (pDev->pConf->lcd_power_ctrl.power_off_config[i].delay > 0)
-				lcd_mdelay(pDev->pConf->lcd_power_ctrl.power_off_config[i].delay);
-		}
-	}
-
-	printk("%s(): %s finished.\n", __FUNCTION__, (status ? "ON" : "OFF"));
-	return ret;
-}
-#endif
-
-void _enable_backlight(void)
-{
-	backlight_power_ctrl(ON);
-}
-void _disable_backlight(void)
-{
-	backlight_power_ctrl(OFF);
-}
-
-static void _lcd_module_enable(void)
-{
-    pDev->pConf->lcd_misc_ctrl.module_enable();
-}
-
-static void _lcd_module_disable(void)
-{
-    pDev->pConf->lcd_misc_ctrl.module_disable();
-}
-
-static const vinfo_t *lcd_get_current_info(void)
-{
-    if (pDev == NULL) {
-        printk("[error] no lcd device exist!\n");
-        return NULL;
-    }
-    else 
-        return &pDev->lcd_info;
-}
-
-DEFINE_MUTEX(lcd_vout_mutex);
-static int lcd_set_current_vmode(vmode_t mode)
-{
-    mutex_lock(&lcd_vout_mutex);
-    if (VMODE_LCD != (mode & VMODE_MODE_BIT_MASK)) {
-        mutex_unlock(&lcd_vout_mutex);
-        return -EINVAL;
-    }
-
-    pDev->pConf->lcd_misc_ctrl.vpp_sel = 0;
-    WRITE_LCD_REG(VPP_POSTBLEND_H_SIZE, pDev->lcd_info.width);
-
-    if( !(mode&VMODE_LOGO_BIT_MASK) ){
-        _disable_backlight();
-        _lcd_module_enable();
-        _enable_backlight();
-    }
-    if (VMODE_INIT_NULL == pDev->lcd_info.mode)
-        pDev->lcd_info.mode = VMODE_LCD;
-    
-    mutex_unlock(&lcd_vout_mutex);
-    return 0;
-}
-
-#ifdef CONFIG_AM_TV_OUTPUT2
-static int lcd_set_current_vmode2(vmode_t mode)
-{
-    mutex_lock(&lcd_vout_mutex);
-    if (mode != VMODE_LCD) {
-        mutex_unlock(&lcd_vout_mutex);
-        return -EINVAL;
-    }
-    _disable_backlight();
-    pDev->pConf->lcd_misc_ctrl.vpp_sel = 1;
-
-    WRITE_LCD_REG(VPP2_POSTBLEND_H_SIZE, pDev->lcd_info.width);
-
-    _lcd_module_enable();
-    if (VMODE_INIT_NULL == pDev->lcd_info.mode)
-        pDev->lcd_info.mode = VMODE_LCD;
-    _enable_backlight();
-    mutex_unlock(&lcd_vout_mutex);
-    return 0;
-}
-#endif
-
-static vmode_t lcd_validate_vmode(char *mode)
-{
-    if ((strncmp(mode, PANEL_NAME, strlen(PANEL_NAME))) == 0)
-        return VMODE_LCD;
-    
-    return VMODE_MAX;
-}
-static int lcd_vmode_is_supported(vmode_t mode)
-{
-    mode&=VMODE_MODE_BIT_MASK;
-    if(mode == VMODE_LCD )
-    return true;
-    return false;
-}
-
-static int lcd_vout_disable(vmode_t cur_vmod)
-{
-    mutex_lock(&lcd_vout_mutex);
-    _disable_backlight();
-    _lcd_module_disable();
-    mutex_unlock(&lcd_vout_mutex);
-    return 0;
-}
-
-#ifdef  CONFIG_PM
-static int lcd_suspend(void)
-{
-    mutex_lock(&lcd_vout_mutex);
-    BUG_ON(pDev==NULL);
-    printk("lcd_suspend\n");
-    _disable_backlight();
-    _lcd_module_disable();
-    mutex_unlock(&lcd_vout_mutex);
-    return 0;
-}
-static int lcd_resume(void)
-{
-    mutex_lock(&lcd_vout_mutex);
-    printk("lcd_resume\n");
-    _lcd_module_enable();
-    _enable_backlight();
-    mutex_unlock(&lcd_vout_mutex);
-    return 0;
-}
-#endif
-static vout_server_t lcd_vout_server={
-    .name = "lcd_vout_server",
-    .op = {
-        .get_vinfo = lcd_get_current_info,
-        .set_vmode = lcd_set_current_vmode,
-        .validate_vmode = lcd_validate_vmode,
-        .vmode_is_supported=lcd_vmode_is_supported,
-        .disable=lcd_vout_disable,
-#ifdef  CONFIG_PM
-        .vout_suspend=lcd_suspend,
-        .vout_resume=lcd_resume,
-#endif
-    },
-};
-
-#ifdef CONFIG_AM_TV_OUTPUT2
-static vout_server_t lcd_vout2_server={
-    .name = "lcd_vout2_server",
-    .op = {
-        .get_vinfo = lcd_get_current_info,
-        .set_vmode = lcd_set_current_vmode2,
-        .validate_vmode = lcd_validate_vmode,
-        .vmode_is_supported=lcd_vmode_is_supported,
-        .disable=lcd_vout_disable,
-#ifdef  CONFIG_PM  
-        .vout_suspend=lcd_suspend,
-        .vout_resume=lcd_resume,
-#endif
-    },
-};
-#endif
-
-static void _init_vout(void)
-{
-    pDev->lcd_info.name = PANEL_NAME;
-    pDev->lcd_info.mode = VMODE_LCD;
-    pDev->lcd_info.width = pDev->pConf->lcd_basic.h_active;
-    pDev->lcd_info.height = pDev->pConf->lcd_basic.v_active;
-    pDev->lcd_info.field_height = pDev->pConf->lcd_basic.v_active;
-    pDev->lcd_info.aspect_ratio_num = pDev->pConf->lcd_basic.screen_ratio_width;
-    pDev->lcd_info.aspect_ratio_den = pDev->pConf->lcd_basic.screen_ratio_height;
-    pDev->lcd_info.screen_real_width= pDev->pConf->lcd_basic.h_active_area;
-    pDev->lcd_info.screen_real_height= pDev->pConf->lcd_basic.v_active_area;
-    pDev->lcd_info.sync_duration_num = pDev->pConf->lcd_timing.sync_duration_num;
-    pDev->lcd_info.sync_duration_den = pDev->pConf->lcd_timing.sync_duration_den;
-    pDev->lcd_info.video_clk = pDev->pConf->lcd_timing.lcd_clk;
-       
-    //add lcd actual active area size
-    printk("lcd actual active area size: %d %d (mm).\n", pDev->pConf->lcd_basic.h_active_area, pDev->pConf->lcd_basic.v_active_area);
-    vout_register_server(&lcd_vout_server);
-#ifdef CONFIG_AM_TV_OUTPUT2
-    vout2_register_server(&lcd_vout2_server);
-#endif
-}
-
-//*********************************************************
-//gamma debug
-//*********************************************************
-#ifdef CONFIG_AML_GAMMA_DEBUG
-static unsigned short gamma_adjust_r[256];
-static unsigned short gamma_adjust_g[256];
-static unsigned short gamma_adjust_b[256];
-static unsigned short gamma_r_coeff, gamma_g_coeff, gamma_b_coeff;
-static unsigned gamma_ctrl;
-
-static void save_original_gamma(Lcd_Config_t *pConf)
-{
-    int i;
-
-    for (i=0; i<256; i++) {
-        gamma_adjust_r[i] = pConf->lcd_effect.GammaTableR[i];
-        gamma_adjust_g[i] = pConf->lcd_effect.GammaTableG[i];
-        gamma_adjust_b[i] = pConf->lcd_effect.GammaTableB[i];
-    }
-    gamma_ctrl = pConf->lcd_effect.gamma_ctrl;
-    gamma_r_coeff = pConf->lcd_effect.gamma_r_coeff;
-    gamma_g_coeff = pConf->lcd_effect.gamma_g_coeff;
-    gamma_b_coeff = pConf->lcd_effect.gamma_b_coeff;
-}
-
-static void read_original_gamma_table(void)
-{
-    unsigned i;
-
-    printk("original gamma: enable=%d, reverse=%d, r_coeff=%u%%, g_coeff=%u%%, b_coeff=%u%%\n", 
-          ((gamma_ctrl >> GAMMA_CTRL_EN) & 1), ((gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1), gamma_r_coeff, gamma_g_coeff, gamma_b_coeff);
-    printk("read original gamma table R:\n");
-    for (i=0; i<256; i++) {
-        printk("%u,", gamma_adjust_r[i]);
-    }
-    printk("\n\nread original gamma table G:\n");
-    for (i=0; i<256; i++) {
-        printk("%u,", gamma_adjust_g[i]);
-    }
-    printk("\n\nread original gamma table B:\n");
-    for (i=0; i<256; i++) {
-        printk("%u,", gamma_adjust_b[i]);
-    }
-    printk("\n");
-}
-
-static void read_current_gamma_table(Lcd_Config_t *pConf)
-{
-    unsigned i;
-
-    printk("current gamma: enable=%d, reverse=%d, r_coeff=%u%%, g_coeff=%u%%, b_coeff=%u%%\n", 
-          ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1), ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1), 
-          pConf->lcd_effect.gamma_r_coeff, pConf->lcd_effect.gamma_g_coeff, pConf->lcd_effect.gamma_b_coeff);
-    printk("read current gamma table R:\n");
-    for (i=0; i<256; i++) {
-        printk("%u ", pConf->lcd_effect.GammaTableR[i]);
-    }
-    printk("\n\nread current gamma table G:\n");
-    for (i=0; i<256; i++) {
-        printk("%u ", pConf->lcd_effect.GammaTableG[i]);
-    }
-    printk("\n\nread current gamma table B:\n");
-    for (i=0; i<256; i++) {
-        printk("%u ", pConf->lcd_effect.GammaTableB[i]);
-    }
-    printk("\n");
-}
-
-static int write_gamma_table(Lcd_Config_t *pConf)
-{
-    int ret = 0;
-
-    if (pConf->lcd_effect.set_gamma_table == NULL) {
-        printk("set gamma table function is null\n");
-        ret = -1;
-    }
-    else {
-        pConf->lcd_effect.set_gamma_table(1); //force enable gamma table
-        printk("write gamma table ");
-    }
-    return ret;
-}
-
-static void set_gamma_coeff(Lcd_Config_t *pConf, unsigned r_coeff, unsigned g_coeff, unsigned b_coeff)
-{
-    pConf->lcd_effect.gamma_r_coeff = (unsigned short)(r_coeff);
-    pConf->lcd_effect.gamma_g_coeff = (unsigned short)(g_coeff);
-    pConf->lcd_effect.gamma_b_coeff = (unsigned short)(b_coeff);
-    if (write_gamma_table(pConf) == 0)
-        printk("with scale factor R:%u%%, G:%u%%, B:%u%%.\n", r_coeff, g_coeff, b_coeff);
-}
-
-static const char * usage_str =
-{"Usage:\n"
-"    echo coeff <R_coeff> <G_coeff> <B_coeff> > write ; set R,G,B gamma scale factor\n"
-"    echo ctrl <enable> <reverse> > write; control gamma table enable and reverse\n"
-"data format:\n"
-"    <R/G/B_coeff>  : a number in Dec(0~100), means a percent value\n"
-"    <enable>       : 0=disable, 1=enable\n"
-"    <reverse>      : 0=normal, 1=reverse\n"
-"\n"
-"    echo [r|g|b] <step> <value> <value> <value> <value> <value> <value> <value> <value> > write ; input R/G/B gamma table\n"
-"    echo w [0 | 8 | 10] > write ; apply the original/8bit/10bit gamma table\n"
-"data format:\n"
-"    <step>  : 0xX, 4bit in Hex, there are 8 steps(0~7, 8bit gamma) or 16 steps(0~f, 10bit gamma) for a single cycle\n"
-"    <value> : 0xXXXXXXXX, 32bit in Hex, 2 or 4 gamma table values (8 or 10bit gamma) combia in one <value>\n"
-"\n"
-"    echo f[r | g | b | w] <level_value> > write ; write R/G/B/white gamma level with fixed level_value\n"
-"data format:\n"
-"    <level_value>  : a number in Dec(0~255)\n"
-"\n"
-"    echo [0 | 1] > read ; readback original/current gamma table\n"
-};
-
-static ssize_t gamma_help(struct class *class, struct class_attribute *attr, char *buf)
-{
-    return sprintf(buf, "%s\n",usage_str);
-}
-
-static ssize_t aml_lcd_gamma_read(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
-{
-    if (buf[0] == '0')
-        read_original_gamma_table();
-    else
-        read_current_gamma_table(pDev->pConf);
-
-    return count;
-}
-
-static unsigned gamma_adjust_r_temp[128];
-static unsigned gamma_adjust_g_temp[128];
-static unsigned gamma_adjust_b_temp[128];
-static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
-{
-    unsigned int ret;
-    unsigned int i, j;
-    unsigned t[8];
-
-    switch (buf[0]) {
-    case 'c':
-        if (buf[1] == 'o') {
-            t[0] = 100;
-            t[1] = 100;
-            t[2] = 100;
-            ret = sscanf(buf, "coeff %u %u %u", &t[0], &t[1], &t[2]);
-            set_gamma_coeff(pDev->pConf, t[0], t[1], t[2]);
-        }
-        else if (buf[1] == 't') {
-            t[0] = 1;
-            t[1] = 0;
-            ret = sscanf(buf, "ctrl %u %u", &t[0], &t[1]);
-            pDev->pConf->lcd_effect.gamma_ctrl = ((t[0] << GAMMA_CTRL_EN) | (t[1] << GAMMA_CTRL_REVERSE));
-            if (write_gamma_table(pDev->pConf) == 0)
-                printk(" finished.\n");
-        }
-        break;
-    case 'r':
-        ret = sscanf(buf, "r %x %x %x %x %x %x %x %x %x", &i, &t[0], &t[1], &t[2], &t[3], &t[4], &t[5], &t[6], &t[7]);
-        if (i<16) {
-            i =  i * 8;
-            for (j=0; j<8; j++) {
-                gamma_adjust_r_temp[i+j] = t[j];
-            }
-            printk("write R table: step %u.\n", i/8);
-        }
-        break;
-    case 'g':
-        ret = sscanf(buf, "g %x %x %x %x %x %x %x %x %x", &i, &t[0], &t[1], &t[2], &t[3], &t[4], &t[5], &t[6], &t[7]);
-        if (i<16) {
-            i =  i * 8;
-            for (j=0; j<8; j++) {
-                gamma_adjust_g_temp[i+j] = t[j];
-            }
-            printk("write G table: step %u.\n", i/8);
-        }
-        break;
-    case 'b':
-        ret = sscanf(buf, "b %x %x %x %x %x %x %x %x %x", &i, &t[0], &t[1], &t[2], &t[3], &t[4], &t[5], &t[6], &t[7]);
-        if (i<16) {
-            i =  i * 8;
-            for (j=0; j<8; j++) {
-                gamma_adjust_b_temp[i+j] = t[j];
-            }
-            printk("write B table: step %u.\n", i/8);
-        }
-        break;
-    case 'w':
-        i = 0;
-        ret = sscanf(buf, "w %u", &i);
-        if (i == 8) {
-            for (i=0; i<64; i++) {
-                for (j=0; j<4; j++){
-                    pDev->pConf->lcd_effect.GammaTableR[i*4+j] = (unsigned short)(((gamma_adjust_r_temp[i] >> (24-j*8)) & 0xff) << 2);
-                    pDev->pConf->lcd_effect.GammaTableG[i*4+j] = (unsigned short)(((gamma_adjust_g_temp[i] >> (24-j*8)) & 0xff) << 2);
-                    pDev->pConf->lcd_effect.GammaTableB[i*4+j] = (unsigned short)(((gamma_adjust_b_temp[i] >> (24-j*8)) & 0xff) << 2);
-                }
-            }
-            if (write_gamma_table(pDev->pConf) == 0)
-                printk("8bit finished.\n");
-        }
-        else if (i == 10) {
-            for (i=0; i<128; i++) {
-                for (j=0; j<2; j++){
-                    pDev->pConf->lcd_effect.GammaTableR[i*2+j] = (unsigned short)((gamma_adjust_r_temp[i] >> (16-j*16)) & 0xffff);
-                    pDev->pConf->lcd_effect.GammaTableG[i*2+j] = (unsigned short)((gamma_adjust_g_temp[i] >> (16-j*16)) & 0xffff);
-                    pDev->pConf->lcd_effect.GammaTableB[i*2+j] = (unsigned short)((gamma_adjust_b_temp[i] >> (16-j*16)) & 0xffff);
-                }
-            }
-            if (write_gamma_table(pDev->pConf) == 0)
-                printk("10bit finished.\n");
-        }
-        else {
-            for (i=0; i<256; i++) {
-                pDev->pConf->lcd_effect.GammaTableR[i] = gamma_adjust_r[i];
-                pDev->pConf->lcd_effect.GammaTableG[i] = gamma_adjust_g[i];
-                pDev->pConf->lcd_effect.GammaTableB[i] = gamma_adjust_b[i];
-            }
-            if (write_gamma_table(pDev->pConf) == 0)
-                printk("to original.\n");
-        }
-        break;
-    case 'f':
-        i=255;
-        if (buf[1] == 'r') {
-            ret = sscanf(buf, "fr %u", &i);
-            i &= 0xff;
-            for (j=0; j<256; j++) {
-                pDev->pConf->lcd_effect.GammaTableR[j] = i<<2;
-            }
-            set_gamma_coeff(pDev->pConf, 100, 0, 0);
-            printk("with R fixed value %u finished.\n", i);
-        }
-        else if (buf[1] == 'g') {
-            ret = sscanf(buf, "fg %u", &i);
-            i &= 0xff; 
-            for (j=0; j<256; j++) {
-                pDev->pConf->lcd_effect.GammaTableG[j] = i<<2;
-            }
-            set_gamma_coeff(pDev->pConf, 0, 100, 0);
-            printk("with G fixed value %u finished.\n", i);
-        }
-        else if (buf[1] == 'b') {
-            ret = sscanf(buf, "fb %u", &i);
-            i &= 0xff;
-            for (j=0; j<256; j++) {
-                pDev->pConf->lcd_effect.GammaTableB[j] = i<<2;
-            }
-            set_gamma_coeff(pDev->pConf, 0, 0, 100);
-            printk("with B fixed value %u finished.\n", i);
-        }
-        else {
-            ret = sscanf(buf, "fw %u", &i);
-            i &= 0xff;
-            for (j=0; j<256; j++) {
-                pDev->pConf->lcd_effect.GammaTableR[j] = i<<2;
-                pDev->pConf->lcd_effect.GammaTableG[j] = i<<2;
-                pDev->pConf->lcd_effect.GammaTableB[j] = i<<2;
-            }
-            set_gamma_coeff(pDev->pConf, 100, 100, 100);
-            printk("with fixed value %u finished.\n", i);
-        }
-        break;
-    default:
-            printk("wrong format of gamma table writing.\n");
-    }
-
-    if (ret != 1 || ret !=2)
-        return -EINVAL;
-
-    return count;
-    //return 0;
-}
-
-static struct class_attribute aml_lcd_gamma_class_attrs[] = {
-    __ATTR(write,  S_IRUGO | S_IWUSR, gamma_help, aml_lcd_gamma_debug),
-    __ATTR(read,  S_IRUGO | S_IWUSR, gamma_help, aml_lcd_gamma_read),
-    __ATTR(help,  S_IRUGO | S_IWUSR, gamma_help, NULL),
-};
-
-static int creat_lcd_gamma_attr(void)
-{
-    int i;
-
-    gamma_debug_class = class_create(THIS_MODULE, "gamma");
-    if(IS_ERR(gamma_debug_class)) {
-        printk("create gamma debug class fail\n");
-        return -1;
-    }
-
-    for(i=0;i<ARRAY_SIZE(aml_lcd_gamma_class_attrs);i++) {
-        if (class_create_file(gamma_debug_class, &aml_lcd_gamma_class_attrs[i])) {
-            printk("create gamma debug attribute %s fail\n", aml_lcd_gamma_class_attrs[i].attr.name);
-        }
-    }
-
-    return 0;
-}
-
-static int remove_lcd_gamma_attr(void)
-{
-    int i;
-
-    if (gamma_debug_class == NULL)
-        return -1;
-
-    for(i=0;i<ARRAY_SIZE(aml_lcd_gamma_class_attrs);i++) {
-        class_remove_file(gamma_debug_class, &aml_lcd_gamma_class_attrs[i]);
-    }
-    class_destroy(gamma_debug_class);
-    gamma_debug_class = NULL;
-
-    return 0;
-}
-#endif
-//*********************************************************
-
-//*********************************************************
-//LCD debug
-//*********************************************************
-static Lcd_Basic_t temp_lcd_basic;
-static Lcd_Timing_t temp_lcd_timing;
-static unsigned short temp_dith_user, temp_dith_ctrl;
-static unsigned int temp_vadj_brightness, temp_vadj_contrast, temp_vadj_saturation;
-static int temp_ttl_rb_swap, temp_ttl_bit_swap;
-static int temp_lvds_repack, temp_pn_swap, temp_lvds_vswing;
-static unsigned char temp_dsi_lane_num;
-static unsigned temp_dsi_bit_rate_min, temp_dsi_bit_rate_max, temp_factor_denominator, temp_factor_numerator;
-static unsigned char temp_edp_link_rate, temp_edp_lane_count, temp_edp_vswing, temp_edp_preemphasis;
-
-static const char * lcd_common_usage_str =
-{"Usage:\n"
-"    echo 0/1 > status ; 0=disable lcd; 1=enable lcd\n"
-"    cat status ; read current lcd status\n"
-"\n"
-"    echo 0/1 > print ; 0=disable debug print; 1=enable debug print\n"
-"    cat print ; read current debug print flag\n"
-"\n"
-"    echo <cmd> ... > debug ; lcd common debug, use 'cat debug' for help\n"
-"    cat debug ; print help information for debug command\n"
-#ifdef CONFIG_LCD_IF_MIPI_VALID
-"\n"
-"    echo <cmd> ... > dsi ; mipi-dsi debug, use 'cat dsi' for help\n"
-"    cat dsi ; print help information for dsi command\n"
-#endif
-#ifdef CONFIG_LCD_IF_EDP_VALID
-"\n"
-"    echo <cmd> ... > print ; edp debug, use 'cat edp' for help\n"
-"    cat print ; print help information for edp command\n"
-#endif
-};
-
-static const char * lcd_usage_str =
-{"Usage:\n"
-"    echo basic <h_active> <v_active> <h_period> <v_period> > debug ; write lcd basic config\n"
-"    echo type <lcd_type> <lcd_bits> > debug ; write lcd type & bits\n"
-"    echo clock <lcd_clk> <ss_level> <clk_pol> > debug ; write lcd clk (Hz)\n"
-"    echo sync <hs_width> <hs_backporch> <hs_pol> <vs_width> <vs_backporch> <vs_pol> > debug ; write lcd sync timing\n"
-"    echo valid <hvsync_valid> <de_valid> > debug ; enable lcd sync signals\n"
-"data format:\n"
-"    <lcd_type> : "
-#ifdef CONFIG_LCD_IF_MIPI_VALID
-"0=mipi, "
-#endif
-"1=lvds, "
-#ifdef CONFIG_LCD_IF_EDP_VALID
-"2=edp, "
-#endif
-"3=ttl\n"
-"    <lcd_bits> : 6=6bit(RGB18bit), 8=8bit(RGB24bit)\n"
-"    <ss_level> : lcd clock spread spectrum level, 0 for disable\n"
-"    <xx_pol>   : 0=negative, 1=positive\n"
-"    <xx_valid> : 0=disable, 1=enable\n"
-"\n"
-"    echo ttl <rb_swap> <bit_swap> > debug ; write ttl RGB swap config\n"
-"    echo lvds <vswing_level> <lvds_repack> <pn_swap> > debug ; write lvds config\n"
-#ifdef CONFIG_LCD_IF_MIPI_VALID
-"    echo mdsi <lane_num> <bit_rate_max> <factor> > debug ; write mipi-dsi clock config\n"
-"    echo mctl <init_mode> <disp_mode> <lp_clk_auto_stop> <transfer_switch> > debug ; write mipi-dsi control config\n"
-#endif
-#ifdef CONFIG_LCD_IF_EDP_VALID
-"    echo edp <link_rate> <lane_count> <vswing_level> > debug ; write edp config\n"
-#endif
-"data format:\n"
-"    <xx_swap>      : 0=normal, 1=swap\n"
-"    <vswing_level> : lvds support level 0~4 (Default=1);"
-#ifdef CONFIG_LCD_IF_EDP_VALID
-" edp support level 0~3 (default=0)"
-#endif
-"\n"
-"    <lvds_repack>  : 0=JEIDA mode, 1=VESA mode\n"
-"    <pn_swap>      : 0=normal, 1=swap lvds p/n channels\n"
-#ifdef CONFIG_LCD_IF_MIPI_VALID
-"    <bit_rate_max> : unit in MHz\n"
-"    <factor>:      : special adjust, 0 for default\n"
-"    <xxxx_mode>    : 0=video mode, 1=command mode\n"
-"    <lp_clk_auto_stop> : 0=disable, 1=enable\n"
-"    <transfer_switch>  : 0=auto, 1=standard, 2=slow\n"
-#endif
-#ifdef CONFIG_LCD_IF_EDP_VALID
-"    <link_rate>    : 0=1.62G, 1=2.7G\n"
-#endif
-"\n"
-"    echo offset <h_sign> <h_offset> <v_sign> <v_offset> > debug ; write ttl display offset\n"
-"    echo dither <dither_user> <dither_ctrl> > debug ; write user dither ctrl config\n"
-"    echo vadj <brightness> <contrast> <saturation> > debug ; write video adjust config\n"
-"data format:\n"
-"    <xx_sign>     : 0=positive, 1=negative\n"
-"    <dither_user> : 0=disable user control, 1=enable user control\n"
-"    <dither_ctrl> : dither ctrl in Hex, such as 0x400 or 0x600\n"
-"    <brightness>  : negative 0x1ff~0x101, positive 0x0~0xff, signed value in Hex, default is 0x0\n"
-"    <contrast>    : 0x0~0xff, unsigned value in Hex, default is 0x80\n"
-"    <saturation>  : 0x0~0x1ff, unsigned value in Hex, default is 0x100\n"
-"\n"
-"    echo write > debug ; update lcd driver\n"
-"    echo reset > debug ; reset lcd config & driver\n"
-"    echo read > debug ; read current lcd config\n"
-"    echo test <num> > debug ; bist pattern test, 0=pattern off, 1~7=different pattern\n"
-};
-
-static ssize_t lcd_debug_common_help(struct class *class, struct class_attribute *attr, char *buf)
-{
-    return sprintf(buf, "%s\n",lcd_common_usage_str);
-}
-
-static ssize_t lcd_debug_help(struct class *class, struct class_attribute *attr, char *buf)
-{
-    return sprintf(buf, "%s\n",lcd_usage_str);
-}
-
-static void read_current_lcd_config(Lcd_Config_t *pConf)
-{
-    unsigned lcd_clk;
-    int h_adj, v_adj;
-
-    lcd_clk = (pConf->lcd_timing.lcd_clk / 1000);
-    h_adj = ((pConf->lcd_timing.h_offset >> 31) & 1);
-    v_adj = ((pConf->lcd_timing.v_offset >> 31) & 1);
-
-    pConf->lcd_misc_ctrl.print_version();
-    printk("LCD mode: %s, %s %ubit, %ux%u@%u.%uHz\n"
-           "lcd_clk           %u.%03uMHz\n"
-           "ss_level          %d\n"
-           "clk_pol           %d\n\n",
-           pConf->lcd_basic.model_name, lcd_type_table[pConf->lcd_basic.lcd_type], pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active,
-           (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10),
-           (lcd_clk / 1000), (lcd_clk % 1000), ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf), ((pConf->lcd_timing.pol_ctrl >> POL_CTRL_CLK) & 1));
-
-    printk("h_period          %d\n"
-           "v_period          %d\n"
-           "hs_width          %d\n"
-           "hs_backporch      %d\n"
-           "hs_pol            %d\n"
-           "vs_width          %d\n"
-           "vs_backporch      %d\n"
-           "vs_pol            %d\n"
-           "vs_h_phase        %s%d\n"
-           "hvsync_valid      %d\n"
-           "de_valid          %d\n"
-           "h_offset          %s%d\n"
-           "v_offset          %s%d\n\n",
-           pConf->lcd_basic.h_period, pConf->lcd_basic.v_period,
-           pConf->lcd_timing.hsync_width, pConf->lcd_timing.hsync_bp, ((pConf->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1),
-           pConf->lcd_timing.vsync_width, pConf->lcd_timing.vsync_bp, ((pConf->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1),
-           (((pConf->lcd_timing.vsync_h_phase >> 31) & 1) ? "-":""), (pConf->lcd_timing.vsync_h_phase & 0xffff), pConf->lcd_timing.hvsync_valid, pConf->lcd_timing.de_valid,
-           (h_adj ? "-" : ""), (pConf->lcd_timing.h_offset & 0xffff), (v_adj ? "-" : ""), (pConf->lcd_timing.v_offset & 0xffff));
-
-    switch (pConf->lcd_basic.lcd_type) {
-        case LCD_DIGITAL_TTL:
-            printk("rb_swap           %u\n"
-                   "bit_swap          %u\n\n",
-                   pConf->lcd_control.ttl_config->rb_swap, pConf->lcd_control.ttl_config->bit_swap);
-            break;
-        case LCD_DIGITAL_LVDS:
-            printk("vswing_level      %u\n"
-                   "lvds_repack       %u\n"
-                   "pn_swap           %u\n\n",
-                   pConf->lcd_control.lvds_config->lvds_vswing, pConf->lcd_control.lvds_config->lvds_repack, pConf->lcd_control.lvds_config->pn_swap);
-            break;
-        case LCD_DIGITAL_MIPI:
-            printk("dsi_lane_num      %u\n"
-                   "dsi_bit_rate      %u.%03uMHz\n"
-                   "operation_mode    %u(%s), %u(%s)\n"
-                   "transfer_ctrl     %u, %u\n\n",
-                   pConf->lcd_control.mipi_config->lane_num, (pConf->lcd_control.mipi_config->bit_rate / 1000000), ((pConf->lcd_control.mipi_config->bit_rate % 1000000) / 1000),
-                   ((pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_INIT) &1), (((pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_INIT) & 1) ? "COMMAND" : "VIDEO"),
-                   ((pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_DISP) & 1), (((pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_DISP) & 1) ? "COMMAND" : "VIDEO"),
-                   ((pConf->lcd_control.mipi_config->transfer_ctrl>>BIT_TRANS_CTRL_CLK) & 1), ((pConf->lcd_control.mipi_config->transfer_ctrl>>BIT_TRANS_CTRL_SWITCH) & 3));
-            break;
-        case LCD_DIGITAL_EDP:
-            printk("link_rate         %s\n"
-                   "lane_count        %u\n"
-                   "link_adaptive     %u\n"
-                   "vswing            %u\n"
-                   "max_lane_count    %u\n"
-                   "sync_clock_mode   %u\n\n",
-                   ((pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pConf->lcd_control.edp_config->lane_count,
-                   pConf->lcd_control.edp_config->link_adaptive, pConf->lcd_control.edp_config->vswing,
-                   pConf->lcd_control.edp_config->max_lane_count, pConf->lcd_control.edp_config->sync_clock_mode);
-            break;
-        default:
-            break;
-    }
-
-    if (pConf->lcd_effect.dith_user)
-        printk("dither_ctrl       0x%x\n", pConf->lcd_effect.dith_cntl_addr);
-
-    printk("pll_ctrl          0x%08x\n"
-           "div_ctrl          0x%08x\n"
-           "clk_ctrl          0x%08x\n"
-           "video_on_pixel    %d\n"
-           "video_on_line     %d\n\n", 
-           pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl,
-           pConf->lcd_timing.video_on_pixel, pConf->lcd_timing.video_on_line);
-}
-
-static void save_lcd_config(Lcd_Config_t *pConf)
-{
-	temp_lcd_basic.h_active = pConf->lcd_basic.h_active;
-	temp_lcd_basic.v_active = pConf->lcd_basic.v_active;
-	temp_lcd_basic.h_period = pConf->lcd_basic.h_period;
-	temp_lcd_basic.v_period = pConf->lcd_basic.v_period;
-	temp_lcd_basic.lcd_type = pConf->lcd_basic.lcd_type;
-	temp_lcd_basic.lcd_bits = pConf->lcd_basic.lcd_bits;
-
-	temp_lcd_timing.pll_ctrl = pConf->lcd_timing.pll_ctrl;
-	temp_lcd_timing.div_ctrl = pConf->lcd_timing.div_ctrl;
-	temp_lcd_timing.clk_ctrl = pConf->lcd_timing.clk_ctrl;
-	temp_lcd_timing.lcd_clk = pConf->lcd_timing.lcd_clk;
-	temp_lcd_timing.hsync_width = pConf->lcd_timing.hsync_width;
-	temp_lcd_timing.hsync_bp = pConf->lcd_timing.hsync_bp;
-	temp_lcd_timing.vsync_width = pConf->lcd_timing.vsync_width;
-	temp_lcd_timing.vsync_bp = pConf->lcd_timing.vsync_bp;
-	temp_lcd_timing.hvsync_valid = pConf->lcd_timing.hvsync_valid;
-	//temp_lcd_timing.de_hstart = pConf->lcd_timing.de_hstart;
-	//temp_lcd_timing.de_vstart = pConf->lcd_timing.de_vstart;
-	temp_lcd_timing.de_valid = pConf->lcd_timing.de_valid;
-	temp_lcd_timing.h_offset = pConf->lcd_timing.h_offset;
-	temp_lcd_timing.v_offset = pConf->lcd_timing.v_offset;
-	temp_lcd_timing.pol_ctrl = pConf->lcd_timing.pol_ctrl;
-	
-	switch (pConf->lcd_basic.lcd_type) {
-		case LCD_DIGITAL_MIPI:
-			temp_dsi_lane_num = pConf->lcd_control.mipi_config->lane_num;
-			temp_dsi_bit_rate_min = pConf->lcd_control.mipi_config->bit_rate_min;
-			temp_dsi_bit_rate_max = pConf->lcd_control.mipi_config->bit_rate_max;
-			temp_factor_denominator = pConf->lcd_control.mipi_config->factor_denominator;
-			temp_factor_numerator = pConf->lcd_control.mipi_config->factor_numerator;
-			break;
-		case LCD_DIGITAL_EDP:
-			temp_edp_link_rate = pConf->lcd_control.edp_config->link_rate;
-			temp_edp_lane_count = pConf->lcd_control.edp_config->lane_count;
-			temp_edp_vswing = pConf->lcd_control.edp_config->vswing;
-			temp_edp_preemphasis = pConf->lcd_control.edp_config->preemphasis;
-			break;
-		case LCD_DIGITAL_LVDS:
-			temp_lvds_repack = pConf->lcd_control.lvds_config->lvds_repack;
-			temp_pn_swap = pConf->lcd_control.lvds_config->pn_swap;
-			temp_lvds_vswing = pConf->lcd_control.lvds_config->lvds_vswing;
-			break;
-		case LCD_DIGITAL_TTL:
-			temp_ttl_rb_swap = pConf->lcd_control.ttl_config->rb_swap;
-			temp_ttl_bit_swap = pConf->lcd_control.ttl_config->bit_swap;
-			break;
-		default:
-			break;
-	}
-	
-	temp_dith_user = pConf->lcd_effect.dith_user;
-	temp_dith_ctrl = pConf->lcd_effect.dith_cntl_addr;
-	temp_vadj_brightness = pConf->lcd_effect.vadj_brightness;
-	temp_vadj_contrast = pConf->lcd_effect.vadj_contrast;
-	temp_vadj_saturation = pConf->lcd_effect.vadj_saturation;
-}
-
-static void reset_lcd_config(Lcd_Config_t *pConf)
-{
-	printk("reset lcd config.\n");
-	
-	_disable_backlight();
-	_lcd_module_disable();
-	mdelay(200);
-	
-	pConf->lcd_basic.h_active = temp_lcd_basic.h_active;
-	pConf->lcd_basic.v_active = temp_lcd_basic.v_active;
-	pConf->lcd_basic.h_period = temp_lcd_basic.h_period;
-	pConf->lcd_basic.v_period = temp_lcd_basic.v_period;
-	pConf->lcd_basic.lcd_type = temp_lcd_basic.lcd_type;
-	pConf->lcd_basic.lcd_bits = temp_lcd_basic.lcd_bits;
-
-	pConf->lcd_timing.pll_ctrl = temp_lcd_timing.pll_ctrl;
-	pConf->lcd_timing.div_ctrl = temp_lcd_timing.div_ctrl;
-	pConf->lcd_timing.clk_ctrl = temp_lcd_timing.clk_ctrl;
-	pConf->lcd_timing.lcd_clk = temp_lcd_timing.lcd_clk;
-	pConf->lcd_timing.hsync_width = temp_lcd_timing.hsync_width;
-	pConf->lcd_timing.hsync_bp = temp_lcd_timing.hsync_bp;
-	pConf->lcd_timing.vsync_width = temp_lcd_timing.vsync_width;
-	pConf->lcd_timing.vsync_bp = temp_lcd_timing.vsync_bp;
-	pConf->lcd_timing.hvsync_valid = temp_lcd_timing.hvsync_valid;
-	//pConf->lcd_timing.de_hstart = temp_lcd_timing.de_hstart;
-	//pConf->lcd_timing.de_vstart = temp_lcd_timing.de_vstart;
-	pConf->lcd_timing.de_valid = temp_lcd_timing.de_valid;
-	pConf->lcd_timing.h_offset = temp_lcd_timing.h_offset;
-	pConf->lcd_timing.v_offset = temp_lcd_timing.v_offset;
-	pConf->lcd_timing.pol_ctrl = temp_lcd_timing.pol_ctrl;
-	
-	pConf->lcd_effect.dith_user = temp_dith_user;
-	pConf->lcd_effect.dith_cntl_addr = temp_dith_ctrl;
-	pConf->lcd_effect.vadj_brightness = temp_vadj_brightness;
-	pConf->lcd_effect.vadj_contrast = temp_vadj_contrast;
-	pConf->lcd_effect.vadj_saturation = temp_vadj_saturation;
-	
-	switch (pConf->lcd_basic.lcd_type) {
-		case LCD_DIGITAL_MIPI:
-			pConf->lcd_control.mipi_config->lane_num = temp_dsi_lane_num;
-			pConf->lcd_control.mipi_config->bit_rate_min = temp_dsi_bit_rate_min;
-			pConf->lcd_control.mipi_config->bit_rate_max = temp_dsi_bit_rate_max;
-			pConf->lcd_control.mipi_config->factor_denominator = temp_factor_denominator;
-			pConf->lcd_control.mipi_config->factor_numerator = temp_factor_numerator;
-			break;
-		case LCD_DIGITAL_EDP:
-			pConf->lcd_control.edp_config->link_rate = temp_edp_link_rate;
-			pConf->lcd_control.edp_config->lane_count = temp_edp_lane_count;
-			pConf->lcd_control.edp_config->vswing = temp_edp_vswing;
-			pConf->lcd_control.edp_config->preemphasis = temp_edp_preemphasis;
-			break;
-		case LCD_DIGITAL_LVDS:
-			pConf->lcd_control.lvds_config->lvds_repack = temp_lvds_repack;
-			pConf->lcd_control.lvds_config->pn_swap = temp_pn_swap;
-			pConf->lcd_control.lvds_config->lvds_vswing = temp_lvds_vswing;
-			break;
-		case LCD_DIGITAL_TTL:
-			pConf->lcd_control.ttl_config->rb_swap = temp_ttl_rb_swap;
-			pConf->lcd_control.ttl_config->bit_swap = temp_ttl_bit_swap;
-			break;
-		default:
-			break;
-	}
-	
-	lcd_config_init(pConf);
-	_init_vout();
-	_lcd_module_enable();
-	_enable_backlight();
-}
-
-static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int ret;
-	unsigned t[6];
-	
-	switch (buf[0]) {
-		case 'b':	//write basic config
-			t[0] = 1024;
-			t[1] = 768;
-			t[2] = 1344;
-			t[3] = 806;
-			ret = sscanf(buf, "basic %d %d %d %d", &t[0], &t[1], &t[2], &t[3]);
-			pDev->pConf->lcd_basic.h_active = t[0];
-			pDev->pConf->lcd_basic.v_active = t[1];
-			pDev->pConf->lcd_basic.h_period = t[2];
-			pDev->pConf->lcd_basic.v_period = t[3];
-			printk("h_active=%d, v_active=%d, h_period=%d, v_period=%d\n", t[0], t[1], t[2], t[3]);
-			break;
-		case 't':
-			if (buf[1] == 'y') {//type
-				t[0] = 1;
-				t[1] = 6;
-				ret = sscanf(buf, "type %d %d", &t[0], &t[1]);
-				pDev->pConf->lcd_basic.lcd_type = t[0];
-				pDev->pConf->lcd_basic.lcd_bits = t[1];
-				printk("lcd_type: %s, lcd_bits: %d\n", lcd_type_table[t[0]], t[1]);
-			}
-			else if (buf[1] == 'e') {//test
-				t[0] = 0;
-				ret = sscanf(buf, "test %d", &t[0]);
-				if (pDev->pConf->lcd_misc_ctrl.lcd_status == 0)
-					printk("lcd is already OFF, can't display test pattern\n");
-				else
-					pDev->pConf->lcd_misc_ctrl.lcd_test(t[0]);
-			}
-			else if (buf[1] == 't') {//ttl
-				t[0] = 0;
-				t[1] = 0;
-				ret = sscanf(buf, "ttl %d %d", &t[0], &t[1]);
-				pDev->pConf->lcd_control.ttl_config->rb_swap = t[0];
-				pDev->pConf->lcd_control.ttl_config->bit_swap = t[1];
-				printk("ttl rb_swap: %s, bit_swap: %s\n", ((t[0] == 0) ? "disable" : "enable"), ((t[1] == 0) ? "disable" : "enable"));
-			}
-			break;
-		case 'c':
-			t[0] = 40000000;
-			t[1] = 0;
-			t[2] = 0;
-			ret = sscanf(buf, "clock %d %d %d", &t[0], &t[1], &t[2]);
-			pDev->pConf->lcd_timing.lcd_clk = t[0];
-			pDev->pConf->lcd_timing.clk_ctrl = ((pDev->pConf->lcd_timing.clk_ctrl & ~((1 << CLK_CTRL_AUTO) | (0xf << CLK_CTRL_SS))) | ((1 << CLK_CTRL_AUTO) | (t[1] << CLK_CTRL_SS)));
-			pDev->pConf->lcd_timing.pol_ctrl = ((pDev->pConf->lcd_timing.pol_ctrl & ~(1 << POL_CTRL_CLK)) | (t[2] << POL_CTRL_CLK));
-			printk("lcd_clk=%dHz, ss_level=%d, clk_pol=%s\n", t[0], t[1], ((t[2] == 0) ? "negative" : "positive"));
-			break;
-		case 's'://sync
-			t[0] = 10;
-			t[1] = 60;
-			t[2] = 0;
-			t[3] = 3;
-			t[4] = 20;
-			t[5] = 0;
-			ret = sscanf(buf, "sync %d %d %d %d %d %d", &t[0], &t[1], &t[2], &t[3], &t[4], &t[5]);
-			pDev->pConf->lcd_timing.hsync_width = t[0];
-			pDev->pConf->lcd_timing.hsync_bp = t[1];
-			pDev->pConf->lcd_timing.vsync_width = t[3];
-			pDev->pConf->lcd_timing.vsync_bp = t[4];
-			pDev->pConf->lcd_timing.pol_ctrl = ((pDev->pConf->lcd_timing.pol_ctrl & ~((1 << POL_CTRL_HS) | (1 << POL_CTRL_VS))) | ((t[2] << POL_CTRL_HS) | (t[5] << POL_CTRL_VS)));
-			printk("hs_width=%d, hs_bp=%d, hs_pol=%s, vs_width=%d, vs_bp=%d, vs_pol=%s\n", t[0], t[1], ((t[2] == 0) ? "negative" : "positive"), t[3], t[4], ((t[5] == 0) ? "negative" : "positive"));
-			break;
-		case 'v':
-			if (buf[2] == 'l') { //valid
-				t[0] = 0;
-				t[1] = 0;
-				t[2] = 1;
-				ret = sscanf(buf, "valid %d %d", &t[0], &t[1]);
-				pDev->pConf->lcd_timing.hvsync_valid = t[0];
-				pDev->pConf->lcd_timing.de_valid = t[1];
-				printk("hvsync: %s, de: %s\n", ((t[0] == 0) ? "disable" : "enable"), ((t[1] == 0) ? "disable" : "enable"));
-			}
-			else if (buf[2] == 'd') { //vadj
-				t[0] = 0x0;
-				t[1] = 0x80;
-				t[2] = 0x100;
-				ret = sscanf(buf, "vadj %d %d %d", &t[0], &t[1], &t[2]);
-				pDev->pConf->lcd_effect.vadj_brightness = t[0];
-				pDev->pConf->lcd_effect.vadj_contrast = t[1];
-				pDev->pConf->lcd_effect.vadj_saturation = t[2];
-				printk("video adjust: brightness=0x%x, contrast=0x%x, stauration=0x%x\n", t[0], t[1], t[2]);
-			}
-			break;
-		case 'o':
-			t[0] = 1;
-			t[1] = 0;
-			t[2] = 1;
-			t[3] = 0;
-			ret = sscanf(buf, "offset %d %d %d %d", &t[0], &t[1], &t[2], &t[3]);
-			pDev->pConf->lcd_timing.h_offset = ((t[0] << 31) | ((t[1] & 0xffff) << 0));
-			pDev->pConf->lcd_timing.v_offset = ((t[2] << 31) | ((t[3] & 0xffff) << 0));
-			printk("h_offset = %s%u, v_offset = %s%u\n", (t[0] ? "+" : "-"), (t[1] & 0xffff), (t[2] ? "+" : "-"), (t[3] & 0xffff));
-			break;
-		case 'l':	//write lvds config		//lvds_repack, pn_swap
-			t[0] = 1;
-			t[1] = 1;
-			t[2] = 0;
-			ret = sscanf(buf, "lvds %d %d %d", &t[0], &t[1], &t[2]);
-			pDev->pConf->lcd_control.lvds_config->lvds_vswing = t[0];
-			pDev->pConf->lcd_control.lvds_config->lvds_repack = t[1];
-			pDev->pConf->lcd_control.lvds_config->pn_swap = t[2];
-			printk("vswing_level: %u, lvds_repack: %s, rb_swap: %s\n", t[0], ((t[1] == 1) ? "VESA mode" : "JEIDA mode"), ((t[2] == 0) ? "disable" : "enable"));
-			break;
-#ifdef CONFIG_LCD_IF_MIPI_VALID
-		case 'm':	//write mipi config
-			if (buf[1] == 'd') {
-				t[0] = 0;
-				t[1] = 4;
-				t[2] = 0;
-				ret = sscanf(buf, "mdsi %d %d %d", &t[0],&t[1],&t[2]);
-				pDev->pConf->lcd_control.mipi_config->lane_num = (unsigned char)(t[0]);
-				pDev->pConf->lcd_control.mipi_config->bit_rate_max = t[1]*1000;
-				pDev->pConf->lcd_control.mipi_config->factor_numerator = t[2];
-				pDev->pConf->lcd_control.mipi_config->factor_denominator=10;
-				printk("dsi lane_num = %d, bit_rate max=%dMHz, factor=%d\n",t[0], t[1], pDev->pConf->lcd_control.mipi_config->factor_numerator);
-			}
-			else if (buf[1] == 'c') {
-				t[0] = 1;
-				t[1] = 0;
-				t[2] = 0;
-				t[3] = 0;
-				ret = sscanf(buf, "mctl %d %d %d %d", &t[0],&t[1],&t[2],&t[3]);
-				pDev->pConf->lcd_control.mipi_config->operation_mode = ((t[0] << BIT_OPERATION_MODE_INIT) | (t[1] << BIT_OPERATION_MODE_DISP));
-				pDev->pConf->lcd_control.mipi_config->transfer_ctrl = ((t[2] << BIT_TRANS_CTRL_CLK) | (t[3] << BIT_TRANS_CTRL_SWITCH));
-				printk("dsi operation mode init=%s(%d), display=%s(%d), lp_clk_auto_stop=%d, transfer_switch=%d\n",(t[0]? "command" : "video"), t[0], (t[1] ? "command" : "video"), t[1], t[2], t[3]);
-			}
-			break;
-#endif
-		case 'd':
-			if (buf[2] == 't') {
-				t[0] = 0;
-				t[1] = 0x600;
-				ret = sscanf(buf, "dither %d %x", &t[0], &t[1]);
-				pDev->pConf->lcd_effect.dith_user = t[0];
-				pDev->pConf->lcd_effect.dith_cntl_addr = t[1];
-				printk("dither user_ctrl: %s, 0x%x\n", ((t[0] == 0) ? "disable" : "enable"), t[1]);
-			}
-			else {
-				printk("power off lcd.\n");
-				_disable_backlight();
-				pDev->pConf->lcd_power_ctrl.power_ctrl(OFF);
-			}
-			break;
-		case 'w':	//update display config
-			if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_MINILVDS) {
-				printk("Don't support miniLVDS yet. Will reset to original lcd config.\n");
-				reset_lcd_config(pDev->pConf);
-			}
-			else {
-				_lcd_module_disable();
-				mdelay(200);
-				lcd_config_init(pDev->pConf);
-				_init_vout();
-				_lcd_module_enable();
-			}
-			break;
-		case 'r':	
-			if (buf[2] == 'a') { //read lcd config
-				read_current_lcd_config(pDev->pConf);
-			}
-			else if (buf[2] == 's') { //reset lcd config
-				reset_lcd_config(pDev->pConf);
-			}
-			break;
-		case 'e':
-			if (buf[1] == 'n') {
-				printk("power on lcd.\n");
-				_lcd_module_disable();
-				mdelay(200);
-				_lcd_module_enable();
-				_enable_backlight();
-			}
-#ifdef CONFIG_LCD_IF_EDP_VALID
-			else if (buf[1] == 'd') {
-				t[0] = 1;
-				t[1] = 4;
-				t[2] = 0;
-				ret = sscanf(buf, "edp %u %u %u", &t[0], &t[1], &t[2]);
-				if (t[0] == 0)
-					pDev->pConf->lcd_control.edp_config->link_rate = 0;
-				else
-					pDev->pConf->lcd_control.edp_config->link_rate = 1;
-				switch (t[1]) {
-					case 1:
-					case 2:
-						pDev->pConf->lcd_control.edp_config->lane_count = t[1];
-						break;
-					default:
-						pDev->pConf->lcd_control.edp_config->lane_count = 4;
-						break;
-				}
-				pDev->pConf->lcd_control.edp_config->vswing = t[2];
-				printk("set edp link_rate = %s, lane_count = %u, vswing_level = %u\n", ((pDev->pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pDev->pConf->lcd_control.edp_config->lane_count, pDev->pConf->lcd_control.edp_config->vswing);
-			}
-#endif
-			else {
-				printk("wrong format of lcd debug command.\n");
-			}
-			break;
-		default:
-			printk("wrong format of lcd debug command.\n");
-	}	
-	
-	if (ret != 1 || ret !=2)
-		return -EINVAL;
-	
-	return count;
-	//return 0;
-}
-
-static ssize_t lcd_status_read(struct class *class, struct class_attribute *attr, char *buf)
-{
-	return sprintf(buf, "read lcd status: %s\n", (pDev->pConf->lcd_misc_ctrl.lcd_status ? "ON":"OFF"));
-}
-
-static ssize_t lcd_status_write(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int ret;
-	unsigned temp;
-
-	temp = 1;
-	ret = sscanf(buf, "%d", &temp);
-	if (temp) {
-		if (pDev->pConf->lcd_misc_ctrl.lcd_status == 0) {
-			mutex_lock(&lcd_vout_mutex);
-			_lcd_module_enable();
-			_enable_backlight();
-			mutex_unlock(&lcd_vout_mutex);
-		}
-		else {
-			printk("lcd is already ON\n");
-		}
-	}
-	else {
-		if (pDev->pConf->lcd_misc_ctrl.lcd_status == 1) {
-			mutex_lock(&lcd_vout_mutex);
-			_disable_backlight();
-			_lcd_module_disable();
-			mutex_unlock(&lcd_vout_mutex);
-		}
-		else {
-			printk("lcd is already OFF\n");
-		}
-	}
-
-	if (ret != 1 || ret !=2)
-		return -EINVAL;
-
-	return count;
-	//return 0;
-}
-
-static ssize_t lcd_print_read(struct class *class, struct class_attribute *attr, char *buf)
-{
-	return sprintf(buf, "lcd print flag: %u\n", lcd_print_flag);
-}
-
-static ssize_t lcd_print_write(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
-{
-	unsigned int ret;
-
-	ret = sscanf(buf, "%u", &lcd_print_flag);
-	printk("write lcd print flag: %u\n", lcd_print_flag);
-
-	if (ret != 1 || ret !=2)
-		return -EINVAL;
-
-	return count;
-	//return 0;
-}
-
-static struct class_attribute lcd_debug_class_attrs[] = {
-	__ATTR(debug,  S_IRUGO | S_IWUSR, lcd_debug_help, lcd_debug),
-	__ATTR(help,  S_IRUGO | S_IWUSR, lcd_debug_common_help, NULL),
-	__ATTR(status,  S_IRUGO | S_IWUSR, lcd_status_read, lcd_status_write),
-	__ATTR(print,  S_IRUGO | S_IWUSR, lcd_print_read, lcd_print_write),
-};
-
-static int creat_lcd_class(void)
-{
-    pDev->pConf->lcd_misc_ctrl.debug_class = class_create(THIS_MODULE, "lcd");
-    if(IS_ERR(pDev->pConf->lcd_misc_ctrl.debug_class)) {
-        printk("create lcd debug class fail\n");
-        return -1;
-    }
-    return 0;
-}
-
-static int remove_lcd_class(void)
-{
-    if (pDev->pConf->lcd_misc_ctrl.debug_class == NULL)
-        return -1;
-
-    class_destroy(pDev->pConf->lcd_misc_ctrl.debug_class);
-    pDev->pConf->lcd_misc_ctrl.debug_class = NULL;
-    return 0;
-}
-
-static int creat_lcd_attr(void)
-{
-    int i;
-
-    if(pDev->pConf->lcd_misc_ctrl.debug_class == NULL) {
-        printk("no lcd debug class exist\n");
-        return -1;
-    }
-
-    for(i=0;i<ARRAY_SIZE(lcd_debug_class_attrs);i++) {
-        if (class_create_file(pDev->pConf->lcd_misc_ctrl.debug_class, &lcd_debug_class_attrs[i])) {
-            printk("create lcd debug attribute %s fail\n", lcd_debug_class_attrs[i].attr.name);
-        }
-    }
-
-    return 0;
-}
-
-static int remove_lcd_attr(void)
-{
-    int i;
-
-    if (pDev->pConf->lcd_misc_ctrl.debug_class == NULL)
-        return -1;
-
-    for(i=0;i<ARRAY_SIZE(lcd_debug_class_attrs);i++) {
-        class_remove_file(pDev->pConf->lcd_misc_ctrl.debug_class, &lcd_debug_class_attrs[i]);
-    }
-
-    return 0;
-}
-//****************************
-
-static int lcd_reboot_notifier(struct notifier_block *nb, unsigned long state, void *cmd)
- {
-	lcd_print("[%s]: %lu\n", __FUNCTION__, state);
-	if (pDev->pConf->lcd_misc_ctrl.lcd_status == 0)
-		return NOTIFY_DONE;
-	
-	_disable_backlight();
-	_lcd_module_disable();
-
-	return NOTIFY_OK;
-}
-
-static int amlogic_pmu_gpio_name_map_num(const char *name)
-{
-	int index;
-	
-	for(index = 0; index < LCD_POWER_PMU_GPIO_MAX; index++) {
-		if(!strcasecmp(name, lcd_power_pmu_gpio_table[index]))
-			break;
-	}
-	return index;
-}
-
-#ifdef CONFIG_USE_OF
-#define LCD_MODEL_LEN_MAX    30
-static int _get_lcd_model_timing(Lcd_Config_t *pConf, struct platform_device *pdev)
-{
-	int ret=0;
-	const char *str;
-	unsigned int val;
-	//unsigned int lcd_para[100];
-	unsigned int *lcd_para = (unsigned int *)kmalloc(sizeof(unsigned int)*100, GFP_KERNEL);
-	int i, j;
-	struct device_node *lcd_model_node;
-	phandle fhandle;
-	
-	if (lcd_para == NULL) {
-		printk("[_get_lcd_model_timing]: Not enough memory\n");
-		return -1;
-	}
-	if (pdev->dev.of_node) {
-		ret = of_property_read_u32(pdev->dev.of_node,"lcd_model_config",&fhandle);
-		lcd_model_node = of_find_node_by_phandle(fhandle);
-		ret = of_property_read_string(lcd_model_node,"model_name", &str);
-		if(ret) {
-			str = "none";
-			printk("lcd: faild to get lcd_model_name!\n");
-		}
-		pConf->lcd_basic.model_name = (char *)kmalloc(sizeof(char)*LCD_MODEL_LEN_MAX, GFP_KERNEL);
-		if (pConf->lcd_basic.model_name == NULL) {
-			printk("[_get_lcd_model_timing]: Not enough memory\n");
-		}
-		else {
-			memset(pConf->lcd_basic.model_name, 0, LCD_MODEL_LEN_MAX);
-			strcpy(pConf->lcd_basic.model_name, str);
-			printk("load lcd model in dtb: %s\n", pConf->lcd_basic.model_name);
-		}
-		
-		ret = of_property_read_string(lcd_model_node, "interface", &str);
-		if (ret) {
-			printk("faild to get lcd_type!\n");
-			str = "invalid";
-		}	
-		for(val = 0; val < LCD_TYPE_MAX; val++) {
-			if(!strcasecmp(str, lcd_type_table[val]))
-				break;
-		}		
-		pConf->lcd_basic.lcd_type = val;
-		lcd_print("lcd_type= %s(%u)\n", lcd_type_table[pConf->lcd_basic.lcd_type], pConf->lcd_basic.lcd_type);
-		ret = of_property_read_u32_array(lcd_model_node,"active_area",&lcd_para[0],2);
-		if(ret){
-			printk("faild to get active_area\n");
-		}
-		else {
-			pConf->lcd_basic.h_active_area = lcd_para[0];
-			pConf->lcd_basic.v_active_area = lcd_para[1];
-			pConf->lcd_basic.screen_ratio_width = lcd_para[0];
-			pConf->lcd_basic.screen_ratio_height = lcd_para[1];
-		}
-		lcd_print("h_active_area = %umm, v_active_area =%umm\n", pConf->lcd_basic.h_active_area, pConf->lcd_basic.v_active_area);
-		ret = of_property_read_u32_array(lcd_model_node,"lcd_bits_option",&lcd_para[0],2);
-		if(ret){
-			printk("faild to get lcd_bits_option\n");
-		}
-		else {
-			pConf->lcd_basic.lcd_bits = (unsigned short)(lcd_para[0]);
-			pConf->lcd_basic.lcd_bits_option = (unsigned short)(lcd_para[1]);
-		}
-		lcd_print("lcd_bits = %u, lcd_bits_option = %u\n", pConf->lcd_basic.lcd_bits, pConf->lcd_basic.lcd_bits_option);
-		ret = of_property_read_u32_array(lcd_model_node,"resolution", &lcd_para[0], 2);
-		if(ret){
-			printk("faild to get resolution\n");
-		}
-		else {
-			pConf->lcd_basic.h_active = (unsigned short)(lcd_para[0]);
-			pConf->lcd_basic.v_active = (unsigned short)(lcd_para[1]);
-		}		
-		ret = of_property_read_u32_array(lcd_model_node,"period",&lcd_para[0],2);
-		if(ret){
-			printk("faild to get period\n");
-		}
-		else {
-			pConf->lcd_basic.h_period = (unsigned short)(lcd_para[0]);
-			pConf->lcd_basic.v_period = (unsigned short)(lcd_para[1]);
-		}
-		lcd_print("h_active = %u, v_active =%u, h_period = %u, v_period = %u\n", pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, pConf->lcd_basic.h_period, pConf->lcd_basic.v_period);
-		ret = of_property_read_u32_array(lcd_model_node,"clock_hz_pol",&lcd_para[0], 2);
-		if(ret){
-			printk("faild to get clock_hz_pol\n");
-		}
-		else {
-			pConf->lcd_timing.lcd_clk = lcd_para[0];
-			pConf->lcd_timing.pol_ctrl = (lcd_para[1] << POL_CTRL_CLK);
-		}
-		lcd_print("pclk = %uHz, pol=%u\n", pConf->lcd_timing.lcd_clk, (pConf->lcd_timing.pol_ctrl >> POL_CTRL_CLK) & 1);
-		ret = of_property_read_u32_array(lcd_model_node,"hsync_width_backporch",&lcd_para[0], 2);
-		if(ret){
-			printk("faild to get hsync_width_backporch\n");
-		}
-		else {
-			pConf->lcd_timing.hsync_width = (unsigned short)(lcd_para[0]);
-			pConf->lcd_timing.hsync_bp = (unsigned short)(lcd_para[1]);
-		}
-		lcd_print("hsync width = %u, backporch = %u\n", pConf->lcd_timing.hsync_width, pConf->lcd_timing.hsync_bp);
-		ret = of_property_read_u32_array(lcd_model_node,"vsync_width_backporch",&lcd_para[0], 2);
-		if(ret){
-			printk("faild to get vsync_width_backporch\n");
-		}
-		else {
-			pConf->lcd_timing.vsync_width = (unsigned short)(lcd_para[0]);
-			pConf->lcd_timing.vsync_bp = (unsigned short)(lcd_para[1]);
-		}
-		lcd_print("vsync width = %u, backporch = %u\n", pConf->lcd_timing.vsync_width, pConf->lcd_timing.vsync_bp);
-		ret = of_property_read_u32_array(lcd_model_node,"pol_hsync_vsync",&lcd_para[0], 2);
-		if(ret){
-			printk("faild to get pol_hsync_vsync\n");
-		}
-		else {
-			pConf->lcd_timing.pol_ctrl = (pConf->lcd_timing.pol_ctrl & ~((1 << POL_CTRL_HS) | (1 << POL_CTRL_VS))) | ((lcd_para[0] << POL_CTRL_HS) | (lcd_para[1] << POL_CTRL_VS));
-		}
-		lcd_print("pol hsync = %u, vsync = %u\n", (pConf->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1, (pConf->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1);
-		ret = of_property_read_u32_array(lcd_model_node,"vsync_horizontal_phase",&lcd_para[0], 2);
-		if(ret){
-			printk("faild to get vsync_horizontal_phase\n");
-			pConf->lcd_timing.vsync_h_phase = 0;
-		} else {
-			pConf->lcd_timing.vsync_h_phase = ((lcd_para[0] << 31) | ((lcd_para[1] & 0xffff) << 0));
-		}
-		if (lcd_para[0] == 0)
-			lcd_print("vsync_horizontal_phase= %d\n", lcd_para[1]);
-		else
-			lcd_print("vsync_horizontal_phase= -%d\n", lcd_para[1]);
-
-        if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_MIPI) {
-            ret = of_property_read_u32(lcd_model_node,"dsi_lane_num",&val);
-            if(ret){
-                printk("faild to get dsi_lane_num\n");
-                pConf->lcd_control.mipi_config->lane_num = 4;
-            }
-            else {
-                pConf->lcd_control.mipi_config->lane_num = (unsigned char)val;
-            }
-            lcd_print("dsi_lane_num= %d\n",  pConf->lcd_control.mipi_config->lane_num);
-            ret = of_property_read_u32(lcd_model_node,"dsi_bit_rate_max",&val);
-            if(ret){
-                printk("faild to get dsi_bit_rate_max\n");
-                pConf->lcd_control.mipi_config->bit_rate_max = 0;
-            }
-            else {
-                pConf->lcd_control.mipi_config->bit_rate_max = val;
-            }
-            lcd_print("dsi bit_rate max = %dMHz\n", pConf->lcd_control.mipi_config->bit_rate_max);
-            ret = of_property_read_u32(lcd_model_node,"pclk_lanebyteclk_factor",&val);
-            if(ret){
-                printk("faild to get pclk_lanebyteclk_factor\n");
-                pConf->lcd_control.mipi_config->factor_numerator = 0;
-            }
-            else {
-                pConf->lcd_control.mipi_config->factor_numerator = val;
-            }
-            pConf->lcd_control.mipi_config->factor_denominator = 10;
-            lcd_print("pclk_lanebyteclk factor= %d\n", pConf->lcd_control.mipi_config->factor_numerator);
-            ret = of_property_read_u32_array(lcd_model_node,"dsi_operation_mode",&lcd_para[0], 2);
-            if(ret){
-                printk("faild to get dsi_operation_mode\n");
-                pConf->lcd_control.mipi_config->operation_mode = ((1 << BIT_OPERATION_MODE_INIT) | (0 << BIT_OPERATION_MODE_DISP));
-            }
-            else {
-                pConf->lcd_control.mipi_config->operation_mode = ((lcd_para[0] << BIT_OPERATION_MODE_INIT) | (lcd_para[1] << BIT_OPERATION_MODE_DISP));
-            }
-            lcd_print("dsi_operation_mode init=%d, display=%d\n", (pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1, (pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
-            ret = of_property_read_u32_array(lcd_model_node,"dsi_transfer_ctrl",&lcd_para[0], 2);
-            if(ret){
-                printk("faild to get dsi_transfer_ctrl\n");
-                pConf->lcd_control.mipi_config->transfer_ctrl = ((0 << BIT_TRANS_CTRL_CLK) | (0 << BIT_TRANS_CTRL_SWITCH));
-            }
-            else {
-                pConf->lcd_control.mipi_config->transfer_ctrl = ((lcd_para[0] << BIT_TRANS_CTRL_CLK) | (lcd_para[1] << BIT_TRANS_CTRL_SWITCH));
-            }
-            lcd_print("dsi_transfer_ctrl clk=%d, switch=%d\n", (pConf->lcd_control.mipi_config->transfer_ctrl >> BIT_TRANS_CTRL_CLK) & 1, (pConf->lcd_control.mipi_config->transfer_ctrl >> BIT_TRANS_CTRL_SWITCH) & 3);
-            //detect dsi init on table
-            if (pConf->lcd_control.mipi_config->dsi_init_on != NULL) {
-                ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", 0, &lcd_para[0]);
-                if (ret) {
-                    printk("faild to get dsi_init_on\n");
-                }
-                else {
-                    i = 0;
-                    while (i < DSI_INIT_ON_MAX) {
-                        ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", i, &val);
-                        if (val == 0xff) {
-                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", (i+1), &val);
-                            i += 2;
-                            if (val == 0xff)
-                                break;
-                        }
-                        else {
-                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", (i+2), &val);
-                            i = i + 3 + val;
-                        }
-                    }
-                    ret = of_property_read_u32_array(lcd_model_node,"dsi_init_on", &lcd_para[0], i);
-                    if(ret){
-                        printk("faild to get dsi_init_on\n");
-                    }
-                    else {
-                        lcd_print("dsi_init_on: ");
-                        for (j=0; j<i; j++) {
-                            pConf->lcd_control.mipi_config->dsi_init_on[j] = (unsigned char)(lcd_para[j] & 0xff);
-                            lcd_print("0x%02x ", pConf->lcd_control.mipi_config->dsi_init_on[j]);
-                        }
-                        lcd_print("\n");
-                    }
-                }
-            }
-            //detect dsi init off table
-            if (pConf->lcd_control.mipi_config->dsi_init_off != NULL) {
-                ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", 0, &lcd_para[0]);
-                if (ret) {
-                    printk("faild to get dsi_init_off\n");
-                }
-                else {
-                    i = 0;
-                    while (i < DSI_INIT_OFF_MAX) {
-                        ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", i, &val);
-                        if (val == 0xff) {
-                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", (i+1), &val);
-                            i += 2;
-                            if (val == 0xff)
-                                break;
-                        }
-                        else {
-                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", (i+2), &val);
-                            i = i + 3 + val;
-                        }
-                    }
-                    ret = of_property_read_u32_array(lcd_model_node,"dsi_init_off", &lcd_para[0], i);
-                    if(ret){
-                        printk("faild to get dsi_init_off\n");
-                    }
-                    else {
-                        lcd_print("dsi_init_off: ");
-                        for (j=0; j<i; j++) {
-                            pConf->lcd_control.mipi_config->dsi_init_off[j] = (unsigned char)(lcd_para[j] & 0xff);
-                            lcd_print("0x%02x ", pConf->lcd_control.mipi_config->dsi_init_off[j]);
-                        }
-                        lcd_print("\n");
-                    }
-                }
-            }
-            ret = of_property_read_u32(lcd_model_node,"lcd_extern_init",&val);
-            if(ret){
-                printk("faild to get lcd_extern_init\n");
-                pConf->lcd_control.mipi_config->lcd_extern_init =0;
-            } else {
-                pConf->lcd_control.mipi_config->lcd_extern_init =(unsigned char)(val);
-            }
-            lcd_print("lcd_extern_init = %d\n",  pConf->lcd_control.mipi_config->lcd_extern_init);
-        }
-        else if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_EDP) {
-            ret = of_property_read_u32(lcd_model_node,"max_lane_count",&val);
-            if(ret){
-                printk("faild to get max_lane_count\n");
-                pConf->lcd_control.edp_config->max_lane_count = 4;
-            } else {
-                pConf->lcd_control.edp_config->max_lane_count =(unsigned char)(val);
-            }
-            lcd_print("max_lane_count = %d\n", pConf->lcd_control.edp_config->max_lane_count);
-        }
-    }
-    kfree(lcd_para);
-    return ret;
-}
-
-static int _get_lcd_default_config(Lcd_Config_t *pConf, struct platform_device *pdev)
-{
-	int ret=0;
-	unsigned int val;
-	unsigned int lcd_para[5];
-	//unsigned int gamma_temp[256];
-	unsigned int *gamma_temp = (unsigned int *)kmalloc(sizeof(unsigned int)*256, GFP_KERNEL);
-	int i;
-	unsigned int lcd_gamma_multi = 0;
-	
-	if (gamma_temp == NULL) {
-		printk("[_get_lcd_default_config]: Not enough memory\n");
-		return -1;
-	}
-	//pdev->dev.of_node = of_find_node_by_name(NULL,"lcd");
-	if (pdev->dev.of_node) {
-		if (pConf->lcd_basic.lcd_bits_option == 1) {
-			ret = of_property_read_u32(pdev->dev.of_node,"lcd_bits_user",&val);
-			if(ret){
-				printk("don't find to match lcd_bits_user, use panel typical setting.\n");
-			}
-			else {
-				pConf->lcd_basic.lcd_bits = (unsigned short)(val);
-				printk("lcd_bits = %u\n", pConf->lcd_basic.lcd_bits);
-			}
-		}
-		//ttl & lvds config
-		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
-			ret = of_property_read_u32_array(pdev->dev.of_node,"ttl_rb_bit_swap",&lcd_para[0], 2);
-			if(ret){
-				printk("don't find to match ttl_rb_bit_swap, use default setting.\n");
-			}
-			else {
-				pConf->lcd_control.ttl_config->rb_swap = (unsigned char)(lcd_para[0]);
-				pConf->lcd_control.ttl_config->bit_swap = (unsigned char)(lcd_para[1]);
-				printk("ttl rb_swap = %u, bit_swap = %u\n", pConf->lcd_control.ttl_config->rb_swap, pConf->lcd_control.ttl_config->bit_swap);
-			}
-		}
-		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
-			ret = of_property_read_u32(pdev->dev.of_node,"lvds_channel_pn_swap",&val);
-			if(ret){
-				printk("don't find to match lvds_channel_pn_swap, use default setting.\n");
-			}
-			else {
-				pConf->lcd_control.lvds_config->pn_swap = val;
-				printk("lvds_pn_swap = %u\n", pConf->lcd_control.lvds_config->pn_swap);
-			}
-		}
-
-		//recommend setting
-		ret = of_property_read_u32_array(pdev->dev.of_node,"valid_hvsync_de",&lcd_para[0], 2);
-		if(ret){
-			printk("don't find to match valid_hvsync_de, use default setting.\n");
-		}
-		else {
-			pConf->lcd_timing.hvsync_valid = (unsigned short)(lcd_para[0]);
-			pConf->lcd_timing.de_valid = (unsigned short)(lcd_para[1]);
-			lcd_print("valid hvsync = %u, de = %u\n", pConf->lcd_timing.hvsync_valid, pConf->lcd_timing.de_valid);
-		}
-		ret = of_property_read_u32_array(pdev->dev.of_node,"hsign_hoffset_vsign_voffset",&lcd_para[0], 4);
-		if(ret){
-			printk("don't find to match hsign_hoffset_vsign_voffset, use default setting.\n");
-			pConf->lcd_timing.h_offset = 0;
-			pConf->lcd_timing.v_offset = 0;
-		}
-		else {
-			pConf->lcd_timing.h_offset = ((lcd_para[0] << 31) | ((lcd_para[1] & 0xffff) << 0));
-			pConf->lcd_timing.v_offset = ((lcd_para[2] << 31) | ((lcd_para[3] & 0xffff) << 0));
-			lcd_print("h_offset = %s%u, ", (((pConf->lcd_timing.h_offset >> 31) & 1) ? "-" : ""), (pConf->lcd_timing.h_offset & 0xffff));
-			lcd_print("v_offset = %s%u\n", (((pConf->lcd_timing.v_offset >> 31) & 1) ? "-" : ""), (pConf->lcd_timing.v_offset & 0xffff));
-		}
-		ret = of_property_read_u32_array(pdev->dev.of_node,"dither_user_ctrl",&lcd_para[0], 2);
-		if(ret){
-			printk("don't find to match dither_user_ctrl, use default setting.\n");
-			pConf->lcd_effect.dith_user = 0;
-		}
-		else {
-			pConf->lcd_effect.dith_user = (unsigned short)(lcd_para[0]);
-			pConf->lcd_effect.dith_cntl_addr = (unsigned short)(lcd_para[1]);
-			lcd_print("dither_user = %u, dither_ctrl = 0x%x\n", pConf->lcd_effect.dith_user, pConf->lcd_effect.dith_cntl_addr);
-		}
-		ret = of_property_read_u32_array(pdev->dev.of_node,"vadj_brightness_contrast_saturation",&lcd_para[0], 3);
-		if(ret){
-			printk("don't find to match vadj_brightness_contrast_saturation, use default setting.\n");
-		}
-		else {
-			pConf->lcd_effect.vadj_brightness = lcd_para[0];
-			pConf->lcd_effect.vadj_contrast = lcd_para[1];
-			pConf->lcd_effect.vadj_saturation = lcd_para[2];
-			lcd_print("vadj_brightness = 0x%x, vadj_contrast = 0x%x, vadj_saturation = 0x%x\n", pConf->lcd_effect.vadj_brightness, pConf->lcd_effect.vadj_contrast, pConf->lcd_effect.vadj_saturation);
-		}
-		ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_en_reverse",&lcd_para[0], 2);
-		if(ret){
-			printk("don't find to match gamma_en_reverse, use default setting.\n");
-		}
-		else {
-			pConf->lcd_effect.gamma_ctrl = ((lcd_para[0] << GAMMA_CTRL_EN) | (lcd_para[1] << GAMMA_CTRL_REVERSE));
-			lcd_print("gamma_en = %u, gamma_reverse=%u\n", ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1), ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1));
-		}
-		ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_multi_rgb_coeff",&lcd_para[0], 4);
-		if(ret){
-			printk("don't find to match gamma_multi_rgb_coeff, use default setting.\n");
-		}
-		else {
-			lcd_gamma_multi = lcd_para[0];
-			pConf->lcd_effect.gamma_r_coeff = (unsigned short)(lcd_para[1]);
-			pConf->lcd_effect.gamma_g_coeff = (unsigned short)(lcd_para[2]);
-			pConf->lcd_effect.gamma_b_coeff = (unsigned short)(lcd_para[3]);
-			lcd_print("gamma_multi = %u, gamma_r_coeff = %u, gamma_g_coeff = %u, gamma_b_coeff = %u\n", lcd_gamma_multi, pConf->lcd_effect.gamma_r_coeff, pConf->lcd_effect.gamma_g_coeff, pConf->lcd_effect.gamma_b_coeff);
-		}
-		if (lcd_gamma_multi == 1) {
-			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table_r",&gamma_temp[0], 256);
-			if(ret){
-				printk("don't find to match gamma_table_r, use default table.\n");
-				lcd_setup_gamma_table(pConf, 0);
-			}
-			else {
-				for (i=0; i<256; i++) {
-					pConf->lcd_effect.GammaTableR[i] = (unsigned short)(gamma_temp[i] << 2);
-				}
-				lcd_print("load gamma_table_r.\n");
-			}
-			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table_g",&gamma_temp[0], 256);
-			if(ret){
-				printk("don't find to match gamma_table_g, use default table.\n");
-				lcd_setup_gamma_table(pConf, 1);
-			}
-			else {
-				for (i=0; i<256; i++) {
-					pConf->lcd_effect.GammaTableG[i] = (unsigned short)(gamma_temp[i] << 2);
-				}
-				lcd_print("load gamma_table_g.\n");
-			}
-			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table_b",&gamma_temp[0], 256);
-			if(ret){
-				printk("don't find to match gamma_table_b, use default table.\n");
-				lcd_setup_gamma_table(pConf, 2);
-			}
-			else {
-				for (i=0; i<256; i++) {
-					pConf->lcd_effect.GammaTableB[i] = (unsigned short)(gamma_temp[i] << 2);
-				}
-				lcd_print("load gamma_table_b.\n");
-			}
-		}
-		else {
-			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table",&gamma_temp[0], 256);
-			if(ret){
-				printk("don't find to match gamma_table, use default table.\n");
-				lcd_setup_gamma_table(pConf, 3);
-			}
-			else {
-				for (i=0; i<256; i++) {
-					pConf->lcd_effect.GammaTableR[i] = (unsigned short)(gamma_temp[i] << 2);
-					pConf->lcd_effect.GammaTableG[i] = (unsigned short)(gamma_temp[i] << 2);
-					pConf->lcd_effect.GammaTableB[i] = (unsigned short)(gamma_temp[i] << 2);
-				}
-				lcd_print("load gamma_table.\n");
-			}
-		}
-		
-		//default setting
-		ret = of_property_read_u32(pdev->dev.of_node,"clock_spread_spectrum",&val);
-		if(ret){
-			printk("don't find to match clock_spread_spectrum, use default setting.\n");
-		}
-		else {
-			pConf->lcd_timing.clk_ctrl = ((pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_SS)) | (val << CLK_CTRL_SS));
-			lcd_print("lcd clock spread spectrum = %u\n", (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf);
-		}
-		ret = of_property_read_u32(pdev->dev.of_node,"clock_auto_generation",&val);
-		if(ret){
-			printk("don't find to match clock_auto_generation, use default setting.\n");
-		}
-		else {
-			pConf->lcd_timing.clk_ctrl = ((pConf->lcd_timing.clk_ctrl & ~(1 << CLK_CTRL_AUTO)) | (val << CLK_CTRL_AUTO));
-			lcd_print("lcd clock auto_generation = %u\n", (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 0x1);
-		}
-		if (((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 0x1) == 0) {
-			ret = of_property_read_u32_array(pdev->dev.of_node,"clk_pll_div_clk_ctrl",&lcd_para[0], 3);
-			if(ret){
-				printk("don't find to match clk_pll_div_clk_ctrl, use default setting.\n");
-			}
-			else {
-				pConf->lcd_timing.pll_ctrl = lcd_para[0];
-				pConf->lcd_timing.div_ctrl = lcd_para[1];
-				pConf->lcd_timing.clk_ctrl = lcd_para[2];
-				printk("pll_ctrl = 0x%x, div_ctrl = 0x%x, clk_ctrl=0x%x\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, (pConf->lcd_timing.clk_ctrl & 0xffff));
-			}
-		}
-		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
-			ret = of_property_read_u32(pdev->dev.of_node,"lvds_vswing",&val);
-			if(ret){
-				printk("don't find to match lvds_vswing, use default setting.\n");
-			}
-			else {
-				pConf->lcd_control.lvds_config->lvds_vswing = val;
-				printk("lvds_vswing level = %u\n", pConf->lcd_control.lvds_config->lvds_vswing = val);
-			}
-			ret = of_property_read_u32_array(pdev->dev.of_node,"lvds_user_repack",&lcd_para[0], 2);
-			if(ret){
-				printk("don't find to match lvds_user_repack, use default setting.\n");
-				pConf->lcd_control.lvds_config->lvds_repack_user = 0;
-				pConf->lcd_control.lvds_config->lvds_repack = 1;
-			}
-			else {
-				pConf->lcd_control.lvds_config->lvds_repack_user = lcd_para[0];
-				pConf->lcd_control.lvds_config->lvds_repack = lcd_para[1];
-				if (lcd_para[0] > 0) {
-					printk("lvds_repack = %u\n", pConf->lcd_control.lvds_config->lvds_repack);
-				}
-				else {
-					lcd_print("lvds_repack_user = %u, lvds_repack = %u\n", pConf->lcd_control.lvds_config->lvds_repack_user, pConf->lcd_control.lvds_config->lvds_repack);
-				}
-			}
-		}
-		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_EDP) {
-			ret = of_property_read_u32_array(pdev->dev.of_node,"edp_user_link_rate_lane_count",&lcd_para[0], 3);
-			if(ret){
-				pConf->lcd_control.edp_config->link_user = 0;
-				pConf->lcd_control.edp_config->link_rate = 1;
-				pConf->lcd_control.edp_config->lane_count = 4;
-				printk("don't find to match edp_user_link_rate_lane_count, use default setting.\n");
-			}
-			else {
-				pConf->lcd_control.edp_config->link_user = (unsigned char)(lcd_para[0]);
-				pConf->lcd_control.edp_config->link_rate = (unsigned char)(lcd_para[1]);
-				pConf->lcd_control.edp_config->lane_count = (unsigned char)(lcd_para[2]);
-				if (pConf->lcd_control.edp_config->link_user > 0) {
-					printk("edp link_rate = %s, lane_count = %u\n", ((pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pConf->lcd_control.edp_config->lane_count);
-				}
-				else {
-					lcd_print("edp user = %u, link_rate = %s, lane_count = %u\n", pConf->lcd_control.edp_config->link_user, ((pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pConf->lcd_control.edp_config->lane_count);
-				}
-			}
-			ret = of_property_read_u32_array(pdev->dev.of_node,"edp_link_adaptive_vswing",&lcd_para[0], 2);
-			if(ret){
-				printk("don't find to match edp_link_adaptive_vswing, use default setting.\n");
-				pConf->lcd_control.edp_config->link_adaptive = 0;
-				pConf->lcd_control.edp_config->vswing = 0;
-				pConf->lcd_control.edp_config->preemphasis = 0;
-			}
-			else {
-				pConf->lcd_control.edp_config->link_adaptive = (unsigned char)(lcd_para[0]);
-				pConf->lcd_control.edp_config->vswing = (unsigned char)(lcd_para[1]);
-				pConf->lcd_control.edp_config->preemphasis = 0;
-				if (pConf->lcd_control.edp_config->link_adaptive == 0) {
-					printk("edp swing_level = %u\n", pConf->lcd_control.edp_config->vswing);
-				}
-				else {
-					lcd_print("edp link_adaptive = %u, swing_level = %u\n", pConf->lcd_control.edp_config->link_adaptive, pConf->lcd_control.edp_config->vswing);
-				}
-			}
-			ret = of_property_read_u32(pdev->dev.of_node,"edp_sync_clock_mode",&val);
-			if(ret){
-				printk("don't find to match edp_sync_clock_mode, use default setting.\n");
-				pConf->lcd_control.edp_config->sync_clock_mode = 1;
-			}
-			else {
-				pConf->lcd_control.edp_config->sync_clock_mode = (val & 1);
-				printk("edp sync_clock_mode = %u\n", pConf->lcd_control.edp_config->sync_clock_mode);
-			}
-		}
-		ret = of_property_read_u32_array(pdev->dev.of_node,"rgb_base_coeff",&lcd_para[0], 2);
-		if(ret){
-			printk("don't find to match rgb_base_coeff, use default setting.\n");
-		}
-		else {
-			pConf->lcd_effect.rgb_base_addr = (unsigned short)(lcd_para[0]);
-			pConf->lcd_effect.rgb_coeff_addr = (unsigned short)(lcd_para[1]);
-			lcd_print("rgb_base = 0x%x, rgb_coeff = 0x%x\n", pConf->lcd_effect.rgb_base_addr, pConf->lcd_effect.rgb_coeff_addr);
-		}
-		// ret = of_property_read_u32_array(pdev->dev.of_node,"video_on_pixel_line",&lcd_para[0], 2);
-		// if(ret){
-			// printk("don't find to match video_on_pixel_line, use default setting.\n");
-		// }
-		// else {
-			// pConf->lcd_timing.video_on_pixel = (unsigned short)(lcd_para[0]);
-			// pConf->lcd_timing.video_on_line = (unsigned short)(lcd_para[1]);
-			// lcd_print("video_on_pixel = %u, video_on_line = %u\n", pConf->lcd_timing.video_on_pixel, pConf->lcd_timing.video_on_line);
-		// }
-	}
-	kfree(gamma_temp);
-	return ret;
-}
-
-static int _get_lcd_power_config(Lcd_Config_t *pConf, struct platform_device *pdev)
-{
-	int ret=0;
-	const char *str;
-	unsigned char propname[20];
-	int val;
-	unsigned int lcd_para[LCD_POWER_CTRL_STEP_MAX];
-	int i;
-	int index;
-	
-	if (pdev->dev.of_node) {
-		//lcd power on
-		for (i=0; i < LCD_POWER_CTRL_STEP_MAX; i++) {
-			//propname = kasprintf(GFP_KERNEL, "power_on_step_%d", i+1);
-			sprintf(propname, "power_on_step_%d", i+1);
-			ret = of_property_read_string_index(pdev->dev.of_node, propname, 0, &str);
-			if (ret) {
-				lcd_print("faild to get %s\n", propname);
-				break;
-			}
-			else if ((strcasecmp(str, "null") == 0) || ((strcasecmp(str, "n") == 0))) {
-				break;
-			}
-			else {
-				lcd_print("%s 0: %s\n", propname, str);
-				for(index = 0; index < LCD_POWER_TYPE_MAX; index++) {
-					if(!strcasecmp(str, lcd_power_type_table[index]))
-						break;
-				}
-				pConf->lcd_power_ctrl.power_on_config[i].type = index;
-				
-				if (pConf->lcd_power_ctrl.power_on_config[i].type < LCD_POWER_TYPE_SIGNAL) {
-					ret = of_property_read_string_index(pdev->dev.of_node, propname, 1, &str);
-					if (ret) {
-						printk("faild to get %s index 1\n", propname);
-					}
-					else {
-						if (pConf->lcd_power_ctrl.power_on_config[i].type == LCD_POWER_TYPE_CPU) {
-							val = amlogic_gpio_name_map_num(str);
-							ret = lcd_gpio_request(val);
-							if (ret) {
-							  printk("faild to alloc lcd power ctrl gpio (%s)\n", str);
-							}
-							pConf->lcd_power_ctrl.power_on_config[i].gpio = val;
-						}
-						else if (pConf->lcd_power_ctrl.power_on_config[i].type == LCD_POWER_TYPE_PMU) {
-							pConf->lcd_power_ctrl.power_on_config[i].gpio = amlogic_pmu_gpio_name_map_num(str);
-						}
-					}
-					ret = of_property_read_string_index(pdev->dev.of_node, propname, 2, &str);
-					if (ret) {
-						printk("faild to get %s\n", propname);
-					}
-					else {
-						if ((strcasecmp(str, "output_low") == 0) || (strcasecmp(str, "0") == 0)) {
-							pConf->lcd_power_ctrl.power_on_config[i].value = LCD_POWER_GPIO_OUTPUT_LOW;
-						}
-						else if ((strcasecmp(str, "output_high") == 0) || (strcasecmp(str, "1") == 0)) {
-							pConf->lcd_power_ctrl.power_on_config[i].value = LCD_POWER_GPIO_OUTPUT_HIGH;
-						}
-						else if ((strcasecmp(str, "input") == 0) || (strcasecmp(str, "2") == 0)) {
-							pConf->lcd_power_ctrl.power_on_config[i].value = LCD_POWER_GPIO_INPUT;
-						}
-					}
-				}
-			}
-		}
-		pConf->lcd_power_ctrl.power_on_step = i;
-		lcd_print("lcd_power_on_step = %d\n", pConf->lcd_power_ctrl.power_on_step);
-		
-		ret = of_property_read_u32_array(pdev->dev.of_node,"power_on_delay",&lcd_para[0],pConf->lcd_power_ctrl.power_on_step);
-		if (ret) {
-			printk("faild to get power_on_delay\n");
-		}
-		else {
-			for (i=0; i<pConf->lcd_power_ctrl.power_on_step; i++) {
-				pConf->lcd_power_ctrl.power_on_config[i].delay = (unsigned short)(lcd_para[i]);
-			}
-		}
-		//lcd power off
-		for (i=0; i < LCD_POWER_CTRL_STEP_MAX; i++) {
-			sprintf(propname, "power_off_step_%d", i+1);
-			//propname = kasprintf(GFP_KERNEL, "power_off_step_%d", i+1);
-			ret = of_property_read_string_index(pdev->dev.of_node, propname, 0, &str);
-			if (ret) {
-				lcd_print("faild to get %s index 0\n", propname);
-				break;
-			}
-			else if ((strcasecmp(str, "null") == 0) || ((strcasecmp(str, "n") == 0))) {
-				break;
-			}
-			else {
-				lcd_print("%s 0: %s\n", propname, str);
-				for(index = 0; index < LCD_POWER_TYPE_MAX; index++) {
-					if(!strcasecmp(str, lcd_power_type_table[index]))
-						break;
-				}
-				pConf->lcd_power_ctrl.power_off_config[i].type = index;
-			
-				if (pConf->lcd_power_ctrl.power_off_config[i].type < LCD_POWER_TYPE_SIGNAL) {
-					ret = of_property_read_string_index(pdev->dev.of_node, propname, 1, &str);
-					if (ret) {
-						printk("faild to get %s index 1\n", propname);
-					}
-					else {
-						if (pConf->lcd_power_ctrl.power_off_config[i].type == LCD_POWER_TYPE_CPU) {
-							val = amlogic_gpio_name_map_num(str);
-							pConf->lcd_power_ctrl.power_off_config[i].gpio = val;
-						}
-						else if (pConf->lcd_power_ctrl.power_off_config[i].type == LCD_POWER_TYPE_PMU) {
-							pConf->lcd_power_ctrl.power_off_config[i].gpio = amlogic_pmu_gpio_name_map_num(str);
-						}
-					}
-					ret = of_property_read_string_index(pdev->dev.of_node, propname, 2, &str);
-					if (ret) {
-						printk("faild to get %s index 2\n", propname);
-					}
-					else {
-						if ((strcasecmp(str, "output_low") == 0) || (strcasecmp(str, "0") == 0)) {
-							pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_OUTPUT_LOW;
-						}
-						else if ((strcasecmp(str, "output_high") == 0) || (strcasecmp(str, "1") == 0)) {
-							pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_OUTPUT_HIGH;
-						}
-						else if ((strcasecmp(str, "input") == 0) || (strcasecmp(str, "2") == 0)) {
-							pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_INPUT;
-						}
-					}
-				}
-			}
-		}
-		pConf->lcd_power_ctrl.power_off_step = i;
-		lcd_print("lcd_power_off_step = %d\n", pConf->lcd_power_ctrl.power_off_step);
-		
-		ret = of_property_read_u32_array(pdev->dev.of_node,"power_off_delay",&lcd_para[0],pConf->lcd_power_ctrl.power_off_step);
-		if (ret) {
-			printk("faild to get power_off_delay\n");
-		}
-		else {
-			for (i=0; i<pConf->lcd_power_ctrl.power_off_step; i++) {
-				pConf->lcd_power_ctrl.power_off_config[i].delay = (unsigned short)(lcd_para[i]);
-			}
-		}
-		
-		for (i=0; i<pConf->lcd_power_ctrl.power_on_step; i++) {
-			lcd_print("power on step %d: type = %s(%d)\n", i+1, lcd_power_type_table[pConf->lcd_power_ctrl.power_on_config[i].type], pConf->lcd_power_ctrl.power_on_config[i].type);
-			lcd_print("power on step %d: gpio = %d\n", i+1, pConf->lcd_power_ctrl.power_on_config[i].gpio);
-			lcd_print("power on step %d: value = %d\n", i+1, pConf->lcd_power_ctrl.power_on_config[i].value);
-			lcd_print("power on step %d: delay = %d\n", i+1, pConf->lcd_power_ctrl.power_on_config[i].delay);
-		}
-		
-		for (i=0; i<pConf->lcd_power_ctrl.power_off_step; i++) {
-			lcd_print("power off step %d: type = %s(%d)\n", i+1, lcd_power_type_table[pConf->lcd_power_ctrl.power_off_config[i].type], pConf->lcd_power_ctrl.power_off_config[i].type);
-			lcd_print("power off step %d: gpio = %d\n", i+1, pConf->lcd_power_ctrl.power_off_config[i].gpio);
-			lcd_print("power off step %d: value = %d\n", i+1, pConf->lcd_power_ctrl.power_off_config[i].value);
-			lcd_print("power off step %d: delay = %d\n", i+1, pConf->lcd_power_ctrl.power_off_config[i].delay);
-		}
-
-		pConf->lcd_misc_ctrl.pin = devm_pinctrl_get(&pdev->dev);
-		if (IS_ERR(pConf->lcd_misc_ctrl.pin))
-			printk("get lcd ttl ports pinmux error.\n");
-	}
-	return ret;
-}
-#endif
-
-#ifdef CONFIG_USE_OF
-static const struct of_device_id lcd_dt_match[] = {
-	{
-		.compatible = "amlogic,lcd",
-	},
-	{},
-};
-#else
-#define lcd_dt_match NULL
-#endif
-
-static void lcd_config_assign(Lcd_Config_t *pConf)
-{
-    pConf->lcd_power_ctrl.power_ctrl = lcd_power_ctrl;
-}
-
-static struct notifier_block lcd_reboot_nb;
-static int lcd_probe(struct platform_device *pdev)
-{
-#ifndef CONFIG_USE_OF
-	struct aml_lcd_platform *pdata;
-#endif
-	int ret = 0;
-	
-	pDev = (lcd_dev_t *)kmalloc(sizeof(lcd_dev_t), GFP_KERNEL);
-	if (!pDev) {
-		printk("[lcd probe]: Not enough memory.\n");
-		return -ENOMEM;
-	}
-	
-#ifdef CONFIG_USE_OF
-	//pdata = lcd_get_driver_data(pdev);
-	pDev->pConf = get_lcd_config();
-	_get_lcd_model_timing(pDev->pConf, pdev);
-	_get_lcd_default_config(pDev->pConf, pdev);
-	_get_lcd_power_config(pDev->pConf, pdev);
-#else
-	pdata = pdev->dev.platform_data;
-	pDev->pConf = (Lcd_Config_t *)(pdata->lcd_conf);
-#endif
-	
-	creat_lcd_class();
-	lcd_config_assign(pDev->pConf);
-	lcd_config_probe(pDev->pConf);
-	save_lcd_config(pDev->pConf);
-	
-	pDev->pConf->lcd_misc_ctrl.print_version();
-	lcd_config_init(pDev->pConf);
-	_init_vout();
-	
-	lcd_reboot_nb.notifier_call = lcd_reboot_notifier;
-	ret = register_reboot_notifier(&lcd_reboot_nb);
-	if (ret) {
-		printk("notifier register lcd_reboot_notifier fail!\n");
-	}
-	
-	ret = creat_lcd_attr();
-#ifdef CONFIG_AML_GAMMA_DEBUG
-	save_original_gamma(pDev->pConf);
-	ret = creat_lcd_gamma_attr();
-#endif
-	
-	printk("LCD probe ok\n");
-	return 0;
-}
-
-static int lcd_remove(struct platform_device *pdev)
-{
-	unregister_reboot_notifier(&lcd_reboot_nb);
-	
-	lcd_config_remove(pDev->pConf);
-	remove_lcd_attr();
-	remove_lcd_class();
-#ifdef CONFIG_AML_GAMMA_DEBUG
-	remove_lcd_gamma_attr();
-#endif
-	
-	if (pDev->pConf->lcd_basic.model_name)
-		kfree(pDev->pConf->lcd_basic.model_name);
-	if (pDev)
-		kfree(pDev);
-
-    return 0;
-}
-
-//device tree
-static struct platform_driver lcd_driver = {
-	.probe = lcd_probe,
-	.remove = lcd_remove,
-	.driver = {
-		.name = "mesonlcd",
-		.owner = THIS_MODULE,
-#ifdef CONFIG_USE_OF
-		.of_match_table = lcd_dt_match,
-#endif
-	},
-};
-
-static int __init lcd_init(void)
-{
-    lcd_print("LCD driver init\n");
-    if (platform_driver_register(&lcd_driver)) {
-        printk("failed to register lcd driver module\n");
-        return -ENODEV;
-    }
-
-    return 0;
-}
-
-static void __exit lcd_exit(void)
-{
-    platform_driver_unregister(&lcd_driver);
-}
-
-subsys_initcall(lcd_init);
-module_exit(lcd_exit);
-
-MODULE_DESCRIPTION("Meson LCD Panel Driver");
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Amlogic, Inc.");
+/*
+ * AMLOGIC lcd controller driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:  Tim Yao <timyao@amlogic.com>
+ *
+ * Modify:  Evoke Zhang <evoke.zhang@amlogic.com>
+ * compatible dts
+ *
+ */
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/amlogic/logo/logo.h>
+#include <plat/regops.h>
+#include <mach/am_regs.h>
+#include <mach/lcd_reg.h>
+#include <mach/lcdoutc.h>
+#include <linux/amlogic/vout/lcdoutc.h>
+#include <linux/amlogic/vout/aml_lcd_common.h>
+#include <linux/amlogic/vout/lcd_aml.h>
+#include <mach/clock.h>
+#include <asm/fiq.h>
+#include <linux/delay.h>
+#include <linux/notifier.h>
+#include <linux/reboot.h>
+#include <linux/of.h>
+#include <linux/amlogic/aml_lcd_bl.h>
+#include <linux/amlogic/vout/aml_lcd_extern.h>
+#ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
+#include <linux/amlogic/aml_pmu_common.h>
+#endif
+
+#define PANEL_NAME		"panel"
+
+typedef struct {
+	Lcd_Config_t *pConf;
+	vinfo_t lcd_info;
+} lcd_dev_t;
+
+static const char* lcd_power_type_table[]={
+	"cpu",
+	"pmu",
+	"signal",
+	"init",
+	"null",
+};
+
+static const char* lcd_power_pmu_gpio_table[]={
+	"GPIO0",
+	"GPIO1",
+	"GPIO2",
+	"GPIO3",
+	"GPIO4",
+	"null",
+};
+
+#ifdef LCD_DEBUG_INFO
+unsigned int lcd_print_flag = 1;
+#else
+unsigned int lcd_print_flag = 0;
+#endif
+
+static lcd_dev_t *pDev = NULL;
+#ifdef CONFIG_AML_GAMMA_DEBUG
+static struct class *gamma_debug_class = NULL;
+#endif
+static Bool_t data_status = ON;
+
+void lcd_print(const char *fmt, ...)
+{
+	va_list args;
+
+	if (lcd_print_flag == 0)
+		return;
+	va_start(args, fmt);
+	vprintk(fmt, args);
+	va_end(args);
+}
+
+static inline void lcd_mdelay(int n)
+{
+	mdelay(n);
+}
+
+#ifdef CONFIG_USE_OF
+static void lcd_setup_gamma_table(Lcd_Config_t *pConf, unsigned int rgb_flag)
+{
+	int i;
+
+	const unsigned short gamma_adjust[256] = {
+		0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,
+		32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,
+		64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,
+		96,97,98,99,100,101,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,
+		128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,
+		160,161,162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191,
+		192,193,194,195,196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,221,222,223,
+		224,225,226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,255
+	};
+
+	if (rgb_flag == 0) {	//r
+		for (i=0; i<256; i++) {
+			pConf->lcd_effect.GammaTableR[i] = gamma_adjust[i] << 2;
+		}
+	}
+	else if (rgb_flag == 1) {	//g
+		for (i=0; i<256; i++) {
+			pConf->lcd_effect.GammaTableG[i] = gamma_adjust[i] << 2;
+		}
+	}
+	else if (rgb_flag == 2) {	//b
+		for (i=0; i<256; i++) {
+			pConf->lcd_effect.GammaTableB[i] = gamma_adjust[i] << 2;
+		}
+	}
+	else if (rgb_flag == 3) {	//rgb
+		for (i=0; i<256; i++) {
+			pConf->lcd_effect.GammaTableR[i] = gamma_adjust[i] << 2;
+			pConf->lcd_effect.GammaTableG[i] = gamma_adjust[i] << 2;
+			pConf->lcd_effect.GammaTableB[i] = gamma_adjust[i] << 2;
+		}
+	}
+}
+
+static void backlight_power_ctrl(Bool_t status)
+{
+	if( status == ON ){
+		if (data_status == OFF)
+			return;
+		bl_power_on(LCD_BL_FLAG);
+	}
+	else{
+		bl_power_off(LCD_BL_FLAG);
+	}
+	lcd_print("%s(%s): data_status=%s\n", __FUNCTION__, (status ? "ON" : "OFF"), (data_status ? "ON" : "OFF"));
+}
+
+static int lcd_power_ctrl(Bool_t status)
+{
+	int i;
+	int ret = 0;
+#ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
+	struct aml_pmu_driver *pmu_driver;
+#endif
+	struct aml_lcd_extern_driver_t *lcd_extern_driver;
+
+	lcd_print("%s(): %s\n", __FUNCTION__, (status ? "ON" : "OFF"));
+	if (status) {
+		for (i=0; i<pDev->pConf->lcd_power_ctrl.power_on_step; i++) {
+			lcd_print("%s %s step %d\n", __FUNCTION__, (status ? "ON" : "OFF"), i+1);
+			switch (pDev->pConf->lcd_power_ctrl.power_on_config[i].type) {
+				case LCD_POWER_TYPE_CPU:
+					if (pDev->pConf->lcd_power_ctrl.power_on_config[i].value == LCD_POWER_GPIO_OUTPUT_LOW) {
+						lcd_gpio_direction_output(pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio, 0);
+					}
+					else if (pDev->pConf->lcd_power_ctrl.power_on_config[i].value == LCD_POWER_GPIO_OUTPUT_HIGH) {
+						lcd_gpio_direction_output(pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio, 1);
+					}
+					else if (pDev->pConf->lcd_power_ctrl.power_on_config[i].value == LCD_POWER_GPIO_INPUT) {
+						lcd_gpio_direction_input(pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio);
+					}
+					break;
+				case LCD_POWER_TYPE_PMU:
+#ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
+					pmu_driver = aml_pmu_get_driver();
+					if (pmu_driver == NULL) {
+						printk("no pmu driver\n");
+					}
+					else if (pmu_driver->pmu_set_gpio) {
+						if (pDev->pConf->lcd_power_ctrl.power_on_config[i].value == LCD_POWER_GPIO_OUTPUT_LOW) {
+							pmu_driver->pmu_set_gpio(pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio, 0);
+						}
+						else {
+							pmu_driver->pmu_set_gpio(pDev->pConf->lcd_power_ctrl.power_on_config[i].gpio, 1);
+						}
+					}
+#endif
+					break;
+				case LCD_POWER_TYPE_SIGNAL:
+					if (pDev->pConf->lcd_power_ctrl.ports_ctrl == NULL)
+						lcd_print("no lcd_ports_ctrl\n");
+					else
+						pDev->pConf->lcd_power_ctrl.ports_ctrl(ON);
+					break;
+				case LCD_POWER_TYPE_INITIAL:
+					lcd_extern_driver = aml_lcd_extern_get_driver();
+					if (lcd_extern_driver == NULL) {
+						printk("no lcd_extern driver\n");
+					}
+					else {
+						if (lcd_extern_driver->power_on) {
+							lcd_extern_driver->power_on();
+							printk("%s power on init\n", lcd_extern_driver->name);
+						}
+					}
+					break;
+				default:
+					printk("lcd power ctrl ON step %d is null.\n", i+1);
+					break;
+			}
+			if (pDev->pConf->lcd_power_ctrl.power_on_config[i].delay > 0)
+				lcd_mdelay(pDev->pConf->lcd_power_ctrl.power_on_config[i].delay);
+		}
+		if (pDev->pConf->lcd_power_ctrl.power_ctrl_video)
+			ret = pDev->pConf->lcd_power_ctrl.power_ctrl_video(ON);
+		data_status = status;
+	}
+	else {
+		data_status = status;
+		lcd_mdelay(30);
+		if (pDev->pConf->lcd_power_ctrl.power_ctrl_video)
+			ret = pDev->pConf->lcd_power_ctrl.power_ctrl_video(OFF);
+		for (i=0; i<pDev->pConf->lcd_power_ctrl.power_off_step; i++) {
+			lcd_print("%s %s step %d\n", __FUNCTION__, (status ? "ON" : "OFF"), i+1);
+			switch (pDev->pConf->lcd_power_ctrl.power_off_config[i].type) {
+				case LCD_POWER_TYPE_CPU:
+					if (pDev->pConf->lcd_power_ctrl.power_off_config[i].value == LCD_POWER_GPIO_OUTPUT_LOW) {
+						lcd_gpio_direction_output(pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio, 0);
+					}
+					else if (pDev->pConf->lcd_power_ctrl.power_off_config[i].value == LCD_POWER_GPIO_OUTPUT_HIGH) {
+						lcd_gpio_direction_output(pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio, 1);
+					}
+					else if (pDev->pConf->lcd_power_ctrl.power_off_config[i].value == LCD_POWER_GPIO_INPUT) {
+						lcd_gpio_direction_input(pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio);
+					}
+					break;
+				case LCD_POWER_TYPE_PMU:
+#ifdef CONFIG_AMLOGIC_BOARD_HAS_PMU
+					pmu_driver = aml_pmu_get_driver();
+					if (pmu_driver == NULL) {
+						printk("no pmu driver\n");
+					}
+					else if (pmu_driver->pmu_set_gpio) {
+						if (pDev->pConf->lcd_power_ctrl.power_off_config[i].value == LCD_POWER_GPIO_OUTPUT_LOW) {
+							pmu_driver->pmu_set_gpio(pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio, 0);
+						}
+						else {
+							pmu_driver->pmu_set_gpio(pDev->pConf->lcd_power_ctrl.power_off_config[i].gpio, 1);
+						}
+					}
+#endif
+					break;
+				case LCD_POWER_TYPE_SIGNAL:
+					if (pDev->pConf->lcd_power_ctrl.ports_ctrl == NULL)
+						lcd_print("no lcd_ports_ctrl\n");
+					else
+						pDev->pConf->lcd_power_ctrl.ports_ctrl(OFF);
+					break;
+				case LCD_POWER_TYPE_INITIAL:
+					lcd_extern_driver = aml_lcd_extern_get_driver();
+					if (lcd_extern_driver == NULL) {
+						printk("no lcd_extern driver\n");
+					}
+					else {
+						if (lcd_extern_driver->power_off) {
+							lcd_extern_driver->power_off();
+							printk("%s power off init\n", lcd_extern_driver->name);
+						}
+					}
+					break;
+				default:
+					printk("lcd power ctrl OFF step %d is null.\n", i+1);
+					break;
+			}
+			if (pDev->pConf->lcd_power_ctrl.power_off_config[i].delay > 0)
+				lcd_mdelay(pDev->pConf->lcd_power_ctrl.power_off_config[i].delay);
+		}
+	}
+
+	printk("%s(): %s finished.\n", __FUNCTION__, (status ? "ON" : "OFF"));
+	return ret;
+}
+#endif
+
+void _enable_backlight(void)
+{
+	backlight_power_ctrl(ON);
+}
+void _disable_backlight(void)
+{
+	backlight_power_ctrl(OFF);
+}
+
+static void _lcd_module_enable(void)
+{
+    pDev->pConf->lcd_misc_ctrl.module_enable();
+}
+
+static void _lcd_module_disable(void)
+{
+    pDev->pConf->lcd_misc_ctrl.module_disable();
+}
+
+static const vinfo_t *lcd_get_current_info(void)
+{
+    if (pDev == NULL) {
+        printk("[error] no lcd device exist!\n");
+        return NULL;
+    }
+    else
+        return &pDev->lcd_info;
+}
+
+DEFINE_MUTEX(lcd_vout_mutex);
+static int lcd_set_current_vmode(vmode_t mode)
+{
+    mutex_lock(&lcd_vout_mutex);
+    if (VMODE_LCD != (mode & VMODE_MODE_BIT_MASK)) {
+        mutex_unlock(&lcd_vout_mutex);
+        return -EINVAL;
+    }
+
+    pDev->pConf->lcd_misc_ctrl.vpp_sel = 0;
+    WRITE_LCD_REG(VPP_POSTBLEND_H_SIZE, pDev->lcd_info.width);
+
+    if( !(mode&VMODE_LOGO_BIT_MASK) ){
+        _disable_backlight();
+        _lcd_module_enable();
+        _enable_backlight();
+    }
+    if (VMODE_INIT_NULL == pDev->lcd_info.mode)
+        pDev->lcd_info.mode = VMODE_LCD;
+
+    mutex_unlock(&lcd_vout_mutex);
+    return 0;
+}
+
+#ifdef CONFIG_AM_TV_OUTPUT2
+static int lcd_set_current_vmode2(vmode_t mode)
+{
+    mutex_lock(&lcd_vout_mutex);
+    if (mode != VMODE_LCD) {
+        mutex_unlock(&lcd_vout_mutex);
+        return -EINVAL;
+    }
+    _disable_backlight();
+    pDev->pConf->lcd_misc_ctrl.vpp_sel = 1;
+
+    WRITE_LCD_REG(VPP2_POSTBLEND_H_SIZE, pDev->lcd_info.width);
+
+    _lcd_module_enable();
+    if (VMODE_INIT_NULL == pDev->lcd_info.mode)
+        pDev->lcd_info.mode = VMODE_LCD;
+    _enable_backlight();
+    mutex_unlock(&lcd_vout_mutex);
+    return 0;
+}
+#endif
+
+static vmode_t lcd_validate_vmode(char *mode)
+{
+    if (mode == NULL)
+        return VMODE_MAX;
+
+    if ((strncmp(mode, PANEL_NAME, strlen(PANEL_NAME))) == 0)
+        return VMODE_LCD;
+
+    return VMODE_MAX;
+}
+static int lcd_vmode_is_supported(vmode_t mode)
+{
+    mode&=VMODE_MODE_BIT_MASK;
+    if(mode == VMODE_LCD )
+    return true;
+    return false;
+}
+
+static int lcd_vout_disable(vmode_t cur_vmod)
+{
+    mutex_lock(&lcd_vout_mutex);
+    _disable_backlight();
+    _lcd_module_disable();
+    mutex_unlock(&lcd_vout_mutex);
+    return 0;
+}
+
+#ifdef  CONFIG_PM
+static int lcd_suspend(int pm_event)
+{
+    /* in freeze process do not turn off the display devices */
+    if (pm_event == PM_EVENT_FREEZE)
+        return 0;
+    mutex_lock(&lcd_vout_mutex);
+    BUG_ON(pDev==NULL);
+    printk("lcd_suspend\n");
+    _disable_backlight();
+    _lcd_module_disable();
+    mutex_unlock(&lcd_vout_mutex);
+    return 0;
+}
+static int lcd_resume(int pm_event)
+{
+    /* in thaw/restore process do not open the display */
+    if (pm_event == PM_EVENT_THAW
+            || pm_event == PM_EVENT_RESTORE)
+        return 0;
+    mutex_lock(&lcd_vout_mutex);
+    printk("lcd_resume\n");
+    _lcd_module_enable();
+    _enable_backlight();
+    mutex_unlock(&lcd_vout_mutex);
+    return 0;
+}
+#endif
+static vout_server_t lcd_vout_server={
+    .name = "lcd_vout_server",
+    .op = {
+        .get_vinfo = lcd_get_current_info,
+        .set_vmode = lcd_set_current_vmode,
+        .validate_vmode = lcd_validate_vmode,
+        .vmode_is_supported=lcd_vmode_is_supported,
+        .disable=lcd_vout_disable,
+#ifdef  CONFIG_PM
+        .vout_suspend=lcd_suspend,
+        .vout_resume=lcd_resume,
+#endif
+    },
+};
+
+#ifdef CONFIG_AM_TV_OUTPUT2
+static vout_server_t lcd_vout2_server={
+    .name = "lcd_vout2_server",
+    .op = {
+        .get_vinfo = lcd_get_current_info,
+        .set_vmode = lcd_set_current_vmode2,
+        .validate_vmode = lcd_validate_vmode,
+        .vmode_is_supported=lcd_vmode_is_supported,
+        .disable=lcd_vout_disable,
+#ifdef  CONFIG_PM
+        .vout_suspend=lcd_suspend,
+        .vout_resume=lcd_resume,
+#endif
+    },
+};
+#endif
+
+static void _init_vout(void)
+{
+    pDev->lcd_info.name = PANEL_NAME;
+    pDev->lcd_info.mode = VMODE_LCD;
+    pDev->lcd_info.width = pDev->pConf->lcd_basic.h_active;
+    pDev->lcd_info.height = pDev->pConf->lcd_basic.v_active;
+    pDev->lcd_info.field_height = pDev->pConf->lcd_basic.v_active;
+    pDev->lcd_info.aspect_ratio_num = pDev->pConf->lcd_basic.screen_ratio_width;
+    pDev->lcd_info.aspect_ratio_den = pDev->pConf->lcd_basic.screen_ratio_height;
+    pDev->lcd_info.screen_real_width= pDev->pConf->lcd_basic.h_active_area;
+    pDev->lcd_info.screen_real_height= pDev->pConf->lcd_basic.v_active_area;
+    pDev->lcd_info.sync_duration_num = pDev->pConf->lcd_timing.sync_duration_num;
+    pDev->lcd_info.sync_duration_den = pDev->pConf->lcd_timing.sync_duration_den;
+    pDev->lcd_info.video_clk = pDev->pConf->lcd_timing.lcd_clk;
+
+    //add lcd actual active area size
+    printk("lcd actual active area size: %d %d (mm).\n", pDev->pConf->lcd_basic.h_active_area, pDev->pConf->lcd_basic.v_active_area);
+    vout_register_server(&lcd_vout_server);
+#ifdef CONFIG_AM_TV_OUTPUT2
+    vout2_register_server(&lcd_vout2_server);
+#endif
+}
+
+//*********************************************************
+//gamma debug
+//*********************************************************
+#ifdef CONFIG_AML_GAMMA_DEBUG
+static unsigned short gamma_adjust_r[256];
+static unsigned short gamma_adjust_g[256];
+static unsigned short gamma_adjust_b[256];
+static unsigned short gamma_r_coeff, gamma_g_coeff, gamma_b_coeff;
+static unsigned gamma_ctrl;
+
+static void save_original_gamma(Lcd_Config_t *pConf)
+{
+    int i;
+
+    for (i=0; i<256; i++) {
+        gamma_adjust_r[i] = pConf->lcd_effect.GammaTableR[i];
+        gamma_adjust_g[i] = pConf->lcd_effect.GammaTableG[i];
+        gamma_adjust_b[i] = pConf->lcd_effect.GammaTableB[i];
+    }
+    gamma_ctrl = pConf->lcd_effect.gamma_ctrl;
+    gamma_r_coeff = pConf->lcd_effect.gamma_r_coeff;
+    gamma_g_coeff = pConf->lcd_effect.gamma_g_coeff;
+    gamma_b_coeff = pConf->lcd_effect.gamma_b_coeff;
+}
+
+static void read_original_gamma_table(void)
+{
+    unsigned i;
+
+    printk("original gamma: enable=%d, reverse=%d, r_coeff=%u%%, g_coeff=%u%%, b_coeff=%u%%\n",
+          ((gamma_ctrl >> GAMMA_CTRL_EN) & 1), ((gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1), gamma_r_coeff, gamma_g_coeff, gamma_b_coeff);
+    printk("read original gamma table R:\n");
+    for (i=0; i<256; i++) {
+        printk("%u,", gamma_adjust_r[i]);
+    }
+    printk("\n\nread original gamma table G:\n");
+    for (i=0; i<256; i++) {
+        printk("%u,", gamma_adjust_g[i]);
+    }
+    printk("\n\nread original gamma table B:\n");
+    for (i=0; i<256; i++) {
+        printk("%u,", gamma_adjust_b[i]);
+    }
+    printk("\n");
+}
+
+static void read_current_gamma_table(Lcd_Config_t *pConf)
+{
+    unsigned i;
+
+    printk("current gamma: enable=%d, reverse=%d, r_coeff=%u%%, g_coeff=%u%%, b_coeff=%u%%\n",
+          ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1), ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1),
+          pConf->lcd_effect.gamma_r_coeff, pConf->lcd_effect.gamma_g_coeff, pConf->lcd_effect.gamma_b_coeff);
+    printk("read current gamma table R:\n");
+    for (i=0; i<256; i++) {
+        printk("%u ", pConf->lcd_effect.GammaTableR[i]);
+    }
+    printk("\n\nread current gamma table G:\n");
+    for (i=0; i<256; i++) {
+        printk("%u ", pConf->lcd_effect.GammaTableG[i]);
+    }
+    printk("\n\nread current gamma table B:\n");
+    for (i=0; i<256; i++) {
+        printk("%u ", pConf->lcd_effect.GammaTableB[i]);
+    }
+    printk("\n");
+}
+
+static int write_gamma_table(Lcd_Config_t *pConf, unsigned int en)
+{
+    int ret = 0;
+
+    if (pConf->lcd_effect.set_gamma_table == NULL) {
+        printk("set gamma table function is null\n");
+        ret = -1;
+    }
+    else {
+        pConf->lcd_effect.set_gamma_table(en);
+    }
+    return ret;
+}
+
+static void set_gamma_coeff(Lcd_Config_t *pConf, unsigned r_coeff, unsigned g_coeff, unsigned b_coeff)
+{
+    pConf->lcd_effect.gamma_r_coeff = (unsigned short)(r_coeff);
+    pConf->lcd_effect.gamma_g_coeff = (unsigned short)(g_coeff);
+    pConf->lcd_effect.gamma_b_coeff = (unsigned short)(b_coeff);
+    if (write_gamma_table(pConf, 1) == 0)
+        printk("write gamma table with scale factor R:%u%%, G:%u%%, B:%u%%.\n", r_coeff, g_coeff, b_coeff);
+}
+
+static void reset_gamma_table(Lcd_Config_t *pConf)
+{
+    int i;
+
+    for (i=0; i<256; i++) {
+        pConf->lcd_effect.GammaTableR[i] = gamma_adjust_r[i];
+        pConf->lcd_effect.GammaTableG[i] = gamma_adjust_g[i];
+        pConf->lcd_effect.GammaTableB[i] = gamma_adjust_b[i];
+    }
+    pConf->lcd_effect.gamma_ctrl = gamma_ctrl;
+    pConf->lcd_effect.gamma_r_coeff = gamma_r_coeff;
+    pConf->lcd_effect.gamma_g_coeff = gamma_g_coeff;
+    pConf->lcd_effect.gamma_b_coeff = gamma_b_coeff;
+    if (write_gamma_table(pConf, ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1)) == 0)
+        printk("write gamma table to original.\n");
+}
+
+static const char * usage_str =
+{"Usage:\n"
+"    echo coeff <R_coeff> <G_coeff> <B_coeff> > write ; set R,G,B gamma scale factor\n"
+"    echo ctrl <enable> <reverse> > write; control gamma table enable and reverse\n"
+"data format:\n"
+"    <R/G/B_coeff>  : a number in Dec(0~100), means a percent value\n"
+"    <enable>       : 0=disable, 1=enable\n"
+"    <reverse>      : 0=normal, 1=reverse\n"
+"\n"
+"    echo [r|g|b] <step> <value> <value> <value> <value> <value> <value> <value> <value> > write ; input R/G/B gamma table\n"
+"    echo w [0 | 8 | 10] > write ; apply the original/8bit/10bit gamma table\n"
+"data format:\n"
+"    <step>  : 0xX, 4bit in Hex, there are 8 steps(0~7, 8bit gamma) or 16 steps(0~f, 10bit gamma) for a single cycle\n"
+"    <value> : 0xXXXXXXXX, 32bit in Hex, 2 or 4 gamma table values (8 or 10bit gamma) combia in one <value>\n"
+"\n"
+"    echo f[r | g | b | w] <level_value> > write ; write R/G/B/white gamma level with fixed level_value\n"
+"    echo reset > write ; reset the gamma table to original\n"
+"data format:\n"
+"    <level_value>  : a number in Dec(0~255)\n"
+"\n"
+"    echo test <num> > write ; gamma curve test, you should control gamma table and video adjust enable manually by other command\n"
+"    echo auto [enable] > write ; gamma curve auto test, auto disable video adjust and run test pattern\n"
+"data format:\n"
+"    <num>   : a number in Dec(1~18), num=0 will disable gamma test pattern\n"
+"    <enable>: 0=disable gamma table(default), 1=enable gamma table."
+"\n"
+"    echo [0 | 1] > read ; readback original/current gamma table\n"
+};
+
+static ssize_t gamma_help(struct class *class, struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n",usage_str);
+}
+
+static ssize_t aml_lcd_gamma_read(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+    if (buf[0] == '0')
+        read_original_gamma_table();
+    else
+        read_current_gamma_table(pDev->pConf);
+
+    return count;
+}
+
+static unsigned gamma_adjust_r_temp[128];
+static unsigned gamma_adjust_g_temp[128];
+static unsigned gamma_adjust_b_temp[128];
+static ssize_t aml_lcd_gamma_debug(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+    unsigned int ret;
+    unsigned int i, j;
+    unsigned t[8];
+
+    switch (buf[0]) {
+    case 'c':
+        if (buf[1] == 'o') {
+            t[0] = 100;
+            t[1] = 100;
+            t[2] = 100;
+            ret = sscanf(buf, "coeff %u %u %u", &t[0], &t[1], &t[2]);
+            set_gamma_coeff(pDev->pConf, t[0], t[1], t[2]);
+        }
+        else if (buf[1] == 't') {
+            t[0] = 1;
+            t[1] = 0;
+            ret = sscanf(buf, "ctrl %u %u", &t[0], &t[1]);
+            t[0] = (t[0] > 0) ? 1 : 0;
+            t[1] = (t[1] > 0) ? 1 : 0;
+            pDev->pConf->lcd_effect.gamma_ctrl = ((t[0] << GAMMA_CTRL_EN) | (t[1] << GAMMA_CTRL_REVERSE));
+            printk("set gamma table enable=%d, reverse=%d.\n", t[0], t[1]);
+            if (write_gamma_table(pDev->pConf, t[0]) == 0)
+                printk("write gamma table finished.\n");
+        }
+        break;
+    case 'r':
+        if (buf[1] == 'e') {
+			reset_gamma_table(pDev->pConf);
+		}
+		else {
+			ret = sscanf(buf, "r %x %x %x %x %x %x %x %x %x", &i, &t[0], &t[1], &t[2], &t[3], &t[4], &t[5], &t[6], &t[7]);
+			if (i<16) {
+				i =  i * 8;
+				for (j=0; j<8; j++) {
+					gamma_adjust_r_temp[i+j] = t[j];
+				}
+				printk("write R table: step %u.\n", i/8);
+			}
+		}
+        break;
+    case 'g':
+        ret = sscanf(buf, "g %x %x %x %x %x %x %x %x %x", &i, &t[0], &t[1], &t[2], &t[3], &t[4], &t[5], &t[6], &t[7]);
+        if (i<16) {
+            i =  i * 8;
+            for (j=0; j<8; j++) {
+                gamma_adjust_g_temp[i+j] = t[j];
+            }
+            printk("write G table: step %u.\n", i/8);
+        }
+        break;
+    case 'b':
+        ret = sscanf(buf, "b %x %x %x %x %x %x %x %x %x", &i, &t[0], &t[1], &t[2], &t[3], &t[4], &t[5], &t[6], &t[7]);
+        if (i<16) {
+            i =  i * 8;
+            for (j=0; j<8; j++) {
+                gamma_adjust_b_temp[i+j] = t[j];
+            }
+            printk("write B table: step %u.\n", i/8);
+        }
+        break;
+    case 'w':
+        i = 0;
+        ret = sscanf(buf, "w %u", &i);
+        if (i == 8) {
+            for (i=0; i<64; i++) {
+                for (j=0; j<4; j++){
+                    pDev->pConf->lcd_effect.GammaTableR[i*4+j] = (unsigned short)(((gamma_adjust_r_temp[i] >> (24-j*8)) & 0xff) << 2);
+                    pDev->pConf->lcd_effect.GammaTableG[i*4+j] = (unsigned short)(((gamma_adjust_g_temp[i] >> (24-j*8)) & 0xff) << 2);
+                    pDev->pConf->lcd_effect.GammaTableB[i*4+j] = (unsigned short)(((gamma_adjust_b_temp[i] >> (24-j*8)) & 0xff) << 2);
+                }
+            }
+            if (write_gamma_table(pDev->pConf, 1) == 0)
+                printk("write gamma table 8bit finished.\n");
+        }
+        else if (i == 10) {
+            for (i=0; i<128; i++) {
+                for (j=0; j<2; j++){
+                    pDev->pConf->lcd_effect.GammaTableR[i*2+j] = (unsigned short)((gamma_adjust_r_temp[i] >> (16-j*16)) & 0xffff);
+                    pDev->pConf->lcd_effect.GammaTableG[i*2+j] = (unsigned short)((gamma_adjust_g_temp[i] >> (16-j*16)) & 0xffff);
+                    pDev->pConf->lcd_effect.GammaTableB[i*2+j] = (unsigned short)((gamma_adjust_b_temp[i] >> (16-j*16)) & 0xffff);
+                }
+            }
+            if (write_gamma_table(pDev->pConf, 1) == 0)
+                printk("write gamma table 10bit finished.\n");
+        }
+        else {
+            reset_gamma_table(pDev->pConf);
+        }
+        break;
+    case 'f':
+        i=255;
+        if (buf[1] == 'r') {
+            ret = sscanf(buf, "fr %u", &i);
+            i &= 0xff;
+            for (j=0; j<256; j++) {
+                pDev->pConf->lcd_effect.GammaTableR[j] = i<<2;
+            }
+            set_gamma_coeff(pDev->pConf, 100, 0, 0);
+            printk("R fixed value: %u.\n", i);
+        }
+        else if (buf[1] == 'g') {
+            ret = sscanf(buf, "fg %u", &i);
+            i &= 0xff;
+            for (j=0; j<256; j++) {
+                pDev->pConf->lcd_effect.GammaTableG[j] = i<<2;
+            }
+            set_gamma_coeff(pDev->pConf, 0, 100, 0);
+            printk("G fixed value: %u.\n", i);
+        }
+        else if (buf[1] == 'b') {
+            ret = sscanf(buf, "fb %u", &i);
+            i &= 0xff;
+            for (j=0; j<256; j++) {
+                pDev->pConf->lcd_effect.GammaTableB[j] = i<<2;
+            }
+            set_gamma_coeff(pDev->pConf, 0, 0, 100);
+            printk("B fixed value: %u.\n", i);
+        }
+        else {
+            ret = sscanf(buf, "fw %u", &i);
+            i &= 0xff;
+            for (j=0; j<256; j++) {
+                pDev->pConf->lcd_effect.GammaTableR[j] = i<<2;
+                pDev->pConf->lcd_effect.GammaTableG[j] = i<<2;
+                pDev->pConf->lcd_effect.GammaTableB[j] = i<<2;
+            }
+            set_gamma_coeff(pDev->pConf, 100, 100, 100);
+            printk("RGB fixed value: %u.\n", i);
+        }
+        break;
+    case 't':
+        ret = sscanf(buf, "test %u", &i);
+        if (pDev->pConf->lcd_effect.gamma_test)
+            pDev->pConf->lcd_effect.gamma_test(i);
+        else
+            printk("gamma test function is null\n");
+        break;
+    case 'a':
+        i = 0;
+        ret = sscanf(buf, "auto %u", &i);
+        i = (i > 0) ? 1 : 0;
+        if (write_gamma_table(pDev->pConf, i) == 0)
+            printk("%s gamma table.\n", i ? "enable" : "disable");
+
+        WRITE_LCD_REG(VPP_VADJ_CTRL, 0);
+        printk("disable video adjust.\n");
+
+        if (pDev->pConf->lcd_effect.gamma_test) {
+            for (i=1; i<=18; i++) {
+                pDev->pConf->lcd_effect.gamma_test(i);
+                for (j=0; j<10; j++) {
+                    printk("%d\n", (10-j));
+                    msleep(2000);
+                }
+            }
+            pDev->pConf->lcd_effect.gamma_test(0);
+        }
+        else
+            printk("gamma test function is null\n");
+        break;
+    default:
+        printk("wrong format of gamma table writing.\n");
+    }
+
+    if (ret != 1 || ret !=2)
+        return -EINVAL;
+
+    return count;
+    //return 0;
+}
+
+static struct class_attribute aml_lcd_gamma_class_attrs[] = {
+    __ATTR(write,  S_IRUGO | S_IWUSR, gamma_help, aml_lcd_gamma_debug),
+    __ATTR(read,  S_IRUGO | S_IWUSR, gamma_help, aml_lcd_gamma_read),
+    __ATTR(help,  S_IRUGO | S_IWUSR, gamma_help, NULL),
+};
+
+static int creat_lcd_gamma_attr(void)
+{
+    int i;
+
+    gamma_debug_class = class_create(THIS_MODULE, "gamma");
+    if(IS_ERR(gamma_debug_class)) {
+        printk("create gamma debug class fail\n");
+        return -1;
+    }
+
+    for(i=0;i<ARRAY_SIZE(aml_lcd_gamma_class_attrs);i++) {
+        if (class_create_file(gamma_debug_class, &aml_lcd_gamma_class_attrs[i])) {
+            printk("create gamma debug attribute %s fail\n", aml_lcd_gamma_class_attrs[i].attr.name);
+        }
+    }
+
+    return 0;
+}
+
+static int remove_lcd_gamma_attr(void)
+{
+    int i;
+
+    if (gamma_debug_class == NULL)
+        return -1;
+
+    for(i=0;i<ARRAY_SIZE(aml_lcd_gamma_class_attrs);i++) {
+        class_remove_file(gamma_debug_class, &aml_lcd_gamma_class_attrs[i]);
+    }
+    class_destroy(gamma_debug_class);
+    gamma_debug_class = NULL;
+
+    return 0;
+}
+#endif
+//*********************************************************
+
+//*********************************************************
+//LCD debug
+//*********************************************************
+static Lcd_Basic_t temp_lcd_basic;
+static Lcd_Timing_t temp_lcd_timing;
+static unsigned short temp_dith_user, temp_dith_ctrl;
+static unsigned int temp_vadj_brightness, temp_vadj_contrast, temp_vadj_saturation;
+static int temp_ttl_rb_swap, temp_ttl_bit_swap;
+static int temp_lvds_repack, temp_pn_swap, temp_lvds_vswing;
+static unsigned char temp_dsi_lane_num;
+static unsigned temp_dsi_bit_rate_min, temp_dsi_bit_rate_max, temp_factor_denominator, temp_factor_numerator;
+static unsigned char temp_edp_link_rate, temp_edp_lane_count, temp_edp_vswing, temp_edp_preemphasis, temp_edp_edid_timing_used;
+static unsigned int temp_edp_sync_clock_mode;
+
+static const char * lcd_common_usage_str =
+{"Usage:\n"
+"    echo 0/1 > status ; 0=disable lcd; 1=enable lcd\n"
+"    cat status ; read current lcd status\n"
+"\n"
+"    echo 0/1 > print ; 0=disable debug print; 1=enable debug print\n"
+"    cat print ; read current debug print flag\n"
+"\n"
+"    echo <cmd> ... > debug ; lcd common debug, use 'cat debug' for help\n"
+"    cat debug ; print help information for debug command\n"
+#ifdef CONFIG_LCD_IF_MIPI_VALID
+"\n"
+"    echo <cmd> ... > dsi ; mipi-dsi debug, use 'cat dsi' for help\n"
+"    cat dsi ; print help information for dsi command\n"
+#endif
+#ifdef CONFIG_LCD_IF_EDP_VALID
+"\n"
+"    echo <cmd> ... > print ; edp debug, use 'cat edp' for help\n"
+"    cat print ; print help information for edp command\n"
+#endif
+};
+
+static const char * lcd_usage_str =
+{"Usage:\n"
+"    echo basic <h_active> <v_active> <h_period> <v_period> > debug ; write lcd basic config\n"
+"    echo type <lcd_type> <lcd_bits> > debug ; write lcd type & bits\n"
+"    echo clock <lcd_clk> <ss_level> <clk_pol> > debug ; write lcd clk (Hz)\n"
+"    echo sync <hs_width> <hs_backporch> <hs_pol> <vs_width> <vs_backporch> <vs_pol> > debug ; write lcd sync timing\n"
+"    echo valid <hvsync_valid> <de_valid> > debug ; enable lcd sync signals\n"
+"data format:\n"
+"    <lcd_type> : "
+#ifdef CONFIG_LCD_IF_MIPI_VALID
+"0=mipi, "
+#endif
+"1=lvds, "
+#ifdef CONFIG_LCD_IF_EDP_VALID
+"2=edp, "
+#endif
+"3=ttl\n"
+"    <lcd_bits> : 6=6bit(RGB18bit), 8=8bit(RGB24bit)\n"
+"    <ss_level> : lcd clock spread spectrum level, 0 for disable\n"
+"    <xx_pol>   : 0=negative, 1=positive\n"
+"    <xx_valid> : 0=disable, 1=enable\n"
+"\n"
+"    echo ttl <rb_swap> <bit_swap> > debug ; write ttl RGB swap config\n"
+"    echo lvds <vswing_level> <lvds_repack> <pn_swap> > debug ; write lvds config\n"
+#ifdef CONFIG_LCD_IF_MIPI_VALID
+"    echo mdsi <lane_num> <bit_rate_max> <factor> > debug ; write mipi-dsi clock config\n"
+"    echo mctl <init_mode> <disp_mode> <lp_clk_auto_stop> <transfer_switch> > debug ; write mipi-dsi control config\n"
+#endif
+#ifdef CONFIG_LCD_IF_EDP_VALID
+"    echo edp <link_rate> <lane_count> <vswing_level> > debug ; write edp lane config\n"
+"    echo ectl <edid_timing_used> <sync_clock_mode> > debug; write edp control config"
+#endif
+"data format:\n"
+"    <xx_swap>      : 0=normal, 1=swap\n"
+"    <vswing_level> : lvds support level 0~4 (Default=1),"
+#ifdef CONFIG_LCD_IF_EDP_VALID
+" edp support level 0~3 (default=0)"
+#endif
+"\n"
+"    <lvds_repack>  : 0=JEIDA mode, 1=VESA mode\n"
+"    <pn_swap>      : 0=normal, 1=swap lvds p/n channels\n"
+#ifdef CONFIG_LCD_IF_MIPI_VALID
+"    <bit_rate_max> : unit in MHz\n"
+"    <factor>:      : special adjust, 0 for default\n"
+"    <xxxx_mode>    : 0=video mode, 1=command mode\n"
+"    <lp_clk_auto_stop> : 0=disable, 1=enable\n"
+"    <transfer_switch>  : 0=auto, 1=standard, 2=slow\n"
+#endif
+#ifdef CONFIG_LCD_IF_EDP_VALID
+"    <link_rate>        : 0=1.62G, 1=2.7G\n"
+"    <edid_timing_used> : 0=no use, 1=use, default=0\n"
+"    <sync_clock_mode>  : 0=asyncronous, 1=synchronous, default=1\n"
+#endif
+"\n"
+"    echo offset <h_sign> <h_offset> <v_sign> <v_offset> > debug ; write ttl display offset\n"
+"    echo dither <dither_user> <dither_ctrl> > debug ; write user dither ctrl config\n"
+"    echo vadj <brightness> <contrast> <saturation> > debug ; write video adjust config\n"
+"data format:\n"
+"    <xx_sign>     : 0=positive, 1=negative\n"
+"    <dither_user> : 0=disable user control, 1=enable user control\n"
+"    <dither_ctrl> : dither ctrl in Hex, such as 0x400 or 0x600\n"
+"    <brightness>  : negative 0x1ff~0x101, positive 0x0~0xff, signed value in Hex, default is 0x0\n"
+"    <contrast>    : 0x0~0xff, unsigned value in Hex, default is 0x80\n"
+"    <saturation>  : 0x0~0x1ff, unsigned value in Hex, default is 0x100\n"
+"\n"
+"    echo write > debug ; update lcd driver\n"
+"    echo reset > debug ; reset lcd config & driver\n"
+"    echo read > debug ; read current lcd config\n"
+"    echo test <num> > debug ; bist pattern test, 0=pattern off, 1~7=different pattern\n"
+};
+
+static ssize_t lcd_debug_common_help(struct class *class, struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n",lcd_common_usage_str);
+}
+
+static ssize_t lcd_debug_help(struct class *class, struct class_attribute *attr, char *buf)
+{
+    return sprintf(buf, "%s\n",lcd_usage_str);
+}
+
+static void read_current_lcd_config(Lcd_Config_t *pConf)
+{
+    unsigned lcd_clk;
+    int h_adj, v_adj;
+
+    lcd_clk = (pConf->lcd_timing.lcd_clk / 1000);
+    h_adj = ((pConf->lcd_timing.h_offset >> 31) & 1);
+    v_adj = ((pConf->lcd_timing.v_offset >> 31) & 1);
+
+    pConf->lcd_misc_ctrl.print_version();
+    printk("LCD mode: %s, %s %ubit, %ux%u@%u.%uHz\n"
+           "lcd_clk           %u.%03uMHz\n"
+           "ss_level          %d\n"
+           "clk_pol           %d\n\n",
+           pConf->lcd_basic.model_name, lcd_type_table[pConf->lcd_basic.lcd_type], pConf->lcd_basic.lcd_bits, pConf->lcd_basic.h_active, pConf->lcd_basic.v_active,
+           (pConf->lcd_timing.sync_duration_num / 10), (pConf->lcd_timing.sync_duration_num % 10),
+           (lcd_clk / 1000), (lcd_clk % 1000), ((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf), ((pConf->lcd_timing.pol_ctrl >> POL_CTRL_CLK) & 1));
+
+    printk("h_period          %d\n"
+           "v_period          %d\n"
+           "hs_width          %d\n"
+           "hs_backporch      %d\n"
+           "hs_pol            %d\n"
+           "vs_width          %d\n"
+           "vs_backporch      %d\n"
+           "vs_pol            %d\n"
+           "vs_h_phase        %s%d\n"
+           "hvsync_valid      %d\n"
+           "de_valid          %d\n"
+           "h_offset          %s%d\n"
+           "v_offset          %s%d\n\n",
+           pConf->lcd_basic.h_period, pConf->lcd_basic.v_period,
+           pConf->lcd_timing.hsync_width, pConf->lcd_timing.hsync_bp, ((pConf->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1),
+           pConf->lcd_timing.vsync_width, pConf->lcd_timing.vsync_bp, ((pConf->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1),
+           (((pConf->lcd_timing.vsync_h_phase >> 31) & 1) ? "-":""), (pConf->lcd_timing.vsync_h_phase & 0xffff), pConf->lcd_timing.hvsync_valid, pConf->lcd_timing.de_valid,
+           (h_adj ? "-" : ""), (pConf->lcd_timing.h_offset & 0xffff), (v_adj ? "-" : ""), (pConf->lcd_timing.v_offset & 0xffff));
+
+    switch (pConf->lcd_basic.lcd_type) {
+        case LCD_DIGITAL_TTL:
+            printk("rb_swap           %u\n"
+                   "bit_swap          %u\n\n",
+                   pConf->lcd_control.ttl_config->rb_swap, pConf->lcd_control.ttl_config->bit_swap);
+            break;
+        case LCD_DIGITAL_LVDS:
+            printk("vswing_level      %u\n"
+                   "lvds_repack       %u\n"
+                   "pn_swap           %u\n\n",
+                   pConf->lcd_control.lvds_config->lvds_vswing, pConf->lcd_control.lvds_config->lvds_repack, pConf->lcd_control.lvds_config->pn_swap);
+            break;
+        case LCD_DIGITAL_MIPI:
+            printk("dsi_lane_num      %u\n"
+                   "dsi_bit_rate      %u.%03uMHz\n"
+                   "operation_mode    %u(%s), %u(%s)\n"
+                   "transfer_ctrl     %u, %u\n\n",
+                   pConf->lcd_control.mipi_config->lane_num, (pConf->lcd_control.mipi_config->bit_rate / 1000000), ((pConf->lcd_control.mipi_config->bit_rate % 1000000) / 1000),
+                   ((pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_INIT) &1), (((pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_INIT) & 1) ? "COMMAND" : "VIDEO"),
+                   ((pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_DISP) & 1), (((pConf->lcd_control.mipi_config->operation_mode>>BIT_OPERATION_MODE_DISP) & 1) ? "COMMAND" : "VIDEO"),
+                   ((pConf->lcd_control.mipi_config->transfer_ctrl>>BIT_TRANS_CTRL_CLK) & 1), ((pConf->lcd_control.mipi_config->transfer_ctrl>>BIT_TRANS_CTRL_SWITCH) & 3));
+            break;
+        case LCD_DIGITAL_EDP:
+            printk("link_rate         %s\n"
+                   "lane_count        %u\n"
+                   "link_adaptive     %u\n"
+                   "vswing            %u\n"
+                   "max_lane_count    %u\n"
+                   "sync_clock_mode   %u\n"
+                   "EDID timing used  %u\n\n",
+                   ((pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pConf->lcd_control.edp_config->lane_count,
+                   pConf->lcd_control.edp_config->link_adaptive, pConf->lcd_control.edp_config->vswing,
+                   pConf->lcd_control.edp_config->max_lane_count, pConf->lcd_control.edp_config->sync_clock_mode, pConf->lcd_control.edp_config->edid_timing_used);
+            break;
+        default:
+            break;
+    }
+
+    if (pConf->lcd_effect.dith_user)
+        printk("dither_ctrl       0x%x\n", pConf->lcd_effect.dith_cntl_addr);
+
+    printk("pll_ctrl          0x%08x\n"
+           "div_ctrl          0x%08x\n"
+           "clk_ctrl          0x%08x\n"
+           "video_on_pixel    %d\n"
+           "video_on_line     %d\n\n",
+           pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, pConf->lcd_timing.clk_ctrl,
+           pConf->lcd_timing.video_on_pixel, pConf->lcd_timing.video_on_line);
+}
+
+static void save_lcd_config(Lcd_Config_t *pConf)
+{
+	temp_lcd_basic.h_active = pConf->lcd_basic.h_active;
+	temp_lcd_basic.v_active = pConf->lcd_basic.v_active;
+	temp_lcd_basic.h_period = pConf->lcd_basic.h_period;
+	temp_lcd_basic.v_period = pConf->lcd_basic.v_period;
+	temp_lcd_basic.lcd_type = pConf->lcd_basic.lcd_type;
+	temp_lcd_basic.lcd_bits = pConf->lcd_basic.lcd_bits;
+
+	temp_lcd_timing.pll_ctrl = pConf->lcd_timing.pll_ctrl;
+	temp_lcd_timing.div_ctrl = pConf->lcd_timing.div_ctrl;
+	temp_lcd_timing.clk_ctrl = pConf->lcd_timing.clk_ctrl;
+	temp_lcd_timing.lcd_clk = pConf->lcd_timing.lcd_clk;
+	temp_lcd_timing.hsync_width = pConf->lcd_timing.hsync_width;
+	temp_lcd_timing.hsync_bp = pConf->lcd_timing.hsync_bp;
+	temp_lcd_timing.vsync_width = pConf->lcd_timing.vsync_width;
+	temp_lcd_timing.vsync_bp = pConf->lcd_timing.vsync_bp;
+	temp_lcd_timing.hvsync_valid = pConf->lcd_timing.hvsync_valid;
+	//temp_lcd_timing.de_hstart = pConf->lcd_timing.de_hstart;
+	//temp_lcd_timing.de_vstart = pConf->lcd_timing.de_vstart;
+	temp_lcd_timing.de_valid = pConf->lcd_timing.de_valid;
+	temp_lcd_timing.h_offset = pConf->lcd_timing.h_offset;
+	temp_lcd_timing.v_offset = pConf->lcd_timing.v_offset;
+	temp_lcd_timing.pol_ctrl = pConf->lcd_timing.pol_ctrl;
+
+	switch (pConf->lcd_basic.lcd_type) {
+		case LCD_DIGITAL_MIPI:
+			temp_dsi_lane_num = pConf->lcd_control.mipi_config->lane_num;
+			temp_dsi_bit_rate_min = pConf->lcd_control.mipi_config->bit_rate_min;
+			temp_dsi_bit_rate_max = pConf->lcd_control.mipi_config->bit_rate_max;
+			temp_factor_denominator = pConf->lcd_control.mipi_config->factor_denominator;
+			temp_factor_numerator = pConf->lcd_control.mipi_config->factor_numerator;
+			break;
+		case LCD_DIGITAL_EDP:
+			temp_edp_link_rate = pConf->lcd_control.edp_config->link_rate;
+			temp_edp_lane_count = pConf->lcd_control.edp_config->lane_count;
+			temp_edp_vswing = pConf->lcd_control.edp_config->vswing;
+			temp_edp_preemphasis = pConf->lcd_control.edp_config->preemphasis;
+			temp_edp_sync_clock_mode = pConf->lcd_control.edp_config->sync_clock_mode;
+			temp_edp_edid_timing_used = pConf->lcd_control.edp_config->edid_timing_used;
+			break;
+		case LCD_DIGITAL_LVDS:
+			temp_lvds_repack = pConf->lcd_control.lvds_config->lvds_repack;
+			temp_pn_swap = pConf->lcd_control.lvds_config->pn_swap;
+			temp_lvds_vswing = pConf->lcd_control.lvds_config->lvds_vswing;
+			break;
+		case LCD_DIGITAL_TTL:
+			temp_ttl_rb_swap = pConf->lcd_control.ttl_config->rb_swap;
+			temp_ttl_bit_swap = pConf->lcd_control.ttl_config->bit_swap;
+			break;
+		default:
+			break;
+	}
+
+	temp_dith_user = pConf->lcd_effect.dith_user;
+	temp_dith_ctrl = pConf->lcd_effect.dith_cntl_addr;
+	temp_vadj_brightness = pConf->lcd_effect.vadj_brightness;
+	temp_vadj_contrast = pConf->lcd_effect.vadj_contrast;
+	temp_vadj_saturation = pConf->lcd_effect.vadj_saturation;
+}
+
+static void reset_lcd_config(Lcd_Config_t *pConf)
+{
+	printk("reset lcd config.\n");
+
+	_disable_backlight();
+	_lcd_module_disable();
+	mdelay(200);
+
+	pConf->lcd_basic.h_active = temp_lcd_basic.h_active;
+	pConf->lcd_basic.v_active = temp_lcd_basic.v_active;
+	pConf->lcd_basic.h_period = temp_lcd_basic.h_period;
+	pConf->lcd_basic.v_period = temp_lcd_basic.v_period;
+	pConf->lcd_basic.lcd_type = temp_lcd_basic.lcd_type;
+	pConf->lcd_basic.lcd_bits = temp_lcd_basic.lcd_bits;
+
+	pConf->lcd_timing.pll_ctrl = temp_lcd_timing.pll_ctrl;
+	pConf->lcd_timing.div_ctrl = temp_lcd_timing.div_ctrl;
+	pConf->lcd_timing.clk_ctrl = temp_lcd_timing.clk_ctrl;
+	pConf->lcd_timing.lcd_clk = temp_lcd_timing.lcd_clk;
+	pConf->lcd_timing.hsync_width = temp_lcd_timing.hsync_width;
+	pConf->lcd_timing.hsync_bp = temp_lcd_timing.hsync_bp;
+	pConf->lcd_timing.vsync_width = temp_lcd_timing.vsync_width;
+	pConf->lcd_timing.vsync_bp = temp_lcd_timing.vsync_bp;
+	pConf->lcd_timing.hvsync_valid = temp_lcd_timing.hvsync_valid;
+	//pConf->lcd_timing.de_hstart = temp_lcd_timing.de_hstart;
+	//pConf->lcd_timing.de_vstart = temp_lcd_timing.de_vstart;
+	pConf->lcd_timing.de_valid = temp_lcd_timing.de_valid;
+	pConf->lcd_timing.h_offset = temp_lcd_timing.h_offset;
+	pConf->lcd_timing.v_offset = temp_lcd_timing.v_offset;
+	pConf->lcd_timing.pol_ctrl = temp_lcd_timing.pol_ctrl;
+
+	pConf->lcd_effect.dith_user = temp_dith_user;
+	pConf->lcd_effect.dith_cntl_addr = temp_dith_ctrl;
+	pConf->lcd_effect.vadj_brightness = temp_vadj_brightness;
+	pConf->lcd_effect.vadj_contrast = temp_vadj_contrast;
+	pConf->lcd_effect.vadj_saturation = temp_vadj_saturation;
+
+	switch (pConf->lcd_basic.lcd_type) {
+		case LCD_DIGITAL_MIPI:
+			pConf->lcd_control.mipi_config->lane_num = temp_dsi_lane_num;
+			pConf->lcd_control.mipi_config->bit_rate_min = temp_dsi_bit_rate_min;
+			pConf->lcd_control.mipi_config->bit_rate_max = temp_dsi_bit_rate_max;
+			pConf->lcd_control.mipi_config->factor_denominator = temp_factor_denominator;
+			pConf->lcd_control.mipi_config->factor_numerator = temp_factor_numerator;
+			break;
+		case LCD_DIGITAL_EDP:
+			pConf->lcd_control.edp_config->link_rate = temp_edp_link_rate;
+			pConf->lcd_control.edp_config->lane_count = temp_edp_lane_count;
+			pConf->lcd_control.edp_config->vswing = temp_edp_vswing;
+			pConf->lcd_control.edp_config->preemphasis = temp_edp_preemphasis;
+			pConf->lcd_control.edp_config->sync_clock_mode = temp_edp_sync_clock_mode;
+			pConf->lcd_control.edp_config->edid_timing_used = temp_edp_edid_timing_used;
+			break;
+		case LCD_DIGITAL_LVDS:
+			pConf->lcd_control.lvds_config->lvds_repack = temp_lvds_repack;
+			pConf->lcd_control.lvds_config->pn_swap = temp_pn_swap;
+			pConf->lcd_control.lvds_config->lvds_vswing = temp_lvds_vswing;
+			break;
+		case LCD_DIGITAL_TTL:
+			pConf->lcd_control.ttl_config->rb_swap = temp_ttl_rb_swap;
+			pConf->lcd_control.ttl_config->bit_swap = temp_ttl_bit_swap;
+			break;
+		default:
+			break;
+	}
+
+	lcd_config_init(pConf);
+	_init_vout();
+	_lcd_module_enable();
+	_enable_backlight();
+}
+
+static ssize_t lcd_debug(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+	unsigned t[6];
+
+	switch (buf[0]) {
+		case 'b':	//write basic config
+			t[0] = 1024;
+			t[1] = 768;
+			t[2] = 1344;
+			t[3] = 806;
+			ret = sscanf(buf, "basic %d %d %d %d", &t[0], &t[1], &t[2], &t[3]);
+			pDev->pConf->lcd_basic.h_active = t[0];
+			pDev->pConf->lcd_basic.v_active = t[1];
+			pDev->pConf->lcd_basic.h_period = t[2];
+			pDev->pConf->lcd_basic.v_period = t[3];
+			printk("h_active=%d, v_active=%d, h_period=%d, v_period=%d\n", t[0], t[1], t[2], t[3]);
+			break;
+		case 't':
+			if (buf[1] == 'y') {//type
+				t[0] = 1;
+				t[1] = 6;
+				ret = sscanf(buf, "type %d %d", &t[0], &t[1]);
+				pDev->pConf->lcd_basic.lcd_type = t[0];
+				pDev->pConf->lcd_basic.lcd_bits = t[1];
+				printk("lcd_type: %s, lcd_bits: %d\n", lcd_type_table[t[0]], t[1]);
+			}
+			else if (buf[1] == 'e') {//test
+				t[0] = 0;
+				ret = sscanf(buf, "test %d", &t[0]);
+				if (pDev->pConf->lcd_misc_ctrl.lcd_status == 0)
+					printk("lcd is already OFF, can't display test pattern\n");
+				else
+					pDev->pConf->lcd_misc_ctrl.lcd_test(t[0]);
+			}
+			else if (buf[1] == 't') {//ttl
+				t[0] = 0;
+				t[1] = 0;
+				ret = sscanf(buf, "ttl %d %d", &t[0], &t[1]);
+				pDev->pConf->lcd_control.ttl_config->rb_swap = t[0];
+				pDev->pConf->lcd_control.ttl_config->bit_swap = t[1];
+				printk("ttl rb_swap: %s, bit_swap: %s\n", ((t[0] == 0) ? "disable" : "enable"), ((t[1] == 0) ? "disable" : "enable"));
+			}
+			break;
+		case 'c':
+			t[0] = 40000000;
+			t[1] = 0;
+			t[2] = 0;
+			ret = sscanf(buf, "clock %d %d %d", &t[0], &t[1], &t[2]);
+			pDev->pConf->lcd_timing.lcd_clk = t[0];
+			pDev->pConf->lcd_timing.clk_ctrl = ((pDev->pConf->lcd_timing.clk_ctrl & ~((1 << CLK_CTRL_AUTO) | (0xf << CLK_CTRL_SS))) | ((1 << CLK_CTRL_AUTO) | (t[1] << CLK_CTRL_SS)));
+			pDev->pConf->lcd_timing.pol_ctrl = ((pDev->pConf->lcd_timing.pol_ctrl & ~(1 << POL_CTRL_CLK)) | (t[2] << POL_CTRL_CLK));
+			printk("lcd_clk=%dHz, ss_level=%d, clk_pol=%s\n", t[0], t[1], ((t[2] == 0) ? "negative" : "positive"));
+			break;
+		case 's'://sync
+			t[0] = 10;
+			t[1] = 60;
+			t[2] = 0;
+			t[3] = 3;
+			t[4] = 20;
+			t[5] = 0;
+			ret = sscanf(buf, "sync %d %d %d %d %d %d", &t[0], &t[1], &t[2], &t[3], &t[4], &t[5]);
+			pDev->pConf->lcd_timing.hsync_width = t[0];
+			pDev->pConf->lcd_timing.hsync_bp = t[1];
+			pDev->pConf->lcd_timing.vsync_width = t[3];
+			pDev->pConf->lcd_timing.vsync_bp = t[4];
+			pDev->pConf->lcd_timing.pol_ctrl = ((pDev->pConf->lcd_timing.pol_ctrl & ~((1 << POL_CTRL_HS) | (1 << POL_CTRL_VS))) | ((t[2] << POL_CTRL_HS) | (t[5] << POL_CTRL_VS)));
+			printk("hs_width=%d, hs_bp=%d, hs_pol=%s, vs_width=%d, vs_bp=%d, vs_pol=%s\n", t[0], t[1], ((t[2] == 0) ? "negative" : "positive"), t[3], t[4], ((t[5] == 0) ? "negative" : "positive"));
+			break;
+		case 'v':
+			if (buf[2] == 'l') { //valid
+				t[0] = 0;
+				t[1] = 0;
+				t[2] = 1;
+				ret = sscanf(buf, "valid %d %d", &t[0], &t[1]);
+				pDev->pConf->lcd_timing.hvsync_valid = t[0];
+				pDev->pConf->lcd_timing.de_valid = t[1];
+				printk("hvsync: %s, de: %s\n", ((t[0] == 0) ? "disable" : "enable"), ((t[1] == 0) ? "disable" : "enable"));
+			}
+			else if (buf[2] == 'd') { //vadj
+				t[0] = 0x0;
+				t[1] = 0x80;
+				t[2] = 0x100;
+				ret = sscanf(buf, "vadj %d %d %d", &t[0], &t[1], &t[2]);
+				pDev->pConf->lcd_effect.vadj_brightness = t[0];
+				pDev->pConf->lcd_effect.vadj_contrast = t[1];
+				pDev->pConf->lcd_effect.vadj_saturation = t[2];
+				printk("video adjust: brightness=0x%x, contrast=0x%x, stauration=0x%x\n", t[0], t[1], t[2]);
+			}
+			break;
+		case 'o':
+			t[0] = 1;
+			t[1] = 0;
+			t[2] = 1;
+			t[3] = 0;
+			ret = sscanf(buf, "offset %d %d %d %d", &t[0], &t[1], &t[2], &t[3]);
+			pDev->pConf->lcd_timing.h_offset = ((t[0] << 31) | ((t[1] & 0xffff) << 0));
+			pDev->pConf->lcd_timing.v_offset = ((t[2] << 31) | ((t[3] & 0xffff) << 0));
+			printk("h_offset = %s%u, v_offset = %s%u\n", (t[0] ? "+" : "-"), (t[1] & 0xffff), (t[2] ? "+" : "-"), (t[3] & 0xffff));
+			break;
+		case 'l':	//write lvds config		//lvds_repack, pn_swap
+			t[0] = 1;
+			t[1] = 1;
+			t[2] = 0;
+			ret = sscanf(buf, "lvds %d %d %d", &t[0], &t[1], &t[2]);
+			pDev->pConf->lcd_control.lvds_config->lvds_vswing = t[0];
+			pDev->pConf->lcd_control.lvds_config->lvds_repack = t[1];
+			pDev->pConf->lcd_control.lvds_config->pn_swap = t[2];
+			printk("vswing_level: %u, lvds_repack: %s, rb_swap: %s\n", t[0], ((t[1] == 1) ? "VESA mode" : "JEIDA mode"), ((t[2] == 0) ? "disable" : "enable"));
+			break;
+#ifdef CONFIG_LCD_IF_MIPI_VALID
+		case 'm':	//write mipi config
+			if (buf[1] == 'd') {
+				t[0] = 0;
+				t[1] = 4;
+				t[2] = 0;
+				ret = sscanf(buf, "mdsi %d %d %d", &t[0],&t[1],&t[2]);
+				pDev->pConf->lcd_control.mipi_config->lane_num = (unsigned char)(t[0]);
+				pDev->pConf->lcd_control.mipi_config->bit_rate_max = t[1]*1000;
+				pDev->pConf->lcd_control.mipi_config->factor_numerator = t[2];
+				pDev->pConf->lcd_control.mipi_config->factor_denominator=10;
+				printk("dsi lane_num = %d, bit_rate max=%dMHz, factor=%d\n",t[0], t[1], pDev->pConf->lcd_control.mipi_config->factor_numerator);
+			}
+			else if (buf[1] == 'c') {
+				t[0] = 1;
+				t[1] = 0;
+				t[2] = 0;
+				t[3] = 0;
+				ret = sscanf(buf, "mctl %d %d %d %d", &t[0],&t[1],&t[2],&t[3]);
+				pDev->pConf->lcd_control.mipi_config->operation_mode = ((t[0] << BIT_OPERATION_MODE_INIT) | (t[1] << BIT_OPERATION_MODE_DISP));
+				pDev->pConf->lcd_control.mipi_config->transfer_ctrl = ((t[2] << BIT_TRANS_CTRL_CLK) | (t[3] << BIT_TRANS_CTRL_SWITCH));
+				printk("dsi operation mode init=%s(%d), display=%s(%d), lp_clk_auto_stop=%d, transfer_switch=%d\n",(t[0]? "command" : "video"), t[0], (t[1] ? "command" : "video"), t[1], t[2], t[3]);
+			}
+			break;
+#endif
+		case 'd':
+			if (buf[2] == 't') {
+				t[0] = 0;
+				t[1] = 0x600;
+				ret = sscanf(buf, "dither %d %x", &t[0], &t[1]);
+				pDev->pConf->lcd_effect.dith_user = t[0];
+				pDev->pConf->lcd_effect.dith_cntl_addr = t[1];
+				printk("dither user_ctrl: %s, 0x%x\n", ((t[0] == 0) ? "disable" : "enable"), t[1]);
+			}
+			else {
+				printk("power off lcd.\n");
+				_disable_backlight();
+				pDev->pConf->lcd_power_ctrl.power_ctrl(OFF);
+			}
+			break;
+		case 'w':	//update display config
+			if (pDev->pConf->lcd_basic.lcd_type == LCD_DIGITAL_MINILVDS) {
+				printk("Don't support miniLVDS yet. Will reset to original lcd config.\n");
+				reset_lcd_config(pDev->pConf);
+			}
+			else {
+				_lcd_module_disable();
+				mdelay(200);
+				lcd_config_init(pDev->pConf);
+				_init_vout();
+				_lcd_module_enable();
+			}
+			break;
+		case 'r':
+			if (buf[2] == 'a') { //read lcd config
+				read_current_lcd_config(pDev->pConf);
+			}
+			else if (buf[2] == 's') { //reset lcd config
+				reset_lcd_config(pDev->pConf);
+			}
+			break;
+		case 'e':
+			if (buf[1] == 'n') {
+				printk("power on lcd.\n");
+				_lcd_module_disable();
+				mdelay(200);
+				_lcd_module_enable();
+				_enable_backlight();
+			}
+#ifdef CONFIG_LCD_IF_EDP_VALID
+			else if (buf[1] == 'd') {
+				t[0] = 1;
+				t[1] = 4;
+				t[2] = 0;
+				ret = sscanf(buf, "edp %u %u %u", &t[0], &t[1], &t[2]);
+				pDev->pConf->lcd_control.edp_config->link_rate = ((t[0] == 0) ? 0 : 1);
+				switch (t[1]) {
+					case 1:
+					case 2:
+						pDev->pConf->lcd_control.edp_config->lane_count = t[1];
+						break;
+					default:
+						pDev->pConf->lcd_control.edp_config->lane_count = 4;
+						break;
+				}
+				pDev->pConf->lcd_control.edp_config->vswing = t[2];
+				printk("set edp link_rate = %s, lane_count = %u, vswing_level = %u\n", ((pDev->pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pDev->pConf->lcd_control.edp_config->lane_count, pDev->pConf->lcd_control.edp_config->vswing);
+			}
+			else if (buf[1] == 'c') {
+				t[0] = 0;
+				t[1] = 1;
+				ret = sscanf(buf, "ectl %u %u", &t[0], &t[1]);
+				pDev->pConf->lcd_control.edp_config->edid_timing_used = ((t[0] == 0) ? 0 : 1);
+				pDev->pConf->lcd_control.edp_config->sync_clock_mode = ((t[1] == 0) ? 0 : 1);
+				printk("set edp edid_timing_used = %u, sync_clock_mode = %u\n", pDev->pConf->lcd_control.edp_config->edid_timing_used, pDev->pConf->lcd_control.edp_config->sync_clock_mode);
+				pDev->pConf->lcd_misc_ctrl.edp_edid_load();
+			}
+#endif
+			else {
+				printk("wrong format of lcd debug command.\n");
+			}
+			break;
+		default:
+			printk("wrong format of lcd debug command.\n");
+	}
+
+	if (ret != 1 || ret !=2)
+		return -EINVAL;
+
+	return count;
+	//return 0;
+}
+
+static ssize_t lcd_status_read(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "read lcd status: %s\n", (pDev->pConf->lcd_misc_ctrl.lcd_status ? "ON":"OFF"));
+}
+
+static ssize_t lcd_status_write(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+	unsigned temp;
+
+	temp = 1;
+	ret = sscanf(buf, "%d", &temp);
+	if (temp) {
+		if (pDev->pConf->lcd_misc_ctrl.lcd_status == 0) {
+			mutex_lock(&lcd_vout_mutex);
+			_lcd_module_enable();
+			_enable_backlight();
+			mutex_unlock(&lcd_vout_mutex);
+		}
+		else {
+			printk("lcd is already ON\n");
+		}
+	}
+	else {
+		if (pDev->pConf->lcd_misc_ctrl.lcd_status == 1) {
+			mutex_lock(&lcd_vout_mutex);
+			_disable_backlight();
+			_lcd_module_disable();
+			mutex_unlock(&lcd_vout_mutex);
+		}
+		else {
+			printk("lcd is already OFF\n");
+		}
+	}
+
+	if (ret != 1 || ret !=2)
+		return -EINVAL;
+
+	return count;
+	//return 0;
+}
+
+static ssize_t lcd_print_read(struct class *class, struct class_attribute *attr, char *buf)
+{
+	return sprintf(buf, "lcd print flag: %u\n", lcd_print_flag);
+}
+
+static ssize_t lcd_print_write(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
+{
+	unsigned int ret;
+
+	ret = sscanf(buf, "%u", &lcd_print_flag);
+	printk("write lcd print flag: %u\n", lcd_print_flag);
+
+	if (ret != 1 || ret !=2)
+		return -EINVAL;
+
+	return count;
+	//return 0;
+}
+
+static struct class_attribute lcd_debug_class_attrs[] = {
+	__ATTR(debug,  S_IRUGO | S_IWUSR, lcd_debug_help, lcd_debug),
+	__ATTR(help,  S_IRUGO | S_IWUSR, lcd_debug_common_help, NULL),
+	__ATTR(status,  S_IRUGO | S_IWUSR, lcd_status_read, lcd_status_write),
+	__ATTR(print,  S_IRUGO | S_IWUSR, lcd_print_read, lcd_print_write),
+};
+
+static int creat_lcd_class(void)
+{
+    pDev->pConf->lcd_misc_ctrl.debug_class = class_create(THIS_MODULE, "lcd");
+    if(IS_ERR(pDev->pConf->lcd_misc_ctrl.debug_class)) {
+        printk("create lcd debug class fail\n");
+        return -1;
+    }
+    return 0;
+}
+
+static int remove_lcd_class(void)
+{
+    if (pDev->pConf->lcd_misc_ctrl.debug_class == NULL)
+        return -1;
+
+    class_destroy(pDev->pConf->lcd_misc_ctrl.debug_class);
+    pDev->pConf->lcd_misc_ctrl.debug_class = NULL;
+    return 0;
+}
+
+static int creat_lcd_attr(void)
+{
+    int i;
+
+    if(pDev->pConf->lcd_misc_ctrl.debug_class == NULL) {
+        printk("no lcd debug class exist\n");
+        return -1;
+    }
+
+    for(i=0;i<ARRAY_SIZE(lcd_debug_class_attrs);i++) {
+        if (class_create_file(pDev->pConf->lcd_misc_ctrl.debug_class, &lcd_debug_class_attrs[i])) {
+            printk("create lcd debug attribute %s fail\n", lcd_debug_class_attrs[i].attr.name);
+        }
+    }
+
+    return 0;
+}
+
+static int remove_lcd_attr(void)
+{
+    int i;
+
+    if (pDev->pConf->lcd_misc_ctrl.debug_class == NULL)
+        return -1;
+
+    for(i=0;i<ARRAY_SIZE(lcd_debug_class_attrs);i++) {
+        class_remove_file(pDev->pConf->lcd_misc_ctrl.debug_class, &lcd_debug_class_attrs[i]);
+    }
+
+    return 0;
+}
+//****************************
+
+static int lcd_reboot_notifier(struct notifier_block *nb, unsigned long state, void *cmd)
+ {
+	lcd_print("[%s]: %lu\n", __FUNCTION__, state);
+	if (pDev->pConf->lcd_misc_ctrl.lcd_status == 0)
+		return NOTIFY_DONE;
+
+	_disable_backlight();
+	_lcd_module_disable();
+
+	return NOTIFY_OK;
+}
+
+static int amlogic_pmu_gpio_name_map_num(const char *name)
+{
+	int index;
+
+	for(index = 0; index < LCD_POWER_PMU_GPIO_MAX; index++) {
+		if(!strcasecmp(name, lcd_power_pmu_gpio_table[index]))
+			break;
+	}
+	return index;
+}
+
+#ifdef CONFIG_USE_OF
+#define LCD_MODEL_LEN_MAX    30
+static int _get_lcd_model_timing(Lcd_Config_t *pConf, struct platform_device *pdev)
+{
+	int ret=0;
+	const char *str;
+	unsigned int val;
+	//unsigned int lcd_para[100];
+	unsigned int *lcd_para = (unsigned int *)kmalloc(sizeof(unsigned int)*100, GFP_KERNEL);
+	int i, j;
+	struct device_node *lcd_model_node;
+	phandle fhandle;
+
+	if (lcd_para == NULL) {
+		printk("[_get_lcd_model_timing]: Not enough memory\n");
+		return -1;
+	}
+	if (pdev->dev.of_node) {
+		ret = of_property_read_u32(pdev->dev.of_node,"lcd_model_config",&fhandle);
+		lcd_model_node = of_find_node_by_phandle(fhandle);
+		ret = of_property_read_string(lcd_model_node,"model_name", &str);
+		if(ret) {
+			str = "none";
+			printk("lcd: faild to get lcd_model_name!\n");
+		}
+		pConf->lcd_basic.model_name = (char *)kmalloc(sizeof(char)*LCD_MODEL_LEN_MAX, GFP_KERNEL);
+		if (pConf->lcd_basic.model_name == NULL) {
+			printk("[_get_lcd_model_timing]: Not enough memory\n");
+		}
+		else {
+			memset(pConf->lcd_basic.model_name, 0, LCD_MODEL_LEN_MAX);
+			strcpy(pConf->lcd_basic.model_name, str);
+			printk("load lcd model in dtb: %s\n", pConf->lcd_basic.model_name);
+		}
+
+		ret = of_property_read_string(lcd_model_node, "interface", &str);
+		if (ret) {
+			printk("faild to get lcd_type!\n");
+			str = "invalid";
+		}
+		for(val = 0; val < LCD_TYPE_MAX; val++) {
+			if(!strcasecmp(str, lcd_type_table[val]))
+				break;
+		}
+		pConf->lcd_basic.lcd_type = val;
+		lcd_print("lcd_type= %s(%u)\n", lcd_type_table[pConf->lcd_basic.lcd_type], pConf->lcd_basic.lcd_type);
+		ret = of_property_read_u32_array(lcd_model_node,"active_area",&lcd_para[0],2);
+		if(ret){
+			printk("faild to get active_area\n");
+		}
+		else {
+			pConf->lcd_basic.h_active_area = lcd_para[0];
+			pConf->lcd_basic.v_active_area = lcd_para[1];
+			pConf->lcd_basic.screen_ratio_width = lcd_para[0];
+			pConf->lcd_basic.screen_ratio_height = lcd_para[1];
+		}
+		lcd_print("h_active_area = %umm, v_active_area =%umm\n", pConf->lcd_basic.h_active_area, pConf->lcd_basic.v_active_area);
+		ret = of_property_read_u32_array(lcd_model_node,"lcd_bits_option",&lcd_para[0],2);
+		if(ret){
+			printk("faild to get lcd_bits_option\n");
+		}
+		else {
+			pConf->lcd_basic.lcd_bits = (unsigned short)(lcd_para[0]);
+			pConf->lcd_basic.lcd_bits_option = (unsigned short)(lcd_para[1]);
+		}
+		lcd_print("lcd_bits = %u, lcd_bits_option = %u\n", pConf->lcd_basic.lcd_bits, pConf->lcd_basic.lcd_bits_option);
+		ret = of_property_read_u32_array(lcd_model_node,"resolution", &lcd_para[0], 2);
+		if(ret){
+			printk("faild to get resolution\n");
+		}
+		else {
+			pConf->lcd_basic.h_active = (unsigned short)(lcd_para[0]);
+			pConf->lcd_basic.v_active = (unsigned short)(lcd_para[1]);
+		}
+		ret = of_property_read_u32_array(lcd_model_node,"period",&lcd_para[0],2);
+		if(ret){
+			printk("faild to get period\n");
+		}
+		else {
+			pConf->lcd_basic.h_period = (unsigned short)(lcd_para[0]);
+			pConf->lcd_basic.v_period = (unsigned short)(lcd_para[1]);
+		}
+		lcd_print("h_active = %u, v_active =%u, h_period = %u, v_period = %u\n", pConf->lcd_basic.h_active, pConf->lcd_basic.v_active, pConf->lcd_basic.h_period, pConf->lcd_basic.v_period);
+		ret = of_property_read_u32_array(lcd_model_node,"clock_hz_pol",&lcd_para[0], 2);
+		if(ret){
+			printk("faild to get clock_hz_pol\n");
+		}
+		else {
+			pConf->lcd_timing.lcd_clk = lcd_para[0];
+			pConf->lcd_timing.pol_ctrl = (lcd_para[1] << POL_CTRL_CLK);
+		}
+		lcd_print("pclk = %uHz, pol=%u\n", pConf->lcd_timing.lcd_clk, (pConf->lcd_timing.pol_ctrl >> POL_CTRL_CLK) & 1);
+		ret = of_property_read_u32_array(lcd_model_node,"hsync_width_backporch",&lcd_para[0], 2);
+		if(ret){
+			printk("faild to get hsync_width_backporch\n");
+		}
+		else {
+			pConf->lcd_timing.hsync_width = (unsigned short)(lcd_para[0]);
+			pConf->lcd_timing.hsync_bp = (unsigned short)(lcd_para[1]);
+		}
+		lcd_print("hsync width = %u, backporch = %u\n", pConf->lcd_timing.hsync_width, pConf->lcd_timing.hsync_bp);
+		ret = of_property_read_u32_array(lcd_model_node,"vsync_width_backporch",&lcd_para[0], 2);
+		if(ret){
+			printk("faild to get vsync_width_backporch\n");
+		}
+		else {
+			pConf->lcd_timing.vsync_width = (unsigned short)(lcd_para[0]);
+			pConf->lcd_timing.vsync_bp = (unsigned short)(lcd_para[1]);
+		}
+		lcd_print("vsync width = %u, backporch = %u\n", pConf->lcd_timing.vsync_width, pConf->lcd_timing.vsync_bp);
+		ret = of_property_read_u32_array(lcd_model_node,"pol_hsync_vsync",&lcd_para[0], 2);
+		if(ret){
+			printk("faild to get pol_hsync_vsync\n");
+		}
+		else {
+			pConf->lcd_timing.pol_ctrl = (pConf->lcd_timing.pol_ctrl & ~((1 << POL_CTRL_HS) | (1 << POL_CTRL_VS))) | ((lcd_para[0] << POL_CTRL_HS) | (lcd_para[1] << POL_CTRL_VS));
+		}
+		lcd_print("pol hsync = %u, vsync = %u\n", (pConf->lcd_timing.pol_ctrl >> POL_CTRL_HS) & 1, (pConf->lcd_timing.pol_ctrl >> POL_CTRL_VS) & 1);
+		ret = of_property_read_u32_array(lcd_model_node,"vsync_horizontal_phase",&lcd_para[0], 2);
+		if(ret){
+			lcd_print("faild to get vsync_horizontal_phase\n");
+			pConf->lcd_timing.vsync_h_phase = 0;
+		} else {
+			pConf->lcd_timing.vsync_h_phase = ((lcd_para[0] << 31) | ((lcd_para[1] & 0xffff) << 0));
+		}
+		if (lcd_para[0] == 0)
+			lcd_print("vsync_horizontal_phase= %d\n", lcd_para[1]);
+		else
+			lcd_print("vsync_horizontal_phase= -%d\n", lcd_para[1]);
+
+        if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_MIPI) {
+            ret = of_property_read_u32(lcd_model_node,"dsi_lane_num",&val);
+            if(ret){
+                printk("faild to get dsi_lane_num\n");
+                pConf->lcd_control.mipi_config->lane_num = 4;
+            }
+            else {
+                pConf->lcd_control.mipi_config->lane_num = (unsigned char)val;
+            }
+            lcd_print("dsi_lane_num= %d\n",  pConf->lcd_control.mipi_config->lane_num);
+            ret = of_property_read_u32(lcd_model_node,"dsi_bit_rate_max",&val);
+            if(ret){
+                printk("faild to get dsi_bit_rate_max\n");
+                pConf->lcd_control.mipi_config->bit_rate_max = 0;
+            }
+            else {
+                pConf->lcd_control.mipi_config->bit_rate_max = val;
+            }
+            lcd_print("dsi bit_rate max = %dMHz\n", pConf->lcd_control.mipi_config->bit_rate_max);
+            ret = of_property_read_u32(lcd_model_node,"pclk_lanebyteclk_factor",&val);
+            if(ret){
+                printk("faild to get pclk_lanebyteclk_factor\n");
+                pConf->lcd_control.mipi_config->factor_numerator = 0;
+            }
+            else {
+                pConf->lcd_control.mipi_config->factor_numerator = val;
+            }
+            pConf->lcd_control.mipi_config->factor_denominator = 10;
+            lcd_print("pclk_lanebyteclk factor= %d\n", pConf->lcd_control.mipi_config->factor_numerator);
+            ret = of_property_read_u32_array(lcd_model_node,"dsi_operation_mode",&lcd_para[0], 2);
+            if(ret){
+                printk("faild to get dsi_operation_mode\n");
+                pConf->lcd_control.mipi_config->operation_mode = ((1 << BIT_OPERATION_MODE_INIT) | (0 << BIT_OPERATION_MODE_DISP));
+            }
+            else {
+                pConf->lcd_control.mipi_config->operation_mode = ((lcd_para[0] << BIT_OPERATION_MODE_INIT) | (lcd_para[1] << BIT_OPERATION_MODE_DISP));
+            }
+            lcd_print("dsi_operation_mode init=%d, display=%d\n", (pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_INIT) & 1, (pConf->lcd_control.mipi_config->operation_mode >> BIT_OPERATION_MODE_DISP) & 1);
+            ret = of_property_read_u32_array(lcd_model_node,"dsi_transfer_ctrl",&lcd_para[0], 2);
+            if(ret){
+                printk("faild to get dsi_transfer_ctrl\n");
+                pConf->lcd_control.mipi_config->transfer_ctrl = ((0 << BIT_TRANS_CTRL_CLK) | (0 << BIT_TRANS_CTRL_SWITCH));
+            }
+            else {
+                pConf->lcd_control.mipi_config->transfer_ctrl = ((lcd_para[0] << BIT_TRANS_CTRL_CLK) | (lcd_para[1] << BIT_TRANS_CTRL_SWITCH));
+            }
+            lcd_print("dsi_transfer_ctrl clk=%d, switch=%d\n", (pConf->lcd_control.mipi_config->transfer_ctrl >> BIT_TRANS_CTRL_CLK) & 1, (pConf->lcd_control.mipi_config->transfer_ctrl >> BIT_TRANS_CTRL_SWITCH) & 3);
+            //detect dsi init on table
+            if (pConf->lcd_control.mipi_config->dsi_init_on != NULL) {
+                ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", 0, &lcd_para[0]);
+                if (ret) {
+                    printk("faild to get dsi_init_on\n");
+                }
+                else {
+                    i = 0;
+                    while (i < DSI_INIT_ON_MAX) {
+                        ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", i, &val);
+                        if (val == 0xff) {
+                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", (i+1), &val);
+                            i += 2;
+                            if (val == 0xff)
+                                break;
+                        }
+                        else if ((val & 0xf) == 0x0) {
+                            printk("get dsi_init_on wrong data_type: 0x%02x\n", val);
+                            break;
+                        }
+                        else {
+                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_on", (i+DSI_CMD_CNT_INDEX), &val);
+                            if (val > 0xffff)
+                                break;
+                            else
+                                i = i + (DSI_CMD_CNT_INDEX + 1) + (val & 0xff);
+                        }
+                    }
+                    i = (i > DSI_INIT_ON_MAX) ? DSI_INIT_ON_MAX : i;
+                    ret = of_property_read_u32_array(lcd_model_node,"dsi_init_on", &lcd_para[0], i);
+                    if(ret){
+                        printk("faild to get dsi_init_on\n");
+                    }
+                    else {
+                        lcd_print("dsi_init_on: ");
+                        for (j=0; j<i; j++) {
+                            pConf->lcd_control.mipi_config->dsi_init_on[j] = (unsigned char)(lcd_para[j] & 0xff);
+                            lcd_print("0x%02x ", pConf->lcd_control.mipi_config->dsi_init_on[j]);
+                        }
+                        lcd_print("\n");
+                    }
+                }
+            }
+            //detect dsi init off table
+            if (pConf->lcd_control.mipi_config->dsi_init_off != NULL) {
+                ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", 0, &lcd_para[0]);
+                if (ret) {
+                    printk("faild to get dsi_init_off\n");
+                }
+                else {
+                    i = 0;
+                    while (i < DSI_INIT_OFF_MAX) {
+                        ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", i, &val);
+                        if (val == 0xff) {
+                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", (i+1), &val);
+                            i += 2;
+                            if (val == 0xff)
+                                break;
+                        }
+                        else if ((val & 0xf) == 0x0) {
+                            printk("get dsi_init_off wrong data_type: 0x%02x\n", val);
+                            break;
+                        }
+                        else {
+                            ret = of_property_read_u32_index(lcd_model_node,"dsi_init_off", (i+DSI_CMD_CNT_INDEX), &val);
+                            if (val > 0xffff)
+                                break;
+                            else
+                                i = i + (DSI_CMD_CNT_INDEX + 1) + (val & 0xff);
+                        }
+                    }
+                    i = (i > DSI_INIT_OFF_MAX) ? DSI_INIT_OFF_MAX : i;
+                    ret = of_property_read_u32_array(lcd_model_node,"dsi_init_off", &lcd_para[0], i);
+                    if(ret){
+                        printk("faild to get dsi_init_off\n");
+                    }
+                    else {
+                        lcd_print("dsi_init_off: ");
+                        for (j=0; j<i; j++) {
+                            pConf->lcd_control.mipi_config->dsi_init_off[j] = (unsigned char)(lcd_para[j] & 0xff);
+                            lcd_print("0x%02x ", pConf->lcd_control.mipi_config->dsi_init_off[j]);
+                        }
+                        lcd_print("\n");
+                    }
+                }
+            }
+            ret = of_property_read_u32(lcd_model_node,"lcd_extern_init",&val);
+            if(ret){
+                printk("faild to get lcd_extern_init\n");
+                pConf->lcd_control.mipi_config->lcd_extern_init =0;
+            } else {
+                pConf->lcd_control.mipi_config->lcd_extern_init =(unsigned char)(val);
+            }
+            lcd_print("lcd_extern_init = %d\n",  pConf->lcd_control.mipi_config->lcd_extern_init);
+        }
+        else if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_EDP) {
+            ret = of_property_read_u32(lcd_model_node,"max_lane_count",&val);
+            if(ret){
+                printk("faild to get max_lane_count\n");
+                pConf->lcd_control.edp_config->max_lane_count = 4;
+            } else {
+                pConf->lcd_control.edp_config->max_lane_count =(unsigned char)(val);
+            }
+            lcd_print("max_lane_count = %d\n", pConf->lcd_control.edp_config->max_lane_count);
+        }
+    }
+    kfree(lcd_para);
+    return ret;
+}
+
+static int _get_lcd_default_config(Lcd_Config_t *pConf, struct platform_device *pdev)
+{
+	int ret=0;
+	unsigned int val;
+	unsigned int lcd_para[5];
+	//unsigned int gamma_temp[256];
+	unsigned int *gamma_temp = (unsigned int *)kmalloc(sizeof(unsigned int)*256, GFP_KERNEL);
+	int i;
+	unsigned int lcd_gamma_multi = 0;
+
+	if (gamma_temp == NULL) {
+		printk("[_get_lcd_default_config]: Not enough memory\n");
+		return -1;
+	}
+	//pdev->dev.of_node = of_find_node_by_name(NULL,"lcd");
+	if (pdev->dev.of_node) {
+		if (pConf->lcd_basic.lcd_bits_option == 1) {
+			ret = of_property_read_u32(pdev->dev.of_node,"lcd_bits_user",&val);
+			if(ret){
+				printk("don't find to match lcd_bits_user, use panel typical setting.\n");
+			}
+			else {
+				pConf->lcd_basic.lcd_bits = (unsigned short)(val);
+				printk("lcd_bits = %u\n", pConf->lcd_basic.lcd_bits);
+			}
+		}
+		//ttl & lvds config
+		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_TTL) {
+			ret = of_property_read_u32_array(pdev->dev.of_node,"ttl_rb_bit_swap",&lcd_para[0], 2);
+			if(ret){
+				printk("don't find to match ttl_rb_bit_swap, use default setting.\n");
+			}
+			else {
+				pConf->lcd_control.ttl_config->rb_swap = (unsigned char)(lcd_para[0]);
+				pConf->lcd_control.ttl_config->bit_swap = (unsigned char)(lcd_para[1]);
+				printk("ttl rb_swap = %u, bit_swap = %u\n", pConf->lcd_control.ttl_config->rb_swap, pConf->lcd_control.ttl_config->bit_swap);
+			}
+		}
+		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
+			ret = of_property_read_u32(pdev->dev.of_node,"lvds_channel_pn_swap",&val);
+			if(ret){
+				printk("don't find to match lvds_channel_pn_swap, use default setting.\n");
+			}
+			else {
+				pConf->lcd_control.lvds_config->pn_swap = val;
+				printk("lvds_pn_swap = %u\n", pConf->lcd_control.lvds_config->pn_swap);
+			}
+		}
+
+		//recommend setting
+		ret = of_property_read_u32_array(pdev->dev.of_node,"valid_hvsync_de",&lcd_para[0], 2);
+		if(ret){
+			printk("don't find to match valid_hvsync_de, use default setting.\n");
+		}
+		else {
+			pConf->lcd_timing.hvsync_valid = (unsigned short)(lcd_para[0]);
+			pConf->lcd_timing.de_valid = (unsigned short)(lcd_para[1]);
+			lcd_print("valid hvsync = %u, de = %u\n", pConf->lcd_timing.hvsync_valid, pConf->lcd_timing.de_valid);
+		}
+		ret = of_property_read_u32_array(pdev->dev.of_node,"hsign_hoffset_vsign_voffset",&lcd_para[0], 4);
+		if(ret){
+			printk("don't find to match hsign_hoffset_vsign_voffset, use default setting.\n");
+			pConf->lcd_timing.h_offset = 0;
+			pConf->lcd_timing.v_offset = 0;
+		}
+		else {
+			pConf->lcd_timing.h_offset = ((lcd_para[0] << 31) | ((lcd_para[1] & 0xffff) << 0));
+			pConf->lcd_timing.v_offset = ((lcd_para[2] << 31) | ((lcd_para[3] & 0xffff) << 0));
+			lcd_print("h_offset = %s%u, ", (((pConf->lcd_timing.h_offset >> 31) & 1) ? "-" : ""), (pConf->lcd_timing.h_offset & 0xffff));
+			lcd_print("v_offset = %s%u\n", (((pConf->lcd_timing.v_offset >> 31) & 1) ? "-" : ""), (pConf->lcd_timing.v_offset & 0xffff));
+		}
+		ret = of_property_read_u32_array(pdev->dev.of_node,"dither_user_ctrl",&lcd_para[0], 2);
+		if(ret){
+			printk("don't find to match dither_user_ctrl, use default setting.\n");
+			pConf->lcd_effect.dith_user = 0;
+		}
+		else {
+			pConf->lcd_effect.dith_user = (unsigned short)(lcd_para[0]);
+			pConf->lcd_effect.dith_cntl_addr = (unsigned short)(lcd_para[1]);
+			lcd_print("dither_user = %u, dither_ctrl = 0x%x\n", pConf->lcd_effect.dith_user, pConf->lcd_effect.dith_cntl_addr);
+		}
+		ret = of_property_read_u32_array(pdev->dev.of_node,"vadj_brightness_contrast_saturation",&lcd_para[0], 3);
+		if(ret){
+			printk("don't find to match vadj_brightness_contrast_saturation, use default setting.\n");
+		}
+		else {
+			pConf->lcd_effect.vadj_brightness = lcd_para[0];
+			pConf->lcd_effect.vadj_contrast = lcd_para[1];
+			pConf->lcd_effect.vadj_saturation = lcd_para[2];
+			lcd_print("vadj_brightness = 0x%x, vadj_contrast = 0x%x, vadj_saturation = 0x%x\n", pConf->lcd_effect.vadj_brightness, pConf->lcd_effect.vadj_contrast, pConf->lcd_effect.vadj_saturation);
+		}
+		ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_en_reverse",&lcd_para[0], 2);
+		if(ret){
+			printk("don't find to match gamma_en_reverse, use default setting.\n");
+		}
+		else {
+			pConf->lcd_effect.gamma_ctrl = ((lcd_para[0] << GAMMA_CTRL_EN) | (lcd_para[1] << GAMMA_CTRL_REVERSE));
+			lcd_print("gamma_en = %u, gamma_reverse=%u\n", ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_EN) & 1), ((pConf->lcd_effect.gamma_ctrl >> GAMMA_CTRL_REVERSE) & 1));
+		}
+		ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_multi_rgb_coeff",&lcd_para[0], 4);
+		if(ret){
+			printk("don't find to match gamma_multi_rgb_coeff, use default setting.\n");
+		}
+		else {
+			lcd_gamma_multi = lcd_para[0];
+			pConf->lcd_effect.gamma_r_coeff = (unsigned short)(lcd_para[1]);
+			pConf->lcd_effect.gamma_g_coeff = (unsigned short)(lcd_para[2]);
+			pConf->lcd_effect.gamma_b_coeff = (unsigned short)(lcd_para[3]);
+			lcd_print("gamma_multi = %u, gamma_r_coeff = %u, gamma_g_coeff = %u, gamma_b_coeff = %u\n", lcd_gamma_multi, pConf->lcd_effect.gamma_r_coeff, pConf->lcd_effect.gamma_g_coeff, pConf->lcd_effect.gamma_b_coeff);
+		}
+		if (lcd_gamma_multi == 1) {
+			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table_r",&gamma_temp[0], 256);
+			if(ret){
+				printk("don't find to match gamma_table_r, use default table.\n");
+				lcd_setup_gamma_table(pConf, 0);
+			}
+			else {
+				for (i=0; i<256; i++) {
+					pConf->lcd_effect.GammaTableR[i] = (unsigned short)(gamma_temp[i] << 2);
+				}
+				lcd_print("load gamma_table_r.\n");
+			}
+			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table_g",&gamma_temp[0], 256);
+			if(ret){
+				printk("don't find to match gamma_table_g, use default table.\n");
+				lcd_setup_gamma_table(pConf, 1);
+			}
+			else {
+				for (i=0; i<256; i++) {
+					pConf->lcd_effect.GammaTableG[i] = (unsigned short)(gamma_temp[i] << 2);
+				}
+				lcd_print("load gamma_table_g.\n");
+			}
+			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table_b",&gamma_temp[0], 256);
+			if(ret){
+				printk("don't find to match gamma_table_b, use default table.\n");
+				lcd_setup_gamma_table(pConf, 2);
+			}
+			else {
+				for (i=0; i<256; i++) {
+					pConf->lcd_effect.GammaTableB[i] = (unsigned short)(gamma_temp[i] << 2);
+				}
+				lcd_print("load gamma_table_b.\n");
+			}
+		}
+		else {
+			ret = of_property_read_u32_array(pdev->dev.of_node,"gamma_table",&gamma_temp[0], 256);
+			if(ret){
+				printk("don't find to match gamma_table, use default table.\n");
+				lcd_setup_gamma_table(pConf, 3);
+			}
+			else {
+				for (i=0; i<256; i++) {
+					pConf->lcd_effect.GammaTableR[i] = (unsigned short)(gamma_temp[i] << 2);
+					pConf->lcd_effect.GammaTableG[i] = (unsigned short)(gamma_temp[i] << 2);
+					pConf->lcd_effect.GammaTableB[i] = (unsigned short)(gamma_temp[i] << 2);
+				}
+				lcd_print("load gamma_table.\n");
+			}
+		}
+
+		//default setting
+		ret = of_property_read_u32(pdev->dev.of_node,"clock_spread_spectrum",&val);
+		if(ret){
+			printk("don't find to match clock_spread_spectrum, use default setting.\n");
+		}
+		else {
+			pConf->lcd_timing.clk_ctrl = ((pConf->lcd_timing.clk_ctrl & ~(0xf << CLK_CTRL_SS)) | (val << CLK_CTRL_SS));
+			lcd_print("lcd clock spread spectrum = %u\n", (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_SS) & 0xf);
+		}
+		ret = of_property_read_u32(pdev->dev.of_node,"clock_auto_generation",&val);
+		if(ret){
+			printk("don't find to match clock_auto_generation, use default setting.\n");
+		}
+		else {
+			pConf->lcd_timing.clk_ctrl = ((pConf->lcd_timing.clk_ctrl & ~(1 << CLK_CTRL_AUTO)) | (val << CLK_CTRL_AUTO));
+			lcd_print("lcd clock auto_generation = %u\n", (pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 0x1);
+		}
+		if (((pConf->lcd_timing.clk_ctrl >> CLK_CTRL_AUTO) & 0x1) == 0) {
+			ret = of_property_read_u32_array(pdev->dev.of_node,"clk_pll_div_clk_ctrl",&lcd_para[0], 3);
+			if(ret){
+				printk("don't find to match clk_pll_div_clk_ctrl, use default setting.\n");
+			}
+			else {
+				pConf->lcd_timing.pll_ctrl = lcd_para[0];
+				pConf->lcd_timing.div_ctrl = lcd_para[1];
+				pConf->lcd_timing.clk_ctrl = lcd_para[2];
+				printk("pll_ctrl = 0x%x, div_ctrl = 0x%x, clk_ctrl=0x%x\n", pConf->lcd_timing.pll_ctrl, pConf->lcd_timing.div_ctrl, (pConf->lcd_timing.clk_ctrl & 0xffff));
+			}
+		}
+		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_LVDS) {
+			ret = of_property_read_u32(pdev->dev.of_node,"lvds_vswing",&val);
+			if(ret){
+				printk("don't find to match lvds_vswing, use default setting.\n");
+			}
+			else {
+				pConf->lcd_control.lvds_config->lvds_vswing = val;
+				printk("lvds_vswing level = %u\n", pConf->lcd_control.lvds_config->lvds_vswing = val);
+			}
+			ret = of_property_read_u32_array(pdev->dev.of_node,"lvds_user_repack",&lcd_para[0], 2);
+			if(ret){
+				printk("don't find to match lvds_user_repack, use default setting.\n");
+				pConf->lcd_control.lvds_config->lvds_repack_user = 0;
+				pConf->lcd_control.lvds_config->lvds_repack = 1;
+			}
+			else {
+				pConf->lcd_control.lvds_config->lvds_repack_user = lcd_para[0];
+				pConf->lcd_control.lvds_config->lvds_repack = lcd_para[1];
+				if (lcd_para[0] > 0) {
+					printk("lvds_repack = %u\n", pConf->lcd_control.lvds_config->lvds_repack);
+				}
+				else {
+					lcd_print("lvds_repack_user = %u, lvds_repack = %u\n", pConf->lcd_control.lvds_config->lvds_repack_user, pConf->lcd_control.lvds_config->lvds_repack);
+				}
+			}
+		}
+		if (pConf->lcd_basic.lcd_type == LCD_DIGITAL_EDP) {
+			ret = of_property_read_u32_array(pdev->dev.of_node,"edp_user_link_rate_lane_count",&lcd_para[0], 3);
+			if(ret){
+				pConf->lcd_control.edp_config->link_user = 0;
+				pConf->lcd_control.edp_config->link_rate = 1;
+				pConf->lcd_control.edp_config->lane_count = 4;
+				printk("don't find to match edp_user_link_rate_lane_count, use default setting.\n");
+			}
+			else {
+				pConf->lcd_control.edp_config->link_user = (unsigned char)(lcd_para[0]);
+				pConf->lcd_control.edp_config->link_rate = (unsigned char)(lcd_para[1]);
+				pConf->lcd_control.edp_config->lane_count = (unsigned char)(lcd_para[2]);
+				if (pConf->lcd_control.edp_config->link_user > 0) {
+					printk("edp link_rate = %s, lane_count = %u\n", ((pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pConf->lcd_control.edp_config->lane_count);
+				}
+				else {
+					lcd_print("edp user = %u, link_rate = %s, lane_count = %u\n", pConf->lcd_control.edp_config->link_user, ((pConf->lcd_control.edp_config->link_rate == 0) ? "1.62G":"2.7G"), pConf->lcd_control.edp_config->lane_count);
+				}
+			}
+			ret = of_property_read_u32_array(pdev->dev.of_node,"edp_link_adaptive_vswing",&lcd_para[0], 2);
+			if(ret){
+				printk("don't find to match edp_link_adaptive_vswing, use default setting.\n");
+				pConf->lcd_control.edp_config->link_adaptive = 0;
+				pConf->lcd_control.edp_config->vswing = 0;
+				pConf->lcd_control.edp_config->preemphasis = 0;
+			}
+			else {
+				pConf->lcd_control.edp_config->link_adaptive = (unsigned char)(lcd_para[0]);
+				pConf->lcd_control.edp_config->vswing = (unsigned char)(lcd_para[1]);
+				pConf->lcd_control.edp_config->preemphasis = 0;
+				if (pConf->lcd_control.edp_config->link_adaptive == 0) {
+					printk("edp swing_level = %u\n", pConf->lcd_control.edp_config->vswing);
+				}
+				else {
+					lcd_print("edp link_adaptive = %u, swing_level = %u\n", pConf->lcd_control.edp_config->link_adaptive, pConf->lcd_control.edp_config->vswing);
+				}
+			}
+			ret = of_property_read_u32(pdev->dev.of_node,"edp_sync_clock_mode",&val);
+			if(ret){
+				printk("don't find to match edp_sync_clock_mode, use default setting.\n");
+				pConf->lcd_control.edp_config->sync_clock_mode = 1;
+			}
+			else {
+				pConf->lcd_control.edp_config->sync_clock_mode = (val & 1);
+				printk("edp sync_clock_mode = %u\n", pConf->lcd_control.edp_config->sync_clock_mode);
+			}
+			ret = of_property_read_u32(pdev->dev.of_node,"edp_edid_timing_used",&val);
+			if(ret){
+				printk("don't find to match edp_edid_timing_used, use default setting.\n");
+				pConf->lcd_control.edp_config->edid_timing_used = 0;
+			}
+			else {
+				pConf->lcd_control.edp_config->edid_timing_used = (unsigned char)(val & 1);
+				printk("edp edid_timing_used = %u\n", pConf->lcd_control.edp_config->edid_timing_used);
+			}
+		}
+		ret = of_property_read_u32_array(pdev->dev.of_node,"rgb_base_coeff",&lcd_para[0], 2);
+		if(ret){
+			printk("don't find to match rgb_base_coeff, use default setting.\n");
+		}
+		else {
+			pConf->lcd_effect.rgb_base_addr = (unsigned short)(lcd_para[0]);
+			pConf->lcd_effect.rgb_coeff_addr = (unsigned short)(lcd_para[1]);
+			lcd_print("rgb_base = 0x%x, rgb_coeff = 0x%x\n", pConf->lcd_effect.rgb_base_addr, pConf->lcd_effect.rgb_coeff_addr);
+		}
+		// ret = of_property_read_u32_array(pdev->dev.of_node,"video_on_pixel_line",&lcd_para[0], 2);
+		// if(ret){
+			// printk("don't find to match video_on_pixel_line, use default setting.\n");
+		// }
+		// else {
+			// pConf->lcd_timing.video_on_pixel = (unsigned short)(lcd_para[0]);
+			// pConf->lcd_timing.video_on_line = (unsigned short)(lcd_para[1]);
+			// lcd_print("video_on_pixel = %u, video_on_line = %u\n", pConf->lcd_timing.video_on_pixel, pConf->lcd_timing.video_on_line);
+		// }
+	}
+	kfree(gamma_temp);
+	return ret;
+}
+
+static int _get_lcd_power_config(Lcd_Config_t *pConf, struct platform_device *pdev)
+{
+	int ret=0;
+	const char *str;
+	unsigned char propname[20];
+	int val;
+	unsigned int lcd_para[LCD_POWER_CTRL_STEP_MAX];
+	int i;
+	int index;
+
+	if (pdev->dev.of_node) {
+		//lcd power on
+		for (i=0; i < LCD_POWER_CTRL_STEP_MAX; i++) {
+			//propname = kasprintf(GFP_KERNEL, "power_on_step_%d", i+1);
+			sprintf(propname, "power_on_step_%d", i+1);
+			ret = of_property_read_string_index(pdev->dev.of_node, propname, 0, &str);
+			if (ret) {
+				lcd_print("faild to get %s\n", propname);
+				break;
+			}
+			else if ((strcasecmp(str, "null") == 0) || ((strcasecmp(str, "n") == 0))) {
+				break;
+			}
+			else {
+				lcd_print("%s 0: %s\n", propname, str);
+				for(index = 0; index < LCD_POWER_TYPE_MAX; index++) {
+					if(!strcasecmp(str, lcd_power_type_table[index]))
+						break;
+				}
+				pConf->lcd_power_ctrl.power_on_config[i].type = index;
+
+				if (pConf->lcd_power_ctrl.power_on_config[i].type < LCD_POWER_TYPE_SIGNAL) {
+					ret = of_property_read_string_index(pdev->dev.of_node, propname, 1, &str);
+					if (ret) {
+						printk("faild to get %s index 1\n", propname);
+					}
+					else {
+						if (pConf->lcd_power_ctrl.power_on_config[i].type == LCD_POWER_TYPE_CPU) {
+							val = amlogic_gpio_name_map_num(str);
+							ret = lcd_gpio_request(val);
+							if (ret) {
+							  printk("faild to alloc lcd power ctrl gpio (%s)\n", str);
+							}
+							pConf->lcd_power_ctrl.power_on_config[i].gpio = val;
+						}
+						else if (pConf->lcd_power_ctrl.power_on_config[i].type == LCD_POWER_TYPE_PMU) {
+							pConf->lcd_power_ctrl.power_on_config[i].gpio = amlogic_pmu_gpio_name_map_num(str);
+						}
+					}
+					ret = of_property_read_string_index(pdev->dev.of_node, propname, 2, &str);
+					if (ret) {
+						printk("faild to get %s\n", propname);
+					}
+					else {
+						if ((strcasecmp(str, "output_low") == 0) || (strcasecmp(str, "0") == 0)) {
+							pConf->lcd_power_ctrl.power_on_config[i].value = LCD_POWER_GPIO_OUTPUT_LOW;
+						}
+						else if ((strcasecmp(str, "output_high") == 0) || (strcasecmp(str, "1") == 0)) {
+							pConf->lcd_power_ctrl.power_on_config[i].value = LCD_POWER_GPIO_OUTPUT_HIGH;
+						}
+						else if ((strcasecmp(str, "input") == 0) || (strcasecmp(str, "2") == 0)) {
+							pConf->lcd_power_ctrl.power_on_config[i].value = LCD_POWER_GPIO_INPUT;
+						}
+					}
+				}
+			}
+		}
+		pConf->lcd_power_ctrl.power_on_step = i;
+		lcd_print("lcd_power_on_step = %d\n", pConf->lcd_power_ctrl.power_on_step);
+
+		ret = of_property_read_u32_array(pdev->dev.of_node,"power_on_delay",&lcd_para[0],pConf->lcd_power_ctrl.power_on_step);
+		if (ret) {
+			printk("faild to get power_on_delay\n");
+		}
+		else {
+			for (i=0; i<pConf->lcd_power_ctrl.power_on_step; i++) {
+				pConf->lcd_power_ctrl.power_on_config[i].delay = (unsigned short)(lcd_para[i]);
+			}
+		}
+		//lcd power off
+		for (i=0; i < LCD_POWER_CTRL_STEP_MAX; i++) {
+			sprintf(propname, "power_off_step_%d", i+1);
+			//propname = kasprintf(GFP_KERNEL, "power_off_step_%d", i+1);
+			ret = of_property_read_string_index(pdev->dev.of_node, propname, 0, &str);
+			if (ret) {
+				lcd_print("faild to get %s index 0\n", propname);
+				break;
+			}
+			else if ((strcasecmp(str, "null") == 0) || ((strcasecmp(str, "n") == 0))) {
+				break;
+			}
+			else {
+				lcd_print("%s 0: %s\n", propname, str);
+				for(index = 0; index < LCD_POWER_TYPE_MAX; index++) {
+					if(!strcasecmp(str, lcd_power_type_table[index]))
+						break;
+				}
+				pConf->lcd_power_ctrl.power_off_config[i].type = index;
+
+				if (pConf->lcd_power_ctrl.power_off_config[i].type < LCD_POWER_TYPE_SIGNAL) {
+					ret = of_property_read_string_index(pdev->dev.of_node, propname, 1, &str);
+					if (ret) {
+						printk("faild to get %s index 1\n", propname);
+					}
+					else {
+						if (pConf->lcd_power_ctrl.power_off_config[i].type == LCD_POWER_TYPE_CPU) {
+							val = amlogic_gpio_name_map_num(str);
+							pConf->lcd_power_ctrl.power_off_config[i].gpio = val;
+						}
+						else if (pConf->lcd_power_ctrl.power_off_config[i].type == LCD_POWER_TYPE_PMU) {
+							pConf->lcd_power_ctrl.power_off_config[i].gpio = amlogic_pmu_gpio_name_map_num(str);
+						}
+					}
+					ret = of_property_read_string_index(pdev->dev.of_node, propname, 2, &str);
+					if (ret) {
+						printk("faild to get %s index 2\n", propname);
+					}
+					else {
+						if ((strcasecmp(str, "output_low") == 0) || (strcasecmp(str, "0") == 0)) {
+							pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_OUTPUT_LOW;
+						}
+						else if ((strcasecmp(str, "output_high") == 0) || (strcasecmp(str, "1") == 0)) {
+							pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_OUTPUT_HIGH;
+						}
+						else if ((strcasecmp(str, "input") == 0) || (strcasecmp(str, "2") == 0)) {
+							pConf->lcd_power_ctrl.power_off_config[i].value = LCD_POWER_GPIO_INPUT;
+						}
+					}
+				}
+			}
+		}
+		pConf->lcd_power_ctrl.power_off_step = i;
+		lcd_print("lcd_power_off_step = %d\n", pConf->lcd_power_ctrl.power_off_step);
+
+		ret = of_property_read_u32_array(pdev->dev.of_node,"power_off_delay",&lcd_para[0],pConf->lcd_power_ctrl.power_off_step);
+		if (ret) {
+			printk("faild to get power_off_delay\n");
+		}
+		else {
+			for (i=0; i<pConf->lcd_power_ctrl.power_off_step; i++) {
+				pConf->lcd_power_ctrl.power_off_config[i].delay = (unsigned short)(lcd_para[i]);
+			}
+		}
+
+		for (i=0; i<pConf->lcd_power_ctrl.power_on_step; i++) {
+			lcd_print("power on step %d: type = %s(%d)\n", i+1, lcd_power_type_table[pConf->lcd_power_ctrl.power_on_config[i].type], pConf->lcd_power_ctrl.power_on_config[i].type);
+			lcd_print("power on step %d: gpio = %d\n", i+1, pConf->lcd_power_ctrl.power_on_config[i].gpio);
+			lcd_print("power on step %d: value = %d\n", i+1, pConf->lcd_power_ctrl.power_on_config[i].value);
+			lcd_print("power on step %d: delay = %d\n", i+1, pConf->lcd_power_ctrl.power_on_config[i].delay);
+		}
+
+		for (i=0; i<pConf->lcd_power_ctrl.power_off_step; i++) {
+			lcd_print("power off step %d: type = %s(%d)\n", i+1, lcd_power_type_table[pConf->lcd_power_ctrl.power_off_config[i].type], pConf->lcd_power_ctrl.power_off_config[i].type);
+			lcd_print("power off step %d: gpio = %d\n", i+1, pConf->lcd_power_ctrl.power_off_config[i].gpio);
+			lcd_print("power off step %d: value = %d\n", i+1, pConf->lcd_power_ctrl.power_off_config[i].value);
+			lcd_print("power off step %d: delay = %d\n", i+1, pConf->lcd_power_ctrl.power_off_config[i].delay);
+		}
+
+		pConf->lcd_misc_ctrl.pin = devm_pinctrl_get(&pdev->dev);
+		if (IS_ERR(pConf->lcd_misc_ctrl.pin))
+			printk("get lcd ttl ports pinmux error.\n");
+	}
+	return ret;
+}
+#endif
+
+#ifdef CONFIG_USE_OF
+static const struct of_device_id lcd_dt_match[] = {
+	{
+		.compatible = "amlogic,lcd",
+	},
+	{},
+};
+#else
+#define lcd_dt_match NULL
+#endif
+
+static void lcd_config_assign(Lcd_Config_t *pConf)
+{
+    pConf->lcd_power_ctrl.power_ctrl = lcd_power_ctrl;
+}
+
+static struct notifier_block lcd_reboot_nb;
+static int lcd_probe(struct platform_device *pdev)
+{
+#ifndef CONFIG_USE_OF
+	struct aml_lcd_platform *pdata;
+#endif
+	int ret = 0;
+
+	pDev = (lcd_dev_t *)kmalloc(sizeof(lcd_dev_t), GFP_KERNEL);
+	if (!pDev) {
+		printk("[lcd probe]: Not enough memory.\n");
+		return -ENOMEM;
+	}
+
+#ifdef CONFIG_USE_OF
+	//pdata = lcd_get_driver_data(pdev);
+	pDev->pConf = get_lcd_config();
+	_get_lcd_model_timing(pDev->pConf, pdev);
+	_get_lcd_default_config(pDev->pConf, pdev);
+	_get_lcd_power_config(pDev->pConf, pdev);
+#else
+	pdata = pdev->dev.platform_data;
+	pDev->pConf = (Lcd_Config_t *)(pdata->lcd_conf);
+#endif
+
+	creat_lcd_class();
+	lcd_config_assign(pDev->pConf);
+	lcd_config_probe(pDev->pConf);
+	save_lcd_config(pDev->pConf);
+
+	pDev->pConf->lcd_misc_ctrl.print_version();
+	lcd_config_init(pDev->pConf);
+	_init_vout();
+
+	lcd_reboot_nb.notifier_call = lcd_reboot_notifier;
+	ret = register_reboot_notifier(&lcd_reboot_nb);
+	if (ret) {
+		printk("notifier register lcd_reboot_notifier fail!\n");
+	}
+
+	ret = creat_lcd_attr();
+#ifdef CONFIG_AML_GAMMA_DEBUG
+	save_original_gamma(pDev->pConf);
+	ret = creat_lcd_gamma_attr();
+#endif
+
+	printk("LCD probe ok\n");
+	return 0;
+}
+
+static int lcd_remove(struct platform_device *pdev)
+{
+	unregister_reboot_notifier(&lcd_reboot_nb);
+
+	lcd_config_remove(pDev->pConf);
+	remove_lcd_attr();
+	remove_lcd_class();
+#ifdef CONFIG_AML_GAMMA_DEBUG
+	remove_lcd_gamma_attr();
+#endif
+
+	if (pDev->pConf->lcd_basic.model_name)
+		kfree(pDev->pConf->lcd_basic.model_name);
+	if (pDev)
+		kfree(pDev);
+
+    return 0;
+}
+
+//device tree
+static struct platform_driver lcd_driver = {
+	.probe = lcd_probe,
+	.remove = lcd_remove,
+	.driver = {
+		.name = "mesonlcd",
+		.owner = THIS_MODULE,
+#ifdef CONFIG_USE_OF
+		.of_match_table = lcd_dt_match,
+#endif
+	},
+};
+
+static int __init lcd_init(void)
+{
+    lcd_print("LCD driver init\n");
+    if (platform_driver_register(&lcd_driver)) {
+        printk("failed to register lcd driver module\n");
+        return -ENODEV;
+    }
+
+    return 0;
+}
+
+static void __exit lcd_exit(void)
+{
+    platform_driver_unregister(&lcd_driver);
+}
+
+subsys_initcall(lcd_init);
+module_exit(lcd_exit);
+
+MODULE_DESCRIPTION("Meson LCD Panel Driver");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Amlogic, Inc.");
diff --git a/drivers/amlogic/display/vout/tvconf.c b/drivers/amlogic/display/vout/tvconf.c
old mode 100644
new mode 100755
index 49c69577..b01a88d7
--- a/drivers/amlogic/display/vout/tvconf.c
+++ b/drivers/amlogic/display/vout/tvconf.c
@@ -39,6 +39,9 @@
 #include <linux/ctype.h>
 #include <linux/amlogic/vout/vinfo.h>
 #include <mach/am_regs.h>
+#ifdef CONFIG_HIBERNATION
+#include <linux/syscore_ops.h>
+#endif
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 #include <mach/vpu.h>
@@ -53,7 +56,8 @@
 
 #define PIN_MUX_REG_0	  0x202c
 #define P_PIN_MUX_REG_0  CBUS_REG_ADDR(PIN_MUX_REG_0)
-static    disp_module_info_t    *info;
+static    disp_module_info_t	disp_module_info __nosavedata;
+static    disp_module_info_t    *info __nosavedata;
 static void  parse_vdac_setting(char *para);
 
 SET_TV_CLASS_ATTR(vdac_setting,parse_vdac_setting)
@@ -82,75 +86,77 @@ SET_TV_CLASS_ATTR(policy_fr_auto, policy_framerate_automation_store)
 *	S-CHRO	----  DAC0
 ******************************/
 
-static const tvmode_t vmode_tvmode_tab[] =
-{
-	TVMODE_480X320P_60HZ, TVMODE_480X272P_60HZ, TVMODE_480I, TVMODE_480I_RPT, TVMODE_480CVBS, TVMODE_480P, 
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	TVMODE_480P_59HZ,
-#endif
-	TVMODE_480P_RPT, TVMODE_576I, TVMODE_576I_RPT, TVMODE_576CVBS, TVMODE_576P, TVMODE_576P_RPT, TVMODE_720P, 
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	TVMODE_720P_59HZ , // for 720p 59.94hz
-#endif
-	TVMODE_800P, TVMODE_800X480P_60HZ, TVMODE_480X800P_60HZ, TVMODE_1366X768P_60HZ,
-	TVMODE_1600X900P_60HZ, TVMODE_800X600P_60HZ, TVMODE_1024X600P_60HZ,
-	TVMODE_1024X768P_60HZ, TVMODE_1360X768P_60HZ, TVMODE_1440X900P_60HZ,
-	TVMODE_1680X1050P_60HZ,
-	TVMODE_1080I, 
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	TVMODE_1080I_59HZ,
-#endif	
-	TVMODE_1080P,
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	TVMODE_1080P_59HZ , // for 1080p 59.94hz
-#endif
-    TVMODE_720P_50HZ, TVMODE_1080I_50HZ, TVMODE_1080P_50HZ,TVMODE_1080P_24HZ, 
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	TVMODE_1080P_23HZ , // for 1080p 23.97hz
-#endif
-	TVMODE_4K2K_30HZ, 
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-		TVMODE_4K2K_29HZ , // for 4k2k 29.97hz
-#endif
-	TVMODE_4K2K_25HZ, TVMODE_4K2K_24HZ, 
+struct vmode_tvmode_tab_t {
+    tvmode_t tvmode;
+    vmode_t  mode;
+};
+
+static struct vmode_tvmode_tab_t mode_tab[] = {
+    {TVMODE_480I, VMODE_480I},
+    {TVMODE_480I_RPT, VMODE_480I_RPT},
+    {TVMODE_480CVBS, VMODE_480CVBS},
+    {TVMODE_480P, VMODE_480P},
+    {TVMODE_480P_RPT, VMODE_480P_RPT},
+    {TVMODE_576I, VMODE_576I},
+    {TVMODE_576I_RPT, VMODE_576I_RPT},
+    {TVMODE_576CVBS, VMODE_576CVBS},
+    {TVMODE_576P, VMODE_576P},
+    {TVMODE_576P_RPT, VMODE_576P_RPT},
+    {TVMODE_720P, VMODE_720P},
+    {TVMODE_1080I, VMODE_1080I},
+    {TVMODE_1080P, VMODE_1080P},
+    {TVMODE_720P_50HZ, VMODE_720P_50HZ},
+    {TVMODE_1080I_50HZ, VMODE_1080I_50HZ},
+    {TVMODE_1080P_50HZ, VMODE_1080P_50HZ},
+    {TVMODE_1080P_24HZ, VMODE_1080P_24HZ},
+    {TVMODE_4K2K_30HZ, VMODE_4K2K_30HZ},
+    {TVMODE_4K2K_25HZ, VMODE_4K2K_25HZ},
+    {TVMODE_4K2K_24HZ, VMODE_4K2K_24HZ},
+    {TVMODE_4K2K_SMPTE, VMODE_4K2K_SMPTE},
+    {TVMODE_4K2K_60HZ_Y420, VMODE_4K2K_60HZ_Y420},
+    {TVMODE_4K2K_50HZ_Y420, VMODE_4K2K_50HZ_Y420},
+    {TVMODE_4K2K_50HZ, VMODE_4K2K_50HZ},
+    {TVMODE_VGA, VMODE_VGA},
+    {TVMODE_SVGA, VMODE_SVGA},
+    {TVMODE_XGA, VMODE_XGA},
+    {TVMODE_SXGA, VMODE_SXGA},
+    {TVMODE_WSXGA, VMODE_WSXGA},
+    {TVMODE_FHDVGA, VMODE_FHDVGA},
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-		TVMODE_4K2K_23HZ , // for 4k2k 23.97hz
+    {TVMODE_480P_59HZ, VMODE_480P_59HZ},
+    {TVMODE_720P_59HZ, VMODE_720P_59HZ}, // for 720p 59.94hz
+    {TVMODE_1080I_59HZ, VMODE_1080I_59HZ},
+    {TVMODE_1080P_59HZ, VMODE_1080P_59HZ}, // for 1080p 59.94hz
+    {TVMODE_1080P_23HZ, VMODE_1080P_23HZ}, // for 1080p 23.97hz
+    {TVMODE_4K2K_29HZ, VMODE_4K2K_29HZ}, // for 4k2k 29.97hz
+    {TVMODE_4K2K_23HZ, VMODE_4K2K_23HZ}, // for 4k2k 23.97hz
 #endif
-	TVMODE_4K2K_SMPTE, 
-    VMODE_1920x1200,
-    TVMODE_VGA, TVMODE_SVGA, TVMODE_XGA, TVMODE_SXGA, TVMODE_WSXGA, TVMODE_FHDVGA,
+    {TVMODE_4K1K_100HZ, VMODE_4K1K_100HZ},
+    {TVMODE_4K1K_100HZ_Y420, VMODE_4K1K_100HZ_Y420},
+    {TVMODE_4K1K_120HZ, VMODE_4K1K_120HZ},
+    {TVMODE_4K1K_120HZ_Y420, VMODE_4K1K_120HZ_Y420},
+    {TVMODE_4K05K_200HZ, VMODE_4K05K_200HZ},
+    {TVMODE_4K05K_200HZ_Y420, VMODE_4K05K_200HZ_Y420},
+    {TVMODE_4K05K_240HZ, VMODE_4K05K_240HZ},
+    {TVMODE_4K05K_240HZ_Y420, VMODE_4K05K_240HZ_Y420},
 };
 
+static const tvmode_t vmode_tvmode_map(vmode_t mode)
+{
+    int i = 0;
+
+    for (i = 0; i < ARRAY_SIZE(mode_tab); i++) {
+        if (mode == mode_tab[i].mode)
+            return mode_tab[i].tvmode;
+    }
+    return TVMODE_MAX;
+}
 
 static const vinfo_t tv_info[] = 
 {
-    { /* VMODE_480X320P_60HZ */
-		.name			= "480x320p60hz",
-		.mode 			= VMODE_480X320P_60HZ,
-		.width			= 480,
-		.height			= 320,
-		.field_height		= 320,
-		.aspect_ratio_num	= 3,
-		.aspect_ratio_den	= 2,
-		.sync_duration_num	= 60,
-		.sync_duration_den	= 1,
-		.video_clk		= 25175000,
-    },
-    { /* VMODE_480X272P_60HZ */
-	.name			= "480x272p60hz",
-	.mode 			= VMODE_480X272P_60HZ,
-	.width			= 480,
-	.height			= 272,
-	.field_height		= 272,
-	.aspect_ratio_num	= 3,
-	.aspect_ratio_den	= 2,
-	.sync_duration_num	= 60,
-	.sync_duration_den	= 1,
-	.video_clk		= 25175000,
-    },
     { /* VMODE_480I */
-		.name              = "480i",
-		.mode              = VMODE_480I,
+        .name              = "480i",
+        .mode              = VMODE_480I,
         .width             = 720,
         .height            = 480,
         .field_height      = 240,
@@ -172,9 +178,9 @@ static const vinfo_t tv_info[] =
         .sync_duration_den = 1,
         .video_clk         = 27000000,
     },
-     { /* VMODE_480CVBS*/
-		.name              = "480cvbs",
-		.mode              = VMODE_480CVBS,
+    { /* VMODE_480CVBS*/
+        .name              = "480cvbs",
+        .mode              = VMODE_480CVBS,
         .width             = 720,
         .height            = 480,
         .field_height      = 240,
@@ -182,11 +188,11 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 3,
         .sync_duration_num = 60,
         .sync_duration_den = 1,
-		.video_clk         = 27000000,
+        .video_clk         = 27000000,
     },
     { /* VMODE_480P */
-		.name              = "480p",
-		.mode              = VMODE_480P,
+        .name              = "480p",
+        .mode              = VMODE_480P,
         .width             = 720,
         .height            = 480,
         .field_height      = 480,
@@ -197,9 +203,9 @@ static const vinfo_t tv_info[] =
         .video_clk         = 27000000,
     },
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{ /* VMODE_480P_59HZ */
-		.name              = "480p59hz",
-		.mode              = VMODE_480P_59HZ,
+    { /* VMODE_480P_59HZ */
+        .name              = "480p59hz",
+        .mode              = VMODE_480P_59HZ,
         .width             = 720,
         .height            = 480,
         .field_height      = 480,
@@ -223,8 +229,8 @@ static const vinfo_t tv_info[] =
         .video_clk         = 27000000,
     },
     { /* VMODE_576I */
-		.name              = "576i",
-		.mode              = VMODE_576I,
+        .name              = "576i",
+        .mode              = VMODE_576I,
         .width             = 720,
         .height            = 576,
         .field_height      = 288,
@@ -247,8 +253,8 @@ static const vinfo_t tv_info[] =
         .video_clk         = 27000000,
     },
     { /* VMODE_576I */
-		.name              = "576cvbs",
-		.mode              = VMODE_576CVBS,
+        .name              = "576cvbs",
+        .mode              = VMODE_576CVBS,
         .width             = 720,
         .height            = 576,
         .field_height      = 288,
@@ -256,11 +262,11 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 3,
         .sync_duration_num = 50,
         .sync_duration_den = 1,
-		.video_clk         = 27000000,
+        .video_clk         = 27000000,
     },
     { /* VMODE_576P */
-		.name              = "576p",
-		.mode              = VMODE_576P,
+        .name              = "576p",
+        .mode              = VMODE_576P,
         .width             = 720,
         .height            = 576,
         .field_height      = 576,
@@ -283,8 +289,8 @@ static const vinfo_t tv_info[] =
         .video_clk         = 27000000,
     },
     { /* VMODE_720P */
-		.name              = "720p",
-		.mode              = VMODE_720P,
+        .name              = "720p",
+        .mode              = VMODE_720P,
         .width             = 1280,
         .height            = 720,
         .field_height      = 720,
@@ -295,9 +301,9 @@ static const vinfo_t tv_info[] =
         .video_clk         = 74250000,
     },
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{ /* VMODE_720P_59HZ */
-		.name              = "720p59hz",
-		.mode              = VMODE_720P_59HZ,
+    { /* VMODE_720P_59HZ */
+        .name              = "720p59hz",
+        .mode              = VMODE_720P_59HZ,
         .width             = 1280,
         .height            = 720,
         .field_height      = 720,
@@ -308,141 +314,9 @@ static const vinfo_t tv_info[] =
         .video_clk         = 74250000,
     },
 #endif
-    { /* VMODE_800P */
-		.name				= "800p",
-		.mode 				= VMODE_800P,
-		.width				= 1280,
-		.height				= 800,
-		.field_height		= 800,
-		.aspect_ratio_num	= 16,
-		.aspect_ratio_den	= 9,
-		.sync_duration_num	= 60,
-		.sync_duration_den	= 1,
-		.video_clk			= 71000000,
-	},
-    { /* VMODE_800X480P_60HZ */
-		.name				= "800x480p60hz",
-		.mode 				= VMODE_800X480P_60HZ,
-		.width				= 800,
-		.height				= 480,
-		.field_height		= 480,
-		.aspect_ratio_num	= 5,
-		.aspect_ratio_den	= 3,
-		.sync_duration_num	= 60,
-		.sync_duration_den	= 1,
-		.video_clk			= 29760000,
-	},
-	{ /* VMODE_480X800P_60HZ */
-		.name			= "480x800p60hz",
-		.mode 			= VMODE_480X800P_60HZ,
-		.width			= 480,
-		.height			= 800,
-		.field_height		= 800,
-		.aspect_ratio_num	= 3,
-		.aspect_ratio_den	= 5,
-		.sync_duration_num	= 60,
-		.sync_duration_den	= 1,
-		.video_clk		= 32000000,
-	},
-    { /* VMODE_1366X768P_60HZ */
-		.name				= "1366x768p60hz",
-		.mode 				= VMODE_1366X768P_60HZ,
-		.width				= 1366,
-		.height				= 768,
-		.field_height		= 768,
-		.aspect_ratio_num	= 16,
-		.aspect_ratio_den	= 9,
-		.sync_duration_num	= 60,
-		.sync_duration_den	= 1,
-		.video_clk			= 85800000,
-	},
-    { /* VMODE_1600X900P_60HZ */
-		.name				= "1600x900p60hz",
-		.mode 				= VMODE_1600X900P_60HZ,
-		.width				= 1600,
-		.height				= 900,
-		.field_height		= 900,
-		.aspect_ratio_num	= 16,
-		.aspect_ratio_den	= 9,
-		.sync_duration_num	= 60,
-		.sync_duration_den	= 1,
-		.video_clk			= 108000000,
-	},
-    { /* VMODE_800X600P_60HZ */
-		.name				= "800x600p60hz",
-		.mode 				= VMODE_800X600P_60HZ,
-		.width				= 800,
-		.height				= 600,
-		.field_height		= 600,
-		.aspect_ratio_num	= 4,
-		.aspect_ratio_den	= 3,
-		.sync_duration_num	= 60,
-		.sync_duration_den	= 1,
-		.video_clk			= 40000000,
-	},
-    { /* VMODE_1024X600P_60HZ */
-		.name				= "1024x600p60hz",
-		.mode 				= VMODE_1024X600P_60HZ,
-		.width				= 1024,
-		.height				= 600,
-		.field_height		= 600,
-		.aspect_ratio_num	= 17,
-		.aspect_ratio_den	= 10,
-		.sync_duration_num	= 60,
-		.sync_duration_den	= 1,
-		.video_clk			= 51450000,
-	},
-    { /* VMODE_1024X768P_60HZ */
-		.name				= "1024x768p60hz",
-		.mode 				= VMODE_1024X768P_60HZ,
-		.width				= 1024,
-		.height				= 768,
-		.field_height		= 768,
-		.aspect_ratio_num	= 4,
-		.aspect_ratio_den	= 3,
-		.sync_duration_num	= 60,
-		.sync_duration_den	= 1,
-		.video_clk			= 65000000,
-	},
-    { /* VMODE_1360X768P_60HZ */
-		.name				= "1360x768p60hz",
-		.mode 				= VMODE_1360X768P_60HZ,
-		.width				= 1360,
-		.height				= 768,
-		.field_height		= 768,
-		.aspect_ratio_num	= 16,
-		.aspect_ratio_den	= 9,
-		.sync_duration_num	= 60,
-		.sync_duration_den	= 1,
-		.video_clk			= 85500000,
-	},
-    { /* VMODE_1440X900P_60HZ */
-		.name				= "1440x900p60hz",
-		.mode 				= VMODE_1440X900P_60HZ,
-		.width				= 1440,
-		.height				= 900,
-		.field_height		= 900,
-		.aspect_ratio_num	= 8,
-		.aspect_ratio_den	= 5,
-		.sync_duration_num	= 60,
-		.sync_duration_den	= 1,
-		.video_clk			= 106500000,
-	},
-    { /* VMODE_1680X1050P_60HZ */
-		.name				= "1680x1050p60hz",
-		.mode 				= VMODE_1680X1050P_60HZ,
-		.width				= 1680,
-		.height				= 1050,
-		.field_height		= 1050,
-		.aspect_ratio_num	= 8,
-		.aspect_ratio_den	= 5,
-		.sync_duration_num	= 60,
-		.sync_duration_den	= 1,
-		.video_clk			= 146250000,
-	},
     { /* VMODE_1080I */
-		.name              = "1080i",
-		.mode              = VMODE_1080I,
+        .name              = "1080i",
+        .mode              = VMODE_1080I,
         .width             = 1920,
         .height            = 1080,
         .field_height      = 540,
@@ -454,8 +328,8 @@ static const vinfo_t tv_info[] =
     },
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION    
     { /* VMODE_1080I_59HZ */
-		.name              = "1080i59hz",
-		.mode              = VMODE_1080I_59HZ,
+        .name              = "1080i59hz",
+        .mode              = VMODE_1080I_59HZ,
         .width             = 1920,
         .height            = 1080,
         .field_height      = 540,
@@ -467,8 +341,8 @@ static const vinfo_t tv_info[] =
     },
 #endif
     { /* VMODE_1080P */
-		.name              = "1080p",
-		.mode              = VMODE_1080P,
+        .name              = "1080p",
+        .mode              = VMODE_1080P,
         .width             = 1920,
         .height            = 1080,
         .field_height      = 1080,
@@ -479,22 +353,22 @@ static const vinfo_t tv_info[] =
         .video_clk         = 148500000,
     },
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{ /* VMODE_1080P_59HZ */
-		.name			   = "1080p59hz",
-		.mode			   = VMODE_1080P_59HZ,
-		.width			   = 1920,
-		.height 		   = 1080,
-		.field_height	   = 1080,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 60000,
-		.sync_duration_den = 1001,
-		.video_clk		   = 148500000,
-	},
+    { /* VMODE_1080P_59HZ */
+        .name              = "1080p59hz",
+        .mode              = VMODE_1080P_59HZ,
+        .width             = 1920,
+        .height            = 1080,
+        .field_height      = 1080,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 60000,
+        .sync_duration_den = 1001,
+        .video_clk         = 148500000,
+    },
 #endif
     { /* VMODE_720P_50hz */
-		.name              = "720p50hz",
-		.mode              = VMODE_720P_50HZ,
+        .name              = "720p50hz",
+        .mode              = VMODE_720P_50HZ,
         .width             = 1280,
         .height            = 720,
         .field_height      = 720,
@@ -505,8 +379,8 @@ static const vinfo_t tv_info[] =
         .video_clk         = 74250000,
     },
     { /* VMODE_1080I_50HZ */
-		.name              = "1080i50hz",
-		.mode              = VMODE_1080I_50HZ,
+        .name              = "1080i50hz",
+        .mode              = VMODE_1080I_50HZ,
         .width             = 1920,
         .height            = 1080,
         .field_height      = 540,
@@ -517,8 +391,8 @@ static const vinfo_t tv_info[] =
         .video_clk         = 74250000,
     },
     { /* VMODE_1080P_50HZ */
-		.name              = "1080p50hz",
-		.mode              = VMODE_1080P_50HZ,
+        .name              = "1080p50hz",
+        .mode              = VMODE_1080P_50HZ,
         .width             = 1920,
         .height            = 1080,
         .field_height      = 1080,
@@ -529,8 +403,8 @@ static const vinfo_t tv_info[] =
         .video_clk         = 148500000,
     },
     { /* VMODE_1080P_24HZ */
-		.name              = "1080p24hz",
-		.mode              = VMODE_1080P_24HZ,
+        .name              = "1080p24hz",
+        .mode              = VMODE_1080P_24HZ,
         .width             = 1920,
         .height            = 1080,
         .field_height      = 1080,
@@ -541,22 +415,22 @@ static const vinfo_t tv_info[] =
         .video_clk         = 74250000,
     },
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{ /* VMODE_1080P_23HZ */
-		.name			   = "1080p23hz",
-		.mode			   = VMODE_1080P_23HZ,
-		.width			   = 1920,
-		.height 		   = 1080,
-		.field_height	   = 1080,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 2397,
-		.sync_duration_den = 100,
-		.video_clk		   = 74250000,
-	},
+    { /* VMODE_1080P_23HZ */
+        .name              = "1080p23hz",
+        .mode              = VMODE_1080P_23HZ,
+        .width             = 1920,
+        .height            = 1080,
+        .field_height      = 1080,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 24000,
+        .sync_duration_den = 1001,
+        .video_clk         = 74250000,
+    },
 #endif
     { /* VMODE_4K2K_30HZ */
         .name              = "4k2k30hz",
-        .mode              = TVMODE_4K2K_30HZ,
+        .mode              = VMODE_4K2K_30HZ,
         .width             = 3840,
         .height            = 2160,
         .field_height      = 2160,
@@ -567,22 +441,22 @@ static const vinfo_t tv_info[] =
         .video_clk         = 297000000,
     },
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{ /* VMODE_4K2K_29HZ */
-		.name			   = "4k2k29hz",
-		.mode			   = TVMODE_4K2K_29HZ,
-		.width			   = 3840,
-		.height 		   = 2160,
-		.field_height	   = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 2997,
-		.sync_duration_den = 100,
-		.video_clk		   = 297000000,
+    { /* VMODE_4K2K_29HZ */
+        .name              = "4k2k29hz",
+        .mode              = VMODE_4K2K_29HZ,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 2997,
+        .sync_duration_den = 100,
+        .video_clk         = 297000000,
 	},
 #endif
     { /* VMODE_4K2K_25HZ */
         .name              = "4k2k25hz",
-        .mode              = TVMODE_4K2K_25HZ,
+        .mode              = VMODE_4K2K_25HZ,
         .width             = 3840,
         .height            = 2160,
         .field_height      = 2160,
@@ -594,7 +468,7 @@ static const vinfo_t tv_info[] =
     },
     { /* VMODE_4K2K_24HZ */
         .name              = "4k2k24hz",
-        .mode              = TVMODE_4K2K_24HZ,
+        .mode              = VMODE_4K2K_24HZ,
         .width             = 3840,
         .height            = 2160,
         .field_height      = 2160,
@@ -605,22 +479,22 @@ static const vinfo_t tv_info[] =
         .video_clk         = 297000000,
     },
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-	{ /* VMODE_4K2K_23HZ */
-		.name			   = "4k2k23hz",
-		.mode			   = TVMODE_4K2K_23HZ,
-		.width			   = 3840,
-		.height 		   = 2160,
-		.field_height	   = 2160,
-		.aspect_ratio_num  = 16,
-		.aspect_ratio_den  = 9,
-		.sync_duration_num = 2397,
-		.sync_duration_den = 100,
-		.video_clk		   = 297000000,
-	},
+    { /* VMODE_4K2K_23HZ */
+        .name              = "4k2k23hz",
+        .mode              = VMODE_4K2K_23HZ,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 24000,
+        .sync_duration_den = 1001,
+        .video_clk         = 297000000,
+    },
 #endif
     { /* VMODE_4K2K_SMPTE */
         .name              = "4k2ksmpte",
-        .mode              = TVMODE_4K2K_SMPTE,
+        .mode              = VMODE_4K2K_SMPTE,
         .width             = 4096,
         .height            = 2160,
         .field_height      = 2160,
@@ -630,33 +504,177 @@ static const vinfo_t tv_info[] =
         .sync_duration_den = 1,
         .video_clk         = 297000000,
     },
-    { /* VMODE_1920x1200 */
-		.name              = "1920x1200",
-		.mode              = VMODE_1920x1200,
-        .width             = 1920,
-        .height            = 1200,
-        .field_height      = 1200,
+    { /* VMODE_4K2K_FAKE_5G */
+        .name              = "4k2k5g",
+        .mode              = VMODE_4K2K_FAKE_5G,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 50,
+        .sync_duration_den = 1,
+        .video_clk         = 495000000,
+    },
+    { /* VMODE_4K2K_60HZ_Y420 */
+        .name              = "4k2k60hz420",
+        .mode              = VMODE_4K2K_60HZ_Y420,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
         .aspect_ratio_num  = 16,
         .aspect_ratio_den  = 9,
         .sync_duration_num = 60,
         .sync_duration_den = 1,
-		.video_clk         = 154000000,
-    }, 
+        .video_clk         = 594000000,
+    },
+    { /* VMODE_4K2K_50HZ_Y420 */
+        .name              = "4k2k50hz420",
+        .mode              = VMODE_4K2K_50HZ_Y420,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 50,
+        .sync_duration_den = 1,
+        .video_clk         = 594000000,
+    },
+    { /* VMODE_4K2K_60HZ */
+        .name              = "4k2k60hz",
+        .mode              = VMODE_4K2K_60HZ,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 594000000,
+    },
+    { /* VMODE_4K1K_100HZ_Y420 */
+        .name              = "4k1k100hz420",
+        .mode              = VMODE_4K1K_100HZ_Y420,
+        .width             = 3840,
+        .height            = 1080,
+        .field_height      = 1080,
+        .aspect_ratio_num  = 32,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 100,
+        .sync_duration_den = 1,
+        .video_clk         = 594000000,
+    },
+    { /* VMODE_4K1K_100HZ */
+        .name              = "4k1k100hz",
+        .mode              = VMODE_4K1K_100HZ,
+        .width             = 3840,
+        .height            = 1080,
+        .field_height      = 1080,
+        .aspect_ratio_num  = 32,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 100,
+        .sync_duration_den = 1,
+        .video_clk         = 594000000,
+    },
+    { /* VMODE_4K1K_120HZ_Y420 */
+        .name              = "4k1k120hz420",
+        .mode              = VMODE_4K1K_120HZ_Y420,
+        .width             = 3840,
+        .height            = 1080,
+        .field_height      = 1080,
+        .aspect_ratio_num  = 32,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 120,
+        .sync_duration_den = 1,
+        .video_clk         = 594000000,
+    },
+    { /* VMODE_4K1K_120HZ */
+        .name              = "4k1k120hz",
+        .mode              = VMODE_4K1K_120HZ,
+        .width             = 3840,
+        .height            = 1080,
+        .field_height      = 1080,
+        .aspect_ratio_num  = 32,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 120,
+        .sync_duration_den = 1,
+        .video_clk         = 594000000,
+    },
+    { /* VMODE_4K05K_200HZ_Y420 */
+        .name              = "4k05k200hz420",
+        .mode              = VMODE_4K05K_200HZ_Y420,
+        .width             = 3840,
+        .height            = 1080,
+        .field_height      = 1080,
+        .aspect_ratio_num  = 64,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 200,
+        .sync_duration_den = 1,
+        .video_clk         = 594000000,
+    },
+    { /* VMODE_4K05K_200HZ */
+        .name              = "4k05k200hz",
+        .mode              = VMODE_4K05K_200HZ,
+        .width             = 3840,
+        .height            = 540,
+        .field_height      = 540,
+        .aspect_ratio_num  = 64,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 200,
+        .sync_duration_den = 1,
+        .video_clk         = 594000000,
+    },
+    { /* VMODE_4K05K_240HZ_Y420 */
+        .name              = "4k05k240hz420",
+        .mode              = VMODE_4K05K_240HZ_Y420,
+        .width             = 3840,
+        .height            = 540,
+        .field_height      = 540,
+        .aspect_ratio_num  = 64,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 240,
+        .sync_duration_den = 1,
+        .video_clk         = 594000000,
+    },
+    { /* VMODE_4K05K_240HZ */
+        .name              = "4k05k240hz",
+        .mode              = VMODE_4K05K_240HZ,
+        .width             = 3840,
+        .height            = 1080,
+        .field_height      = 1080,
+        .aspect_ratio_num  = 64,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 240,
+        .sync_duration_den = 1,
+        .video_clk         = 594000000,
+    },
+    { /* VMODE_4K2K_50HZ */
+        .name              = "4k2k50hz",
+        .mode              = TVMODE_4K2K_50HZ,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 50,
+        .sync_duration_den = 1,
+        .video_clk         = 594000000,
+    },
     { /* VMODE_vga */
-		.name              = "vga",
-		.mode              = VMODE_VGA,
+        .name              = "vga",
+        .mode              = VMODE_VGA,
         .width             = 640,
         .height            = 480,
-        .field_height      = 480,
+        .field_height      = 240,
         .aspect_ratio_num  = 4,
         .aspect_ratio_den  = 3,
         .sync_duration_num = 60,
         .sync_duration_den = 1,
-		.video_clk         = 25175000,
+        .video_clk         = 25175000,
     }, 
     { /* VMODE_SVGA */
-		.name              = "svga",
-		.mode              = VMODE_SVGA,
+        .name              = "svga",
+        .mode              = VMODE_SVGA,
         .width             = 800,
         .height            = 600,
         .field_height      = 600,
@@ -664,11 +682,11 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 3,
         .sync_duration_num = 60,
         .sync_duration_den = 1,
-		.video_clk         = 40000000,
+        .video_clk         = 40000000,
     }, 
     { /* VMODE_XGA */
-		.name              = "xga",
-		.mode              = VMODE_XGA,
+        .name              = "xga",
+        .mode              = VMODE_XGA,
         .width             = 1024,
         .height            = 768,
         .field_height      = 768,
@@ -676,11 +694,11 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 3,
         .sync_duration_num = 60,
         .sync_duration_den = 1,
-		.video_clk         = 65000000,
+        .video_clk         = 65000000,
     }, 
     { /* VMODE_sxga */
-		.name              = "sxga",
-		.mode              = VMODE_SXGA,
+        .name              = "sxga",
+        .mode              = VMODE_SXGA,
         .width             = 1280,
         .height            = 1024,
         .field_height      = 1024,
@@ -688,11 +706,11 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 4,
         .sync_duration_num = 60,
         .sync_duration_den = 1,
-		.video_clk         = 108000000,
+        .video_clk         = 108000000,
     }, 
 	{ /* VMODE_wsxga */
-		.name              = "wsxga",
-		.mode              = VMODE_WSXGA,
+        .name              = "wsxga",
+        .mode              = VMODE_WSXGA,
         .width             = 1440,
         .height            = 900,
         .field_height      = 900,
@@ -700,11 +718,11 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 5,
         .sync_duration_num = 60,
         .sync_duration_den = 1,
-		.video_clk         = 88750000,
+        .video_clk         = 88750000,
     },
-	{ /* VMODE_fhdvga */
-		.name              = "fhdvga",
-		.mode              = VMODE_FHDVGA,
+    { /* VMODE_fhdvga */
+        .name              = "fhdvga",
+        .mode              = VMODE_FHDVGA,
         .width             = 1920,
         .height            = 1080,
         .field_height      = 1080,
@@ -712,253 +730,270 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 9,
         .sync_duration_num = 60,
         .sync_duration_den = 1,
-		.video_clk         = 148500000,
+        .video_clk         = 148500000,
     },
 };
 
 static const struct file_operations am_tv_fops = {
-	.open	= NULL,  
-	.read	= NULL,//am_tv_read, 
-	.write	= NULL, 
-	.unlocked_ioctl	= NULL,//am_tv_ioctl, 
-	.release	= NULL, 	
-	.poll		= NULL,
+    .open	= NULL,
+    .read	= NULL,//am_tv_read,
+    .write	= NULL,
+    .unlocked_ioctl	= NULL,//am_tv_ioctl,
+    .release	= NULL,
+    .poll		= NULL,
 };
 
 static const vinfo_t *get_valid_vinfo(char  *mode)
 {
-	const vinfo_t * vinfo = NULL;
-	int  i,count=ARRAY_SIZE(tv_info);
-	int mode_name_len=0;
-	
-	for(i=0;i<count;i++)
-	{
-		if(strncmp(tv_info[i].name,mode,strlen(tv_info[i].name))==0)
-		{
-			if((vinfo==NULL)||(strlen(tv_info[i].name)>mode_name_len)){
-			    vinfo = &tv_info[i];
-			    mode_name_len = strlen(tv_info[i].name);
-			}
-		}
-	}
-	return vinfo;
+    const vinfo_t * vinfo = NULL;
+    int  i,count=ARRAY_SIZE(tv_info);
+    int mode_name_len=0;
+
+    for (i=0;i<count;i++)
+    {
+        if (strncmp(tv_info[i].name,mode,strlen(tv_info[i].name)) == 0)
+        {
+            if ((vinfo == NULL) || (strlen(tv_info[i].name)>mode_name_len)) {
+                vinfo = &tv_info[i];
+                mode_name_len = strlen(tv_info[i].name);
+            }
+        }
+    }
+    return vinfo;
 }
 
 static const vinfo_t *tv_get_current_info(void)
 {
-	return info->vinfo;
+    return info->vinfo;
 }
 
 tvmode_t vmode_to_tvmode(vmode_t mod) 
 {
-    return vmode_tvmode_tab[mod];
+    return vmode_tvmode_map(mod);
+}
+
+static const vinfo_t *get_tv_info(vmode_t mode)
+{
+    int i = 0;
+    for (i = 0; i < ARRAY_SIZE(tv_info); i++) {
+        if (mode == tv_info[i].mode)
+            return &tv_info[i];
+    }
+    return NULL;
 }
 
 static int tv_set_current_vmode(vmode_t mod)
 {
-	if ((mod&VMODE_MODE_BIT_MASK)> VMODE_FHDVGA)
-		return -EINVAL;
-	info->vinfo = &tv_info[mod & VMODE_MODE_BIT_MASK];
-	if(mod&VMODE_LOGO_BIT_MASK)  return 0;
+    if ((mod&VMODE_MODE_BIT_MASK)> VMODE_MAX)
+	return -EINVAL;
+    info->vinfo = get_tv_info(mod & VMODE_MODE_BIT_MASK);
+    if(!info->vinfo) {
+        printk("don't get tv_info, mode is %d\n", mod);
+        return 1;
+    }
+//	info->vinfo = &tv_info[mod & VMODE_MODE_BIT_MASK];
+    printk("mode is %d,sync_duration_den=%d,sync_duration_num=%d\n", mod,info->vinfo->sync_duration_den,info->vinfo->sync_duration_num);
+    if(mod&VMODE_LOGO_BIT_MASK)  return 0;
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	switch_vpu_mem_pd_vmod(info->vinfo->mode, VPU_MEM_POWER_ON);
-	request_vpu_clk_vmod(info->vinfo->video_clk, info->vinfo->mode);
+    switch_vpu_mem_pd_vmod(info->vinfo->mode, VPU_MEM_POWER_ON);
+    request_vpu_clk_vmod(info->vinfo->video_clk, info->vinfo->mode);
 #endif
-	tvoutc_setmode(vmode_to_tvmode(mod));
+    tvoutc_setmode(vmode_to_tvmode(mod));
 //	change_vdac_setting(get_current_vdac_setting(),mod);
-	return 0;
+    return 0;
 }
 
 static vmode_t tv_validate_vmode(char *mode)
 {
-	const vinfo_t *info = get_valid_vinfo(mode);
-	if (info)
-		return info->mode;
-	
-	return VMODE_MAX;
+    const vinfo_t *info = get_valid_vinfo(mode);
+    if (info)
+	return info->mode;
+
+    return VMODE_MAX;
 }
 static int tv_vmode_is_supported(vmode_t mode)
 {
-	int  i,count=ARRAY_SIZE(tv_info);
-	mode&=VMODE_MODE_BIT_MASK;
-	for(i=0;i<count;i++)
-	{
-		if(tv_info[i].mode==mode)
-		{
-			return true;
-		}
-	}
-	return false;
+    int  i,count=ARRAY_SIZE(tv_info);
+    mode&=VMODE_MODE_BIT_MASK;
+    for (i=0;i<count;i++)
+    {
+        if (tv_info[i].mode == mode)
+        {
+            return true;
+        }
+    }
+    return false;
 }
 static int tv_module_disable(vmode_t cur_vmod)
 {
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
-	if (info->vinfo) {
-		release_vpu_clk_vmod(info->vinfo->mode);
-		switch_vpu_mem_pd_vmod(info->vinfo->mode, VPU_MEM_POWER_DOWN);
-	}
+    if (info->vinfo) {
+        release_vpu_clk_vmod(info->vinfo->mode);
+        switch_vpu_mem_pd_vmod(info->vinfo->mode, VPU_MEM_POWER_DOWN);
+    }
 #endif
-	//video_dac_disable();
-	return 0;
+    //video_dac_disable();
+    return 0;
 }
 
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-
-static char* get_name_from_vmode(vmode_t mode)
+char* get_name_from_vmode(vmode_t mode)
 {
-	int i = 0, count = 0;
-	
-	count = ARRAY_SIZE(tv_info);
-	for( i=0; i<count; i++ )
-	{
-		if( tv_info[i].mode == mode )
-			break;
-	}
+    int i = 0, count = 0;
 
-	if( i == count )
-		return NULL;
+    count = ARRAY_SIZE(tv_info);
+    for ( i=0; i<count; i++ )
+    {
+        if ( tv_info[i].mode == mode )
+            break;
+    }
 
-	return tv_info[i].name;
+    if ( i == count )
+        return NULL;
+
+    return tv_info[i].name;
 }
 
 // frame_rate = 9600/duration/100 hz
 static int get_vsource_frame_rate(int duration)
 {
-	int frame_rate = 0;
-
-	switch( duration )
-	{
-		case 1600:
-			frame_rate = 6000;
-			break;
-		case 1601:
-		case 1602:
-			frame_rate = 5994;
-			break;
-		case 1920:
-			frame_rate = 5000;
-			break;
-		case 3200:
-			frame_rate = 3000;
-			break;
-		case 3203:
-			frame_rate = 2997;
-			break;
-		case 3840:
-			frame_rate = 2500;
-			break;
-		case 4000:
-			frame_rate = 2400;
-			break;
-		case 4004:
-			frame_rate = 2397;
-			break;
-		default:
-			break;
-	}
-
-	return frame_rate;
+    int frame_rate = 0;
+
+    switch ( duration )
+    {
+        case 1600:
+            frame_rate = 6000;
+            break;
+        case 1601:
+        case 1602:
+            frame_rate = 5994;
+            break;
+        case 1920:
+            frame_rate = 5000;
+            break;
+        case 3200:
+            frame_rate = 3000;
+            break;
+        case 3203:
+            frame_rate = 2997;
+            break;
+        case 3840:
+            frame_rate = 2500;
+            break;
+        case 4000:
+            frame_rate = 2400;
+            break;
+        case 4004:
+            frame_rate = 2397;
+            break;
+        default:
+            break;
+    }
+
+    return frame_rate;
 }
 
 static int get_target_frame_rate(int framerate_vsource, int policy)
 {
-	const vinfo_t *pvinfo ;
-	int framerate_target = 0;
-	pvinfo = tv_get_current_info();
-	switch( policy )
-	{
-		case 0: // not change
-			break;
-		case 1: // change to the frame rate of video source
-			if( (framerate_vsource==2397) || (framerate_vsource==2997) || (framerate_vsource==5994) ){
-				switch(pvinfo->sync_duration_num)
-				{
-				case 24:
-					framerate_target=2397;
-					break;
-				case 30:
-					framerate_target=2997;
-					break;
-				case 60:
-					framerate_target=5994;
-					break;	
-				default:
-					framerate_target = ( pvinfo->sync_duration_num > 100 ? pvinfo->sync_duration_num : pvinfo->sync_duration_num*100 );
-					break;
-				}
-			}
-			else
-				framerate_target = framerate_vsource;
-			break;
-		case 2: // change to the frame rate of video source, but use 59.94 for 23.97/29.97
-			if( (framerate_vsource==2397) || (framerate_vsource==2997) )
-				framerate_target = 5994;
-			else
-				framerate_target = framerate_vsource;
-			break;
-		default:
-			break;
-	}
-	return framerate_target;
+    const vinfo_t *pvinfo ;
+    int framerate_target = 0;
+    pvinfo = tv_get_current_info();
+    switch ( policy )
+    {
+        case 0: // not change
+            break;
+        case 1: // change to the frame rate of video source
+            if ( (framerate_vsource == 2397) || (framerate_vsource == 2997) || (framerate_vsource == 5994) ) {
+                switch (pvinfo->sync_duration_num)
+                {
+                case 24:
+                    framerate_target=2397;
+                    break;
+                case 30:
+                    framerate_target=2997;
+                    break;
+                case 60:
+                    framerate_target=5994;
+                    break;
+                default:
+                    framerate_target = ( pvinfo->sync_duration_num > 100 ? pvinfo->sync_duration_num : pvinfo->sync_duration_num*100 );
+                    break;
+                }
+            }
+            else
+                framerate_target = framerate_vsource;
+            break;
+        case 2: // change to the frame rate of video source, but use 59.94 for 23.97/29.97
+            if ( (framerate_vsource == 2397) || (framerate_vsource == 2997) )
+                framerate_target = 5994;
+            else
+                framerate_target = framerate_vsource;
+            break;
+        default:
+            break;
+    }
+    return framerate_target;
 }
 
-extern int hdmitx_is_vmode_supported(char *mode_name);
+//extern int hdmitx_is_vmode_supported(char *mode_name);
 
 static int get_target_vmode(int framerate_target)
 {
-	int is_receiver_supported = 0;
-	const vinfo_t *pvinfo ;
-	vmode_t mode_target = VMODE_INIT_NULL;
-
-	printk("vout [%s] frame_rate_target = %d\n", __FUNCTION__, framerate_target);
-
-	pvinfo = tv_get_current_info();
-
-	mode_target = pvinfo->mode;
-
-	if( (framerate_target==2397) || (framerate_target==2997) || (framerate_target==5994) ){
-		switch( mode_target ){
-			case VMODE_480P:
-				mode_target = VMODE_480P_59HZ;
-				break;
-			case VMODE_720P:
-				mode_target = VMODE_720P_59HZ;
-				break;
-			case VMODE_1080I:
-				mode_target = VMODE_1080I_59HZ;
-				break;
-			case VMODE_1080P_24HZ:
-				mode_target = VMODE_1080P_23HZ;
-				break;
-			case VMODE_1080P:
-				mode_target = VMODE_1080P_59HZ;
-				break;
-			case VMODE_4K2K_24HZ:
-				mode_target = VMODE_4K2K_23HZ;
-				break;
-			case VMODE_4K2K_30HZ:
-				mode_target = VMODE_4K2K_29HZ;
-				break;
-			default:
-				break;
-		}
-	}
-	is_receiver_supported = hdmitx_is_vmode_supported(get_name_from_vmode(mode_target));
-	
-	switch( is_receiver_supported )
-	{
-		case 0: // not supported in edid
-			mode_target = pvinfo->mode;
-			break;
-		case 1: // supported in edid
-			break;
-		case 2: // no edid
-			mode_target = pvinfo->mode;
-			break;
-		default:
-			break;
-	}
-	return mode_target;
+//	int is_receiver_supported = 0;
+    const vinfo_t *pvinfo ;
+    vmode_t mode_target = VMODE_INIT_NULL;
+
+    printk("vout [%s] frame_rate_target = %d\n", __FUNCTION__, framerate_target);
+
+    pvinfo = tv_get_current_info();
+
+    mode_target = pvinfo->mode;
+
+    if ( (framerate_target == 2397) || (framerate_target == 2997) || (framerate_target == 5994) ) {
+        switch ( mode_target ) {
+            case VMODE_480P:
+                mode_target = VMODE_480P_59HZ;
+                break;
+            case VMODE_720P:
+                mode_target = VMODE_720P_59HZ;
+                break;
+            case VMODE_1080I:
+                mode_target = VMODE_1080I_59HZ;
+                break;
+            case VMODE_1080P_24HZ:
+                mode_target = VMODE_1080P_23HZ;
+                break;
+            case VMODE_1080P:
+                mode_target = VMODE_1080P_59HZ;
+                break;
+            case VMODE_4K2K_24HZ:
+                mode_target = VMODE_4K2K_23HZ;
+                break;
+            case VMODE_4K2K_30HZ:
+                mode_target = VMODE_4K2K_29HZ;
+                break;
+            default:
+                break;
+        }
+    }
+/*
+    is_receiver_supported = hdmitx_is_vmode_supported(get_name_from_vmode(mode_target));
+
+    switch ( is_receiver_supported )
+    {
+        case 0: // not supported in edid
+            mode_target = pvinfo->mode;
+            break;
+        case 1: // supported in edid
+            break;
+        case 2: // no edid
+            mode_target = pvinfo->mode;
+            break;
+        default:
+            break;
+    }
+*/
+    return mode_target;
 }
 
 // return values:
@@ -968,85 +1003,102 @@ static int get_target_vmode(int framerate_target)
 //		2: 		different vmode, need change mode
 static int get_exchange_mode(vmode_t mode_target)
 {
-	const vinfo_t *pvinfo;
-	vmode_t mode_current = VMODE_INIT_NULL;
-	
-	pvinfo = tv_get_current_info();
-	mode_current = pvinfo->mode;
-	
-	if( mode_current == mode_target )
-		return 0;
-	
-	if( ((mode_current==VMODE_480P) && (mode_target==VMODE_480P_59HZ)) ||
-		((mode_current==VMODE_480P_59HZ) && (mode_target==VMODE_480P)) ||
-		((mode_current==VMODE_720P) && (mode_target==VMODE_720P_59HZ)) ||
-		((mode_current==VMODE_720P_59HZ) && (mode_target==VMODE_720P)) ||
-		((mode_current==VMODE_1080I) && (mode_target==VMODE_1080I_59HZ))||
-		((mode_current==VMODE_1080I_59HZ) && (mode_target==VMODE_1080I))||
-		((mode_current==VMODE_1080P) && (mode_target==VMODE_1080P_59HZ))||
-		((mode_current==VMODE_1080P_59HZ) && (mode_target==VMODE_1080P))||
-		((mode_current==VMODE_1080P_24HZ) && (mode_target==VMODE_1080P_23HZ))||
-		((mode_current==VMODE_1080P_23HZ) && (mode_target==VMODE_1080P_24HZ) )||
-		((mode_current==VMODE_4K2K_30HZ) && (mode_target==VMODE_4K2K_29HZ))||
-		((mode_current==VMODE_4K2K_29HZ) && (mode_target==VMODE_4K2K_30HZ))||
-		((mode_current==VMODE_4K2K_24HZ) && (mode_target==VMODE_4K2K_23HZ))||
-		((mode_current==VMODE_4K2K_23HZ) && (mode_target==VMODE_4K2K_24HZ)) )
-		return 0x1;
-
-	return 2;
+    const vinfo_t *pvinfo;
+    vmode_t mode_current = VMODE_INIT_NULL;
+
+    pvinfo = tv_get_current_info();
+    mode_current = pvinfo->mode;
+
+    if ( mode_current == mode_target )
+        return 0;
+
+    if ( ((mode_current == VMODE_480P) && (mode_target == VMODE_480P_59HZ)) ||
+        ((mode_current == VMODE_480P_59HZ) && (mode_target == VMODE_480P)) ||
+        ((mode_current == VMODE_720P) && (mode_target == VMODE_720P_59HZ)) ||
+        ((mode_current == VMODE_720P_59HZ) && (mode_target == VMODE_720P)) ||
+        ((mode_current == VMODE_1080I) && (mode_target == VMODE_1080I_59HZ)) ||
+        ((mode_current == VMODE_1080I_59HZ) && (mode_target == VMODE_1080I)) ||
+        ((mode_current == VMODE_1080P) && (mode_target == VMODE_1080P_59HZ)) ||
+        ((mode_current == VMODE_1080P_59HZ) && (mode_target == VMODE_1080P)) ||
+        ((mode_current == VMODE_1080P_24HZ) && (mode_target == VMODE_1080P_23HZ)) ||
+        ((mode_current == VMODE_1080P_23HZ) && (mode_target == VMODE_1080P_24HZ) ) ||
+        ((mode_current == VMODE_4K2K_30HZ) && (mode_target == VMODE_4K2K_29HZ)) ||
+        ((mode_current == VMODE_4K2K_29HZ) && (mode_target == VMODE_4K2K_30HZ)) ||
+        ((mode_current == VMODE_4K2K_24HZ) && (mode_target == VMODE_4K2K_23HZ)) ||
+        ((mode_current == VMODE_4K2K_23HZ) && (mode_target == VMODE_4K2K_24HZ)) )
+        return 0x1;
+
+    return 2;
 }
 
+extern int hdmitx_is_special_tv_process(void);
+
 // just to fine tune the 0.1% clock
 static int clock_fine_tune(void)
 {
-	const vinfo_t *pvinfo ;
-	pvinfo = tv_get_current_info();
-#if (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON8B)
-	switch( pvinfo->mode )
-	{
-		case VMODE_720P_59HZ:
-		case VMODE_1080I_59HZ:
-		case VMODE_1080P_23HZ:
-		case VMODE_1080P_59HZ:
-		case VMODE_4K2K_29HZ:
-		case VMODE_4K2K_23HZ:
-			aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84d04);
-			break;
-		case VMODE_720P:
-		case VMODE_1080I:
-		case VMODE_1080P:
-		case VMODE_1080P_24HZ:
-		case VMODE_4K2K_30HZ:	
-		case VMODE_4K2K_24HZ:
-			aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84e00);
-			break;
-		case VMODE_480P_59HZ:
-			if( (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON8B) || (IS_MESON_M8M2_CPU) ){
-				aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84f48);
-				aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x400d042c);
-			}
-			else{
-				aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8cf48);
-				aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4008042c);
-			}
-			break;
-		case VMODE_480P:
-			if( (MESON_CPU_TYPE==MESON_CPU_TYPE_MESON8B) || (IS_MESON_M8M2_CPU) ){
-				aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84000);
-				aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x400d042d);
-			}
-			else{
-				aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c88000);
-				aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4008042d);
-			}
-			break;
-		default:
-			break;
-	}
+    const vinfo_t *pvinfo ;
+    pvinfo = tv_get_current_info();
+#if (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8) || (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B)
+    switch ( pvinfo->mode )
+    {
+        case VMODE_720P_59HZ:
+        case VMODE_1080I_59HZ:
+        case VMODE_1080P_23HZ:
+        case VMODE_1080P_59HZ:
+            if ( MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B )
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84cf8);
+            else
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84d04);
+            break;
+        case VMODE_4K2K_23HZ:
+        case VMODE_4K2K_29HZ:
+            if ( MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B )
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69d84cf8);
+            else if (IS_MESON_M8_CPU && hdmitx_is_special_tv_process())//SAMSUNG future TV, M8, in 4K2K mode
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c84d04);
+            else
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69d84d04);
+            break;
+        case VMODE_720P:
+        case VMODE_1080I:
+        case VMODE_1080P:
+        case VMODE_1080P_24HZ:
+            aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84e00);
+            break;
+        case VMODE_4K2K_24HZ:
+        case VMODE_4K2K_30HZ:
+            if (IS_MESON_M8_CPU && hdmitx_is_special_tv_process())//SAMSUNG future TV, M8, in 4K2K mode
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x59c84e00);
+            else
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84e00);
+            break;
+        case VMODE_480P_59HZ:
+            if ( (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (IS_MESON_M8M2_CPU) ) {
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84f48);
+                aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x400d042c);
+            }
+            else {
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c8cf48);
+                aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4008042c);
+            }
+            break;
+        case VMODE_480P:
+            if ( (MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B) || (IS_MESON_M8M2_CPU) ) {
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c84000);
+                aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x400d042d);
+            }
+            else {
+                aml_write_reg32(P_HHI_VID_PLL_CNTL2, 0x69c88000);
+                aml_write_reg32(P_HHI_VID_PLL_CNTL,  0x4008042d);
+            }
+            break;
+        default:
+            break;
+    }
 
 #endif
 
-	return 0;
+    return 0;
 }
 
 extern void update_vmode_status(char* name);
@@ -1109,7 +1161,7 @@ static int framerate_automation_process(int duration)
 
 	fr_vsource = get_vsource_frame_rate(duration);
 	fr_target = get_target_frame_rate(fr_vsource, policy);
-
+	
 	pvinfo = tv_get_current_info();
 	if( (pvinfo->sync_duration_num==fr_target) || (pvinfo->sync_duration_num==(fr_target/100)) )
 		return 0;
@@ -1158,8 +1210,11 @@ static int tv_set_vframe_rate_end_hint(void)
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 extern void cvbs_cntl_output(unsigned int open);
 #endif
-static int tv_suspend(void)
+static int tv_suspend(int pm_event)
 {
+	/* in freeze process do not turn off the display devices */
+	if (pm_event == PM_EVENT_FREEZE)
+		return 0;
 	video_dac_disable();
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
 	cvbs_cntl_output(0);
@@ -1167,8 +1222,12 @@ static int tv_suspend(void)
 
 	return 0;
 }
-static int tv_resume(void)
+static int tv_resume(int pm_event)
 {
+	/* in thaw/restore process do not reset the display mode */
+	if (pm_event == PM_EVENT_THAW
+		|| pm_event == PM_EVENT_RESTORE)
+		return 0;
 	video_dac_enable(0xff);
 	tv_set_current_vmode(info->vinfo->mode);
 	return 0;
@@ -1289,24 +1348,50 @@ static int  create_tv_attr(disp_module_info_t* info)
 
 	return   0;
 }
+
+#ifdef CONFIG_HIBERNATION
+struct class  *info_base_class;
+static int tvconf_suspend(void)
+{
+	info_base_class = info->base_class;
+	return 0;
+}
+
+static void tvconf_resume(void)
+{
+	info->base_class = info_base_class;
+}
+
+static struct syscore_ops tvconf_ops = {
+	.suspend = tvconf_suspend,
+	.resume = tvconf_resume,
+	.shutdown = NULL,
+};
+#endif
+
 static int __init tv_init_module(void)
 {
 	int  ret ;
 
-	info=(disp_module_info_t*)kmalloc(sizeof(disp_module_info_t),GFP_KERNEL) ;
-    printk("%s\n", __func__);
+#ifdef CONFIG_HIBERNATION
+	INIT_LIST_HEAD(&tvconf_ops.node);
+	register_syscore_ops(&tvconf_ops);
+#endif
+
+	info=&disp_module_info;
+	printk("%s\n", __func__);
 
-	if (!info)
+	/*if (!info)
 	{
 		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"can't alloc display info struct\n");
 		return -ENOMEM;
-	}
-	
+	}*/
+
 	memset(info, 0, sizeof(disp_module_info_t));
 
 	sprintf(info->name,TV_CLASS_NAME) ;
 	ret=register_chrdev(0,info->name,&am_tv_fops);
-	if(ret <0) 
+	if(ret <0)
 	{
 		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register char dev tv error\n");
 		return  ret ;
@@ -1342,7 +1427,7 @@ static __exit void tv_exit_module(void)
 	if(info)
 	{
 		unregister_chrdev(info->major,info->name)	;
-		kfree(info);
+		//kfree(info);
 	}
 	vout_unregister_server(&tv_server);
 	
diff --git a/drivers/amlogic/display/vout/tvconf.h b/drivers/amlogic/display/vout/tvconf.h
old mode 100644
new mode 100755
diff --git a/drivers/amlogic/display/vout/tvmode.h b/drivers/amlogic/display/vout/tvmode.h
old mode 100644
new mode 100755
index 713ab3e4..90a9e419
--- a/drivers/amlogic/display/vout/tvmode.h
+++ b/drivers/amlogic/display/vout/tvmode.h
@@ -25,70 +25,6 @@
 #ifndef TVMODE_H
 #define TVMODE_H
 
-typedef enum {
-    TVMODE_480X320P_60HZ = 0,
-    TVMODE_480X272P_60HZ,
-    TVMODE_480I,
-    TVMODE_480I_RPT  ,
-    TVMODE_480CVBS,
-    TVMODE_480P  ,
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    TVMODE_480P_59HZ , // for framerate automation 480p 59.94hz
-#endif
-    TVMODE_480P_RPT  ,
-    TVMODE_576I  ,
-    TVMODE_576I_RPT  ,
-    TVMODE_576CVBS,
-    TVMODE_576P  ,
-    TVMODE_576P_RPT  ,
-    TVMODE_720P  ,
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    TVMODE_720P_59HZ , // for framerate automation 720p 59.94hz
-#endif
-    TVMODE_800P	,
-    TVMODE_800X480P_60HZ,
-    TVMODE_480X800P_60HZ,
-    TVMODE_1366X768P_60HZ,
-    TVMODE_1600X900P_60HZ,
-    TVMODE_800X600P_60HZ,
-    TVMODE_1024X600P_60HZ,
-    TVMODE_1024X768P_60HZ,
-    TVMODE_1360X768P_60HZ,
-    TVMODE_1440X900P_60HZ,
-    TVMODE_1680X1050P_60HZ,
-    TVMODE_1080I ,
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    TVMODE_1080I_59HZ , // for framerate automation 1080i 59.94hz
-#endif
-    TVMODE_1080P ,
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    TVMODE_1080P_59HZ , // for framerate automation 1080p 59.94hz
-#endif
-    TVMODE_720P_50HZ ,
-    TVMODE_1080I_50HZ ,
-    TVMODE_1080P_50HZ ,
-    TVMODE_1080P_24HZ ,
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    TVMODE_1080P_23HZ , // for framerate automation 1080p 23.97hz
-#endif
-    TVMODE_4K2K_30HZ ,
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    TVMODE_4K2K_29HZ , // for framerate automation 4k2k 29.97hz
-#endif
-    TVMODE_4K2K_25HZ ,
-    TVMODE_4K2K_24HZ ,
-#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-    TVMODE_4K2K_23HZ , // for framerate automation 4k2k 23.97hz
-#endif
-    TVMODE_4K2K_SMPTE ,
-    TVMODE_1920x1200,
-    TVMODE_VGA ,
-    TVMODE_SVGA,
-    TVMODE_XGA,
-    TVMODE_SXGA,
-    TVMODE_WSXGA,
-    TVMODE_FHDVGA,
-    TVMODE_MAX    
-} tvmode_t;
+// move to <linux/amlogic/vout/vinfo.h>
 
 #endif /* TVMODE_H */
diff --git a/drivers/amlogic/display/vout/tvoutc.c b/drivers/amlogic/display/vout/tvoutc.c
old mode 100644
new mode 100755
index 30a6b839..36e7f34d
--- a/drivers/amlogic/display/vout/tvoutc.c
+++ b/drivers/amlogic/display/vout/tvoutc.c
@@ -51,7 +51,7 @@ static const unsigned int  signal_set[SIGNAL_SET_MAX][3]=
 	{
 		VIDEO_SIGNAL_TYPE_CVBS,            	//cvbs&svideo
 		VIDEO_SIGNAL_TYPE_SVIDEO_LUMA,
-    	VIDEO_SIGNAL_TYPE_SVIDEO_CHROMA,
+	VIDEO_SIGNAL_TYPE_SVIDEO_CHROMA,
 	},
 	{	VIDEO_SIGNAL_TYPE_PROGRESSIVE_Y,     //progressive.
 		VIDEO_SIGNAL_TYPE_PROGRESSIVE_PB,
@@ -66,12 +66,12 @@ static const unsigned int  signal_set[SIGNAL_SET_MAX][3]=
 };
 static  const  char*   signal_table[]={
 	"INTERLACE_Y ", /**< Interlace Y signal */
-    	"CVBS",            /**< CVBS signal */
-    	"SVIDEO_LUMA",     /**< S-Video luma signal */
-    	"SVIDEO_CHROMA",   /**< S-Video chroma signal */
-    	"INTERLACE_PB",    /**< Interlace Pb signal */
-    	"INTERLACE_PR",    /**< Interlace Pr signal */
-    	"INTERLACE_R",     /**< Interlace R signal */
+	"CVBS",            /**< CVBS signal */
+	"SVIDEO_LUMA",     /**< S-Video luma signal */
+	"SVIDEO_CHROMA",   /**< S-Video chroma signal */
+	"INTERLACE_PB",    /**< Interlace Pb signal */
+	"INTERLACE_PR",    /**< Interlace Pr signal */
+	"INTERLACE_R",     /**< Interlace R signal */
          "INTERLACE_G",     /**< Interlace G signal */
          "INTERLACE_B",     /**< Interlace B signal */
          "PROGRESSIVE_Y",   /**< Progressive Y signal */
@@ -227,20 +227,12 @@ int tvoutc_setclk(tvmode_t mode)
 		case TVMODE_576P:
 			  setreg(&sd[xtal]);
 			  break;
-		case TVMODE_480X320P_60HZ:
-		case TVMODE_480X272P_60HZ:
 		case TVMODE_720P:
-		case TVMODE_800P:
-	        case TVMODE_800X480P_60HZ:
-	        case TVMODE_480X800P_60HZ:
-	        case TVMODE_720P_50HZ:
+		case TVMODE_720P_50HZ:
 		case TVMODE_1080I:
 		case TVMODE_1080I_50HZ:
 		case TVMODE_1080P:
 		case TVMODE_1080P_50HZ:
-		case TVMODE_SVGA:
-		case TVMODE_SXGA:
-		case TVMODE_1920x1200:
 			  setreg(&hd[xtal]);
 			  if(xtal == 1)
 			  {
@@ -260,6 +252,16 @@ static void set_tvmode_misc(tvmode_t mode)
     set_vmode_clk(mode);
 }
 
+static const reg_t * tvregs_setting_mode(tvmode_t mode)
+{
+    int i = 0;
+    for(i = 0; i < ARRAY_SIZE(tvregsTab); i++) {
+        if(mode == tvregsTab[i].tvmode)
+            return tvregsTab[i].reg_setting;
+    }
+    return NULL;
+}
+
 /*
  * uboot_display_already() uses to judge whether display has already
  * be set in uboot.
@@ -268,21 +270,15 @@ static void set_tvmode_misc(tvmode_t mode)
  */
 static int uboot_display_already(tvmode_t mode)
 {
-    tvmode_t source = vmode_to_tvmode(get_resolution_vmode());
-    if(source == mode)
-        return 1;
-    else
-        return 0;
-    /*
-    const  reg_t *s = tvregsTab[mode];
+    const  reg_t *s = tvregs_setting_mode(mode);
     unsigned int pxcnt_tab = 0;
     unsigned int lncnt_tab = 0;
 
     while(s->reg != MREG_END_MARKER) {
-        if(s->reg == P_ENCP_VIDEO_MAX_PXCNT) {
+        if(s->reg == P_ENCP_VIDEO_MAX_PXCNT || s->reg == ENCP_VIDEO_MAX_PXCNT) {
             pxcnt_tab = s->val;
         }
-        if(s->reg == P_ENCP_VIDEO_MAX_LNCNT) {
+        if(s->reg == P_ENCP_VIDEO_MAX_LNCNT || s->reg == ENCP_VIDEO_MAX_LNCNT) {
             lncnt_tab = s->val;
         }
         s++;
@@ -294,7 +290,6 @@ static int uboot_display_already(tvmode_t mode)
     } else {
         return 0;
     }
-    */
 }
 
 #if (MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8)
@@ -302,7 +297,7 @@ static unsigned int vdac_cfg_valid = 0, vdac_cfg_value = 0;
 static unsigned int cvbs_get_trimming_version(unsigned int flag)
 {
 	unsigned int version = 0xff;
-	
+
 	if( (flag&0xf0) == 0xa0 )
 		version = 5;
 	else if( (flag&0xf0) == 0x40 )
@@ -373,7 +368,8 @@ static void cvbs_performance_enhancement(tvmode_t mode)
 {
 	const reg_t *s;
 	unsigned int index = cvbs_performance_index;
-	unsigned int max = sizeof(tvregs_576cvbs_performance)/sizeof(reg_t*);
+	unsigned int max = 0;
+	unsigned int type = 0;
 
 	if( TVMODE_576CVBS != mode )
 		return ;
@@ -381,12 +377,33 @@ static void cvbs_performance_enhancement(tvmode_t mode)
 	if( 0xff == index )
 		return ;
 
-	index = (index>=max)?0:index;
-	printk("cvbs performance use table = %d\n", index);
-	s = tvregs_576cvbs_performance[index];
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
+		if( IS_MESON_M8M2_CPU )
+		{
+			max = sizeof(tvregs_576cvbs_performance_m8m2)/sizeof(reg_t*);
+			index = (index>=max)?0:index;
+			s = tvregs_576cvbs_performance_m8m2[index];
+			type = 2;
+		}
+		else
+		{
+			max = sizeof(tvregs_576cvbs_performance_m8)/sizeof(reg_t*);
+			index = (index>=max)?0:index;
+			s = tvregs_576cvbs_performance_m8[index];
+			type = 0;
+		}
+#elif MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8B
+		max = sizeof(tvregs_576cvbs_performance_m8b)/sizeof(reg_t*);
+		index = (index>=max)?0:index;
+		s = tvregs_576cvbs_performance_m8b[index];
+		type = 1;
+#endif
+
+	printk("cvbs performance type = %d, table = %d\n", type, index);
+
 	while (MREG_END_MARKER != s->reg)
 	{
-    	setreg(s++);
+	setreg(s++);
 	}
 	return ;
 }
@@ -395,10 +412,21 @@ static void cvbs_performance_enhancement(tvmode_t mode)
 
 static DEFINE_MUTEX(setmode_mutex);
 
+const static tvinfo_t * tvinfo_mode(tvmode_t mode)
+{
+    int i = 0;
+    for(i = 0; i < ARRAY_SIZE(tvinfoTab); i++) {
+        if(mode == tvinfoTab[i].tvmode)
+            return &tvinfoTab[i];
+    }
+    return NULL;
+}
+
 int tvoutc_setmode(tvmode_t mode)
 {
-    const  reg_t *s;
-#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    const reg_t *s;
+    const tvinfo_t * tvinfo;
+#if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6
     static int uboot_display_flag = 1;
 #else
     static int uboot_display_flag = 0;
@@ -412,7 +440,13 @@ int tvoutc_setmode(tvmode_t mode)
 //TODO
 //    switch_mod_gate_by_name("venc", 1);
 #endif
-    printk("TV mode %s selected.\n", tvinfoTab[mode].id);
+    tvinfo = tvinfo_mode(mode);
+    if(!tvinfo) {
+        printk(KERN_ERR "tvinfo %d not find\n", mode);
+        mutex_unlock(&setmode_mutex);
+        return 0;
+    }
+    printk("TV mode %s selected.\n", tvinfo->id);
 
 #ifdef CONFIG_ARCH_MESON8B
 	if( (mode!=TVMODE_480CVBS) && (mode!=TVMODE_576CVBS) )
@@ -428,8 +462,13 @@ int tvoutc_setmode(tvmode_t mode)
 		CLK_GATE_OFF(VCLK2_VENCI1);
 	}
 #endif
-
-    s = tvregsTab[mode];
+    s = tvregs_setting_mode(mode);
+    if(!s) {
+        printk("display mode %d regs setting failed\n", mode);
+        mutex_lock(&setmode_mutex);
+        return 0;
+    }
+    //s = tvregsTab[mode];
 
     if(uboot_display_flag) {
         uboot_display_flag = 0;
@@ -448,10 +487,14 @@ int tvoutc_setmode(tvmode_t mode)
 		(mode==TVMODE_1080I) || (mode==TVMODE_1080I_50HZ) ||
 		(mode==TVMODE_1080P) || (mode==TVMODE_1080P_50HZ) ||
 		(mode==TVMODE_1080P_24HZ) || (mode==TVMODE_4K2K_24HZ) ||
-		(mode==TVMODE_4K2K_25HZ) || (mode==TVMODE_4K2K_30HZ) ||
-		(mode==TVMODE_4K2K_SMPTE) )
+		(mode==TVMODE_4K2K_25HZ) || (mode==TVMODE_4K2K_30HZ) || (mode==TVMODE_4K2K_FAKE_5G) ||
+		(mode==TVMODE_4K2K_SMPTE) || (mode==TVMODE_4K2K_60HZ) )
 	{
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESONG9TV
+    // NOTE: for G9TV, DO NOT TURN OFF HPLL
+#else
 		WRITE_CBUS_REG_BITS(HHI_VID_PLL_CNTL, 0x0, 30, 1);
+#endif
 	}
 
     cvbs_cntl_output(0);
@@ -470,7 +513,7 @@ int tvoutc_setmode(tvmode_t mode)
     }else{
 	aml_write_reg32(P_PERIPHS_PIN_MUX_0, (aml_read_reg32(P_PERIPHS_PIN_MUX_0)&(~(3<<20))));
     }
-
+printk("%s[%d] mode is %d\n", __func__, __LINE__, mode);
 #if ((defined CONFIG_ARCH_MESON8) || (defined CONFIG_ARCH_MESON8B))
 	// for hdmi mode, leave the hpll setting to be done by hdmi module.
 	if( (mode==TVMODE_480CVBS) || (mode==TVMODE_576CVBS) )
@@ -504,7 +547,6 @@ int tvoutc_setmode(tvmode_t mode)
 		case TVMODE_480P_RPT:
 		case TVMODE_576P:
 		case TVMODE_576P_RPT:
-        case TVMODE_800X480P_60HZ:
 		case TVMODE_720P:
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 		case TVMODE_720P_59HZ:
@@ -534,22 +576,23 @@ int tvoutc_setmode(tvmode_t mode)
 		case TVMODE_4K2K_23HZ:
 #endif
         case TVMODE_4K2K_SMPTE:
+        case TVMODE_4K2K_FAKE_5G:
+        case TVMODE_4K2K_60HZ:
 		case TVMODE_VGA:
 		case TVMODE_SVGA:
 		case TVMODE_XGA:
 		case TVMODE_SXGA:
 		case TVMODE_WSXGA:
 		case TVMODE_FHDVGA:
-        aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, 2, 0, 2); //reg0x271a, select ENCP to VIU1
-        aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, 2, 4, 4); //reg0x271a, Select encP clock to VDIN
-        aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, 2, 8, 4); //reg0x271a,Enable VIU of ENC_P domain to VDIN;
+        default:
+            aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, 2, 0, 2); //reg0x271a, select ENCP to VIU1
+            aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, 2, 4, 4); //reg0x271a, Select encP clock to VDIN
+            aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, 2, 8, 4); //reg0x271a,Enable VIU of ENC_P domain to VDIN;
         break;
-		default:
-			printk(KERN_ERR "unsupport tv mode,video clk is not set!!\n");
 	}
 #endif
 
-    aml_write_reg32(P_VPP_POSTBLEND_H_SIZE, tvinfoTab[mode].xres);
+    aml_write_reg32(P_VPP_POSTBLEND_H_SIZE, tvinfo->xres);
 
 #ifdef CONFIG_ARCH_MESON3
 printk(" clk_util_clk_msr 6 = %d\n", clk_util_clk_msr(6));
@@ -584,13 +627,13 @@ printk(" clk_util_clk_msr 29 = %d\n", clk_util_clk_msr(29));
     if( (mode==TVMODE_480CVBS) || (mode==TVMODE_576CVBS) )
     {
         msleep(1000);
-#ifdef CONFIG_ARCH_MESON8B
+
 		CLK_GATE_ON(VCLK2_ENCI);
 		CLK_GATE_ON(VCLK2_VENCI1);
         CLK_GATE_ON(CTS_ENCI);
         CLK_GATE_ON(CTS_VDAC);
 		CLK_GATE_ON(DAC_CLK);
-#endif
+
         cvbs_cntl_output(1);
     }
 #endif
@@ -598,4 +641,3 @@ printk(" clk_util_clk_msr 29 = %d\n", clk_util_clk_msr(29));
     mutex_unlock(&setmode_mutex);
     return 0;
 }
-
diff --git a/drivers/amlogic/display/vout/tvoutc.h b/drivers/amlogic/display/vout/tvoutc.h
old mode 100644
new mode 100755
index ae9e96d0..5c08025b
--- a/drivers/amlogic/display/vout/tvoutc.h
+++ b/drivers/amlogic/display/vout/tvoutc.h
@@ -1,61 +1,61 @@
-/*
- * Amlogic Apollo
- * frame buffer driver
- *
- * Copyright (C) 2009 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
- *
- * Author:	Tim Yao <timyao@amlogic.com>
- *
- */
-
-#ifndef TVOUTC_H
-#define TVOUTC_H
-
-#include "tvmode.h"
-
-#define  	DEFAULT_VDAC_SEQUENCE   	0x120120
-
-typedef  enum{
-	INTERALCE_COMPONENT=0,
-	CVBS_SVIDEO,
-	PROGRESSIVE,
-	VGA_SVIDEO,
-	SIGNAL_SET_MAX
-}video_signal_set_t;
-typedef enum {
-    VIDEO_SIGNAL_TYPE_INTERLACE_Y = 0, /**< Interlace Y signal */
-    VIDEO_SIGNAL_TYPE_CVBS,            /**< CVBS signal */
-    VIDEO_SIGNAL_TYPE_SVIDEO_LUMA,     /**< S-Video luma signal */
-    VIDEO_SIGNAL_TYPE_SVIDEO_CHROMA,   /**< S-Video chroma signal */
-    VIDEO_SIGNAL_TYPE_INTERLACE_PB,    /**< Interlace Pb signal */
-    VIDEO_SIGNAL_TYPE_INTERLACE_PR,    /**< Interlace Pr signal */
-    VIDEO_SIGNAL_TYPE_INTERLACE_R,     /**< Interlace R signal */
-    VIDEO_SIGNAL_TYPE_INTERLACE_G,     /**< Interlace G signal */
-    VIDEO_SIGNAL_TYPE_INTERLACE_B,     /**< Interlace B signal */
-    VIDEO_SIGNAL_TYPE_PROGRESSIVE_Y,   /**< Progressive Y signal */
-    VIDEO_SIGNAL_TYPE_PROGRESSIVE_PB,  /**< Progressive Pb signal */
-    VIDEO_SIGNAL_TYPE_PROGRESSIVE_PR,  /**< Progressive Pr signal */
-    VIDEO_SIGNAL_TYPE_PROGEESSIVE_R,   /**< Progressive R signal */
-    VIDEO_SIGNAL_TYPE_PROGEESSIVE_G,   /**< Progressive G signal */
-    VIDEO_SIGNAL_TYPE_PROGEESSIVE_B,   /**< Progressive B signal */
-    VIDEO_SIGNAL_TYPE_MAX
-} video_signal_type_t;
-
-int tvoutc_setmode(tvmode_t mode);
-int 	 get_current_vdac_setting(void) ;
-void  change_vdac_setting(unsigned int  vdec_setting,vmode_t mode);
-#endif /* TVOUTC_H */
+/*
+ * Amlogic Apollo
+ * frame buffer driver
+ *
+ * Copyright (C) 2009 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:	Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef TVOUTC_H
+#define TVOUTC_H
+
+#include "tvmode.h"
+
+#define  	DEFAULT_VDAC_SEQUENCE   	0x120120
+
+typedef  enum{
+	INTERALCE_COMPONENT=0,
+	CVBS_SVIDEO,
+	PROGRESSIVE,
+	VGA_SVIDEO,
+	SIGNAL_SET_MAX
+}video_signal_set_t;
+typedef enum {
+    VIDEO_SIGNAL_TYPE_INTERLACE_Y = 0, /**< Interlace Y signal */
+    VIDEO_SIGNAL_TYPE_CVBS,            /**< CVBS signal */
+    VIDEO_SIGNAL_TYPE_SVIDEO_LUMA,     /**< S-Video luma signal */
+    VIDEO_SIGNAL_TYPE_SVIDEO_CHROMA,   /**< S-Video chroma signal */
+    VIDEO_SIGNAL_TYPE_INTERLACE_PB,    /**< Interlace Pb signal */
+    VIDEO_SIGNAL_TYPE_INTERLACE_PR,    /**< Interlace Pr signal */
+    VIDEO_SIGNAL_TYPE_INTERLACE_R,     /**< Interlace R signal */
+    VIDEO_SIGNAL_TYPE_INTERLACE_G,     /**< Interlace G signal */
+    VIDEO_SIGNAL_TYPE_INTERLACE_B,     /**< Interlace B signal */
+    VIDEO_SIGNAL_TYPE_PROGRESSIVE_Y,   /**< Progressive Y signal */
+    VIDEO_SIGNAL_TYPE_PROGRESSIVE_PB,  /**< Progressive Pb signal */
+    VIDEO_SIGNAL_TYPE_PROGRESSIVE_PR,  /**< Progressive Pr signal */
+    VIDEO_SIGNAL_TYPE_PROGEESSIVE_R,   /**< Progressive R signal */
+    VIDEO_SIGNAL_TYPE_PROGEESSIVE_G,   /**< Progressive G signal */
+    VIDEO_SIGNAL_TYPE_PROGEESSIVE_B,   /**< Progressive B signal */
+    VIDEO_SIGNAL_TYPE_MAX
+} video_signal_type_t;
+
+int tvoutc_setmode(tvmode_t mode);
+int 	 get_current_vdac_setting(void) ;
+void  change_vdac_setting(unsigned int  vdec_setting,vmode_t mode);
+#endif /* TVOUTC_H */
diff --git a/drivers/amlogic/display/vout/vdac_switch.c b/drivers/amlogic/display/vout/vdac_switch.c
old mode 100644
new mode 100755
index 8cf30afb..0d6ac6e0
--- a/drivers/amlogic/display/vout/vdac_switch.c
+++ b/drivers/amlogic/display/vout/vdac_switch.c
@@ -1,5 +1,5 @@
 /*************************************************************
- * Amlogic 
+ * Amlogic
  * vdac switch program
  *
  * Copyright (C) 2010 Amlogic, Inc.
@@ -19,8 +19,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
  *
  * Author:   jets.yan@amlogic
- *		   
- *		   
+ *
+ *
  **************************************************************/
 #include <linux/version.h>
 #include <linux/module.h>
@@ -75,7 +75,7 @@ static inline int str2lower(char *dst, char *src, int length)
 
 #ifdef  CONFIG_PM
 static int  meson_vdac_switch_suspend(struct platform_device *pdev, pm_message_t state)
-{	
+{
 #ifdef CONFIG_HAS_EARLYSUSPEND
     if (early_suspend_flag)
         return 0;
@@ -93,7 +93,7 @@ static int  meson_vdac_switch_resume(struct platform_device *pdev)
 
 	return 0;
 }
-#endif 
+#endif
 
 
 #ifdef CONFIG_HAS_EARLYSUSPEND
@@ -136,7 +136,7 @@ static int vdac_switch_set_mode(unsigned char mode)
 
 /*****************************************************************
 **
-**	vout driver interface  
+**	vout driver interface
 **
 ******************************************************************/
 #define VDACSWITCH_CLASS_NAME "vdac_hw_switch"
@@ -190,7 +190,7 @@ static struct class_attribute vdacswitch_class_attrs[] =
     __ATTR_NULL
 };
 
-static struct class vdacswitch_class = 
+static struct class vdacswitch_class =
 {
     .name = VDACSWITCH_CLASS_NAME,
     .class_attrs = vdacswitch_class_attrs,
@@ -254,7 +254,7 @@ static int meson_vdac_switch_probe(struct platform_device *pdev)
     int val = 0;
     struct device_node *init_data;
 #endif
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"start init vdac switch module \r\n");
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"start init vdac switch module\n");
 #ifdef CONFIG_HAS_EARLYSUSPEND
     early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
     early_suspend.suspend = meson_vdac_switch_early_suspend;
@@ -310,10 +310,10 @@ static int meson_vdac_switch_remove(struct platform_device *pdev)
 static struct platform_driver vdac_switch_driver = {
     .probe      = meson_vdac_switch_probe,
     .remove     = meson_vdac_switch_remove,
-#ifdef  CONFIG_PM      
+#ifdef  CONFIG_PM
     .suspend  =meson_vdac_switch_suspend,
     .resume    =meson_vdac_switch_resume,
-#endif    
+#endif
     .driver     = {
         .name   = DEVICE_NAME,
     }
@@ -322,14 +322,14 @@ static struct platform_driver vdac_switch_driver = {
 static int __init vdac_switch_init_module(void)
 {
 	int ret =0;
-    
+
     printk("%s\n", __func__);
-	if (platform_driver_register(&vdac_switch_driver)) 
+	if (platform_driver_register(&vdac_switch_driver))
 	{
-   		amlog_level(LOG_LEVEL_HIGH,"failed to register vdac switch driver\n");
-    	ret= -ENODEV;
+		amlog_level(LOG_LEVEL_HIGH,"failed to register vdac switch driver\n");
+	ret= -ENODEV;
 	}
-	
+
 	return ret;
 }
 
diff --git a/drivers/amlogic/display/vout/vout_log.h b/drivers/amlogic/display/vout/vout_log.h
old mode 100644
new mode 100755
index ac398522..0eb4f798
--- a/drivers/amlogic/display/vout/vout_log.h
+++ b/drivers/amlogic/display/vout/vout_log.h
@@ -1,27 +1,26 @@
-#ifndef  TV_LOG_H
-#define TV_LOG_H
-
-#define DEBUG
-#ifdef  DEBUG
-#define  AMLOG   1
-#define LOG_LEVEL_VAR amlog_level_vout
-#define LOG_MASK_VAR amlog_mask_vout
-#endif
-
-
-#define  	LOG_LEVEL_HIGH    		0x00f
-#define	LOG_LEVEL_1			0x001
-#define 	LOG_LEVEL_LOW			0x000
-
-#define LOG_LEVEL_DESC \
-"[0x00]LOW[0X01]LEVEL1[0xf]HIGH"	
-
-#define  	LOG_MASK_INIT			0x001
-#define	LOG_MASK_IOCTL		0x002
-#define	LOG_MASK_HARDWARE	0x004
-#define	LOG_MASK_PARA			0x008
-#define 	LOG_MASK_DESC \
-"[0x01]:INIT,[0x02]:IOCTL,[0x04]:HARDWARE,[0x08]PARA"
-
-#endif
-
+#ifndef  TV_LOG_H
+#define TV_LOG_H
+
+#define DEBUG
+#ifdef  DEBUG
+#define  AMLOG   1
+#define LOG_LEVEL_VAR amlog_level_vout
+#define LOG_MASK_VAR amlog_mask_vout
+#endif
+
+
+#define  	LOG_LEVEL_HIGH    		0x00f
+#define	LOG_LEVEL_1			0x001
+#define 	LOG_LEVEL_LOW			0x000
+
+#define LOG_LEVEL_DESC \
+"[0x00]LOW[0X01]LEVEL1[0xf]HIGH"
+
+#define  	LOG_MASK_INIT			0x001
+#define	LOG_MASK_IOCTL		0x002
+#define	LOG_MASK_HARDWARE	0x004
+#define	LOG_MASK_PARA			0x008
+#define 	LOG_MASK_DESC \
+"[0x01]:INIT,[0x02]:IOCTL,[0x04]:HARDWARE,[0x08]PARA"
+
+#endif
diff --git a/drivers/amlogic/display/vout/vout_notify.c b/drivers/amlogic/display/vout/vout_notify.c
old mode 100644
new mode 100755
index 8848c1d5..70d77b60
--- a/drivers/amlogic/display/vout/vout_notify.c
+++ b/drivers/amlogic/display/vout/vout_notify.c
@@ -6,7 +6,7 @@
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file COPYING in the main directory of this archive
  * for more details.
- * author :   
+ * author :
  *		 jianfeng_wang@amlogic
  */
 #include <linux/module.h>
@@ -14,12 +14,15 @@
 #include <linux/delay.h>
 #include <linux/sched.h>
 
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+extern vmode_t mode_by_user;
+#endif
 
 static BLOCKING_NOTIFIER_HEAD(vout_notifier_list);
-static  DEFINE_MUTEX(vout_mutex)  ;
-static  vout_module_t  vout_module={
+static DEFINE_MUTEX(vout_mutex);
+static vout_module_t  vout_module={
 		.vout_server_list={&vout_module.vout_server_list,&vout_module.vout_server_list},
-		.curr_vout_server=NULL,	
+		.curr_vout_server=NULL,
 };
 /**
  *	vout_register_client - register a client notifier
@@ -85,9 +88,9 @@ vmode_t get_current_vmode(void)
 		BUG_ON(vout_module.curr_vout_server->op.get_vinfo == NULL);
 		info = vout_module.curr_vout_server->op.get_vinfo();
 		mode=info->mode;
-	}	
+	}
 	mutex_unlock(&vout_mutex);
-	
+
 	return mode;
 }
 EXPORT_SYMBOL(get_current_vmode);
@@ -104,7 +107,7 @@ int set_vframe_rate_hint(int duration)
     list_for_each_entry(p_server, &vout_module.vout_server_list, list)
     {
 		if ( (p_server->op.set_vframe_rate_hint!=NULL) && (p_server->op.set_vframe_rate_hint(duration)==0) )
-    	{
+	{
 			//mutex_unlock(&vout_mutex);
 			return 0;
         }
@@ -147,7 +150,7 @@ void wakeup_early_suspend_proc(void)
 	wake_up_flag = 1;
 }
 #endif
-int vout_suspend(void)
+int vout_suspend(int pm_event)
 {
 	int ret=0 ;
 	vout_server_t  *p_server = vout_module.curr_vout_server;
@@ -166,14 +169,14 @@ int vout_suspend(void)
 	{
 		if(p_server->op.vout_suspend)
 		{
-			ret = p_server->op.vout_suspend() ;
+			ret = p_server->op.vout_suspend(pm_event) ;
 		}
 	}
 	mutex_unlock(&vout_mutex);
 	return ret;
 }
 EXPORT_SYMBOL(vout_suspend);
-int vout_resume(void)
+int vout_resume(int pm_event)
 {
 	vout_server_t  *p_server = vout_module.curr_vout_server;
 
@@ -182,10 +185,10 @@ int vout_resume(void)
 	{
 		if (p_server->op.vout_resume)
 		{
-			p_server->op.vout_resume() ; //ignore error when resume.
+			p_server->op.vout_resume(pm_event) ; //ignore error when resume.
 		}
 	}
-	
+
 	mutex_unlock(&vout_mutex);
 	return 0;
 }
@@ -193,11 +196,12 @@ EXPORT_SYMBOL(vout_resume);
 /*
 *interface export to client who want to set current vmode.
 */
+extern void update_vout_mode_attr(const vinfo_t* vinfo);
 int set_current_vmode(vmode_t mode)
 {
 	int r=-1;
 	vout_server_t  *p_server;
-	
+
 	mutex_lock(&vout_mutex);
 	list_for_each_entry(p_server, &vout_module.vout_server_list, list)
 	{
@@ -207,6 +211,17 @@ int set_current_vmode(vmode_t mode)
 			vout_module.curr_vout_server=p_server;
 			r=p_server->op.set_vmode(mode);
 			//break;  do not exit , should disable other modules
+			if (vout_module.curr_vout_server)
+			{
+				BUG_ON(vout_module.curr_vout_server->op.get_vinfo == NULL);
+				update_vout_mode_attr(vout_module.curr_vout_server->op.get_vinfo());
+#ifdef CONFIG_HIBERNATION
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+				if (VMODE_INIT_NULL == mode_by_user)
+					mode_by_user = mode;
+#endif /* CONFIG_AML_VOUT_FRAMERATE_AUTOMATION */
+#endif /* CONFIG_HIBERNATION */
+			}
 		}
 		else
 		{
@@ -227,7 +242,7 @@ vmode_t validate_vmode(char *name)
 {
 	vmode_t r=VMODE_MAX;
 	vout_server_t  *p_server;
-	
+
 	mutex_lock(&vout_mutex);
 	list_for_each_entry(p_server, &vout_module.vout_server_list, list)
 	{
@@ -266,7 +281,7 @@ int vout_register_server(vout_server_t*  mem_server)
 		if(p_server->name && mem_server->name && strcmp(p_server->name,mem_server->name)==0)
 		{
 			//vout server already registered.
-			
+
 			mutex_unlock(&vout_mutex);
 			return -1;
 		}
@@ -287,11 +302,11 @@ int vout_unregister_server(vout_server_t*  mem_server)
 		if(p_server->name && mem_server->name && strcmp(p_server->name,mem_server->name)==0)
 		{
 			//we will not move current vout server pointer automatically if current vout server
-			//pointer is the one which will be deleted next .so you should change current vout server 
+			//pointer is the one which will be deleted next .so you should change current vout server
 			//first then remove it .
 			if(vout_module.curr_vout_server==p_server)
 			vout_module.curr_vout_server=NULL;
-			
+
 			list_del(&mem_server->list);
 			mutex_unlock(&vout_mutex);
 			return 0;
diff --git a/drivers/amlogic/display/vout/vout_serve.c b/drivers/amlogic/display/vout/vout_serve.c
old mode 100644
new mode 100755
index 207fad9d..01c23aff
--- a/drivers/amlogic/display/vout/vout_serve.c
+++ b/drivers/amlogic/display/vout/vout_serve.c
@@ -1,5 +1,5 @@
 /*************************************************************
- * Amlogic 
+ * Amlogic
  * vout  serve program
  *
  * Copyright (C) 2010 Amlogic, Inc.
@@ -19,8 +19,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
  *
  * Author:   jianfeng_wang@amlogic
- *		   
- *		   
+ *
+ *
  **************************************************************/
 #include <linux/version.h>
 #include <linux/module.h>
@@ -64,6 +64,15 @@ SET_VOUT_CLASS_ATTR(axis,set_vout_window)
 SET_VOUT_CLASS_ATTR(wr_reg,write_reg)
 SET_VOUT_CLASS_ATTR(rd_reg,read_reg)
 
+void update_vout_mode_attr(const vinfo_t* vinfo)
+{
+	if (vinfo == NULL) {
+		printk("error vinfo is null\n");
+		return;
+	} else
+		printk("vinfo mode is: %s\n", vinfo->name);
+	snprintf(mode,40,"%s",vinfo->name);
+}
 
 static  vout_info_t	vout_info;
 int power_level=0;
@@ -77,7 +86,7 @@ EXPORT_SYMBOL(get_power_level);
 
 /*****************************************************************
 **
-**	sysfs impletement part  
+**	sysfs impletement part
 **
 ******************************************************************/
 static  void   func_default_null(char  *str)
@@ -86,7 +95,7 @@ static  void   func_default_null(char  *str)
 }
 static   int* parse_para(char *para,char   *para_num)
 {
-	 static unsigned   int  buffer[MAX_NUMBER_PARA] ; 
+	 static unsigned   int  buffer[MAX_NUMBER_PARA] ;
 	 char  *endp ;
 	 int *pt=NULL;
 	 int len=0,count=0;
@@ -98,20 +107,20 @@ static   int* parse_para(char *para,char   *para_num)
 	endp=(char*)buffer;
 	do
 	{
-		//filter space out 
+		//filter space out
 		while(para && ( isspace(*para) || !isalnum(*para)) && len)
 		{
 			para++;
-			len --; 
+			len --;
 		}
 		if(len==0) break;
 		*pt++=simple_strtoul(para,&endp,0);
-		
+
 		para=endp;
 		len=strlen(para);
 	}while(endp && ++count<*para_num&&count<MAX_NUMBER_PARA) ;
 	*para_num=count;
-	
+
 	return  buffer;
 }
 
@@ -128,50 +137,53 @@ static  void  write_reg(char *para)
 }
 
 
-	
+
 #ifdef  CONFIG_PM
 static int  meson_vout_suspend(struct platform_device *pdev, pm_message_t state);
 static int  meson_vout_resume(struct platform_device *pdev);
 #endif
 
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-vmode_t mode_by_user = VMODE_INIT_NULL;
+__nosavedata vmode_t mode_by_user = VMODE_INIT_NULL;
+
+void update_vmode_status(char* name)
+{
+	snprintf(mode, 40, "%s\n", name);
+}
+
+EXPORT_SYMBOL(update_vmode_status);
+
 #endif
 
 static  void  set_vout_mode(char * name)
 {
 	vmode_t    mode;
 
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"tvmode set to %s\r\n",name);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"tvmode set to %s\n",name);
 	mode=validate_vmode(name);
 	if(VMODE_MAX==mode)
 	{
 		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"no matched vout mode\n");
-		return ; 
+		return ;
 	}
 
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
 	mode_by_user = mode;
+#endif
 
 	if(mode==get_current_vmode())
 	{
-		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"don't set the same mode as current.\r\n");	
+		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"don't set the same mode as current.\n");
 		return ;
 	}
 
 	set_current_vmode(mode);
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"new mode %s set ok\r\n",name);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"new mode %s set ok\n",name);
 	vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE,&mode) ;
 	printk("%s[%d]\n", __func__, __LINE__);
 }
 
 #ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
-void update_vmode_status(char* name)
-{
-	snprintf(mode, 40, "%s\n", name);
-}
-
-EXPORT_SYMBOL(update_vmode_status);
-
 void set_vout_mode_fr_auto(char* name)
 {
 	vmode_t    vmode;
@@ -182,14 +194,14 @@ void set_vout_mode_fr_auto(char* name)
 	if(VMODE_MAX==vmode)
 	{
 		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"no matched vout mode\n");
-		return ; 
+		return ;
 	}
 	if(vmode==get_current_vmode())
 	{
 		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"don't set the same mode as current.\n");
 		return ;
 	}
-	
+
 	update_vmode_status(name);
 
 	set_current_vmode(vmode);
@@ -208,35 +220,35 @@ char* get_vout_mode_internal(void)
 EXPORT_SYMBOL(get_vout_mode_internal);
 
 //axis type : 0x12  0x100 0x120 0x130
-static void  set_vout_window(char *para) 
+static void  set_vout_window(char *para)
 {
 #define   OSD_COUNT   2
 	static  disp_rect_t  disp_rect[OSD_COUNT];
-	char  count=OSD_COUNT*4;	
+	char  count=OSD_COUNT*4;
 	int   *pt=&disp_rect[0].x;
-	
+
 
 	//parse window para .
 	memcpy(pt,parse_para(para,&count),sizeof(disp_rect_t)*OSD_COUNT);
-	
+
 	if(count >=4 && count <8 )
 	{
 		disp_rect[1]=disp_rect[0] ;
 	}
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"osd0=>x:%d ,y:%d,w:%d,h:%d\r\n osd1=> x:%d,y:%d,w:%d,h:%d \r\n", \
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"osd0=>x:%d ,y:%d,w:%d,h:%d\n osd1=> x:%d,y:%d,w:%d,h:%d\n", \
 			*pt,*(pt+1),*(pt+2),*(pt+3),*(pt+4),*(pt+5),*(pt+6),*(pt+7));
 	vout_notifier_call_chain(VOUT_EVENT_OSD_DISP_AXIS,&disp_rect[0]) ;
 }
 
 /*****************************************************************
 **
-**	sysfs  declare part 
+**	sysfs  declare part
 **
 ******************************************************************/
 
 static  struct  class_attribute   *vout_attr[]={
 &class_vout_attr_enable,
-&class_vout_attr_mode,	
+&class_vout_attr_mode,
 &class_vout_attr_axis ,
 &class_vout_attr_wr_reg,
 &class_vout_attr_rd_reg,
@@ -252,7 +264,7 @@ static int  create_vout_attr(void)
 	vout_info.base_class=class_create(THIS_MODULE,VOUT_CLASS_NAME);
 	if(IS_ERR(vout_info.base_class))
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create vout class fail\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create vout class fail\n");
 		return  -1 ;
 	}
 	//create  class attr
@@ -260,7 +272,7 @@ static int  create_vout_attr(void)
 	{
 		if ( class_create_file(vout_info.base_class,vout_attr[i]))
 		{
-			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp attribute %s fail\r\n",vout_attr[i]->attr.name);
+			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp attribute %s fail\n",vout_attr[i]->attr.name);
 		}
 	}
 
@@ -274,31 +286,54 @@ static int  create_vout_attr(void)
 
 #ifdef  CONFIG_PM
 static int  meson_vout_suspend(struct platform_device *pdev, pm_message_t state)
-{	
+{
 #ifdef CONFIG_HAS_EARLYSUSPEND
     if (early_suspend_flag)
         return 0;
 #endif
-	vout_suspend();
-	return 0;
+    vout_suspend(PM_EVENT_SUSPEND);
+    return 0;
 }
 
 static int  meson_vout_resume(struct platform_device *pdev)
 {
 #ifdef CONFIG_SCREEN_ON_EARLY
     if (early_resume_flag) {
-    	early_resume_flag = 0;
-    	return 0;
+	early_resume_flag = 0;
+	return 0;
     }
 #endif
 #ifdef CONFIG_HAS_EARLYSUSPEND
     if (early_suspend_flag)
         return 0;
 #endif
-	vout_resume();
-	return 0;
+    vout_resume(PM_EVENT_RESUME);
+    return 0;
+}
+#endif
+
+#ifdef CONFIG_HIBERNATION
+static int  meson_vout_freeze(struct device *dev)
+{
+    vout_suspend(PM_EVENT_FREEZE);
+    return 0;
+}
+
+static int  meson_vout_thaw(struct device *dev)
+{
+    vout_resume(PM_EVENT_THAW);
+    return 0;
 }
-#endif 
+
+static int  meson_vout_restore(struct device *dev)
+{
+    vmode_t mode;
+    vout_resume(PM_EVENT_RESTORE);
+    mode = get_current_vmode();
+    vout_notifier_call_chain(VOUT_EVENT_MODE_CHANGE, &mode);
+    return 0;
+}
+#endif
 
 #ifdef CONFIG_SCREEN_ON_EARLY
 void resume_vout_early(void)
@@ -319,7 +354,7 @@ static void meson_vout_early_suspend(struct early_suspend *h)
     if (early_suspend_flag)
         return;
     //meson_vout_suspend((struct platform_device *)h->param, PMSG_SUSPEND);
-    vout_suspend();
+    vout_suspend(PM_EVENT_SUSPEND);
     early_suspend_flag = 1;
 }
 
@@ -329,22 +364,22 @@ static void meson_vout_late_resume(struct early_suspend *h)
         return;
     early_suspend_flag = 0;
     //meson_vout_resume((struct platform_device *)h->param);
-    vout_resume();
+    vout_resume(PM_EVENT_RESUME);
 }
 #endif
 
 /*****************************************************************
 **
-**	vout driver interface  
+**	vout driver interface
 **
 ******************************************************************/
-static int 
+static int
  meson_vout_probe(struct platform_device *pdev)
 {
 	int ret =-1;
-	
+
 	vout_info.base_class=NULL;
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"start init vout module \r\n");
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"start init vout module\n");
 #ifdef CONFIG_HAS_EARLYSUSPEND
     early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
     early_suspend.suspend = meson_vout_early_suspend;
@@ -359,11 +394,11 @@ static int
 	ret =create_vout_attr();
 	if(ret==0)
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout attribute ok \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout attribute ok\n");
 	}
 	else
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout attribute fail \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout attribute fail\n");
 	}
 
 	return ret;
@@ -371,19 +406,19 @@ static int
 static int
  meson_vout_remove(struct platform_device *pdev)
 {
-   	int i;
+	int i;
 	if(vout_info.base_class==NULL) return -1;
 #ifdef CONFIG_HAS_EARLYSUSPEND
     unregister_early_suspend(&early_suspend);
 #endif
-	
+
 	for(i=0;i<VOUT_ATTR_MAX;i++)
 	{
 		class_remove_file(vout_info.base_class,vout_attr[i]) ;
 	}
-		
+
 	class_destroy(vout_info.base_class);
-	
+
 	return 0;
 }
 
@@ -394,39 +429,50 @@ static const struct of_device_id meson_vout_dt_match[]={
 	{},
 };
 
+#ifdef CONFIG_HIBERNATION
+struct dev_pm_ops vout_pm = {
+	.freeze		= meson_vout_freeze,
+	.thaw		= meson_vout_thaw,
+	.restore	= meson_vout_restore,
+};
+#endif
+
 static struct platform_driver
 vout_driver = {
     .probe      = meson_vout_probe,
     .remove     = meson_vout_remove,
-#ifdef  CONFIG_PM      
+#ifdef  CONFIG_PM
     .suspend  =meson_vout_suspend,
     .resume    =meson_vout_resume,
-#endif    
+#endif
     .driver     = {
         .name   = "mesonvout",
         .of_match_table=meson_vout_dt_match,
+#ifdef CONFIG_HIBERNATION
+        .pm	= &vout_pm,
+#endif
     }
 };
 static int __init vout_init_module(void)
 {
 	int ret =0;
-    
+
     printk("%s\n", __func__);
-	if (platform_driver_register(&vout_driver)) 
+	if (platform_driver_register(&vout_driver))
 	{
-       		amlog_level(LOG_LEVEL_HIGH,"failed to register osd driver\n");
-        	ret= -ENODEV;
-    	}
-	
+		amlog_level(LOG_LEVEL_HIGH,"failed to register osd driver\n");
+		ret= -ENODEV;
+	}
+
 	return ret;
 
 }
 static __exit void vout_exit_module(void)
 {
-	
+
 	amlog_level(LOG_LEVEL_HIGH,"osd_remove_module.\n");
 
-    	platform_driver_unregister(&vout_driver);
+	platform_driver_unregister(&vout_driver);
 }
 module_init(vout_init_module);
 module_exit(vout_exit_module);
diff --git a/drivers/amlogic/display/vout/vout_serve.h b/drivers/amlogic/display/vout/vout_serve.h
old mode 100644
new mode 100755
index b9e465ce..8148c35a
--- a/drivers/amlogic/display/vout/vout_serve.h
+++ b/drivers/amlogic/display/vout/vout_serve.h
@@ -1,83 +1,83 @@
-#ifndef   _VOUT_SERVE_H
-#define	_VOUT_SERVE_H
-
-#ifdef CONFIG_AM_TV_OUTPUT
-#include  "tvoutc.h"	
-#endif
-#include  <linux/amlogic/vout/vout_notify.h>
-
-/*****************************************************************
-**
-**	type define part 
-**
-******************************************************************/
-
-static  DEFINE_MUTEX(vout_mutex)  ;
-
+#ifndef   _VOUT_SERVE_H
+#define	_VOUT_SERVE_H
+
+#ifdef CONFIG_AM_TV_OUTPUT
+#include  "tvoutc.h"
+#endif
+#include  <linux/amlogic/vout/vout_notify.h>
+
+/*****************************************************************
+**
+**	type define part
+**
+******************************************************************/
+
+static  DEFINE_MUTEX(vout_mutex)  ;
+
 typedef enum   {
-VOUT_ATTR_ENABLE=0 ,
-VOUT_ATTR_MODE,
-VOUT_ATTR_AXIS,
-VOUT_ATTR_WR_REG,
-VOUT_ATTR_RD_REG,
-VOUT_ATTR_MAX
-}vout_attr_t ;
-
+VOUT_ATTR_ENABLE=0 ,
+VOUT_ATTR_MODE,
+VOUT_ATTR_AXIS,
+VOUT_ATTR_WR_REG,
+VOUT_ATTR_RD_REG,
+VOUT_ATTR_MAX
+}vout_attr_t ;
+
 typedef  struct {
 	unsigned int  addr;
 	unsigned int  value;
-}vout_reg_t ;
-
-typedef  struct {
+}vout_reg_t ;
+
+typedef  struct {
 	int x ;
 	int y ;
 	int w ;
 	int h ;
-}disp_rect_t;
-typedef struct {
-	 struct class  *base_class;
-}vout_info_t;
-/*****************************************************************
-**
-**	macro define part 
-**
-******************************************************************/
-#define  VOUT_CLASS_NAME  	"display"
-#define	MAX_NUMBER_PARA  10
-
-#define  SHOW_INFO(name)      \
-	{return snprintf(buf,40, "%s\n", name);}  	
+}disp_rect_t;
+typedef struct {
+	 struct class  *base_class;
+}vout_info_t;
+/*****************************************************************
+**
+**	macro define part
+**
+******************************************************************/
+#define  VOUT_CLASS_NAME  	"display"
+#define	MAX_NUMBER_PARA  10
+
+#define  SHOW_INFO(name)      \
+	{return snprintf(buf,40, "%s\n", name);}
 
 #define  STORE_INFO(name)\
-	{mutex_lock(&vout_mutex);\
+	{mutex_lock(&vout_mutex);\
 	snprintf(name,40,"%s",buf) ;\
-	mutex_unlock(&vout_mutex); }			
-		
-#define    SET_VOUT_CLASS_ATTR(name,op)    \
-static  char    name[40] ;				  \
-static ssize_t aml_vout_attr_##name##_show(struct class  * cla, struct class_attribute *attr, char *buf)   \
+	mutex_unlock(&vout_mutex); }
+
+#define    SET_VOUT_CLASS_ATTR(name,op)    \
+static  char    name[40] __nosavedata;				  \
+static ssize_t aml_vout_attr_##name##_show(struct class  * cla, struct class_attribute *attr, char *buf)   \
 {  											\
 	SHOW_INFO(name)  	\
 } 											\
-static ssize_t  aml_vout_attr_##name##_store(struct class *cla,  struct class_attribute *attr, \
+static ssize_t  aml_vout_attr_##name##_store(struct class *cla,  struct class_attribute *attr, \
 			    const char *buf, size_t count)    \
 {\
-	STORE_INFO(name);   						\
+	STORE_INFO(name);   						\
 	op(name) ;						\
 	return strnlen(buf, count);				\
 }											\
-struct  class_attribute  class_vout_attr_##name =  \
-__ATTR(name, S_IRUGO|S_IWUSR|S_IWGRP, aml_vout_attr_##name##_show, aml_vout_attr_##name##_store) ; 
-/*****************************************************************
-**
-**	function  declare  part 
-**
-******************************************************************/
-static  void  read_reg(char *para);
+struct  class_attribute  class_vout_attr_##name =  \
+__ATTR(name, S_IRUGO|S_IWUSR|S_IWGRP, aml_vout_attr_##name##_show, aml_vout_attr_##name##_store) ;
+/*****************************************************************
+**
+**	function  declare  part
+**
+******************************************************************/
+static  void  read_reg(char *para);
 static  void  write_reg(char *para);
-static  void  set_vout_mode(char *mode) ;
-static void  set_vout_window(char *para) ;
-static  void   func_default_null(char  *str);
-
-
-#endif
+static  void  set_vout_mode(char *mode) ;
+static void  set_vout_window(char *para) ;
+static  void   func_default_null(char  *str);
+
+
+#endif
diff --git a/drivers/amlogic/display/vout2/Kconfig b/drivers/amlogic/display/vout2/Kconfig
index 772ff840..11ad00fd 100755
--- a/drivers/amlogic/display/vout2/Kconfig
+++ b/drivers/amlogic/display/vout2/Kconfig
@@ -6,9 +6,8 @@ menu "Amlogic video output2 module"
 config AM_TV_OUTPUT2
 	tristate "TV output2"
 	default n
-	help  
+	help
 		tv output2 module
 
-		
+
 endmenu
-	
diff --git a/drivers/amlogic/display/vout2/Makefile b/drivers/amlogic/display/vout2/Makefile
index f81652ed..aae18ba1 100755
--- a/drivers/amlogic/display/vout2/Makefile
+++ b/drivers/amlogic/display/vout2/Makefile
@@ -4,4 +4,3 @@ display2-objs=vout2_notify.o  vout2_serve.o
 
 obj-$(CONFIG_AM_TV_OUTPUT2)  += am_tvout2.o
 am_tvout2-objs :=   tvoutc2.o  tvconf2.o nulldisp.o
-
diff --git a/drivers/amlogic/display/vout2/nulldisp.c b/drivers/amlogic/display/vout2/nulldisp.c
old mode 100644
new mode 100755
index bee3b24b..7a57fa9e
--- a/drivers/amlogic/display/vout2/nulldisp.c
+++ b/drivers/amlogic/display/vout2/nulldisp.c
@@ -1,133 +1,133 @@
-/*
- * AMLOGIC NullDisp controller driver.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
- *
- *
- */
-#include <linux/init.h>
-#include <linux/version.h>
-#include <linux/types.h>
-#include <linux/slab.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/string.h>
-#include <linux/delay.h>
-
-#include <mach/am_regs.h>
-
-#include <linux/amlogic/vout/vinfo.h>
-#include <linux/amlogic/vout/vout_notify.h>
-
-
-#define DisableVideoLayer() \
-    do { CLEAR_MPEG_REG_MASK(VPP2_MISC, \
-         VPP_VD1_PREBLEND|VPP_VD2_PREBLEND|VPP_VD2_POSTBLEND|VPP_VD1_POSTBLEND ); \
-    } while (0)
-
-static const vinfo_t nulldisp_info =
-{
-    .name              = "null",
-    .mode              = VMODE_MAX+1,
-    .width             = 1920,
-    .height            = 1080,
-    .field_height      = 1080,
-    .aspect_ratio_num  = 16,
-    .aspect_ratio_den  = 9,
-    .sync_duration_num = 50,
-    .sync_duration_den = 1,
-};
-
-static const vinfo_t *nulldisp_get_current_info(void)
-{
-    return &nulldisp_info;
-}
-
-
-static int nulldisp_set_current_vmode(vmode_t mode)
-{
-    return 0;
-}
-
-static const vinfo_t *get_valid_vinfo(char  *mode)
-{
-    if(strncmp(nulldisp_info.name,mode,strlen(nulldisp_info.name))==0)
-    {
-        return &nulldisp_info;
-    }
-    return NULL;
-}
-
-static vmode_t nulldisp_validate_vmode(char *mode)
-{
-    const vinfo_t *info = get_valid_vinfo(mode);
-    int viu1_select = aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)&0x3;
-    
-	DisableVideoLayer();
-	
-    aml_set_reg32_bits (P_VPU_VIU_VENC_MUX_CTRL, (viu1_select+1)&0x3, 2, 2); //viu2_select should be different from viu1_select (to fix viu1 video smooth problem)
-
-    if (info)
-        return info->mode;
-
-    return VMODE_MAX;
-}
-
-static int nulldisp_vmode_is_supported(vmode_t mode)
-{
-    if(nulldisp_info.mode==mode)
-    {
-            return true;
-    }
-    return false;
-
-}
-
-static int nulldisp_module_disable(vmode_t cur_vmod)
-{
-    return 0;
-}
-
-static vout_server_t nulldisp_vout_server={
-    .name = "nulldisp_vout_server",
-    .op = {
-        .get_vinfo          = nulldisp_get_current_info,
-        .set_vmode          = nulldisp_set_current_vmode,
-        .validate_vmode     = nulldisp_validate_vmode,
-        .vmode_is_supported = nulldisp_vmode_is_supported,
-        .disable            = nulldisp_module_disable,
-    },
-};
-
-static int __init nulldisp_init(void)
-{
-    vout2_register_server(&nulldisp_vout_server);
-    return 0;
-}
-
-static void __exit nulldisp_exit(void)
-{
-    vout2_unregister_server(&nulldisp_vout_server);
-}
-
-//module_init(nulldisp_init);
-subsys_initcall(nulldisp_init);
-module_exit(nulldisp_exit);
-
-MODULE_DESCRIPTION("AMLOGIC NullDisp ");
-MODULE_LICENSE("GPL");
-MODULE_AUTHOR("Tim Yao <timyao@amlogic.com>");
-
+/*
+ * AMLOGIC NullDisp controller driver.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ *
+ */
+#include <linux/init.h>
+#include <linux/version.h>
+#include <linux/types.h>
+#include <linux/slab.h>
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/platform_device.h>
+#include <linux/string.h>
+#include <linux/delay.h>
+
+#include <mach/am_regs.h>
+
+#include <linux/amlogic/vout/vinfo.h>
+#include <linux/amlogic/vout/vout_notify.h>
+
+
+#define DisableVideoLayer() \
+    do { CLEAR_MPEG_REG_MASK(VPP2_MISC, \
+         VPP_VD1_PREBLEND|VPP_VD2_PREBLEND|VPP_VD2_POSTBLEND|VPP_VD1_POSTBLEND ); \
+    } while (0)
+
+static const vinfo_t nulldisp_info =
+{
+    .name              = "null",
+    .mode              = VMODE_MAX+1,
+    .width             = 1920,
+    .height            = 1080,
+    .field_height      = 1080,
+    .aspect_ratio_num  = 16,
+    .aspect_ratio_den  = 9,
+    .sync_duration_num = 50,
+    .sync_duration_den = 1,
+};
+
+static const vinfo_t *nulldisp_get_current_info(void)
+{
+    return &nulldisp_info;
+}
+
+
+static int nulldisp_set_current_vmode(vmode_t mode)
+{
+    return 0;
+}
+
+static const vinfo_t *get_valid_vinfo(char  *mode)
+{
+    if(strncmp(nulldisp_info.name,mode,strlen(nulldisp_info.name))==0)
+    {
+        return &nulldisp_info;
+    }
+    return NULL;
+}
+
+static vmode_t nulldisp_validate_vmode(char *mode)
+{
+    const vinfo_t *info = get_valid_vinfo(mode);
+#ifndef CONFIG_AM_VIDEO2
+    int viu1_select = aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL)&0x3;
+#endif
+	DisableVideoLayer();
+#ifndef CONFIG_AM_VIDEO2
+    aml_set_reg32_bits (P_VPU_VIU_VENC_MUX_CTRL, (viu1_select+1)&0x3, 2, 2); //viu2_select should be different from viu1_select (to fix viu1 video smooth problem)
+#endif
+    if (info)
+        return info->mode;
+
+    return VMODE_MAX;
+}
+
+static int nulldisp_vmode_is_supported(vmode_t mode)
+{
+    if(nulldisp_info.mode==mode)
+    {
+            return true;
+    }
+    return false;
+
+}
+
+static int nulldisp_module_disable(vmode_t cur_vmod)
+{
+    return 0;
+}
+
+static vout_server_t nulldisp_vout_server={
+    .name = "nulldisp_vout_server",
+    .op = {
+        .get_vinfo          = nulldisp_get_current_info,
+        .set_vmode          = nulldisp_set_current_vmode,
+        .validate_vmode     = nulldisp_validate_vmode,
+        .vmode_is_supported = nulldisp_vmode_is_supported,
+        .disable            = nulldisp_module_disable,
+    },
+};
+
+static int __init nulldisp_init(void)
+{
+    vout2_register_server(&nulldisp_vout_server);
+    return 0;
+}
+
+static void __exit nulldisp_exit(void)
+{
+    vout2_unregister_server(&nulldisp_vout_server);
+}
+
+//module_init(nulldisp_init);
+subsys_initcall(nulldisp_init);
+module_exit(nulldisp_exit);
+
+MODULE_DESCRIPTION("AMLOGIC NullDisp ");
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR("Tim Yao <timyao@amlogic.com>");
diff --git a/drivers/amlogic/display/vout2/tvconf.h b/drivers/amlogic/display/vout2/tvconf.h
old mode 100644
new mode 100755
index d56c331b..d1abd3f9
--- a/drivers/amlogic/display/vout2/tvconf.h
+++ b/drivers/amlogic/display/vout2/tvconf.h
@@ -7,7 +7,7 @@
 
 /*****************************************************************
 **
-**	type define part 
+**	type define part
 **
 ******************************************************************/
 typedef  struct {
@@ -20,20 +20,20 @@ typedef  struct {
 static  DEFINE_MUTEX(TV_mutex)  ;
 /*****************************************************************
 **
-**	macro define part 
+**	macro define part
 **
 ******************************************************************/
 #define  TV_CLASS_NAME  	"tv2"
 #define	MAX_NUMBER_PARA  10
 
 #define  SHOW_INFO(name)      \
-	{return snprintf(buf,40, "%s\n", name);}  	
+	{return snprintf(buf,40, "%s\n", name);}
 
 #define  STORE_INFO(name)\
 	{mutex_lock(&TV_mutex);\
 	snprintf(name,40,"%s",buf) ;\
-	mutex_unlock(&TV_mutex); }			
-		
+	mutex_unlock(&TV_mutex); }
+
 #define    SET_TV2_CLASS_ATTR(name,op)    \
 static  char    name[40] ;				  \
 static ssize_t aml_TV_attr_##name##_show(struct class  * cla, struct class_attribute *attr, char *buf)   \
@@ -48,11 +48,11 @@ static ssize_t  aml_TV_attr_##name##_store(struct class *cla,  struct class_attr
 	return strnlen(buf, count);				\
 }											\
 struct  class_attribute  class_TV2_attr_##name =  \
-__ATTR(name, S_IRUGO|S_IWUSR, aml_TV_attr_##name##_show, aml_TV_attr_##name##_store) ; 
+__ATTR(name, S_IRUGO|S_IWUSR, aml_TV_attr_##name##_show, aml_TV_attr_##name##_store) ;
 
 /*****************************************************************
 **
-**	function declare part 
+**	function declare part
 **
 ******************************************************************/
 static void  parse_vdac_setting(char *para);
diff --git a/drivers/amlogic/display/vout2/tvconf2.c b/drivers/amlogic/display/vout2/tvconf2.c
old mode 100644
new mode 100755
index 95cc03b5..f886147a
--- a/drivers/amlogic/display/vout2/tvconf2.c
+++ b/drivers/amlogic/display/vout2/tvconf2.c
@@ -19,8 +19,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
  *
  * Author:   jianfeng_wang@amlogic
- *		   
- *		   
+ *
+ *
  */
 
 #include <linux/version.h>
@@ -70,12 +70,40 @@ SET_TV2_CLASS_ATTR(vdac_setting,parse_vdac_setting)
 
 static const tvmode_t vmode_tvmode_tab[] =
 {
-	TVMODE_480I, TVMODE_480CVBS,TVMODE_480P, TVMODE_576I,TVMODE_576CVBS, TVMODE_576P, TVMODE_720P, TVMODE_1080I, TVMODE_1080P,
-    TVMODE_720P_50HZ, TVMODE_1080I_50HZ, TVMODE_1080P_50HZ
+    TVMODE_480I, TVMODE_480I_RPT, TVMODE_480CVBS, TVMODE_480P,
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    TVMODE_480P_59HZ,
+#endif
+    TVMODE_480P_RPT, TVMODE_576I, TVMODE_576I_RPT, TVMODE_576CVBS, TVMODE_576P, TVMODE_576P_RPT, TVMODE_720P,
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    TVMODE_720P_59HZ , // for 720p 59.94hz
+#endif
+    TVMODE_1080I,
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    TVMODE_1080I_59HZ,
+#endif
+    TVMODE_1080P,
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    TVMODE_1080P_59HZ , // for 1080p 59.94hz
+#endif
+    TVMODE_720P_50HZ, TVMODE_1080I_50HZ, TVMODE_1080P_50HZ,TVMODE_1080P_24HZ, 
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    TVMODE_1080P_23HZ , // for 1080p 23.97hz
+#endif
+    TVMODE_4K2K_30HZ,
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    TVMODE_4K2K_29HZ , // for 4k2k 29.97hz
+#endif
+    TVMODE_4K2K_25HZ, TVMODE_4K2K_24HZ,
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    TVMODE_4K2K_23HZ , // for 4k2k 23.97hz
+#endif
+    TVMODE_4K2K_SMPTE,
+    TVMODE_VGA, TVMODE_SVGA, TVMODE_XGA, TVMODE_SXGA
 };
 
 
-static const vinfo_t tv_info[] = 
+static const vinfo_t tv_info[] =
 {
     { /* VMODE_480I */
         .name              = "480i",
@@ -85,9 +113,36 @@ static const vinfo_t tv_info[] =
         .field_height      = 240,
         .aspect_ratio_num  = 4,
         .aspect_ratio_den  = 3,
-        .sync_duration_num = 5994,
-        .sync_duration_den = 100,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 27000000,
+    },
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    { /* VMODE_480P_59HZ */
+        .name              = "480p59hz",
+        .mode              = VMODE_480P_59HZ,
+        .width             = 720,
+        .height            = 480,
+        .field_height      = 480,
+        .aspect_ratio_num  = 4,
+        .aspect_ratio_den  = 3,
+        .sync_duration_num = 60000,
+        .sync_duration_den = 1001,
+        .video_clk         = 27000000,
     },
+#endif
+    { /* VMODE_480I_RPT */
+        .name              = "480i_rpt",
+        .mode              = VMODE_480I_RPT,
+        .width             = 720,
+        .height            = 480,
+        .field_height      = 240,
+        .aspect_ratio_num  = 4,
+        .aspect_ratio_den  = 3,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 27000000,
+     },
      { /* VMODE_480CVBS*/
         .name              = "480cvbs",
         .mode              = VMODE_480CVBS,
@@ -96,8 +151,9 @@ static const vinfo_t tv_info[] =
         .field_height      = 240,
         .aspect_ratio_num  = 4,
         .aspect_ratio_den  = 3,
-        .sync_duration_num = 5994,
-        .sync_duration_den = 100,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 27000000,
     },
     { /* VMODE_480P */
         .name              = "480p",
@@ -107,8 +163,21 @@ static const vinfo_t tv_info[] =
         .field_height      = 480,
         .aspect_ratio_num  = 4,
         .aspect_ratio_den  = 3,
-        .sync_duration_num = 5994,
-        .sync_duration_den = 100,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 27000000,
+    },
+    { /* VMODE_480P_RPT */
+        .name              = "480p_rpt",
+        .mode              = VMODE_480P_RPT,
+        .width             = 720,
+        .height            = 480,
+        .field_height      = 480,
+        .aspect_ratio_num  = 4,
+        .aspect_ratio_den  = 3,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 27000000,
     },
     { /* VMODE_576I */
         .name              = "576i",
@@ -120,6 +189,19 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 3,
         .sync_duration_num = 50,
         .sync_duration_den = 1,
+        .video_clk         = 27000000,
+    },
+    { /* VMODE_576I_RPT */
+        .name              = "576i_rpt",
+        .mode              = VMODE_576I_RPT,
+        .width             = 720,
+        .height            = 576,
+        .field_height      = 288,
+        .aspect_ratio_num  = 4,
+        .aspect_ratio_den  = 3,
+        .sync_duration_num = 50,
+        .sync_duration_den = 1,
+        .video_clk         = 27000000,
     },
     { /* VMODE_576I */
         .name              = "576cvbs",
@@ -131,6 +213,7 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 3,
         .sync_duration_num = 50,
         .sync_duration_den = 1,
+        .video_clk         = 27000000,
     },
     { /* VMODE_576P */
         .name              = "576p",
@@ -142,6 +225,19 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 3,
         .sync_duration_num = 50,
         .sync_duration_den = 1,
+        .video_clk         = 27000000,
+    },
+    { /* VMODE_576P_RPT */
+        .name              = "576p_rpt",
+        .mode              = VMODE_576P_RPT,
+        .width             = 720,
+        .height            = 576,
+        .field_height      = 576,
+        .aspect_ratio_num  = 4,
+        .aspect_ratio_den  = 3,
+        .sync_duration_num = 50,
+        .sync_duration_den = 1,
+        .video_clk         = 27000000,
     },
     { /* VMODE_720P */
         .name              = "720p",
@@ -153,7 +249,22 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 9,
         .sync_duration_num = 60,
         .sync_duration_den = 1,
+        .video_clk         = 74250000,
+    },
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    { /* VMODE_720P_59HZ */
+        .name              = "720p59hz",
+        .mode              = VMODE_720P_59HZ,
+        .width             = 1280,
+        .height            = 720,
+        .field_height      = 720,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 60000,
+        .sync_duration_den = 1001,
+        .video_clk         = 74250000,
     },
+#endif
     { /* VMODE_1080I */
         .name              = "1080i",
         .mode              = VMODE_1080I,
@@ -164,7 +275,22 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 9,
         .sync_duration_num = 60,
         .sync_duration_den = 1,
+        .video_clk         = 74250000,
     },
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    { /* VMODE_1080I_59HZ */
+        .name              = "1080i59hz",
+        .mode              = VMODE_1080I_59HZ,
+        .width             = 1920,
+        .height            = 1080,
+        .field_height      = 540,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 60000,
+        .sync_duration_den = 1001,
+        .video_clk         = 74250000,
+    },
+#endif
     { /* VMODE_1080P */
         .name              = "1080p",
         .mode              = VMODE_1080P,
@@ -175,7 +301,22 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 9,
         .sync_duration_num = 60,
         .sync_duration_den = 1,
+        .video_clk         = 148500000,
+    },
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    { /* VMODE_1080P_59HZ */
+        .name              = "1080p59hz",
+        .mode              = VMODE_1080P_59HZ,
+        .width             = 1920,
+        .height            = 1080,
+        .field_height      = 1080,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 60000,
+        .sync_duration_den = 1001,
+        .video_clk         = 148500000,
     },
+#endif
     { /* VMODE_720P_50hz */
         .name              = "720p50hz",
         .mode              = VMODE_720P_50HZ,
@@ -186,6 +327,7 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 9,
         .sync_duration_num = 50,
         .sync_duration_den = 1,
+        .video_clk         = 74250000,
     },
     { /* VMODE_1080I_50HZ */
         .name              = "1080i50hz",
@@ -197,6 +339,7 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 9,
         .sync_duration_num = 50,
         .sync_duration_den = 1,
+        .video_clk         = 74250000,
     },
     { /* VMODE_1080P_50HZ */
         .name              = "1080p50hz",
@@ -208,16 +351,190 @@ static const vinfo_t tv_info[] =
         .aspect_ratio_den  = 9,
         .sync_duration_num = 50,
         .sync_duration_den = 1,
+        .video_clk         = 148500000,
+    },
+    { /* VMODE_1080P_24HZ */
+        .name              = "1080p24hz",
+        .mode              = VMODE_1080P_24HZ,
+        .width             = 1920,
+        .height            = 1080,
+        .field_height      = 1080,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 24,
+        .sync_duration_den = 1,
+        .video_clk         = 74250000,
+    },
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    { /* VMODE_1080P_23HZ */
+        .name              = "1080p23hz",
+        .mode              = VMODE_1080P_23HZ,
+        .width             = 1920,
+        .height            = 1080,
+        .field_height      = 1080,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 2397,
+        .sync_duration_den = 100,
+        .video_clk         = 74250000,
+    },
+#endif
+    { /* VMODE_4K2K_30HZ */
+        .name              = "4k2k30hz",
+        .mode              = TVMODE_4K2K_30HZ,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 30,
+        .sync_duration_den = 1,
+        .video_clk         = 297000000,
+    },
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    { /* VMODE_4K2K_29HZ */
+        .name              = "4k2k29hz",
+        .mode              = TVMODE_4K2K_29HZ,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 2997,
+        .sync_duration_den = 100,
+        .video_clk         = 297000000,
+    },
+#endif
+    { /* VMODE_4K2K_25HZ */
+        .name              = "4k2k25hz",
+        .mode              = TVMODE_4K2K_25HZ,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 25,
+        .sync_duration_den = 1,
+        .video_clk         = 297000000,
+    },
+    { /* VMODE_4K2K_24HZ */
+        .name              = "4k2k24hz",
+        .mode              = TVMODE_4K2K_24HZ,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 24,
+        .sync_duration_den = 1,
+        .video_clk         = 297000000,
+    },
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    { /* VMODE_4K2K_23HZ */
+        .name              = "4k2k23hz",
+        .mode              = TVMODE_4K2K_23HZ,
+        .width             = 3840,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 2397,
+        .sync_duration_den = 100,
+        .video_clk         = 297000000,
+    },
+#endif
+    { /* VMODE_4K2K_SMPTE */
+        .name              = "4k2ksmpte",
+        .mode              = TVMODE_4K2K_SMPTE,
+        .width             = 4096,
+        .height            = 2160,
+        .field_height      = 2160,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 24,
+        .sync_duration_den = 1,
+        .video_clk         = 297000000,
+    },
+    { /* VMODE_vga */
+        .name              = "vga",
+        .mode              = VMODE_VGA,
+        .width             = 640,
+        .height            = 480,
+        .field_height      = 240,
+        .aspect_ratio_num  = 4,
+        .aspect_ratio_den  = 3,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 25175000,
+    },
+    { /* VMODE_SVGA */
+        .name              = "svga",
+        .mode              = VMODE_SVGA,
+        .width             = 800,
+        .height            = 600,
+        .field_height      = 600,
+        .aspect_ratio_num  = 4,
+        .aspect_ratio_den  = 3,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 40000000,
+    },
+    { /* VMODE_XGA */
+        .name              = "xga",
+        .mode              = VMODE_XGA,
+        .width             = 1024,
+        .height            = 768,
+        .field_height      = 768,
+        .aspect_ratio_num  = 4,
+        .aspect_ratio_den  = 3,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 65000000,
+    },
+    { /* VMODE_sxga */
+        .name              = "sxga",
+        .mode              = VMODE_SXGA,
+        .width             = 1280,
+        .height            = 1024,
+        .field_height      = 1024,
+        .aspect_ratio_num  = 5,
+        .aspect_ratio_den  = 4,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 108000000,
+    },
+	{ /* VMODE_wsxga */
+        .name              = "wsxga",
+        .mode              = VMODE_WSXGA,
+        .width             = 1440,
+        .height            = 900,
+        .field_height      = 900,
+        .aspect_ratio_num  = 8,
+        .aspect_ratio_den  = 5,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 88750000,
+    },
+	{ /* VMODE_fhdvga */
+        .name              = "fhdvga",
+        .mode              = VMODE_FHDVGA,
+        .width             = 1920,
+        .height            = 1080,
+        .field_height      = 1080,
+        .aspect_ratio_num  = 16,
+        .aspect_ratio_den  = 9,
+        .sync_duration_num = 60,
+        .sync_duration_den = 1,
+        .video_clk         = 148500000,
     },
-
 };
 
 static const struct file_operations am_tv_fops = {
-	.open	= NULL,  
-	.read	= NULL,//am_tv_read, 
-	.write	= NULL, 
-	.unlocked_ioctl	= NULL,//am_tv_ioctl, 
-	.release	= NULL, 	
+	.open	= NULL,
+	.read	= NULL,//am_tv_read,
+	.write	= NULL,
+	.unlocked_ioctl	= NULL,//am_tv_ioctl,
+	.release	= NULL,
 	.poll		= NULL,
 };
 
@@ -226,7 +543,7 @@ static const vinfo_t *get_valid_vinfo(char  *mode)
 	const vinfo_t * vinfo = NULL;
 	int  i,count=ARRAY_SIZE(tv_info);
 	int mode_name_len=0;
-	
+
 	for(i=0;i<count;i++)
 	{
 		if(strncmp(tv_info[i].name,mode,strlen(tv_info[i].name))==0)
@@ -247,7 +564,7 @@ static const vinfo_t *tv_get_current_info(void)
 
 static int tv_set_current_vmode(vmode_t mod)
 {
-	if ((mod&VMODE_MODE_BIT_MASK)> VMODE_1080P_50HZ)
+	if ((mod&VMODE_MODE_BIT_MASK)> VMODE_SXGA)
 		return -EINVAL;
 
 	info->vinfo = &tv_info[mod];
@@ -264,10 +581,10 @@ static int tv_set_current_vmode(vmode_t mod)
 static vmode_t tv_validate_vmode(char *mode)
 {
 	const vinfo_t *info = get_valid_vinfo(mode);
-	
+
 	if (info)
 		return info->mode;
-	
+
 	return VMODE_MAX;
 }
 static int tv_vmode_is_supported(vmode_t mode)
@@ -296,30 +613,30 @@ static int tv_module_disable(vmode_t cur_vmod)
 	return 0;
 }
 #ifdef  CONFIG_PM
-static int tv_suspend(void)
+static int tv_suspend(int pm_event)
 {
 	video_dac_disable();
 	return 0;
 }
-static int tv_resume(void)
+static int tv_resume(int pm_event)
 {
 	video_dac_enable(0xff);
 	tv_set_current_vmode(info->vinfo->mode);
 	return 0;
 }
-#endif 
+#endif
 static vout_server_t tv_server={
 	.name = "vout2_tv_server",
-	.op = {	
+	.op = {
 		.get_vinfo=tv_get_current_info,
 		.set_vmode=tv_set_current_vmode,
 		.validate_vmode=tv_validate_vmode,
 		.vmode_is_supported=tv_vmode_is_supported,
 		.disable = tv_module_disable,
-#ifdef  CONFIG_PM  
+#ifdef  CONFIG_PM
 		.vout_suspend=tv_suspend,
 		.vout_resume=tv_resume,
-#endif	
+#endif
 	},
 };
 
@@ -333,15 +650,15 @@ static vout_server_t tv_server={
 **	The 6th digit control s-video chroma output DAC number
 ** 	examble :
 **		echo  120120 > /sys/class/display/vdac_setting
-**		the first digit from the left side .	
+**		the first digit from the left side .
 ******************************************************/
-static void  parse_vdac_setting(char *para) 
+static void  parse_vdac_setting(char *para)
 {
 	int  i;
 	char  *pt=strstrip(para);
 	int len=strlen(pt);
 	u32  vdac_sequence=get_current_vdac_setting2();
-	
+
 	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"origin vdac setting:0x%x,strlen:%d\n",vdac_sequence,len);
 	if(len!=6)
 	{
@@ -356,7 +673,7 @@ static void  parse_vdac_setting(char *para)
 		pt++;
 	}
 	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"current vdac setting:0x%x\n",vdac_sequence);
-	
+
 	change_vdac_setting2(vdac_sequence,get_current_vmode2());
 }
 static  struct  class_attribute   *tv_attr[]={
@@ -370,7 +687,7 @@ static int  create_tv_attr(disp_module_info_t* info)
 	info->base_class=class_create(THIS_MODULE,info->name);
 	if(IS_ERR(info->base_class))
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create tv display class fail\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create tv display class fail\n");
 		return  -1 ;
 	}
 	//create  class attr
@@ -378,7 +695,7 @@ static int  create_tv_attr(disp_module_info_t* info)
 	{
 		if ( class_create_file(info->base_class,tv_attr[i]))
 		{
-			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp attribute %s fail\r\n",tv_attr[i]->attr.name);
+			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp attribute %s fail\n",tv_attr[i]->attr.name);
 		}
 	}
 	sprintf(vdac_setting,"%x",get_current_vdac_setting2());
@@ -391,28 +708,28 @@ static int __init tv_init_module(void)
 	info=(disp_module_info_t*)kmalloc(sizeof(disp_module_info_t),GFP_KERNEL) ;
 	if (!info)
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"can't alloc display info struct\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"can't alloc display info struct\n");
 		return -ENOMEM;
 	}
-	
+
 	memset(info, 0, sizeof(disp_module_info_t));
 
 	sprintf(info->name,TV_CLASS_NAME) ;
 	ret=register_chrdev(TV2_CONF_MAJOR,info->name,&am_tv_fops);
-	if(ret <0) 
+	if(ret <0)
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register char dev tv error\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register char dev tv error\n");
 		return  ret ;
 	}
 	info->major=TV2_CONF_MAJOR;
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"major number %d for disp\r\n",ret);
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"major number %d for disp\n",ret);
 	if(vout2_register_server(&tv_server))
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register tv module server fail \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register tv module server fail\n");
 	}
 	else
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register tv module server ok \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"register tv module server ok\n");
 	}
 	create_tv_attr(info);
 	return 0;
@@ -421,24 +738,24 @@ static int __init tv_init_module(void)
 static __exit void tv_exit_module(void)
 {
 	int i;
-	
+
 	if(info->base_class)
 	{
 		for(i=0;i<ARRAY_SIZE(tv_attr);i++)
 		{
 			class_remove_file(info->base_class,tv_attr[i]) ;
 		}
-		
+
 		class_destroy(info->base_class);
-	}	
+	}
 	if(info)
 	{
 		unregister_chrdev(info->major,info->name)	;
 		kfree(info);
 	}
 	vout2_unregister_server(&tv_server);
-	
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"exit tv module\r\n");
+
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"exit tv module\n");
 }
 
 
@@ -448,4 +765,3 @@ module_exit(tv_exit_module);
 MODULE_DESCRIPTION("display configure  module");
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("jianfeng_wang <jianfeng.wang@amlogic.com>");
-
diff --git a/drivers/amlogic/display/vout2/tvmode.h b/drivers/amlogic/display/vout2/tvmode.h
old mode 100644
new mode 100755
index 28902dd0..3aa408d6
--- a/drivers/amlogic/display/vout2/tvmode.h
+++ b/drivers/amlogic/display/vout2/tvmode.h
@@ -1,44 +1,28 @@
-/*
- * Amlogic Apollo
- * frame buffer driver
- *
- * Copyright (C) 2009 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
- *
- * Author:	Tim Yao <timyao@amlogic.com>
- *
- */
-
-#ifndef TVMODE_H
-#define TVMODE_H
-
-typedef enum {
-    TVMODE_480I  = 0,
-    TVMODE_480CVBS,
-    TVMODE_480P  ,
-    TVMODE_576I  ,
-    TVMODE_576CVBS,
-    TVMODE_576P  ,
-    TVMODE_720P  ,
-    TVMODE_1080I ,
-    TVMODE_1080P ,
-    TVMODE_720P_50HZ ,
-    TVMODE_1080I_50HZ ,
-    TVMODE_1080P_50HZ ,
-    TVMODE_MAX   
-} tvmode_t;
-
-#endif /* TVMODE_H */
+/*
+ * Amlogic Apollo
+ * frame buffer driver
+ *
+ * Copyright (C) 2009 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:	Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef TVMODE_H
+#define TVMODE_H
+
+#endif /* TVMODE_H */
diff --git a/drivers/amlogic/display/vout2/tvoutc.h b/drivers/amlogic/display/vout2/tvoutc.h
old mode 100644
new mode 100755
index 3de530e2..3e33b78a
--- a/drivers/amlogic/display/vout2/tvoutc.h
+++ b/drivers/amlogic/display/vout2/tvoutc.h
@@ -1,60 +1,60 @@
-/*
- * Amlogic Apollo
- * frame buffer driver
- *
- * Copyright (C) 2009 Amlogic, Inc.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the named License,
- * or any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
- *
- * Author:	Tim Yao <timyao@amlogic.com>
- *
- */
-
-#ifndef TVOUTC_H
-#define TVOUTC_H
-
-#include "tvmode.h"
-
-#define  	DEFAULT_VDAC_SEQUENCE   	0x120120
-
-typedef  enum{
-	INTERALCE_COMPONENT=0,
-	CVBS_SVIDEO,
-	PROGRESSIVE,
-	SIGNAL_SET_MAX
-}video_signal_set_t;
-typedef enum {
-    VIDEO_SIGNAL_TYPE_INTERLACE_Y = 0, /**< Interlace Y signal */
-    VIDEO_SIGNAL_TYPE_CVBS,            /**< CVBS signal */
-    VIDEO_SIGNAL_TYPE_SVIDEO_LUMA,     /**< S-Video luma signal */
-    VIDEO_SIGNAL_TYPE_SVIDEO_CHROMA,   /**< S-Video chroma signal */
-    VIDEO_SIGNAL_TYPE_INTERLACE_PB,    /**< Interlace Pb signal */
-    VIDEO_SIGNAL_TYPE_INTERLACE_PR,    /**< Interlace Pr signal */
-    VIDEO_SIGNAL_TYPE_INTERLACE_R,     /**< Interlace R signal */
-    VIDEO_SIGNAL_TYPE_INTERLACE_G,     /**< Interlace G signal */
-    VIDEO_SIGNAL_TYPE_INTERLACE_B,     /**< Interlace B signal */
-    VIDEO_SIGNAL_TYPE_PROGRESSIVE_Y,   /**< Progressive Y signal */
-    VIDEO_SIGNAL_TYPE_PROGRESSIVE_PB,  /**< Progressive Pb signal */
-    VIDEO_SIGNAL_TYPE_PROGRESSIVE_PR,  /**< Progressive Pr signal */
-    VIDEO_SIGNAL_TYPE_PROGEESSIVE_R,   /**< Progressive R signal */
-    VIDEO_SIGNAL_TYPE_PROGEESSIVE_G,   /**< Progressive G signal */
-    VIDEO_SIGNAL_TYPE_PROGEESSIVE_B,   /**< Progressive B signal */
-    VIDEO_SIGNAL_TYPE_MAX
-} video_signal_type_t;
-
-int tvoutc_setmode2(tvmode_t mode);
-int 	 get_current_vdac_setting2(void) ;
-void  change_vdac_setting2(unsigned int  vdec_setting,vmode_t mode);
-#endif /* TVOUTC_H */
+/*
+ * Amlogic Apollo
+ * frame buffer driver
+ *
+ * Copyright (C) 2009 Amlogic, Inc.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the named License,
+ * or any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
+ *
+ * Author:	Tim Yao <timyao@amlogic.com>
+ *
+ */
+
+#ifndef TVOUTC_H
+#define TVOUTC_H
+
+#include "tvmode.h"
+
+#define  	DEFAULT_VDAC_SEQUENCE   	0x120120
+
+typedef  enum{
+	INTERALCE_COMPONENT=0,
+	CVBS_SVIDEO,
+	PROGRESSIVE,
+	SIGNAL_SET_MAX
+}video_signal_set_t;
+typedef enum {
+    VIDEO_SIGNAL_TYPE_INTERLACE_Y = 0, /**< Interlace Y signal */
+    VIDEO_SIGNAL_TYPE_CVBS,            /**< CVBS signal */
+    VIDEO_SIGNAL_TYPE_SVIDEO_LUMA,     /**< S-Video luma signal */
+    VIDEO_SIGNAL_TYPE_SVIDEO_CHROMA,   /**< S-Video chroma signal */
+    VIDEO_SIGNAL_TYPE_INTERLACE_PB,    /**< Interlace Pb signal */
+    VIDEO_SIGNAL_TYPE_INTERLACE_PR,    /**< Interlace Pr signal */
+    VIDEO_SIGNAL_TYPE_INTERLACE_R,     /**< Interlace R signal */
+    VIDEO_SIGNAL_TYPE_INTERLACE_G,     /**< Interlace G signal */
+    VIDEO_SIGNAL_TYPE_INTERLACE_B,     /**< Interlace B signal */
+    VIDEO_SIGNAL_TYPE_PROGRESSIVE_Y,   /**< Progressive Y signal */
+    VIDEO_SIGNAL_TYPE_PROGRESSIVE_PB,  /**< Progressive Pb signal */
+    VIDEO_SIGNAL_TYPE_PROGRESSIVE_PR,  /**< Progressive Pr signal */
+    VIDEO_SIGNAL_TYPE_PROGEESSIVE_R,   /**< Progressive R signal */
+    VIDEO_SIGNAL_TYPE_PROGEESSIVE_G,   /**< Progressive G signal */
+    VIDEO_SIGNAL_TYPE_PROGEESSIVE_B,   /**< Progressive B signal */
+    VIDEO_SIGNAL_TYPE_MAX
+} video_signal_type_t;
+
+int tvoutc_setmode2(tvmode_t mode);
+int 	 get_current_vdac_setting2(void) ;
+void  change_vdac_setting2(unsigned int  vdec_setting,vmode_t mode);
+#endif /* TVOUTC_H */
diff --git a/drivers/amlogic/display/vout2/tvoutc2.c b/drivers/amlogic/display/vout2/tvoutc2.c
old mode 100644
new mode 100755
index e740d622..dfd6464a
--- a/drivers/amlogic/display/vout2/tvoutc2.c
+++ b/drivers/amlogic/display/vout2/tvoutc2.c
@@ -46,8 +46,8 @@ static const unsigned int  signal_set[SIGNAL_SET_MAX][3]=
 	},
 	{
 		VIDEO_SIGNAL_TYPE_CVBS,            	//cvbs&svideo
-		VIDEO_SIGNAL_TYPE_SVIDEO_LUMA,    
-    	VIDEO_SIGNAL_TYPE_SVIDEO_CHROMA,   
+		VIDEO_SIGNAL_TYPE_SVIDEO_LUMA,
+	VIDEO_SIGNAL_TYPE_SVIDEO_CHROMA,
 	},
 	{	VIDEO_SIGNAL_TYPE_PROGRESSIVE_Y,     //progressive.
 		VIDEO_SIGNAL_TYPE_PROGRESSIVE_PB,
@@ -56,12 +56,12 @@ static const unsigned int  signal_set[SIGNAL_SET_MAX][3]=
 };
 static  const  char*   signal_table[]={
 	"INTERLACE_Y ", /**< Interlace Y signal */
-    	"CVBS",            /**< CVBS signal */
-    	"SVIDEO_LUMA",     /**< S-Video luma signal */
-    	"SVIDEO_CHROMA",   /**< S-Video chroma signal */
-    	"INTERLACE_PB",    /**< Interlace Pb signal */
-    	"INTERLACE_PR",    /**< Interlace Pr signal */
-    	"INTERLACE_R",     /**< Interlace R signal */
+	"CVBS",            /**< CVBS signal */
+	"SVIDEO_LUMA",     /**< S-Video luma signal */
+	"SVIDEO_CHROMA",   /**< S-Video chroma signal */
+	"INTERLACE_PB",    /**< Interlace Pb signal */
+	"INTERLACE_PR",    /**< Interlace Pr signal */
+	"INTERLACE_R",     /**< Interlace R signal */
          "INTERLACE_G",     /**< Interlace G signal */
          "INTERLACE_B",     /**< Interlace B signal */
          "PROGRESSIVE_Y",   /**< Progressive Y signal */
@@ -70,7 +70,7 @@ static  const  char*   signal_table[]={
          "PROGEESSIVE_R",   /**< Progressive R signal */
          "PROGEESSIVE_G",   /**< Progressive G signal */
          "PROGEESSIVE_B",   /**< Progressive B signal */
-		
+
 	};
 int 	 get_current_vdac_setting2(void)
 {
@@ -93,7 +93,7 @@ void  change_vdac_setting2(unsigned int  vdec_setting,vmode_t  mode)
 		break;
 		case VMODE_480CVBS:
 		case VMODE_576CVBS:
-		signal_set_index=1;	
+		signal_set_index=1;
 		bit=2;
 		break;
 		default :
@@ -116,7 +116,7 @@ static void enable_vsync_interrupt(void)
     printk("enable_vsync_interrupt\n");
 
     CLEAR_CBUS_REG_MASK(HHI_MPEG_CLK_CNTL, 1<<11);
-	
+
     if (READ_MPEG_REG(ENCP_VIDEO_EN) & 1) {
         WRITE_MPEG_REG(VENC_INTCTRL, 0x200);
 
@@ -193,15 +193,18 @@ int tvoutc_setclk2(tvmode_t mode)
 		}
 	else
 		{
-		printk(KERN_WARNING "UNsupport xtal setting for vidoe xtal=%d,default to 24M\n",xtal);	
+		printk(KERN_WARNING "UNsupport xtal setting for vidoe xtal=%d,default to 24M\n",xtal);
 		xtal=0;
 		}
 	switch(mode)
 	{
 		case TVMODE_480I:
+		case TVMODE_480I_RPT:
 		case TVMODE_480CVBS:
 		case TVMODE_480P:
+		case TVMODE_480P_RPT:
 		case TVMODE_576I:
+		case TVMODE_576I_RPT:
 		case TVMODE_576CVBS:
 		case TVMODE_576P:
 			  setreg(&sd[xtal]);
@@ -219,25 +222,58 @@ int tvoutc_setclk2(tvmode_t mode)
 			  }
 			  break;
 		default:
-			printk(KERN_ERR "unsupport tv mode,video clk is not set!!\n");	
+			printk(KERN_ERR "unsupport tv mode,video clk is not set!!\n");
 	}
 
 	return 0;
 }
 
+static const reg_t * tvregs_setting_mode(tvmode_t mode)
+{
+    int i = 0;
+    for(i = 0; i < ARRAY_SIZE(tvregsTab2); i++) {
+        if(mode == tvregsTab2[i].tvmode)
+            return tvregsTab2[i].reg_setting;
+    }
+    return NULL;
+}
+
+const static tvinfo_t * tvinfo_mode(tvmode_t mode)
+{
+    int i = 0;
+    for(i = 0; i < ARRAY_SIZE(tvinfoTab2); i++) {
+        if(mode == tvinfoTab2[i].tvmode)
+            return &tvinfoTab2[i];
+    }
+    return NULL;
+}
+
 int tvoutc_setmode2(tvmode_t mode)
 {
     const  reg_t *s;
+    const tvinfo_t * tvinfo;
 
     if (mode >= TVMODE_MAX) {
         printk(KERN_ERR "Invalid video output modes.\n");
         return -ENODEV;
     }
 
-    printk(KERN_DEBUG "TV mode %s selected.\n", tvinfoTab[mode].id);
-   
-    s = tvregsTab[mode];
-			
+    printk(KERN_DEBUG "TV mode %s selected.\n", tvinfoTab2[mode].id);
+
+    tvinfo = tvinfo_mode(mode);
+    if(!tvinfo) {
+        printk(KERN_ERR "tvinfo %d not find\n", mode);
+        return 0;
+    }
+    printk("TV mode %s selected.\n", tvinfo->id);
+
+    s = tvregs_setting_mode(mode);
+    if(!s) {
+        printk("display2 mode %d regs setting failed\n", mode);
+        return 0;
+    }
+    //s = tvregsTab[mode];
+
     while (MREG_END_MARKER != s->reg)
         setreg(s++);
 	//tvoutc_setclk2(mode);
@@ -245,34 +281,78 @@ int tvoutc_setmode2(tvmode_t mode)
 	switch(mode)
 	{
 		case TVMODE_480I:
+		case TVMODE_480I_RPT:
 		case TVMODE_480CVBS:
 		case TVMODE_480P:
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+		case TVMODE_480P_59HZ:
+#endif
+		case TVMODE_480P_RPT:
 		case TVMODE_576I:
 		case TVMODE_576CVBS:
 		case TVMODE_576P:
-        //WRITE_MPEG_REG(HHI_VIID_CLK_DIV, (READ_MPEG_REG(HHI_VIID_CLK_DIV)&(~(0xff)))|0x3); // reg 0x104a
+			  //WRITE_MPEG_REG(HHI_VIID_CLK_DIV, (READ_MPEG_REG(HHI_VIID_CLK_DIV)&(~(0xff)))|0x3); // reg 0x104a 
+			  #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+			  WRITE_VCBUS_REG_BITS(VPU_VIU_VENC_MUX_CTRL, 1, 2, 2); //reg0x271a, select ENCT to VIU2
+			  WRITE_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0x03, 0, 2);
+			  WRITE_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 1, 16, 1);
+			  aml_write_reg32(P_HHI_VID2_PLL_CNTL, 0x41000032);//--set vid2 pll < 1.7G
+			  aml_write_reg32(P_HHI_VID2_PLL_CNTL2, 0x0421a000);
+			  aml_write_reg32(P_HHI_VID2_PLL_CNTL3, 0xca45b823);
+			  aml_write_reg32(P_HHI_VID2_PLL_CNTL4, 0xd4000d67);
+			  aml_write_reg32(P_HHI_VID2_PLL_CNTL5, 0x01700001);//--
+			  WRITE_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 0x01, 24, 5);//clock tree N=1
+			  WRITE_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 0x36, 0, 9);//clock tree M=54
+			  WRITE_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 0x00, 9, 2);//clock tree OD=0
+			  WRITE_CBUS_REG_BITS(HHI_VID2_PLL_CNTL5, 0x01, 24, 1);//select CLK1 = 24x54 = 1296M
+			  WRITE_CBUS_REG_BITS(HHI_DSI_LVDS_EDP_CNTL1, 0x00, 4, 1);
+			  WRITE_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0x03, 15, 2);
+			  WRITE_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0x05, 4, 3);//select 6
+			  WRITE_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0x00, 8, 2);//select 0
+			  WRITE_CBUS_REG_BITS(HHI_VIID_DIVIDER_CNTL, 0x00, 12, 3);//select 0 clock = 1296/6 = 216M
+			  WRITE_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0x0c, 16, 4);//select vid2_pll_clk & open bit19
+			  WRITE_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 0x03, 0, 4);//select 4 clock = 216/4 = 54M
+			  WRITE_CBUS_REG_BITS(HHI_VIID_CLK_CNTL, 0x07, 0, 5);//open div1 div2 div4
+			  WRITE_CBUS_REG_BITS(HHI_VID_CLK_DIV, 0x09, 28, 4);//reg 0x1059, select v2_clk_div2 for cts_enci_clk , 27MHz
+			  WRITE_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 0x09, 28, 4); //0x104a, select v2_clk_div2 for cts_vdac_clk[0] 
+			  WRITE_CBUS_REG_BITS(HHI_VIID_CLK_DIV, 0x09, 24, 4); //0x104a, select v2_clk_div2 for cts_vdac_clk[1] (DAC3)
+			  WRITE_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 0x01, 29, 1);//reset
+			  WRITE_CBUS_REG_BITS(HHI_VID2_PLL_CNTL, 0x00, 29, 1);//clean reset
+			  #endif
 			  break;
 		case TVMODE_720P:
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+		case TVMODE_720P_59HZ:
+#endif
 		case TVMODE_720P_50HZ:
 		case TVMODE_1080I:
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+		case TVMODE_1080I_59HZ:
+#endif
 		case TVMODE_1080I_50HZ:
         //WRITE_MPEG_REG(HHI_VIID_CLK_DIV, (READ_MPEG_REG(HHI_VIID_CLK_DIV)&(~(0xff)))|0x0); // reg 0x104a
-        break;		    
+        break;
 		case TVMODE_1080P:
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+		case TVMODE_1080P_59HZ:
+#endif
 		case TVMODE_1080P_50HZ:
         //WRITE_MPEG_REG(HHI_VIID_CLK_DIV, (READ_MPEG_REG(HHI_VIID_CLK_DIV)&(~(0xff)))|0x1); // reg 0x104a
-        break;		    
+        break;
 		default:
-			printk(KERN_ERR "unsupport tv mode,video clk is not set!!\n");	
+			printk(KERN_ERR "unsupport tv mode,video clk is not set!!\n");
 	}
-    
-        //WRITE_MPEG_REG(HHI_VIID_CLK_CNTL, 0x8001f); //reg 0x104b, select vid_pll_clk as source of v2_clk_divN
-        //WRITE_MPEG_REG(HHI_VID_CLK_DIV, (READ_MPEG_REG(HHI_VID_CLK_DIV)&(~(0xff<<24)))|(0x88<<24)); // reg 0x1059, select cts_encp_clk and cts_enci_clk from v2_clk_div1
-        aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, 2, 2, 2); //reg0x271a, select ENCP to VIU2
+    //WRITE_MPEG_REG(HHI_VIID_CLK_CNTL, 0x8001f); //reg 0x104b, select vid_pll_clk as source of v2_clk_divN
+    //WRITE_MPEG_REG(HHI_VID_CLK_DIV, (READ_MPEG_REG(HHI_VID_CLK_DIV)&(~(0xff<<24)))|(0x88<<24)); // reg 0x1059, select cts_encp_clk and cts_enci_clk from v2_clk_div1
+    //aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, 2, 2, 2); //reg0x271a, select ENCP to VIU2
+    #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
+    aml_write_reg32(P_HHI_VDAC_CNTL0, 0x00000001);
+    aml_write_reg32(P_HHI_VDAC_CNTL1, 0x00000000);
+    aml_write_reg32(P_ENCI_MACV_N0, 0x00000000);
+    aml_write_reg32(P_HHI_GCLK_OTHER, aml_read_reg32(P_HHI_GCLK_OTHER)|(1<<8));
+    #endif
+    aml_write_reg32(P_VPP2_POSTBLEND_H_SIZE, tvinfo->xres);
 
-    
-    aml_write_reg32(P_VPP2_POSTBLEND_H_SIZE, tvinfoTab[mode].xres);
-    
 // For debug only
 #if 0
 printk(" clk_util_clk_msr 6 = %d\n", clk_util_clk_msr(6));
@@ -288,6 +368,3 @@ printk(" clk_util_clk_msr 29 = %d\n", clk_util_clk_msr(29));
 
     return 0;
 }
-
-
-
diff --git a/drivers/amlogic/display/vout2/tvregs.h b/drivers/amlogic/display/vout2/tvregs.h
old mode 100644
new mode 100755
index 21bf1e73..a1486354
--- a/drivers/amlogic/display/vout2/tvregs.h
+++ b/drivers/amlogic/display/vout2/tvregs.h
@@ -26,24 +26,13 @@
 #define TVREGS_H
 
 #define MREG_END_MARKER 0xffff
-
+#include <linux/amlogic/vout/vinfo.h>
 
 	#define VIDEO_CLOCK_HD_25	0x00101529
 	#define VIDEO_CLOCK_SD_25	0x00500a6c
 	#define VIDEO_CLOCK_HD_24	0x00140863
 	#define VIDEO_CLOCK_SD_24	0x0050042d
 
-
-typedef struct reg_s {
-    uint reg;
-    uint val;
-} reg_t;
-
-typedef struct tvinfo_s {
-    uint xres;
-    uint yres;
-    const char *id;
-} tvinfo_t;
 /*
 24M
 25M
@@ -366,7 +355,7 @@ static const reg_t tvregs_480p[] = {
 };
 
 static const reg_t tvregs_576i[] = {
-    {VENC_VDAC_SETTING,          0xff,  },
+    {P_VENC_VDAC_SETTING,          0xff,  },
 //	{VCLK_SD},
     {P_ENCI_CFILT_CTRL,                 0x12,    },
     {P_ENCI_CFILT_CTRL2,                 0x12,    },
@@ -417,7 +406,7 @@ static const reg_t tvregs_576i[] = {
 };
 
 static const reg_t tvregs_576cvbs[] = {
-    {VENC_VDAC_SETTING,          0xff,  },
+    {P_VENC_VDAC_SETTING,          0xff,  },
 //	{VCLK_SD},
     {P_ENCI_CFILT_CTRL,                 0x12,    },
     {P_ENCI_CFILT_CTRL2,                 0x12,    },
@@ -732,47 +721,121 @@ static const reg_t tvregs_1080p_50hz[] = {
     {MREG_END_MARKER,            0      }
 };
 
+static const reg_t tvregs_1080p_24hz[] = {
+    {MREG_END_MARKER,            0      }
+};
+
+static const reg_t tvregs_4k2k_30hz[] = {
+    {MREG_END_MARKER,            0      }
+};
+
+static const reg_t tvregs_4k2k_25hz[] = {
+    {MREG_END_MARKER,            0      }
+};
+
+static const reg_t tvregs_4k2k_24hz[] = {
+    {MREG_END_MARKER,            0      }
+};
+
+static const reg_t tvregs_4k2k_smpte[] = {
+    {MREG_END_MARKER,            0      }
+};
 
-/* The sequence of register tables items must match the enum define in tvmode.h */
-static const reg_t *tvregsTab[] = {
-    tvregs_480i,
-    tvregs_480cvbs,		
-    tvregs_480p,
-    tvregs_576i,
-    tvregs_576cvbs,
-    tvregs_576p,
-    tvregs_720p,
-    tvregs_1080i,       //Adjust tvregs_* sequences and match the enum define in tvmode.h
-    tvregs_1080p,
-    tvregs_720p_50hz,
-    tvregs_1080i_50hz,
-    tvregs_1080p_50hz
+static const reg_t tvregs_vga_640x480[] = {
+    {MREG_END_MARKER,            0      }
 };
 
-static const tvinfo_t tvinfoTab[] = {
-    {.xres =  720, .yres =  480, .id = "480i"},
-    {.xres =  720, .yres =  480, .id = "480cvbs"},		
-    {.xres =  720, .yres =  480, .id = "480p"},
-    {.xres =  720, .yres =  576, .id = "576i"},
-    {.xres =  720, .yres =  576, .id = "576cvbs"},
-    {.xres =  720, .yres =  576, .id = "576p"},
-    {.xres = 1280, .yres =  720, .id = "720p"},
-    {.xres = 1920, .yres = 1080, .id = "1080i"},
-    {.xres = 1920, .yres = 1080, .id = "1080p"},
-    {.xres = 1280, .yres =  720, .id = "720p50hz"},
-    {.xres = 1920, .yres = 1080, .id = "1080i50hz"},
-    {.xres = 1920, .yres = 1080, .id = "1080p50hz"}
+static const reg_t tvregs_svga_800x600[]={
+    {MREG_END_MARKER,            0      }
+};
+
+static const reg_t tvregs_xga_1024x768[] = {
+    {MREG_END_MARKER,            0      }
+};
+
+// Using tvmode as index
+static struct tvregs_set_t tvregsTab2[] = {
+    {TVMODE_480I, tvregs_480i,        },
+    {TVMODE_480I_RPT, tvregs_480i,        },// For REPEAT MODE use, ENC setting is same
+    {TVMODE_480CVBS, tvregs_480cvbs,     },
+    {TVMODE_480P, tvregs_480p,        },
+    {TVMODE_480P_RPT, tvregs_480p,        },// For REPEAT MODE use, ENC setting is same
+    {TVMODE_576I, tvregs_576i,        },
+    {TVMODE_576I_RPT, tvregs_576i,        },// For REPEAT MODE use, ENC setting is same
+    {TVMODE_576CVBS, tvregs_576cvbs,     },
+    {TVMODE_576P, tvregs_576p,        },
+    {TVMODE_576P_RPT, tvregs_576p,        },// For REPEAT MODE use, ENC setting is same
+    {TVMODE_720P, tvregs_720p,        },
+    {TVMODE_1080I, tvregs_1080i,       },//Adjust tvregs_* sequences and match the enum define in tvmode.h
+    {TVMODE_1080P, tvregs_1080p,       },
+    {TVMODE_720P_50HZ, tvregs_720p_50hz,   },
+    {TVMODE_1080I_50HZ, tvregs_1080i_50hz,  },
+    {TVMODE_1080P_50HZ, tvregs_1080p_50hz,  },
+    {TVMODE_1080P_24HZ, tvregs_1080p_24hz,  },
+    {TVMODE_4K2K_30HZ, tvregs_4k2k_30hz,   },
+    {TVMODE_4K2K_25HZ, tvregs_4k2k_25hz,   },
+    {TVMODE_4K2K_24HZ, tvregs_4k2k_24hz,   },
+    {TVMODE_4K2K_SMPTE, tvregs_4k2k_smpte,  },
+    {TVMODE_VGA, tvregs_vga_640x480, },
+    {TVMODE_SVGA, tvregs_svga_800x600,},
+    {TVMODE_XGA, tvregs_xga_1024x768,},
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    {TVMODE_480P_59HZ, tvregs_480p,},
+    {TVMODE_720P_59HZ , tvregs_720p,},
+    {TVMODE_1080I_59HZ, tvregs_1080i,},
+    {TVMODE_1080P_59HZ, tvregs_1080p,},
+    {TVMODE_1080P_23HZ, tvregs_1080p_24hz,},
+    {TVMODE_4K2K_29HZ, tvregs_4k2k_30hz,},
+    {TVMODE_4K2K_23HZ, tvregs_4k2k_24hz,},
+#endif
+
+};
+
+static const tvinfo_t tvinfoTab2[] = {
+    {.tvmode = TVMODE_480I, .xres =  720, .yres =  480, .id = "480i"},
+    {.tvmode = TVMODE_480I_RPT, .xres =  720, .yres =  480, .id = "480i_rpt"},
+    {.tvmode = TVMODE_480CVBS, .xres =  720, .yres =  480, .id = "480cvbs"},
+    {.tvmode = TVMODE_480P, .xres =  720, .yres =  480, .id = "480p"},
+    {.tvmode = TVMODE_480P_RPT, .xres =  720, .yres =  480, .id = "480p_rpt"},
+    {.tvmode = TVMODE_576I, .xres =  720, .yres =  576, .id = "576i"},
+    {.tvmode = TVMODE_576I_RPT, .xres =  720, .yres =  576, .id = "576i_rpt"},
+    {.tvmode = TVMODE_576CVBS, .xres =  720, .yres =  576, .id = "576cvbs"},
+    {.tvmode = TVMODE_576P, .xres =  720, .yres =  576, .id = "576p"},
+    {.tvmode = TVMODE_576P_RPT, .xres =  720, .yres =  576, .id = "576p_prt"},
+    {.tvmode = TVMODE_720P, .xres = 1280, .yres =  720, .id = "720p"},
+    {.tvmode = TVMODE_1080I, .xres = 1920, .yres = 1080, .id = "1080i"},
+    {.tvmode = TVMODE_1080P, .xres = 1920, .yres = 1080, .id = "1080p"},
+    {.tvmode = TVMODE_720P_50HZ, .xres = 1280, .yres =  720, .id = "720p50hz"},
+    {.tvmode = TVMODE_1080I_50HZ, .xres = 1920, .yres = 1080, .id = "1080i50hz"},
+    {.tvmode = TVMODE_1080P_50HZ, .xres = 1920, .yres = 1080, .id = "1080p50hz"},
+    {.tvmode = TVMODE_1080P_24HZ, .xres = 1920, .yres = 1080, .id = "1080p24hz"},
+    {.tvmode = TVMODE_4K2K_30HZ, .xres = 3840, .yres = 2160, .id = "4k2k30hz"},
+    {.tvmode = TVMODE_4K2K_25HZ, .xres = 3840, .yres = 2160, .id = "4k2k25hz"},
+    {.tvmode = TVMODE_4K2K_24HZ, .xres = 3840, .yres = 2160, .id = "4k2k24hz"},
+    {.tvmode = TVMODE_4K2K_SMPTE, .xres = 4096, .yres = 2160, .id = "4k2ksmpte"},
+    {.tvmode = TVMODE_VGA, .xres = 640, .yres = 480, .id = "vga"},
+    {.tvmode = TVMODE_SVGA, .xres = 800, .yres = 600, .id = "svga"},
+    {.tvmode = TVMODE_XGA, .xres = 1024, .yres = 768, .id = "xga"},
+#ifdef CONFIG_AML_VOUT_FRAMERATE_AUTOMATION
+    {.tvmode = TVMODE_480P_59HZ, .xres =  720, .yres =	480, .id = "480p59hz"},
+    {.tvmode = TVMODE_720P_59HZ, .xres = 1280, .yres =	  720, .id = "720p59hz"},
+    {.tvmode = TVMODE_1080I_59HZ, .xres = 1920, .yres = 1080, .id = "1080i59hz"},
+    {.tvmode = TVMODE_1080P_59HZ, .xres = 1920, .yres = 1080, .id = "1080p59hz"},
+    {.tvmode = TVMODE_1080P_23HZ, .xres = 1920, .yres = 1080, .id = "1080p23hz"},
+    {.tvmode = TVMODE_4K2K_29HZ, .xres = 3840, .yres = 2160, .id = "4k2k29hz"},
+    {.tvmode = TVMODE_4K2K_23HZ, .xres = 3840, .yres = 2160, .id = "4k2k23hz"},
+#endif
+
 };
 
 static inline void setreg(const reg_t *r)
 {
     aml_write_reg32(r->reg, r->val);
-    
-// For debug only. 
-#if 0 
+
+// For debug only.
+#if 0
     printk("[0x%x] = 0x%x\n", r->reg, r->val);
 #endif
 }
 
 #endif /* TVREGS_H */
-
diff --git a/drivers/amlogic/display/vout2/vout2_notify.c b/drivers/amlogic/display/vout2/vout2_notify.c
old mode 100644
new mode 100755
index 2870740b..6a157d5c
--- a/drivers/amlogic/display/vout2/vout2_notify.c
+++ b/drivers/amlogic/display/vout2/vout2_notify.c
@@ -6,7 +6,7 @@
  * This file is subject to the terms and conditions of the GNU General Public
  * License.  See the file COPYING in the main directory of this archive
  * for more details.
- * author :   
+ * author :
  *		 jianfeng_wang@amlogic
  */
 #include <linux/module.h>
@@ -17,7 +17,7 @@ static BLOCKING_NOTIFIER_HEAD(vout_notifier_list);
 static  DEFINE_MUTEX(vout_mutex)  ;
 static  vout_module_t  vout_module={
 		.vout_server_list={&vout_module.vout_server_list,&vout_module.vout_server_list},
-		.curr_vout_server=NULL,	
+		.curr_vout_server=NULL,
 };
 /**
  *	vout_register_client - register a client notifier
@@ -83,13 +83,13 @@ vmode_t get_current_vmode2(void)
 		BUG_ON(vout_module.curr_vout_server->op.get_vinfo == NULL);
 		info = vout_module.curr_vout_server->op.get_vinfo();
 		mode=info->mode;
-	}	
+	}
 	mutex_unlock(&vout_mutex);
-	
+
 	return mode;
 }
 EXPORT_SYMBOL(get_current_vmode2);
-int vout2_suspend(void)
+int vout2_suspend(int pm_event)
 {
 	int ret=0 ;
 	vout_server_t  *p_server = vout_module.curr_vout_server;
@@ -99,15 +99,15 @@ int vout2_suspend(void)
 	{
 		if(p_server->op.vout_suspend)
 		{
-			ret = p_server->op.vout_suspend() ;
+			ret = p_server->op.vout_suspend(pm_event) ;
 		}
 	}
-	
+
 	mutex_unlock(&vout_mutex);
 	return ret;
 }
 EXPORT_SYMBOL(vout2_suspend);
-int vout2_resume(void)
+int vout2_resume(int pm_event)
 {
 	vout_server_t  *p_server = vout_module.curr_vout_server;
 
@@ -116,10 +116,10 @@ int vout2_resume(void)
 	{
 		if (p_server->op.vout_resume)
 		{
-			p_server->op.vout_resume() ; //ignore error when resume.
+			p_server->op.vout_resume(pm_event) ; //ignore error when resume.
 		}
 	}
-	
+
 	mutex_unlock(&vout_mutex);
 	return 0;
 }
@@ -131,7 +131,7 @@ int set_current_vmode2(vmode_t mode)
 {
 	int r=-1;
 	vout_server_t  *p_server;
-	
+
 	mutex_lock(&vout_mutex);
 	list_for_each_entry(p_server, &vout_module.vout_server_list, list)
 	{
@@ -147,7 +147,7 @@ int set_current_vmode2(vmode_t mode)
 			//p_server->op.disable(mode);
 		}
 	}
-	
+
 	mutex_unlock(&vout_mutex);
 
 	return r;
@@ -161,7 +161,7 @@ vmode_t validate_vmode2(char *name)
 {
 	vmode_t r=VMODE_MAX;
 	vout_server_t  *p_server;
-	
+
 	mutex_lock(&vout_mutex);
 	list_for_each_entry(p_server, &vout_module.vout_server_list, list)
 	{
@@ -198,7 +198,7 @@ int vout2_register_server(vout_server_t*  mem_server)
 		if(p_server->name && mem_server->name && strcmp(p_server->name,mem_server->name)==0)
 		{
 			//vout server already registered.
-			
+
 			mutex_unlock(&vout_mutex);
 			return -1;
 		}
@@ -219,11 +219,11 @@ int vout2_unregister_server(vout_server_t*  mem_server)
 		if(p_server->name && mem_server->name && strcmp(p_server->name,mem_server->name)==0)
 		{
 			//we will not move current vout server pointer automatically if current vout server
-			//pointer is the one which will be deleted next .so you should change current vout server 
+			//pointer is the one which will be deleted next .so you should change current vout server
 			//first then remove it .
 			if(vout_module.curr_vout_server==p_server)
 			vout_module.curr_vout_server=NULL;
-			
+
 			list_del(&mem_server->list);
 			mutex_unlock(&vout_mutex);
 			return 0;
diff --git a/drivers/amlogic/display/vout2/vout2_serve.c b/drivers/amlogic/display/vout2/vout2_serve.c
old mode 100644
new mode 100755
index cca47b5a..422f1b2e
--- a/drivers/amlogic/display/vout2/vout2_serve.c
+++ b/drivers/amlogic/display/vout2/vout2_serve.c
@@ -1,5 +1,5 @@
 /*************************************************************
- * Amlogic 
+ * Amlogic
  * vout  serve program
  *
  * Copyright (C) 2010 Amlogic, Inc.
@@ -19,8 +19,8 @@
  * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307, USA
  *
  * Author:   jianfeng_wang@amlogic
- *		   
- *		   
+ *
+ *
  **************************************************************/
 #include <linux/version.h>
 #include <linux/module.h>
@@ -64,16 +64,38 @@ static int s_venc_mux = 0;
 
 /*****************************************************************
 **
-**	sysfs impletement part  
+**	sysfs impletement part
 **
 ******************************************************************/
-static  void   func_default_null(char  *str)
+static  int   func_default_null(char  *str)
 {
-	return ;
+#if MESON_CPU_TYPE == MESON_CPU_TYPE_MESON8
+    int val;
+    unsigned int cntl0=0, cntl1=0;
+    int r = sscanf(str, "%d", &val);
+    if (r != 1) {
+        return -EINVAL;
+    }
+    if ((val < 0) || (val > 1)) {
+        return -EINVAL;
+    }
+    if(!val){
+        cntl0 = 0;
+        cntl1 = 8;
+        WRITE_MPEG_REG(HHI_VDAC_CNTL0, cntl0);//close cvbs
+        WRITE_MPEG_REG(HHI_VDAC_CNTL1, cntl1);
+    }else{
+        cntl0 = 1;
+        cntl1 = 0;
+        WRITE_MPEG_REG(HHI_VDAC_CNTL0, cntl0);//open cvbs
+        WRITE_MPEG_REG(HHI_VDAC_CNTL1, cntl1);
+    }
+#endif
+    return 0;
 }
 static   int* parse_para(char *para,char   *para_num)
 {
-	 static unsigned   int  buffer[MAX_NUMBER_PARA] ; 
+	 static unsigned   int  buffer[MAX_NUMBER_PARA] ;
 	 char  *endp ;
 	 int *pt=NULL;
 	 int len=0,count=0;
@@ -85,25 +107,25 @@ static   int* parse_para(char *para,char   *para_num)
 	endp=(char*)buffer;
 	do
 	{
-		//filter space out 
+		//filter space out
 		while(para && ( isspace(*para) || !isalnum(*para)) && len)
 		{
 			para++;
-			len --; 
+			len --;
 		}
 		if(len==0) break;
 		*pt++=simple_strtoul(para,&endp,0);
-		
+
 		para=endp;
 		len=strlen(para);
 	}while(endp && ++count<*para_num&&count<MAX_NUMBER_PARA) ;
 	*para_num=count;
-	
+
 	return  buffer;
 }
 
 
-#if 0	
+#if 0
 #ifdef  CONFIG_PM
 static int  meson_vout_suspend(struct platform_device *pdev, pm_message_t state);
 static int  meson_vout_resume(struct platform_device *pdev);
@@ -113,27 +135,27 @@ static  void  set_vout_mode(char * name)
 {
 	vmode_t    mode;
 
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"tvmode2 set to %s\r\n",name);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"tvmode2 set to %s\n",name);
 	mode=validate_vmode2(name);
 	if(VMODE_MAX==mode)
 	{
 		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"no matched vout2 mode\n");
-		return ; 
+		return ;
 	}
 	if(mode==get_current_vmode2())
 	{
-		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"don't set the same mode as current.\r\n");	
+		amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_HIGH,"don't set the same mode as current.\n");	
 		return ;
 	}
 	set_current_vmode2(mode);
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"new mode2 %s set ok\r\n",name);
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"new mode2 %s set ok\n",name);
 	vout2_notifier_call_chain(VOUT_EVENT_MODE_CHANGE,&mode) ;
 }
 
 void  set_vout2_mode_internal(char * name)
 {
     set_vout_mode(name);
-}    
+}
 EXPORT_SYMBOL(set_vout2_mode_internal);
 
 char* get_vout2_mode_internal(void)
@@ -143,34 +165,35 @@ char* get_vout2_mode_internal(void)
 EXPORT_SYMBOL(get_vout2_mode_internal);
 
 //axis type : 0x12  0x100 0x120 0x130
-static void  set_vout_window(char *para) 
+static void  set_vout_window(char *para)
 {
 #define   OSD_COUNT   2
 	static  disp_rect_t  disp_rect[OSD_COUNT];
-	char  count=OSD_COUNT*4;	
+	char  count=OSD_COUNT*4;
 	int   *pt=&disp_rect[0].x;
-	
+
 
 	//parse window para .
 	memcpy(pt,parse_para(para,&count),sizeof(disp_rect_t)*OSD_COUNT);
-	
+
 	if(count >=4 && count <8 )
 	{
 		disp_rect[1]=disp_rect[0] ;
 	}
-	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"osd0=>x:%d ,y:%d,w:%d,h:%d\r\n osd1=> x:%d,y:%d,w:%d,h:%d \r\n", \
+	amlog_mask_level(LOG_MASK_PARA,LOG_LEVEL_LOW,"osd0=>x:%d ,y:%d,w:%d,h:%d\n osd1=> x:%d,y:%d,w:%d,h:%d\n", \
 			*pt,*(pt+1),*(pt+2),*(pt+3),*(pt+4),*(pt+5),*(pt+6),*(pt+7));
 	vout2_notifier_call_chain(VOUT_EVENT_OSD_DISP_AXIS,&disp_rect[0]) ;
 }
 
 /*****************************************************************
 **
-**	sysfs  declare part 
+**	sysfs  declare part
 **
 ******************************************************************/
 static const char *venc_mux_help = {
 	"venc_mux:\n"
 	"    0. single display, viu1->panel, viu2->null\n"
+	"    1. dual display, viu1->cvbs, viu2->panel\n"
 	"    2. dual display, viu1->hdmi, viu2->panel\n"
 	"    4. single display, viu1->null, viu2->hdmi\n"
 	"    8. dual display, viu1->panel, viu2->hdmi\n"
@@ -178,7 +201,7 @@ static const char *venc_mux_help = {
 
 static ssize_t venc_mux_show(struct class *class, struct class_attribute *attr, char *buf)
 {
-	return sprintf(buf, "%s\ncurrent venc_mux: %d\r\n", venc_mux_help, s_venc_mux);
+	return sprintf(buf, "%s\ncurrent venc_mux: %d\n", venc_mux_help, s_venc_mux);
 }
 
 static ssize_t venc_mux_store(struct class *class, struct class_attribute *attr, const char *buf, size_t count)
@@ -192,6 +215,10 @@ static ssize_t venc_mux_store(struct class *class, struct class_attribute *attr,
 		mux_type = s_venc_mux;
 		aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, mux_type, 0, 4);
 		break;
+	case 0x1:
+		mux_type = mux |(s_venc_mux<<2);
+		aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, mux_type, 0, 4);
+		break;
 	case 0x2:
 		mux_type = mux |(s_venc_mux<<2);
 		aml_set_reg32_bits(P_VPU_VIU_VENC_MUX_CTRL, mux_type, 0, 4);
@@ -215,7 +242,7 @@ static ssize_t venc_mux_store(struct class *class, struct class_attribute *attr,
 
 static  struct  class_attribute   *vout_attr[]={
 &class_vout2_attr_enable,
-&class_vout2_attr_mode,	
+&class_vout2_attr_mode,
 &class_vout2_attr_axis ,
 };
 static CLASS_ATTR(venc_mux, S_IWUSR | S_IRUGO, venc_mux_show, venc_mux_store);
@@ -228,7 +255,7 @@ static int  create_vout_attr(void)
 	vout_info.base_class=class_create(THIS_MODULE,VOUT_CLASS_NAME);
 	if(IS_ERR(vout_info.base_class))
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create vout2 class fail\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create vout2 class fail\n");
 		return  -1 ;
 	}
 	//create  class attr
@@ -236,18 +263,18 @@ static int  create_vout_attr(void)
 	{
 		if ( class_create_file(vout_info.base_class,vout_attr[i]))
 		{
-			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp2 attribute %s fail\r\n",vout_attr[i]->attr.name);
+			amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp2 attribute %s fail\n",vout_attr[i]->attr.name);
 		}
 	}
 	if (class_create_file(vout_info.base_class, &class_attr_venc_mux))
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp2 attribute venc_mux fail\r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create disp2 attribute venc_mux fail\n");
 
 	return   0;
 }
 #if 0
 #ifdef  CONFIG_PM
 static int  meson_vout_suspend(struct platform_device *pdev, pm_message_t state)
-{	
+{
 #if 0 //def CONFIG_HAS_EARLYSUSPEND
     if (early_suspend_flag)
         return 0;
@@ -265,7 +292,7 @@ static int  meson_vout_resume(struct platform_device *pdev)
 	vout2_resume();
 	return 0;
 }
-#endif 
+#endif
 #endif
 #if 0 //def CONFIG_HAS_EARLYSUSPEND
 static void meson_vout_early_suspend(struct early_suspend *h)
@@ -287,7 +314,7 @@ static void meson_vout_late_resume(struct early_suspend *h)
 
 /*****************************************************************
 **
-**	vout driver interface  
+**	vout driver interface
 **
 ******************************************************************/
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
@@ -298,13 +325,13 @@ static void meson_vout_late_resume(struct early_suspend *h)
 #define VPP_OFIFO_SIZE_MASK         0xfff
 #define VPP_OFIFO_SIZE_BIT          0
 
-static int 
+static int
  meson_vout_probe(struct platform_device *pdev)
 {
 	int ret =-1;
-	
+
 	vout_info.base_class=NULL;
-	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"start init vout2 module \r\n");
+	amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"start init vout2 module\n");
 #if 0 //def CONFIG_HAS_EARLYSUSPEND
     early_suspend.level = EARLY_SUSPEND_LEVEL_BLANK_SCREEN;
     early_suspend.suspend = meson_vout_early_suspend;
@@ -317,11 +344,11 @@ static int
 	s_venc_mux = aml_read_reg32(P_VPU_VIU_VENC_MUX_CTRL) & 0x3;
 	if(ret==0)
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout2 attribute ok \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout2 attribute ok\n");
 	}
 	else
 	{
-		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout2 attribute fail \r\n");
+		amlog_mask_level(LOG_MASK_INIT,LOG_LEVEL_HIGH,"create  vout2 attribute fail\n");
 	}
 
 #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON8
@@ -330,26 +357,26 @@ static int
 #else
     aml_set_reg32_bits(P_VPP2_OFIFO_SIZE, 0x780,
                         VPP_OFIFO_SIZE_BIT, VPP_OFIFO_SIZE_WID);
-#endif                        
+#endif
 
 	return ret;
 }
 static int
  meson_vout_remove(struct platform_device *pdev)
 {
-   	int i;
+	int i;
 	if(vout_info.base_class==NULL) return -1;
 #if 0 //def CONFIG_HAS_EARLYSUSPEND
     unregister_early_suspend(&early_suspend);
 #endif
-	
+
 	for(i=0;i<VOUT_ATTR_MAX;i++)
 	{
 		class_remove_file(vout_info.base_class,vout_attr[i]) ;
 	}
-		
+
 	class_destroy(vout_info.base_class);
-	
+
 	return 0;
 }
 
@@ -364,10 +391,10 @@ static struct platform_driver
 vout2_driver = {
     .probe      = meson_vout_probe,
     .remove     = meson_vout_remove,
-#if 0 //def  CONFIG_PM      
+#if 0 //def  CONFIG_PM
     .suspend  =meson_vout_suspend,
     .resume    =meson_vout_resume,
-#endif    
+#endif
     .driver     = {
         .name   = "mesonvout2",
         .of_match_table=meson_vout2_dt_match,
@@ -377,22 +404,22 @@ static int __init vout2_init_module(void)
 {
 	int ret =0;
   printk("%s enter\n", __func__);
-	if (platform_driver_register(&vout2_driver)) 
+	if (platform_driver_register(&vout2_driver))
 	{
     printk("%s fail\n", __func__);
-       		amlog_level(LOG_LEVEL_HIGH,"failed to register vout2 driver\n");
-        	ret= -ENODEV;
-    	}
-	
+		amlog_level(LOG_LEVEL_HIGH,"failed to register vout2 driver\n");
+		ret= -ENODEV;
+	}
+
 	return ret;
 
 }
 static __exit void vout2_exit_module(void)
 {
-	
+
 	amlog_level(LOG_LEVEL_HIGH,"vout2_remove_module.\n");
 
-    	platform_driver_unregister(&vout2_driver);
+	platform_driver_unregister(&vout2_driver);
 }
 module_init(vout2_init_module);
 module_exit(vout2_exit_module);
diff --git a/drivers/amlogic/display/vout2/vout_log.h b/drivers/amlogic/display/vout2/vout_log.h
old mode 100644
new mode 100755
index 702823e2..aae3a279
--- a/drivers/amlogic/display/vout2/vout_log.h
+++ b/drivers/amlogic/display/vout2/vout_log.h
@@ -1,27 +1,26 @@
-#ifndef  TV_LOG_H
-#define TV_LOG_H
-
-#define DEBUG
-#ifdef  DEBUG
-#define  AMLOG   1
-#define LOG_LEVEL_VAR amlog_level_vout2
-#define LOG_MASK_VAR amlog_mask_vout2
-#endif
-
-
-#define  	LOG_LEVEL_HIGH    		0x00f
-#define	LOG_LEVEL_1			0x001
-#define 	LOG_LEVEL_LOW			0x000
-
-#define LOG_LEVEL_DESC \
-"[0x00]LOW[0X01]LEVEL1[0xf]HIGH"	
-
-#define  	LOG_MASK_INIT			0x001
-#define	LOG_MASK_IOCTL		0x002
-#define	LOG_MASK_HARDWARE	0x004
-#define	LOG_MASK_PARA			0x008
-#define 	LOG_MASK_DESC \
-"[0x01]:INIT,[0x02]:IOCTL,[0x04]:HARDWARE,[0x08]PARA"
-
-#endif
-
+#ifndef  TV_LOG_H
+#define TV_LOG_H
+
+#define DEBUG
+#ifdef  DEBUG
+#define  AMLOG   1
+#define LOG_LEVEL_VAR amlog_level_vout2
+#define LOG_MASK_VAR amlog_mask_vout2
+#endif
+
+
+#define  	LOG_LEVEL_HIGH    		0x00f
+#define	LOG_LEVEL_1			0x001
+#define 	LOG_LEVEL_LOW			0x000
+
+#define LOG_LEVEL_DESC \
+"[0x00]LOW[0X01]LEVEL1[0xf]HIGH"
+
+#define  	LOG_MASK_INIT			0x001
+#define	LOG_MASK_IOCTL		0x002
+#define	LOG_MASK_HARDWARE	0x004
+#define	LOG_MASK_PARA			0x008
+#define 	LOG_MASK_DESC \
+"[0x01]:INIT,[0x02]:IOCTL,[0x04]:HARDWARE,[0x08]PARA"
+
+#endif
diff --git a/drivers/amlogic/display/vout2/vout_serve.h b/drivers/amlogic/display/vout2/vout_serve.h
old mode 100644
new mode 100755
index bd0aac5a..44e6d285
--- a/drivers/amlogic/display/vout2/vout_serve.h
+++ b/drivers/amlogic/display/vout2/vout_serve.h
@@ -1,83 +1,83 @@
-#ifndef   _VOUT_SERVE_H
-#define	_VOUT_SERVE_H
-
-#ifdef CONFIG_AM_TV_OUTPUT
-#include  "tvoutc.h"	
-#endif
-#include  <linux/amlogic/vout/vout_notify.h>
-
-/*****************************************************************
-**
-**	type define part 
-**
-******************************************************************/
-
-static  DEFINE_MUTEX(vout_mutex)  ;
-
+#ifndef   _VOUT_SERVE_H
+#define	_VOUT_SERVE_H
+
+#ifdef CONFIG_AM_TV_OUTPUT
+#include  "tvoutc.h"
+#endif
+#include  <linux/amlogic/vout/vout_notify.h>
+
+/*****************************************************************
+**
+**	type define part
+**
+******************************************************************/
+
+static  DEFINE_MUTEX(vout_mutex)  ;
+
 typedef enum   {
-VOUT_ATTR_ENABLE=0 ,
-VOUT_ATTR_MODE,
-VOUT_ATTR_AXIS,
-VOUT_ATTR_MAX
-}vout_attr_t ;
-
+VOUT_ATTR_ENABLE=0 ,
+VOUT_ATTR_MODE,
+VOUT_ATTR_AXIS,
+VOUT_ATTR_MAX
+}vout_attr_t ;
+
 typedef  struct {
 	unsigned int  addr;
 	unsigned int  value;
-}vout_reg_t ;
-
-typedef  struct {
+}vout_reg_t ;
+
+typedef  struct {
 	int x ;
 	int y ;
 	int w ;
 	int h ;
-}disp_rect_t;
-typedef struct {
-	 struct class  *base_class;
-}vout_info_t;
-/*****************************************************************
-**
-**	macro define part 
-**
-******************************************************************/
-#define  VOUT_CLASS_NAME  	"display2"
-#define	MAX_NUMBER_PARA  10
-
-#define  SHOW_INFO(name)      \
-	{return snprintf(buf,40, "%s\n", name);}  	
+}disp_rect_t;
+typedef struct {
+	 struct class  *base_class;
+}vout_info_t;
+/*****************************************************************
+**
+**	macro define part
+**
+******************************************************************/
+#define  VOUT_CLASS_NAME  	"display2"
+#define	MAX_NUMBER_PARA  10
+
+#define  SHOW_INFO(name)      \
+	{return snprintf(buf,40, "%s\n", name);}
 
 #define  STORE_INFO(name)\
-	{mutex_lock(&vout_mutex);\
+	{mutex_lock(&vout_mutex);\
 	snprintf(name,40,"%s",buf) ;\
-	mutex_unlock(&vout_mutex); }			
-		
-#define    SET_VOUT2_CLASS_ATTR(name,op)    \
+	mutex_unlock(&vout_mutex); }
+
+#define    SET_VOUT2_CLASS_ATTR(name,op)    \
 static  char    name[40] ;				  \
-static ssize_t aml_vout_attr_##name##_show(struct class  * cla, struct class_attribute *attr, char *buf)   \
+static ssize_t aml_vout_attr_##name##_show(struct class  * cla, struct class_attribute *attr, char *buf)   \
 {  											\
 	SHOW_INFO(name)  	\
 } 											\
-static ssize_t  aml_vout_attr_##name##_store(struct class *cla,  struct class_attribute *attr, \
+static ssize_t  aml_vout_attr_##name##_store(struct class *cla,  struct class_attribute *attr, \
 			    const char *buf, size_t count)    \
 {\
-	STORE_INFO(name);   						\
+	STORE_INFO(name);   						\
 	op(name) ;						\
 	return strnlen(buf, count);				\
 }											\
-struct  class_attribute  class_vout2_attr_##name =  \
-__ATTR(name, S_IRUGO|S_IWUSR|S_IWGRP, aml_vout_attr_##name##_show, aml_vout_attr_##name##_store) ; 
-/*****************************************************************
-**
-**	function  declare  part 
-**
-******************************************************************/
-#if 0
-static  void  read_reg(char *para);
+struct  class_attribute  class_vout2_attr_##name =  \
+__ATTR(name, S_IRUGO|S_IWUSR|S_IWGRP, aml_vout_attr_##name##_show, aml_vout_attr_##name##_store) ;
+/*****************************************************************
+**
+**	function  declare  part
+**
+******************************************************************/
+#if 0
+static  void  read_reg(char *para);
 static  void  write_reg(char *para);
-#endif
-static  void  set_vout_mode(char *mode) ;
-static void  set_vout_window(char *para) ;
-static  void   func_default_null(char  *str);
-
-
-#endif
+#endif
+static  void  set_vout_mode(char *mode) ;
+static void  set_vout_window(char *para) ;
+static  int   func_default_null(char  *str);
+
+
+#endif
